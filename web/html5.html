<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--HTML5</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<link href="css/demo-html5.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">HTML5</h3>
					</div>
					<div class="list-group">
						<a href="#html5-intro" class="list-group-item">简介</a>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#java-tools" aria-expanded="true">
							...<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-tools" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#" class="list-group-item"
								style="border-top: 1px solid #DDDDDD;">...</a>
							<a href="#" class="list-group-item">...</a>
							<a href="#" class="list-group-item">...</a>
						</div>
						<a href="#html5-local-storage" class="list-group-item">本地存储</a>

						<a href="#html5-canvas" class="list-group-item">CANVAS</a>
						<a href="#html5-svg" class="list-group-item">SVG</a>
						<a href="#" class="list-group-item">...</a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<a id="html5-intro" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="html5-local-storage" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">本地存储</h3>
					</div>
					<div class="panel-body">
						<p>在 Html4 的时代在浏览器端存储点网站个性化的数据，尤其是用户浏览器的痕迹，用户的相关数据等一般只能存储在
							Cookie 中，但是大多是浏览器对于 Cookie
							的限制也就逼迫网站存储数据尽量精简，想存储复杂的、关系型的用户数据就根本不可能。</p>
						<p>
							<b>下面是Cookie的限制：</b>
						</p>
						<ul>
							<li>大多数浏览器支持最大为 4096 字节的 Cookie。</li>
							<li>浏览器还限制站点可以在用户计算机上存储的 Cookie 的数量。大多数浏览器只允许每个站点存储 20 个
								Cookie；如果试图存储更多 Cookie，则最旧的 Cookie 便会被丢弃。</li>
							<li>有些浏览器还会对它们将接受的来自所有站点的 Cookie 总数作出绝对限制，通常为 300 个。</li>
							<li>Cookie 默认情况都会随着 Http 请求发送到后台服务器，但并不是所有请求都需要 Cookie
								的，比如：js、css、图片等请求则不需要 Cookie。</li>
						</ul>
						<p>
							<b>Html5 支持两种的 WebStorage:</b>
						</p>
						<ul>
							<li>
								<code>localStorage</code>
								-- 永久本地存储, 以便于用户存储永久存储的 Web 端的数据。而且数据不会随着 Http
								请求发送到后台服务器，而且存储数据的大小机会不用考虑，因为在 HTML5 的标准中要求浏览器至少要支持到 4
								MB.所以，这完全是颠覆了 Cookie 的限制，为 Web 应用在本地存储复杂的用户痕迹数据提供非常方便的技术支持。
								<pre class="brush: js;">
// 添加 key-value 数据到 sessionStorage
localStorage.setItem("demokey", "http://blog.itjeek.com");
localStorage.setItem("userName", "jiwanger");

// 通过 key 来获取 value
var dt = localStorage.getItem("demokey");
alert(dt);

// 通过 key 删除本地数据
localStorage.removeItem("demokey");

// 清空所有的 key-value 数据。
// localStorage.clear();
alert(sessionStorage.length);
</pre>
							</li>
							<li>
								<code>sessionStorage</code>
								-- 会话级别的本地存储, 通过此对象可以直接操作存储在浏览器中的会话级别的 WebStorage。存储在
								sessionStorage 中的数据首先是 Key-Value
								形式的，另外就是它跟浏览器当前会话相关，当会话结束后，数据会自动清除，跟未设置过期时间的 Cookie 类似。
								<pre class="brush: js;">
// 添加 key-value 数据到 sessionStorage
sessionStorage.setItem("demokey", "http://blog.itjeek.com");
sessionStorage.setItem("userName", "jiwanger");

// 通过 key 来获取 value
var dt = sessionStorage.getItem("demokey");
alert(dt);

// 通过 key 删除本地数据
sessionStorage.removeItem("demokey");

// 清空所有的 key-value 数据。
// sessionStorage.clear();
alert(sessionStorage.length);
</pre>
						</ul>

						<p>
							<b>本地数据库 -- IndexedDB</b>
						</p>
						<p>
							虽然 Html5 已经提供了功能强大的
							<code>localStorage</code>
							和
							<code>sessionStorage</code>
							，但是他们两个都只能提供存储简单数据结构的数据，对于复杂的 Web 应用的数据却无能为力。IndexedDB
							是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。
						</p>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="html5-canvas" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">CANVAS</h3>
					</div>
					<div class="panel-body">
						<p>HTML5 &lt;canvas&gt; 标签用于绘制图像（通过脚本，通常是 JavaScript）。</p>
						<p>不过，&lt;canvas&gt; 元素本身并没有绘制能力（它仅仅是图形的容器） -
							您必须使用脚本来完成实际的绘图任务。</p>
						<p>getContext() 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性。</p>

						<div class="sub-item">
							<h5 class="text-primary">颜色、样式和阴影</h5>
							<table class="table table-bordered table-striped runoob"
								data-base="http://www.runoob.com/tags/">
								<tbody>
									<tr>
										<th width="25%" align="left">属性</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-fillstyle.html">fillStyle</a></td>
										<td>设置或返回用于填充绘画的颜色、渐变或模式。</td>
									</tr>
									<tr>
										<td><a href="canvas-strokestyle.html">strokeStyle</a></td>
										<td>设置或返回用于笔触的颜色、渐变或模式。</td>
									</tr>
									<tr>
										<td><a href="canvas-shadowcolor.html">shadowColor</a></td>
										<td>设置或返回用于阴影的颜色。</td>
									</tr>
									<tr>
										<td><a href="canvas-shadowblur.html">shadowBlur</a></td>
										<td>设置或返回用于阴影的模糊级别。</td>
									</tr>
									<tr>
										<td><a href="canvas-shadowoffsetx.html">shadowOffsetX</a></td>
										<td>设置或返回阴影与形状的水平距离。</td>
									</tr>
									<tr>
										<td><a href="canvas-shadowoffsety.html">shadowOffsetY</a></td>
										<td>设置或返回阴影与形状的垂直距离。</td>
									</tr>
									<tr>
										<th width="25%" align="left">方法</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-createlineargradient.html">createLinearGradient()</a></td>
										<td>创建线性渐变（用在画布内容上）。</td>
									</tr>
									<tr>
										<td><a href="canvas-createpattern.html">createPattern()</a></td>
										<td>在指定的方向上重复指定的元素。</td>
									</tr>
									<tr>
										<td><a href="canvas-createradialgradient.html">createRadialGradient()</a></td>
										<td>创建放射状/环形的渐变（用在画布内容上）。</td>
									</tr>
									<tr>
										<td><a href="canvas-addcolorstop.html">addColorStop()</a></td>
										<td>规定渐变对象中的颜色和停止位置。</td>
									</tr>
								</tbody>
							</table>
							<div class="row">
								<div class="col-md-4">
									<canvas id="canvas-color" height="280px;" />
								</div>
								<div class="col-md-8" style="padding-left: 0px;">
									<pre class="brush: js;">
var c = document.getElementById("canvas-color");
var ctx = c.getContext("2d");
var ctx_text = c.getContext("2d");
ctx.save();
ctx.fillStyle = "#FF0000"; // 填充绘画的颜色、渐变或模式
ctx.fillRect(10, 15, 240, 20);
ctx.fillText("填充绘画的颜色、渐变或模式:", 10, 10);

ctx.strokeStyle = "#00FF00"; // 笔触的颜色、渐变或模式
ctx.strokeRect(10, 55, 240, 20);
ctx.fillText("笔触的颜色、渐变或模式:", 10, 50);

// 阴影
ctx.shadowBlur = 5;
ctx.shadowColor = "#0000FF";
ctx.shadowOffsetX = 3;
ctx.shadowOffsetY = 3;
ctx.fillStyle = "#FF0000";
ctx.fillRect(10, 95, 240, 20);
ctx.fillText("阴影:", 10, 90);

ctx.restore();
// 创建线性渐变,参数(开始点: x 坐标,y 坐标,结束点:x 坐标,y 坐标)
var grd = ctx.createLinearGradient(0, 0, 240, 0);
grd.addColorStop(0, "#FF0000");
grd.addColorStop(1, "#00FFFF");
ctx.fillStyle = grd;
ctx.fillRect(10, 135, 240, 20);
ctx.fillText("创建线性渐变:", 10, 130);

// 放射状/圆形渐变,参数(开始圆:x 坐标,y 坐标,半径,结束圆:x 坐标,y 坐标,半径)
var rg = ctx.createRadialGradient(130, 215, 20, 130, 215, 120);
rg.addColorStop(0, "#FF0000");
rg.addColorStop(1, "#00FFFF");
ctx.fillStyle = rg;
ctx.fillRect(10, 175, 240, 80);
ctx.fillText("放射状/圆形渐变,:", 10, 170);
</pre>
								</div>
							</div>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">线条样式</h5>
							<table class="table table-bordered table-striped runoob"
								data-base="http://www.runoob.com/tags/">
								<tbody>
									<tr>
										<th width="25%" align="left">属性</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-linecap.html">lineCap</a></td>
										<td>设置或返回线条的结束端点样式。</td>
									</tr>
									<tr>
										<td><a href="canvas-linejoin.html">lineJoin</a></td>
										<td>设置或返回两条线相交时，所创建的拐角类型。</td>
									</tr>
									<tr>
										<td><a href="canvas-linewidth.html">lineWidth</a></td>
										<td>设置或返回当前的线条宽度。</td>
									</tr>
									<tr>
										<td><a href="canvas-miterlimit.html">miterLimit</a></td>
										<td>设置或返回最大斜接长度。</td>
									</tr>
								</tbody>
							</table>
							<div class="row">
								<div class="col-md-4">
									<canvas id="canvas-line" height="200px;" />
								</div>
								<div class="col-md-8" style="padding-left: 0px;">
									<pre class="brush: js;">
var c = document.getElementById("canvas-line");
var ctx = c.getContext("2d");
ctx.save();
ctx.strokeStyle = "#FF0000";

ctx.fillText("结束端点样式:", 10, 10);
ctx.beginPath();
ctx.lineWidth = 5;
ctx.lineCap = "butt"; // 默认。向线条的每个末端添加平直的边缘
ctx.moveTo(10, 20);
ctx.lineTo(240, 20);
ctx.stroke();

ctx.beginPath();
ctx.lineCap = "round"; // 向线条的每个末端添加圆形线帽
ctx.moveTo(10, 40);
ctx.lineTo(240, 40);
ctx.stroke();

ctx.beginPath();
ctx.lineCap = "square"; // 向线条的每个末端添加正方形线帽
ctx.moveTo(10, 60);
ctx.lineTo(240, 60);
ctx.stroke();

ctx.fillText("两条线相交时，所创建的拐角类型:", 10, 90);
ctx.beginPath();
// 两条线相交时，所创建的拐角类型, 
// 	bevel:创建斜角; round:创建圆角; miter:默认。创建尖角。
ctx.lineJoin = "round";
ctx.moveTo(10, 105);
ctx.lineTo(100, 115);
ctx.lineTo(10, 125);
ctx.stroke();

ctx.beginPath();
ctx.lineJoin = "bevel";
ctx.moveTo(10, 135);
ctx.lineTo(100, 145);
ctx.lineTo(10, 155);
ctx.stroke();

ctx.beginPath();
ctx.lineJoin = "miter";
ctx.moveTo(10, 165);
ctx.lineTo(100, 175);
ctx.lineTo(10, 185);
ctx.stroke();
</pre>
								</div>
							</div>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">矩形</h5>
							<table class="table table-bordered table-striped runoob"
								data-base="http://www.runoob.com/tags/">
								<tbody>
									<tr>
										<th width="25%" align="left">方法</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-rect.html">rect()</a></td>
										<td>创建矩形。</td>
									</tr>
									<tr>
										<td><a href="canvas-fillrect.html">fillRect()</a></td>
										<td>绘制"被填充"的矩形。</td>
									</tr>
									<tr>
										<td><a href="canvas-strokerect.html">strokeRect()</a></td>
										<td>绘制矩形（无填充）。</td>
									</tr>
									<tr>
										<td><a href="canvas-clearrect.html">clearRect()</a></td>
										<td>在给定的矩形内清除指定的像素。</td>
									</tr>
								</tbody>
							</table>
							<div class="row">
								<div class="col-md-4">
									<canvas id="canvas-rect" height="240px;" />
								</div>
								<div class="col-md-8" style="padding-left: 0px;">
									<pre class="brush: js;">
var c = document.getElementById("canvas-rect");
var ctx = c.getContext("2d");
ctx.beginPath();
ctx.rect(10, 10, 240, 60);
ctx.stroke();

// 创建矩形
ctx.beginPath();
ctx.lineWidth = 8;
ctx.strokeStyle = "#De88C4";
ctx.rect(20, 20, 220, 40);
ctx.stroke();

ctx.beginPath();
ctx.fillRect(10, 80, 240, 60);
ctx.stroke();

// 绘制"被填充"的矩形
ctx.beginPath();
ctx.fillStyle = "#De88C4";
ctx.fillRect(20, 90, 220, 40);
ctx.stroke();

ctx.beginPath();
ctx.fillStyle = "#De88C4";
ctx.fillRect(10, 150, 240, 60);
ctx.stroke();

// 在给定的矩形内清除指定的像素
ctx.beginPath();
ctx.clearRect(20, 160, 220, 20);
ctx.stroke();

ctx.beginPath();
ctx.clearRect(110, 180, 30, 20);
ctx.stroke();
</pre>
								</div>
							</div>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">路径</h5>
							<table class="table table-bordered table-striped runoob"
								data-base="http://www.runoob.com/tags/">
								<tbody>
									<tr>
										<th width="25%" align="left">方法</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-fill.html">fill()</a></td>
										<td>填充当前绘图（路径）。</td>
									</tr>
									<tr>
										<td><a href="canvas-stroke.html">stroke()</a></td>
										<td>绘制已定义的路径。</td>
									</tr>
									<tr>
										<td><a href="canvas-beginpath.html">beginPath()</a></td>
										<td>起始一条路径，或重置当前路径。</td>
									</tr>
									<tr>
										<td><a href="canvas-moveto.html">moveTo()</a></td>
										<td>把路径移动到画布中的指定点，不创建线条。</td>
									</tr>
									<tr>
										<td><a href="canvas-closepath.html">closePath()</a></td>
										<td>创建从当前点回到起始点的路径。</td>
									</tr>
									<tr>
										<td><a href="canvas-lineto.html">lineTo()</a></td>
										<td>添加一个新点，然后在画布中创建从该点到最后指定点的线条。</td>
									</tr>
									<tr>
										<td><a href="canvas-clip.html">clip()</a></td>
										<td>从原始画布剪切任意形状和尺寸的区域。</td>
									</tr>
									<tr>
										<td><a href="canvas-quadraticcurveto.html">quadraticCurveTo()</a></td>
										<td>创建二次贝塞尔曲线。</td>
									</tr>
									<tr>
										<td><a href="canvas-beziercurveto.html">bezierCurveTo()</a></td>
										<td>创建三次贝塞尔曲线。</td>
									</tr>
									<tr>
										<td><a href="canvas-arc.html">arc()</a></td>
										<td>创建弧/曲线（用于创建圆形或部分圆）。</td>
									</tr>
									<tr>
										<td><a href="canvas-arcto.html">arcTo()</a></td>
										<td>创建两切线之间的弧/曲线。</td>
									</tr>
									<tr>
										<td><a href="canvas-ispointinpath.html">isPointInPath()</a></td>
										<td>如果指定的点位于当前路径中，则返回 true，否则返回 false。</td>
									</tr>
								</tbody>
							</table>
							<div class="row">
								<div class="col-md-4">
									<canvas id="canvas-path" height="700px;" />
								</div>
								<div class="col-md-8" style="padding-left: 0px;">
									<pre class="brush: js;">
var c = document.getElementById("canvas-path");
var ctx = c.getContext("2d");

// 填充当前绘图（路径）
ctx.rect(10, 10, 240, 60);
ctx.fillStyle = "red";
ctx.fill();

// 绘制已定义的路径
ctx.beginPath();
ctx.moveTo(10, 80);
ctx.lineTo(250, 80);
ctx.lineTo(250, 110);
ctx.closePath();
ctx.strokeStyle="red";
ctx.stroke(); 

// 剪切,只有被剪切区域内的红色矩形部分是可见的
/** 一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布
 * 上的其他区域）。您也可以在使用 clip() 方法前通过使用 save() 方法对当前画布
 * 区域进行保存，并在以后的任意时间对其进行恢复（通过 restore() 方法）。*/
ctx.beginPath();
ctx.rect(10,120,240,120);
ctx.stroke();
ctx.clip();
// 剪切之后画一个矩形
ctx.fillStyle="green";
ctx.fillRect(30,120,150,140);// 此部分超出剪切高度，超出部分不可见

// 二次贝塞尔曲线
ctx.restore();
ctx.beginPath();
ctx.moveTo(10, 270);
ctx.quadraticCurveTo(10, 350, 240, 270);
ctx.stroke();

drawDashLine(ctx, 10, 270, 10, 350, 1);
drawDashLine(ctx, 10, 350, 240, 270, 1);
ctx.fillText("(10, 270)", 0, 270);
ctx.fillText("(10, 350)", 0, 360);
ctx.fillText("(240, 270)", 200, 270);

// 三次贝塞尔曲线
ctx.beginPath();
ctx.moveTo(10, 370);
ctx.bezierCurveTo(10, 470, 240, 470, 240, 370);
ctx.stroke();

drawDashLine(ctx, 10, 370, 10, 470, 1);
drawDashLine(ctx, 240, 370, 240, 470, 1);
drawDashLine(ctx, 10, 470, 240, 470, 1);

ctx.fillText("(10, 370)", 0, 370);
ctx.fillText("(10, 470)", 0, 480);
ctx.fillText("(240, 470)", 200, 480);
ctx.fillText("(240, 370)", 200, 370);

// 弧/曲线
ctx.beginPath();
ctx.fillStyle = "#FF0000"
ctx.arc(60, 540, 50, 0, 1.5 * Math.PI);
ctx.stroke();
ctx.beginPath();
ctx.arc(170, 540, 50, 0, 1.5 * Math.PI);
ctx.fill();

// 介于两个切线之间的弧
ctx.beginPath();
ctx.moveTo(10,600);
ctx.lineTo(100, 600);
ctx.arcTo(150, 600,150, 670,50);
ctx.stroke();
</pre>
								</div>
							</div>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">转换</h5>
							<table class="table table-bordered table-striped runoob"
								data-base="http://www.runoob.com/tags/">
								<tbody>
									<tr>
										<th width="25%" align="left">方法</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-scale.html">scale()</a></td>
										<td>缩放当前绘图至更大或更小。</td>
									</tr>
									<tr>
										<td><a href="canvas-rotate.html">rotate()</a></td>
										<td>旋转当前绘图。</td>
									</tr>
									<tr>
										<td><a href="canvas-translate.html">translate()</a></td>
										<td>重新映射画布上的 (0,0) 位置。</td>
									</tr>
									<tr>
										<td><a href="canvas-transform.html">transform()</a></td>
										<td>替换绘图的当前转换矩阵。</td>
									</tr>
									<tr>
										<td><a href="canvas-settransform.html">setTransform()</a></td>
										<td>将当前转换重置为单位矩阵。然后运行 transform()。</td>
									</tr>
								</tbody>
							</table>
							<div class="row">
								<div class="col-md-4">
									<canvas id="canvas-convertion" height="540px;" />
								</div>
								<div class="col-md-8" style="padding-left: 0px;">
									<pre class="brush: js;">
var c = document.getElementById("canvas-convertion");
var ctx = c.getContext("2d");
ctx.save();

// 如果您对绘图进行缩放，所有之后的绘图也会被缩放。定位也会被缩放。
ctx.strokeRect(10, 10, 70, 40);
// 缩放
ctx.scale(2, 2);
ctx.strokeRect(10, 10, 70, 40);

ctx.restore();
ctx.save();
// 旋转
ctx.rotate(20 * Math.PI / 180);
ctx.strokeRect(80, 90, 70, 40);

ctx.restore();
ctx.save();
ctx.strokeRect(10, 180, 70, 40);
// 移动
ctx.translate(40, 20);
ctx.strokeRect(10, 180, 70, 40);

ctx.restore();
ctx.save();
ctx.fillStyle = "yellow";
ctx.fillRect(10, 250, 240, 60);
// 参数(水平缩放, 水平倾斜, 垂直倾斜, 垂直缩放, 水平移动, 垂直移动)
ctx.transform(1, 0.2, -0.2, 1, 60, 10);
ctx.fillStyle = "red";
ctx.fillRect(10, 250, 240, 60);

// 将当前转换重置为单位矩阵。然后运行 transform()
ctx.restore();
ctx.fillStyle = "yellow";
ctx.fillRect(10, 400, 240, 60)
ctx.setTransform(1, 0.2, -0.2, 1, 80, 10);
ctx.fillStyle = "red";
ctx.fillRect(10, 400, 240, 60);
ctx.setTransform(1, 0.2, -0.2, 1, 80, 10);
ctx.fillStyle = "blue";
ctx.fillRect(10, 400, 240, 60);
</pre>
								</div>
							</div>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">文本</h5>
							<table class="table table-bordered table-striped runoob"
								data-base="http://www.runoob.com/tags/">
								<tbody>
									<tr>
										<th width="25%" align="left">属性</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-font.html">font</a></td>
										<td>设置或返回文本内容的当前字体属性。</td>
									</tr>
									<tr>
										<td><a href="canvas-textalign.html">textAlign</a></td>
										<td>设置或返回文本内容的当前对齐方式。</td>
									</tr>
									<tr>
										<td><a href="canvas-textbaseline.html">textBaseline</a></td>
										<td>设置或返回在绘制文本时使用的当前文本基线。</td>
									</tr>
									<tr>
										<th width="25%" align="left">方法</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-filltext.html">fillText()</a></td>
										<td>在画布上绘制"被填充的"文本。</td>
									</tr>
									<tr>
										<td><a href="canvas-stroketext.html">strokeText()</a></td>
										<td>在画布上绘制文本（无填充）。</td>
									</tr>
									<tr>
										<td><a href="canvas-measuretext.html">measureText()</a></td>
										<td>返回包含指定文本宽度的对象。</td>
									</tr>
								</tbody>
							</table>
							<h5 class="text-primary">font 属性</h5>
							<pre class="brush: js;">
// 语法
context.font="italic small-caps bold 12px arial";
</pre>
							<table class="table table-condensed table-bordered"
								<tbody>
									<tr>
										<th style="width: 23%">值</th>
										<th style="width: 65%">描述</th>

									</tr>
									<tr>
										<td><i>font-style</i></td>
										<td>规定字体样式。可能的值：
											<ul>
												<li>normal</li>
												<li>italic</li>
												<li>oblique</li>
											</ul>
										</td>

									</tr>
									<tr>
										<td><i>font-variant</i></td>
										<td>规定字体变体。可能的值：
											<ul>
												<li>normal</li>
												<li>small-caps</li>
											</ul>
										</td>

									</tr>
									<tr>
										<td><i>font-weight</i></td>
										<td>规定字体的粗细。可能的值：
											<ul>
												<li>normal</li>
												<li>bold</li>
												<li>bolder</li>
												<li>lighter</li>
												<li>100</li>
												<li>200</li>
												<li>300</li>
												<li>400</li>
												<li>500</li>
												<li>600</li>
												<li>700</li>
												<li>800</li>
												<li>900</li>
											</ul>
										</td>
									</tr>
									<tr>
										<td><i>font-size/line-height</i></td>
										<td>规定字号和行高，以像素计。</td>

									</tr>
									<tr>
										<td><i>font-family</i></td>
										<td>规定字体系列。</td>

									</tr>
									<tr>
										<td>caption</td>
										<td>使用标题控件的字体（比如按钮、下拉列表等）。</td>

									</tr>
									<tr>
										<td>icon</td>
										<td>使用用于标记图标的字体。</td>

									</tr>
									<tr>
										<td>menu</td>
										<td>使用用于菜单中的字体（下拉列表和菜单列表）。</td>

									</tr>
									<tr>
										<td>message-box</td>
										<td>使用用于对话框中的字体。</td>

									</tr>
									<tr>
										<td>small-caption</td>
										<td>使用用于标记小型控件的字体。</td>

									</tr>
									<tr>
										<td>status-bar</td>
										<td>使用用于窗口状态栏中的字体。</td>

									</tr>
								</tbody>
							</table>
							<div class="row">
								<div class="col-md-4">
									<canvas id="canvas-font" height="400px;" />
								</div>
								<div class="col-md-8" style="padding-left: 0px;">
									<pre class="brush: js;">
var c = document.getElementById("canvas-font");
var ctx = c.getContext("2d");
ctx.save();

ctx.strokeStyle = "red";
ctx.moveTo(150, 20);
ctx.lineTo(150, 170);
ctx.stroke();

ctx.font = "15px Arial";

// textAlign 对齐
ctx.textAlign = "start";
ctx.fillText("textAlign=start", 150, 60);
ctx.textAlign = "end";
ctx.fillText("textAlign=end", 150, 80);
ctx.textAlign = "left";
ctx.fillText("textAlign=left", 150, 100);
ctx.textAlign = "center";
ctx.fillText("textAlign=center", 150, 120);
ctx.textAlign = "right";
ctx.fillText("textAlign=right", 150, 140);

// textBaseline 基线
ctx.strokeStyle = "red";
ctx.moveTo(00, 210);
ctx.lineTo(240, 210);
ctx.stroke();
ctx.font = "12px Arial"

// Place each word at y=100 with different textBaseline values
ctx.textBaseline = "top";
ctx.fillText("Top", 20, 210);
ctx.textBaseline = "bottom";
ctx.fillText("Bottom", 70, 210);
ctx.textBaseline = "middle";
ctx.fillText("Middle", 120, 210);
ctx.textBaseline = "alphabetic";
ctx.fillText("Alphabetic", 190, 210);
ctx.textBaseline = "hanging";
ctx.fillText("Hanging", 240, 210);

ctx.restore();
ctx.font = "30px Verdana";
// Create gradient
var gradient = ctx.createLinearGradient(0, 0, c.width, 0);
gradient.addColorStop("0", "magenta");
gradient.addColorStop("0.5", "blue");
gradient.addColorStop("1.0", "red");
// Fill with gradient
ctx.fillStyle = gradient;
ctx.fillText("Big smile!", 10, 270);

ctx.strokeStyle = gradient;
ctx.strokeText("Big smile!", 10, 300);

ctx.font = "30px Arial";
var txt = "Hello World"
ctx.fillText("计算文本宽度:" + ctx.measureText(txt).width, 10, 360);
ctx.fillText(txt, 10, 390);
</pre>

								</div>
							</div>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">图像绘制</h5>
							<table class="table table-bordered table-striped runoob"
								data-base="http://www.runoob.com/tags/">
								<tbody>
									<tr>
										<th width="25%" align="left">方法</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-drawimage.html">drawImage()</a></td>
										<td>向画布上绘制图像、画布或视频。</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: js;">
context.drawImage(img,x,y);

context.drawImage(img,x,y,width,height);

context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);							
</pre>
							<table class="table table-bordered table-striped runoob">
								<tbody>
									<tr>
										<th style="width: 15%">参数</th>
										<th>描述</th>

									</tr>
									<tr>
										<td><i>img</i></td>
										<td>规定要使用的图像、画布或视频。</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td><i>sx</i></td>
										<td>可选。开始剪切的 x 坐标位置。</td>

									</tr>
									<tr>
										<td><i>sy</i></td>
										<td>可选。开始剪切的 y 坐标位置。</td>

									</tr>
									<tr>
										<td><i>swidth</i></td>
										<td>可选。被剪切图像的宽度。</td>

									</tr>
									<tr>
										<td><i>sheight</i></td>
										<td>可选。被剪切图像的高度。</td>

									</tr>
									<tr>
										<td><i>x</i></td>
										<td>在画布上放置图像的 x 坐标位置。</td>

									</tr>
									<tr>
										<td><i>y</i></td>
										<td>在画布上放置图像的 y 坐标位置。</td>

									</tr>
									<tr>
										<td><i>width</i></td>
										<td>可选。要使用的图像的宽度（伸展或缩小图像）。</td>

									</tr>
									<tr>
										<td><i>height</i></td>
										<td>可选。要使用的图像的高度（伸展或缩小图像）。</td>

									</tr>
								</tbody>
							</table>
							<div class="row">
								<div class="col-md-4">
									<canvas id="canvas-image" height="500px" />
								</div>
								<div class="col-md-8" style="padding-left: 0px;">
									<img id="canvas-img" src="images/img_the_scream.jpg"
										style="display: none;">
									<pre class="brush: js;">
var c = document.getElementById("canvas-image");
var ctx = c.getContext("2d");
var img = document.getElementById("canvas-img");
ctx.drawImage(img, 10, 10);

ctx.drawImage(img, 10, 300, 80, 90);

ctx.drawImage(img, 80, 120, 120, 130, 10, 400, 120, 130);
</pre>
								</div>
							</div>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">像素操作</h5>
							<table class="table table-bordered table-striped runoob"
								data-base="http://www.runoob.com/tags/">
								<tbody>
									<tr>
										<th width="25%" align="left">属性</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-imagedata-width.html">width</a></td>
										<td>返回 ImageData 对象的宽度。</td>
									</tr>
									<tr>
										<td><a href="canvas-imagedata-height.html">height</a></td>
										<td>返回 ImageData 对象的高度。</td>
									</tr>
									<tr>
										<td><a href="canvas-imagedata-data.html">data</a></td>
										<td>返回一个对象，其包含指定的 ImageData 对象的图像数据。</td>
									</tr>
									<tr>
										<th width="25%" align="left">方法</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-createimagedata.html">createImageData()</a></td>
										<td>创建新的、空白的 ImageData 对象。</td>
									</tr>
									<tr>
										<td><a href="canvas-getimagedata.html">getImageData()</a></td>
										<td>返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据。</td>
									</tr>
									<tr>
										<td><a href="canvas-putimagedata.html">putImageData()</a></td>
										<td>把图像数据（从指定的 ImageData 对象）放回画布上。</td>
									</tr>
								</tbody>
							</table>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">合成</h5>
							<table class="table table-bordered table-striped runoob"
								data-base="http://www.runoob.com/tags/">
								<tbody>
									<tr>
										<th width="25%" align="left">属性</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td><a href="canvas-globalalpha.html">globalAlpha</a></td>
										<td>设置或返回绘图的当前 alpha 或透明值。</td>
									</tr>
									<tr>
										<td><a href="canvas-globalcompositeoperation.html">globalCompositeOperation</a></td>
										<td>设置或返回新图像如何绘制到已有的图像上。</td>
									</tr>
								</tbody>
							</table>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">其他</h5>
							<table class="table table-bordered table-striped runoob"
								data-base="http://www.runoob.com/tags/">
								<tbody>
									<tr>
										<th width="25%" align="left">方法</th>
										<th width="75%" align="left">描述</th>
									</tr>
									<tr>
										<td>save()</td>
										<td>保存当前环境的状态。</td>
									</tr>
									<tr>
										<td>restore()</td>
										<td>返回之前保存过的路径状态和属性。</td>
									</tr>
									<tr>
										<td>createEvent()</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>getContext()</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>toDataURL()</td>
										<td>&nbsp;</td>
									</tr>
								</tbody>
							</table>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="html5-svg" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">SVG</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p>SVG 是使用 XML 来描述二维图形和绘图程序的语言。</p>
							<p>
								由于SVG是XML文件，SVG图像可以用任何文本编辑器创建，但它往往是与一个绘图程序一起使用，如
								<a href="http://inkscape.org/" target="_blank">Inkscape</a>
								，更方便地创建SVG图像。
							</p>
							<h5>什么是SVG？</h5>
							<ul>
								<li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li>
								<li>SVG 用来定义用于网络的基于矢量的图形</li>
								<li>SVG 使用 XML 格式定义图形</li>
								<li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li>
								<li>SVG 是万维网联盟的标准</li>
								<li>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</li>
							</ul>
							<p>与其他图像格式相比，使用 SVG 的优势在于：</p>
							<ul>
								<li>SVG 可被非常多的工具读取和修改（比如记事本）</li>
								<li>SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。</li>
								<li>SVG 是可伸缩的</li>
								<li>SVG 图像可在任何的分辨率下被高质量地打印</li>
								<li>SVG 可在图像质量不下降的情况下被放大</li>
								<li>SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）</li>
								<li>SVG 可以与 Java 技术一起运行</li>
								<li>SVG 是开放的标准</li>
								<li>SVG 文件是纯粹的 XML</li>
							</ul>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">Canvas 与 SVG 的比较</h5>

							<p>下表列出了 canvas 与 SVG 之间的一些不同之处。</p>

							<h5>Canvas</h5>
							<ul class="listintable">
								<li>依赖分辨率</li>
								<li>不支持事件处理器</li>
								<li>弱的文本渲染能力</li>
								<li>能够以 .png 或 .jpg 格式保存结果图像</li>
								<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>
							</ul>

							<h5>SVG</h5>
							<ul class="listintable">
								<li>不依赖分辨率</li>
								<li>支持事件处理器</li>
								<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>
								<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>
								<li>不适合游戏应用</li>
							</ul>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">HTML 中引入 SVG</h5>
							<ol>
								<li>
									<p>使用 &lt;embed&gt; 标签</p>
									<div class="row">
										<div class="col-md-1">
											<embed src="images/html5-svg-test.svg" type="image/svg+xml" />
										</div>
										<div class="col-md-11">
											<pre class="brush: xml">
												<embed src="images/html5-svg-test.svg" type="image/svg+xml" />
</pre>
										</div>
									</div>
									<p>优势：所有主要浏览器都支持，并允许使用脚本</p>
									<p>缺点：不推荐在HTML4和XHTML中使用（但在HTML5允许）</p>
								</li>
								<li>
									<p>使用 &lt;object&gt; 标签</p>
									<div class="row">
										<div class="col-md-1">
											<object data="images/html5-svg-test.svg" type="image/svg+xml"></object>
										</div>
										<div class="col-md-11">
											<pre class="brush: xml">
												<object data="images/html5-svg-test.svg"
													type="image/svg+xml"></object>
</pre>
										</div>
									</div>
									<p>优势：所有主要浏览器都支持，并支持HTML4，XHTML和HTML5标准</p>
									<p>缺点：不允许使用脚本</p>
								</li>

								<li>
									<p>使用 &lt;iframe&gt; 标签</p>
									<div class="row">
										<div class="col-md-1">
											<iframe src="images/html5-svg-test.svg"
												style="width: 52px; height: 52px; border: none;"></iframe>
										</div>
										<div class="col-md-11">
											<pre class="brush: xml">
												<iframe src="images/html5-svg-test.svg"></iframe>
</pre>
										</div>
									</div>
									<p>优势：所有主要浏览器都支持，并允许使用脚本</p>
									<p>缺点：不推荐在HTML4和XHTML中使用（但在HTML5允许）</p>
								</li>
								<li>
									<p>直接在HTML嵌入SVG代码</p>
									<div class="row">
										<div class="col-md-1">
											<svg xmlns="http://www.w3.org/2000/svg" version="1.1"
												height="52px">
	<circle cx="26" cy="26" r="24" stroke="black" stroke-width="2"
													fill="blue" />
</svg>
										</div>
										<div class="col-md-11">
											<pre class="brush: xml">
<svg xmlns="http://www.w3.org/2000/svg" width="52px" height="52px">
	<circle cx="26" cy="26" r="24" stroke="black" stroke-width="2"
														fill="green" />
</svg>
</pre>
										</div>
									</div>
									<p>优势：可通过dom直接修改属性。</p>
									<p>缺点：SVG不能直接嵌入到Opera。</p>
								</li>
							</ol>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">SVG有一些预定义的形状元素</h5>
							<table class="table table-bordered table-striped">
								<tbody>
									<tr>
										<td width="14%">元素</td>
										<td width="140px">实例</td>
										<td>代码</td>
									</tr>
									<tr>
										<td>矩形 &lt;rect&gt;</td>
										<td><embed src="images/svg/svg-rect.svg" /></td>
										<td><pre class="brush: xml;">
&lt;rect x="10" y="10" width="100" height="60"  rx="5" ry="5"
    style="fill: #663366; stroke:#993333; stroke-width:5;
    	fill-opacity:0.6; stroke-opacity:0.9" /&gt;
</pre></td>
									</tr>
									<tr>
										<td>圆形 &lt;circle&gt;</td>
										<td><embed src="images/svg/svg-circle.svg" /></td>
										<td><pre class="brush: xml;">
&lt;circle r="32" cx="60" cy="40"
    style="fill: #663366;stroke:#993333;stroke-width:5;
    	fill-opacity:0.6; stroke-opacity:0.9" /&gt;
</pre></td>
									</tr>
									<tr>
										<td>椭圆 &lt;ellipse&gt;</td>
										<td><embed src="images/svg/svg-ellipse.svg" /></td>
										<td><pre class="brush: xml;">
&lt;ellipse rx="56" ry="24" cx="60" cy="40"
    style="fill: #663366;stroke:#993333;stroke-width:5;
    	fill-opacity:0.6; stroke-opacity:0.9" /&gt;
</pre></td>
									</tr>
									<tr>
										<td>线 &lt;line&gt;</td>
										<td><embed src="images/svg/svg-line.svg" /></td>
										<td><pre class="brush: xml;">
&lt;line x1="10" y1="25" x2="110" y2="25"
    style="stroke:#993333; stroke-width:5; stroke-opacity:0.9" /&gt;
</pre></td>
									</tr>
									<tr>
										<td>折线 &lt;polyline&gt;</td>
										<td><embed src="images/svg/svg-polyline.svg" /></td>
										<td><pre class="brush: xml;">
&lt;polyline points="10,10 40,10 40,40 80,40 80,10, 120,10"
    style="fill: none;stroke:#993333;stroke-width:5;
    	fill-opacity:0.6; stroke-opacity:0.9" /&gt;
</pre></td>
									</tr>
									<tr>
										<td>多边形 &lt;polygon&gt;</td>
										<td><embed src="images/svg/svg-polyline-mul.svg" /></td>
										<td><pre class="brush: xml;">
&lt;polyline points="10,10 70,10 110,70 50,70 10,10"
    style="fill: #663366;stroke:#993333;stroke-width:2;
    	fill-opacity:0.6; stroke-opacity:0.9" /&gt;
</pre></td>
									</tr>
									<tr>
										<td>路径 &lt;path&gt;</td>
										<td><embed src="images/svg/svg-path.svg" /></td>
										<td><pre class="brush: xml;">
&lt;path d="M50 0 L10 70 L100 70 Z" 
    style="fill: #663366;stroke:#993333;stroke-width:1;
    	fill-opacity:0.6; stroke-opacity:0.9" /&lt;
&lt;!-- 
	注意：以下所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。
    M = moveto
    L = lineto
    H = horizontal lineto
    V = vertical lineto
    C = curveto
    S = smooth curveto
    Q = quadratic Bézier curve
    T = smooth quadratic Bézier curveto
    A = elliptical Arc
    Z = closepath
 --&gt;
</pre></td>
									</tr>
									<tr>
										<td>文本 &lt;text&gt;</td>
										<td><embed src="images/svg/svg-text.svg" /></td>
										<td><pre class="brush: xml;">
&lt;svg
	xmlns="http://www.w3.org/2000/svg"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	width="120px"
	height="80px">
	&lt;defs>
    	&lt;path id="path1" d="M10,80 a1,1 0 0,0 100,0" />
	&lt;/defs>
	&lt;text x="10" y="20" style="fill:#663366;">普通文字&lt;/text>
	&lt;text x="10" y="60" fill="#663366" transform="rotate(30 20,40)">
		旋转的文字
	&lt;/text>
	&lt;text x="10" y="100" style="fill:#663366;">
		&lt;textPath xlink:href="#path1">路径 PATH 上的文字&lt;/textPath>
	&lt;/text>
&lt;/svg>
</pre></td>
									</tr>
									<tr>
										<td>效果</td>
										<td>实例</td>
										<td>代码</td>
									</tr>
									<tr>
										<td>Stroke 属性</td>
										<td><embed src="images/svg/svg-stroke.svg" /></td>
										<td><pre class="brush: xml;">
<!-- stroke 属性 -->
&lt;g fill="none">
    &lt;path stroke="red" d="M5 20 l110 0" />
    &lt;path stroke="blue" d="M5 40 l110 0" />
    &lt;path stroke="black" d="M5 60 l110 0" />
&lt;/g>
&lt;!-- stroke-width -->
&lt;g fill="none">
    &lt;path stroke="red" stroke-width="2" d="M5 80 l110 0" />
    &lt;path stroke="blue" stroke-width="4" d="M5 100 l110 0" />
    &lt;path stroke="black" stroke-width="6" d="M5 120 l110 0" />
&lt;/g>
&lt;!-- stroke-linecap -->
&lt;g fill="none" stroke-width="6">
    &lt;path stroke="red" stroke-linecap="butt" d="M5 140 l110 0" />
    &lt;path stroke="blue" stroke-linecap="round" d="M5 160 l110 0" />
    &lt;path stroke="black" stroke-linecap="square" d="M5 180 l110 0" />
&lt;/g>
&lt;!-- stroke-dasharray -->
&lt;g fill="none" stroke="#663366" stroke-width="4">
    &lt;path stroke-dasharray="5,5" d="M5 200 l110 0" />
    &lt;path stroke-dasharray="10,10" d="M5 220 l110 0" />
    &lt;path stroke-dasharray="20,10,5,5,5,10" d="M5 240 l110 0" />
&lt;/g>
</pre></td>
									</tr>
								</tbody>
							</table>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">SVG 参考手册</h5>
							<table class="table table-bordered table-striped">
								<tbody>
									<tr>
										<th width="20%" align="left">元素</th>
										<th width="30%" align="left">说明</th>
										<th width="50%" align="left">属性</th>
									</tr>
									<tr>
										<td>&lt;a&gt;</td>
										<td>创建一个SVG元素周围链接</td>
										<td>xlink:show<br> xlink:actuate<br> xlink:href<br>
											target
										</td>
									</tr>
									<tr>
										<td>&lt;altGlyph&gt;</td>
										<td>允许对象性文字进行控制，来呈现特殊的字符数据</td>
										<td>x<br> y<br> dx<br> dy<br> rotate<br>
											glyphRef<br> format<br> xlink:href
										</td>
									</tr>
									<tr>
										<td>&lt;altGlyphDef&gt;</td>
										<td>定义一系列象性符号的替换</td>
										<td>id</td>
									</tr>
									<tr>
										<td>&lt;altGlyphItem&gt;</td>
										<td>定义一系列候选的象性符号的替换</td>
										<td>id</td>
									</tr>
									<tr>
										<td>&lt;animate&gt;</td>
										<td>随时间动态改变属性</td>
										<td>attributeName="目标属性名称"<br> from="起始值"<br>
											to="结束值"<br> dur="持续时间"<br> repeatCount="动画时间将发生"
										</td>
									</tr>
									<tr>
										<td>&lt;animateColor&gt;</td>
										<td>定义随着时间的推移颜色转换</td>
										<td>by="相对偏移值"<br> from="起始值"<br> to="结束值"
										</td>
									</tr>
									<tr>
										<td>&lt;animateMotion&gt;</td>
										<td>使元素沿着动作路径移动</td>
										<td>calcMode="动画的插补模式。可以是'discrete', 'linear', 'paced',
											'spline'"<br> path="运动路径"<br>
											keyPoints="沿运动路径的对象目前时间应移动多远"<br> rotate="应用旋转变换"<br>
											xlink:href="一个URI引用&lt;path&gt;元素，它定义运动路径"
										</td>
									</tr>
									<tr>
										<td>&lt;animateTransform&gt;</td>
										<td>动画上一个目标元素变换属性，从而使动画控制平移，缩放，旋转或倾斜</td>
										<td>by="相对偏移值"<br> from="起始值"<br> to="结束值"<br>
											type="类型的转换其值是随时间变化。可以是 'translate', 'scale', 'rotate',
											'skewX', 'skewY'"
										</td>
									</tr>
									<tr>
										<td>&lt;circle&gt;</td>
										<td>定义一个圆</td>
										<td>cx="圆的x轴坐标"<br> cy="圆的y轴坐标"<br> r="圆的半径".
											必需.<br> <br> + 显现属性：颜色，FillStroke，图形
										</td>
									</tr>
									<tr>
										<td>&lt;clipPath&gt;</td>
										<td>用于隐藏位于剪切路径以外的对象部分。定义绘制什么和什么不绘制的模具被称为剪切路径</td>
										<td>clip-path="引用剪贴路径和引用剪贴路径交叉"<br>
											clipPathUnits="userSpaceOnUse'或'objectBoundingBox"。第二个值childern一个对象的边框，会使用掩码的一小部分单位（默认："userSpaceOnUse"）"
										</td>
									</tr>
									<tr>
										<td>&lt;color-profile&gt;</td>
										<td>指定颜色配置文件的说明（使用CSS样式文件时）</td>
										<td>local="本地存储颜色配置文件唯一ID"<br> name=""<br>
											rendering-intent="auto|perceptual|relative-colorimetric|saturation|absolute-colorimetric"<br>
											xlink:href="ICC配置文件资源URI"
										</td>
									</tr>
									<tr>
										<td>&lt;cursor&gt;</td>
										<td>定义一个独立于平台的自定义光标</td>
										<td>x="x轴左上角光标（默认为0）"<br> y="y轴的左上角光标（默认为0）"<br>
											xlink:href="使用光标图像URI
										</td>
									</tr>
									<tr>
										<td>&lt;defs&gt;</td>
										<td>引用的元素容器</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>&lt;desc&gt;</td>
										<td>对 SVG 中的元素的纯文本描述 - 并不作为图形的一部分来显示。用户代理会将其显示为工具提示</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>&lt;ellipse&gt;</td>
										<td>定义一个椭圆</td>
										<td>cx="椭圆x轴坐标"<br> cy="椭圆y轴坐标"<br>
											rx="沿x轴椭圆形的半径"。必需。<br> ry="沿y轴长椭圆形的半径"。必需。<br> <br>
											+ 显现属性：颜色，FillStroke，图形
										</td>
									</tr>
									<tr>
										<td>&lt;feBlend&gt;</td>
										<td>使用不同的混合模式把两个对象合成在一起</td>
										<td>mode="图像混合模式：normal|multiply|screen|darken|lighten"<br>
											in="标识为给定的滤镜原始输入：SourceGraphic | SourceAlpha |
											BackgroundImage | BackgroundAlpha | FillPaint | StrokePaint |
											&lt;filter-primitive-reference&gt;"<br>
											in2="第二输入图像的混合操作"
										</td>
									</tr>
									<tr>
										<td>feColorMatrix</td>
										<td>SVG滤镜。适用矩阵转换</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feComponentTransfer</td>
										<td>SVG 滤镜。执行数据的 component-wise 重映射</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feComposite</td>
										<td>SVG 滤镜</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feConvolveMatrix</td>
										<td>SVG 滤镜</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feDiffuseLighting</td>
										<td>SVG 滤镜</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feDisplacementMap</td>
										<td>SVG 滤镜</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feDistantLight</td>
										<td>SVG滤镜。定义一个光源</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feFlood</td>
										<td>SVG滤镜</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feFuncA</td>
										<td>SVG 滤镜。feComponentTransfer 的子元素</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feFuncB</td>
										<td>SVG 滤镜。feComponentTransfer 的子元素</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feFuncG</td>
										<td>SVG 滤镜。feComponentTransfer 的子元素</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feFuncR</td>
										<td>SVG 滤镜。feComponentTransfer 的子元素</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feGaussianBlur</td>
										<td>SVG滤镜。执行高斯模糊图像</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feImage</td>
										<td>SVG滤镜。</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feMerge</td>
										<td>SVG滤镜。建立在彼此顶部图像层</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feMergeNode</td>
										<td>SVG 滤镜。feMerge的子元素</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feMorphology</td>
										<td>SVG 滤镜。 对源图形执行"fattening" 或者 "thinning"</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feOffset</td>
										<td>SVG滤镜。相对其当前位置移动图像</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>fePointLight</td>
										<td>SVG滤镜</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feSpecularLighting</td>
										<td>SVG滤镜</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feSpotLight</td>
										<td>SVG滤镜</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feTile</td>
										<td>SVG滤镜</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>feTurbulence</td>
										<td>SVG滤镜</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>filter</td>
										<td>滤镜效果的容器</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>font</td>
										<td>定义字体</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>font-face</td>
										<td>描述一种字体的特点</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>font-face-format</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>font-face-name</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>font-face-src</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>font-face-uri</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>foreignObject</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>&lt;g&gt;</td>
										<td>用于把相关元素进行组合的容器元素</td>
										<td>id="该组的名称"<br> fill="该组填充颜色"<br>
											opacity="该组不透明度"<br> <br> + 显现属性:<br> All
										</td>
									</tr>
									<tr>
										<td>glyph</td>
										<td>为给定的象形符号定义图形</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>glyphRef</td>
										<td>定义要使用的可能的象形符号</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>hkern</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>&lt;image&gt;</td>
										<td>定义图像</td>
										<td>x="图像的左上角的x轴坐标"<br> y="图像的左上角的y轴坐标"<br>
											width="图像的宽度". 必须.<br> height="图像的高度". 必须.<br>
											xlink:href="图像的路径". 必须.<br> <br> + 显现属性:<br>
											Color, Graphics, Images, Viewports
										</td>
									</tr>
									<tr>
										<td>&lt;line&gt;</td>
										<td>定义一条线</td>
										<td>x1="直线起始点x坐标"<br> y1="直线起始点y坐标"<br>
											x2="直线终点x坐标"<br> y2="直线终点y坐标"<br> <br> + 显现属性:<br>
											Color, FillStroke, Graphics, Markers
										</td>
									</tr>
									<tr>
										<td>&lt;linearGradient&gt;</td>
										<td>定义线性渐变。通过使用矢量线性渐变填充对象，并可以定义为水平，垂直或角渐变。</td>
										<td>id="id 属性可为渐变定义一个唯一的名称。引用必须"<br>
											gradientUnits="'userSpaceOnUse' or
											'objectBoundingBox'.使用视图框或对象，以确定相对位置矢量点。
											（默认为'objectBoundingBox）"<br>
											gradientTransform="适用于渐变的转变"<br> x1="渐变向量x启动点（默认0％）"<br>
											y1="渐变向量y启动点（默认0％）" <br> x2="渐变向量x的终点。 （默认100％）"<br>
											y2="渐变向量y的终点。 （默认0％）" <br> spreadMethod="'pad' or
											'reflect' or 'repeat'"<br> xlink:href="reference to
											another gradient whose attribute values are used as defaults
											and stops included. Recursive"
										</td>
									</tr>
									<tr>
										<td>&lt;marker&gt;</td>
										<td>标记可以放在直线，折线，多边形和路径的顶点。这些元素可以使用maeker属性的"maeker-start"，"maeker-mid"和"maeker-end"，继承默认情况下或可设置为"none"或定义的标记的URI。您必须先定义标记，然后才可以通过其URI引用。任何一种形状，可以把标记放在里面。他们绘制元素时把它们附加到顶部</td>
										<td>markerUnits="strokeWidth'或'userSpaceOnUse"。如果是strokeWidth"那么使用一个单位等于一个笔划宽度。否则，标记尺度不会使用同一视图单位作为引用元素（默认为'strokeWidth'）"<br>
											refx="标记顶点连接的位置（默认为0）"<br> refy="标记顶点连接的位置（默认为0）"<br>
											orient="'auto'始终显示标记的角度。 "auto"将计算某个角度使得X轴一个顶点的正切值（默认为0）<br>
											markerWidth="标记的宽度（默认3）"<br> markerHeight="标记的高度（默认3）"<br>
											viewBox="各点"看到"这个SVG绘图区域。由空格或逗号分隔的4个值。(min x, min y, width,
											height)" <br> <br> + presentation attributes:<br>
											All
										</td>
									</tr>
									<tr>
										<td>&lt;mask&gt;</td>
										<td>度屏蔽是一种不透明度值的组合和裁剪。像裁剪，您可以使用图形，文字或路径定义掩码的部分。一个掩码的默认状态是完全透明的，也就是裁剪平面的对面的。在掩码的图形设置掩码的不透明部分</td>
										<td>maskUnits="'userSpaceOnUse' or
											'objectBoundingBox'.设定裁剪面是否是相对完整的视窗或对象（默认：'objectBoundingBox'）"<br>
											maskContentUnits="第二个掩码相对对象的图形位置使用百分比'userSpaceOnUse'或'objectBoundingBox'（默认：'userSpaceOnUse'）"<br>
											x="裁剪面掩码（默认值：-10％）" <br> y="裁剪面掩码（默认值：-10％）" <br>
											width="裁剪面掩码（默认是：120％）"<br> height="裁剪面掩码（默认是：120％）"
										</td>
									</tr>
									<tr>
										<td>metadata</td>
										<td>指定元数据</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>missing-glyph</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>mpath</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>&lt;path&gt;</td>
										<td>定义一个路径</td>
										<td>d="定义路径指令"<br>
											pathLength="如果存在，路径将进行缩放，以便计算各点相当于此值的路径长度"<br>
											transform="转换列表"<br> <br> + 显现属性:<br> Color,
											FillStroke, Graphics, Markers
										</td>
									</tr>
									<tr>
										<td>&lt;pattern&gt;</td>
										<td>定义坐标，你想要的视图显示和视图的大小。然后添加到您的模式形状。该模式命中时重复视图框的边缘（可视范围）</td>
										<td>id="用于引用这个模式的唯一ID。"必需的。 <br>
											patternUnits="userSpaceOnUse'或'objectBoundingBox"。第二个值X，Y，width，height
											一个会使用模式对象的边框的小部分，单位（％）。"<br>
											patternContentUnits="'userSpaceOnUse'或 'objectBoundingBox'"<br>
											patternTransform="允许整个表达式进行转换"<br>
											x="模式的偏移量，来自左上角（默认为0）" <br> y="模式的偏移量，来自左上角（默认为0）"<br>
											width="模式平铺的宽度（默认为100％）" <br> height="模式平铺的高度（默认为100％）"<br>
											viewBox="各点"看到"这个SVG绘图区域。由空格或逗号分隔的4个值。(min x, min y, width,
											height)" <br> xlink:href="另一种模式，其属性值是默认值以及任何子类可以继承。递归"<br>
											&nbsp;
										</td>
									</tr>
									<tr>
										<td>&lt;polygon&gt;</td>
										<td>定义一个包含至少三边图形</td>
										<td>points="多边形的点。点的总数必须是偶数"。必需的。<br>
											fill-rule="FillStroke演示属性的部分"<br> <br> + 显现属性:<br>
											Color, FillStroke, Graphics, Markers
										</td>
									</tr>
									<tr>
										<td>&lt;polyline&gt;</td>
										<td>定义只有直线组成的任意形状</td>
										<td>points=折线上的"点"。必需的。<br> <br> + 显现属性:<br>
											Color, FillStroke, Graphics, Markers
										</td>
									</tr>
									<tr>
										<td>&lt;radialGradient&gt;</td>
										<td>定义放射性渐变。放射性渐变创建一个圆圈</td>
										<td>gradientUnits="'userSpaceOnUse' or
											'objectBoundingBox'. 使用视图框或对象以确定相对位置的矢量点。
											（默认为'objectBoundingBox）"<br>
											gradientTransform="适用于渐变的变换" <br> cx="渐变的中心点（数字或％ -
											50％是默认）"<br> cy="渐变的中心点。 （默认50％）"<br> r="渐变的半径。
											（默认50％）" <br> fx="渐变的焦点。 （默认0％）"<br> fy="渐变的焦点。
											（默认0％）"<br> spreadMethod="'pad' or 'reflect' or
											'repeat'"<br> xlink:href="引用到另一个渐变，其属性值作为默认值。递归"
										</td>
									</tr>
									<tr>
										<td>&lt;rect&gt;</td>
										<td>定义一个矩形</td>
										<td>x="矩形的左上角的x轴"<br> y="矩形的左上角的y轴"<br>
											rx="x轴的半径（round元素）"<br> ry="y轴的半径（round元素）" <br>
											width="矩形的宽度"。必需的。<br> height="矩形的高度"。必需的。<br> <br>
											+ 显现属性:<br> Color, FillStroke, Graphics
										</td>
									</tr>
									<tr>
										<td>script</td>
										<td>脚本容器。（例如ECMAScript）</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>set</td>
										<td>设置一个属性值指定时间</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>&lt;stop&gt;</td>
										<td>渐变停止</td>
										<td>offset="偏移停止（0到1/0％到100％）". 参考<br>
											stop-color="这个stop的颜色" <br> stop-opacity="这个Stop的不透明度
											(0到1)"
										</td>
									</tr>
									<tr>
										<td>style</td>
										<td>可使样式表直接嵌入SVG内容内部</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>&lt;svg&gt;</td>
										<td>创建一个SVG文档片段</td>
										<td>x="左上角嵌入（默认为0）"<br> y="左上角嵌入（默认为0）"<br>
											width="SVG片段的宽度（默认为100％）"<br> height="SVG片段的高度（默认为100％）"<br>
											viewBox="点"seen"这个SVG绘图区域。由空格或逗号分隔的4个值。 (min x, min y, width,
											height)"<br>
											preserveAspectRatio="'none'或任何'xVALYVAL'的9种组合,VAL是"min"，"mid"或"max"。（默认情况下none）"<br>
											zoomAndPan="'magnify' or
											'disable'.Magnify选项允许用户平移和缩放您的文件（默认Magnify ）"<br>
											xml="最外层&lt;svg&gt;元素都需要安装SVG和它的命名空间：
											xmlns="http://www.w3.org/2000/svg"
											xmlns:xlink="http://www.w3.org/1999/xlink"
											xml:space="preserve""<br> <br> + 显现属性:<br> All
										</td>
									</tr>
									<tr>
										<td>switch</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>symbol</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>&lt;text&gt;</td>
										<td>定义一个文本</td>
										<td>x="列表的X
											-轴的位置。在文本中在第n个字符的位置在第n个x轴。如果后面存在额外的字符，耗尽他们最后一个字符之后放置的位置。
											0是默认"<br> y="列表的Y轴位置。（参考x）0是默认"<br>
											dx="在字符的长度列表中移动相对最后绘制标志符号的绝对位置。（参考x）"<br>
											dy="在字符的长度列表中移动相对最后绘制标志符号的绝对位置。（参考x）" <br>
											rotate="一个旋转的列表。第n个旋转是第n个字符。附加字符没有给出最后的旋转值"<br>
											textLength="SVG查看器将尝试显示文本之间的间距/或字形调整的文本目标长度。（默认：正常文本的长度）"<br>
											lengthAdjust="告诉查看器，如果指定长度就尝试进行调整用以呈现文本。这两个值是'spacing'和'spacingAndGlyphs'"<br>
											<br> + 显现属性:<br> Color, FillStroke, Graphics,
											FontSpecification, TextContentElements
										</td>
									</tr>
									<tr>
										<td>textPath</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>title</td>
										<td>对 SVG 中的元素的纯文本描述 - 并不作为图形的一部分来显示。用户代理会将其显示为工具提示</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>&lt;tref&gt;</td>
										<td>引用任何SVG文档中的&lt;text&gt;元素和重用</td>
										<td>相同的&lt;TEXT&gt;元素</td>
									</tr>
									<tr>
										<td>&lt;tspan&gt;</td>
										<td>元素等同于&lt;text&gt;，但可以在内部嵌套文本标记以及内部本身</td>
										<td>Identical to the &lt;text&gt; element<br> + in
											addition:<br> xlink:href="引用一个&lt;TEXT&gt;元素"
										</td>
									</tr>
									<tr>
										<td>&lt;use&gt;</td>
										<td>使用URI引用一个&lt;G&gt;,&lt;svg&gt;或其他具有一个唯一的ID属性和重复的图形元素。复制的是原始的元素，因此文件中的原始存在只是一个参考。原始影响到所有副本的任何改变。</td>
										<td>x="克隆元素的左上角的x轴"<br> y="克隆元素的左上角的y轴"<br>
											width="克隆元素的宽度"<br> height="克隆元素的高度"<br>
											xlink:href="URI引用克隆元素"<br> <br> + 显现属性:<br>
											All
										</td>
									</tr>
									<tr>
										<td>view</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
									<tr>
										<td>vkern</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
								</tbody>
							</table>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="html5-" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">...</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="html5-" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">...</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushXml.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJScript.js"></script>
	<script src="../commons/js/common.js"></script>
	<script src="res/menu.js"></script>
	<script src="js/demo-canvas.js"></script>
</body>
</html>
