<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--NODE-JS</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">NODE-JS</h3>
					</div>
					<div class="list-group">
						<a href="#node-js-intro" class="list-group-item">简介</a>
						<a href="#node-js-npm" class="list-group-item">NPM 使用介绍</a>
						<a href="#node-js-package" class="list-group-item">package.json</a>
						<a href="#node-js-EventEmitter" class="list-group-item">EventEmitter</a>
						<a href="#node-js-Buffer" class="list-group-item">Buffer</a>
						<a href="#node-js-Stream" class="list-group-item">Stream</a>
						<a href="#node-js-get-post" class="list-group-item">GET 和 POST</a>
						<a href="#node-js-global" class="list-group-item">全局对象</a>
						<a href="#node-js-util" class="list-group-item">常用工具 -- util</a>
						<a href="#node-js-file-system" class="list-group-item">文件系统</a>
						<a href="#node-js-tools" class="list-group-item">工具模块</a>
						<a href="#node-js-express" class="list-group-item">Express 框架</a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<a id="node-js-intro" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<p>简单的说 Node.js 就是运行在服务端的 JavaScript。</p>
						<p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p>
						<p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
						<p>
							Node.js v7.2.1 Documentation --
							<a href="https://nodejs.org/api/index.html" target="_blank">官网链接</a>
							--
							<a href="docs/node-js-7.2.1/api/index.html" target="_blank">本地副本</a>
						</p>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-npm" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">NPM 介绍</h3>
					</div>
					<div class="panel-body">
						<p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
						<ul>
							<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
							<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
							<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
						</ul>
						<p>npm 常用命令</p>
						<pre class="brush: bash;">
$ npm -v					# 显示版本号
$ npm ls -g					# 查看所有全局安装的模块
$ npm uninstall express		# 卸载模块
$ npm ls					# 查看模块
$ npm update express		# 更新模块
$ npm search express		# 搜索模块
$ npm init					# 创建模块
$ npm publish				# 发布模块
</pre>
						<p>使用 npm 命令安装模块</p>
						<pre class="brush: bash;">
# 安装 express 模块, 安装完成 express 包就放在了工程目录下的 node_modules 目录中,
$ npm install express		# 使用: var express = require('express');
$ npm install express		# 本地安装
$ npm install express -g	# 全局安装
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-package" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">package.json 属性说明</h3>
					</div>
					<div class="panel-body">
						<ul>
							<li>
								<p>
									<b>name</b> - 包名。
								</p>
							</li>
							<li>
								<p>
									<b>version</b> - 包的版本号。
								</p>
							</li>
							<li>
								<p>
									<b>description</b> - 包的描述。
								</p>
							</li>
							<li>
								<p>
									<b>homepage</b> - 包的官网 url 。
								</p>
							</li>
							<li>
								<p>
									<b>author</b> - 包的作者姓名。
								</p>
							</li>
							<li>
								<p>
									<b>contributors</b> - 包的其他贡献者姓名。
								</p>
							</li>
							<li>
								<p>
									<b>dependencies</b> - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在
									node_module 目录下。
								</p>
							</li>
							<li>
								<p>
									<b>repository</b> - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。
								</p>
							</li>
							<li>
								<p>
									<b>main</b> - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫
									express，然后用户安装它，然后require("express")。
								</p>
							</li>
							<li>
								<p>
									<b>keywords</b> - 关键字
								</p>
							</li>
						</ul>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-EventEmitter" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">EventEmitter -- 事件发射器</h3>
					</div>
					<div class="panel-body">
						<p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>
						<p>Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件，
							一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是
							events.EventEmitter 的实例。</p>
						<p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter
							的核心就是事件触发与事件监听器功能的封装。</p>
						<p>
						<pre class="brush: js;">
// 引入 events 模块
var events = require('events');
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();

eventEmitter.on("some-event", function(){
    console.log("some-event 事件触发");
});

eventEmitter.emit("some-event");
</pre>
						<p class="h5 text-primary">继承 EventEmitter</p>
						<p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http
							在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
						<p>为什么要这样做呢？原因有两点：</p>
						<p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。</p>
						<p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter
							不会打乱对象原有的继承关系。</p>

						<p class="h5 text-primary">EventEmitter 参考</p>
						<p class="h6 text-primary">方法
						</h6>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th>序号</th>
									<th>方法 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>addListener(event, listener)</b> --
										为指定事件添加一个监听器到监听器数组的尾部。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>on(event, listener)</b> -- 为指定事件注册一个监听器，接受一个字符串
										event 和一个回调函数。 <pre class="brush: js;" style="">
server.on('connection', function (stream) {
	console.log('someone connected!');
});
</pre></td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>once(event, listener)</b> -- 为指定事件注册一个单次监听器，即
										监听器最多只会触发一次，触发后立刻解除该监听器。 <pre class="brush: js;">
server.once('connection', function (stream) {
  console.log('Ah, we have our first user!');
});
</pre></td>
								</tr>
								<tr>
									<td>4</td>
									<td><b>removeListener(event, listener)</b> --
										移除指定事件的某个监听器，监听器 必须是该事件已经注册过的监听器。 <pre class="brush: js;"
											style="">
var callback = function(stream) {
	console.log('someone connected!');
};
server.on('connection', callback);
// ...
server.removeListener('connection', callback);
</pre></td>
								</tr>
								<tr>
									<td>5</td>
									<td><b>removeAllListeners([event])</b> -- 移除所有事件的所有监听器，
										如果指定事件，则移除指定事件的所有监听器。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><b>setMaxListeners(n)</b> -- 默认情况下， EventEmitters
										如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><b>listeners(event)</b> -- 返回指定事件的监听器数组。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><b>emit(event, [arg1], [arg2], [...])</b> --
										按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td>
								</tr>
							</tbody>
						</table>
						<p class="h6 text-primary">类方法
						</h6>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th>序号</th>
									<th>方法 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>listenerCount(emitter, event)</b> -- 返回指定事件的监听器数量。</td>
								</tr>
							</tbody>
						</table>
						<p class="h6 text-primary">事件
						</h6>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th>序号</th>
									<th>事件 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>newListener</b> --
										<ul>
											<li>
												<p>
													<b>event</b> - 字符串，事件名称
												</p>
											</li>
											<li>
												<p>
													<b>listener</b> - 处理事件函数
												</p>
											</li>
										</ul>
										<p>该事件在添加新监听器时被触发。</p></td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>removeListener</b> --
										<ul>
											<li>
												<p>
													<b>event</b> - 字符串，事件名称
												</p>
											</li>
											<li>
												<p>
													<b>listener</b> - 处理事件函数
												</p>
											</li>
										</ul>
										<p>从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</p></td>
								</tr>
							</tbody>
						</table>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-Buffer" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Buffer</h3>
					</div>
					<div class="panel-body">
						<p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p>
						<p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer
							类，该类用来创建一个专门存放二进制数据的缓存区。</p>
						<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js
							带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js
							中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer
							类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th width="50px">序号</th>
									<th>方法 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>new Buffer(size)</b> <br>分配一个新的 size
										大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常
										RangeError。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>new Buffer(buffer)</b> <br>拷贝参数 buffer 的数据到
										Buffer 实例。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>new Buffer(str[, encoding])</b> -- 分配一个新的 buffer
										，其中包含着传入的 str 字符串。 encoding 编码方式默认为 'utf8'。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><b>buf.length</b> -- 返回这个 buffer 的 bytes 数。注意这未必是
										buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer
										对象内容的改变而改变。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><b>buf.write(string[, offset[, length]][,
											encoding])</b> -- 根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string
										数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length
										长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer
										没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length -
										offset。 这个方法不会出现写入部分字符。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><b>buf.writeUIntLE(value, offset, byteLength[,
											noAssert])</b> -- 将value 写入到 buffer 里， 它由offset 和 byteLength
										决定，支持 48 位计算，例如：<br> <pre class="brush: js;" style="">
var b = new Buffer(6);
b.writeUIntBE(0x1234567890ab, 0, 6);
// &lt;Buffer 12 34 56 78 90 ab&gt;
</pre> noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><b>buf.writeUIntBE(value, offset, byteLength[,
											noAssert])</b> -- 将value 写入到 buffer 里， 它由offset 和 byteLength
										决定，支持 48 位计算。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是
										false。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><b>buf.writeIntLE(value, offset, byteLength[,
											noAssert])</b> -- 将value 写入到 buffer 里， 它由offset 和 byteLength
										决定，支持 48 位计算。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是
										false。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><b>buf.writeIntBE(value, offset, byteLength[,
											noAssert])</b> -- 将value 写入到 buffer 里， 它由offset 和 byteLength
										决定，支持 48 位计算。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是
										false。</td>
								</tr>
								<tr>
									<td>10</td>
									<td><b>buf.readUIntLE(offset, byteLength[, noAssert])</b>
										-- 支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer
										的长度，默认为 false。</td>
								</tr>
								<tr>
									<td>11</td>
									<td><b>buf.readUIntBE(offset, byteLength[, noAssert])</b>
										-- 支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer
										的长度，默认为 false。</td>
								</tr>
								<tr>
									<td>12</td>
									<td><b>buf.readIntLE(offset, byteLength[, noAssert])</b>
										-- 支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer
										的长度，默认为 false。</td>
								</tr>
								<tr>
									<td>13</td>
									<td><b>buf.readIntBE(offset, byteLength[, noAssert])</b>
										-- 支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer
										的长度，默认为 false。</td>
								</tr>
								<tr>
									<td>14</td>
									<td><b>buf.toString([encoding[, start[, end]]])</b> -- 根据
										encoding 参数（默认是 'utf8'）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是
										0) 和 end (默认是 buffer.length)作为取值范围。</td>
								</tr>
								<tr>
									<td>15</td>
									<td><b>buf.toJSON()</b> -- 将 Buffer 实例转换为 JSON 对象。</td>
								</tr>
								<tr>
									<td>16</td>
									<td><b>buf[index]</b> --
										获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。</td>
								</tr>
								<tr>
									<td>17</td>
									<td><b>buf.equals(otherBuffer)</b> -- 比较两个缓冲区是否相等，如果是返回
										true，否则返回 false。</td>
								</tr>
								<tr>
									<td>18</td>
									<td><b>buf.compare(otherBuffer)</b> -- 比较两个 Buffer
										对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</td>
								</tr>
								<tr>
									<td>19</td>
									<td><b>buf.copy(targetBuffer[, targetStart[,
											sourceStart[, sourceEnd]]])</b> -- buffer 拷贝，源和目标可以相同。
										targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd
										源结束位置偏移默认是源的长度 buffer.length 。</td>
								</tr>
								<tr>
									<td>20</td>
									<td><b>buf.slice([start[, end]])</b> -- 剪切 Buffer 对象，根据
										start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从
										buffer 尾部开始计算的。</td>
								</tr>
								<tr>
									<td>21</td>
									<td><b>buf.readUInt8(offset[, noAssert])</b> --
										根据指定的偏移量，读取一个有符号 8 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。
										如果这样 offset 可能会超出buffer 的末尾。默认是 false。</td>
								</tr>
								<tr>
									<td>22</td>
									<td><b>buf.readUInt16LE(offset[, noAssert])</b> --
										根据指定的偏移量，使用特殊的 endian 字节序格式读取一个有符号 16 位整数。若参数 noAssert 为 true
										将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
								</tr>
								<tr>
									<td>23</td>
									<td><b>buf.readUInt16BE(offset[, noAssert])</b> --
										根据指定的偏移量，使用特殊的 endian 字节序格式读取一个有符号 16 位整数。若参数 noAssert 为 true
										将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
								</tr>
								<tr>
									<td>24</td>
									<td><b>buf.readUInt32LE(offset[, noAssert])</b> --
										根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数。 若参数 noAssert 为 true
										将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td>
								</tr>
								<tr>
									<td>25</td>
									<td><b>buf.readUInt32BE(offset[, noAssert])</b> --
										根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数。 若参数 noAssert 为 true
										将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td>
								</tr>
								<tr>
									<td>26</td>
									<td><b>buf.readInt8(offset[, noAssert])</b> --
										根据指定的偏移量，读取一个 signed 8 位整数。 若参数 noAssert 为 true 将不会验证 offset
										偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
								</tr>
								<tr>
									<td>27</td>
									<td><b>buf.readInt16LE(offset[, noAssert])</b> --
										根据指定的偏移量，使用特殊的 endian 格式读取一个 signed 16 位整数。 若参数 noAssert 为
										true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是
										false。</td>
								</tr>
								<tr>
									<td>28</td>
									<td><b>buf.readInt16BE(offset[, noAssert])</b> --
										根据指定的偏移量，使用特殊的 endian 格式读取一个 signed 16 位整数。 若参数 noAssert 为
										true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是
										false。</td>
								</tr>
								<tr>
									<td>29</td>
									<td><b>buf.readInt32LE(offset[, noAssert])</b> --
										根据指定的偏移量，使用指定的 endian 字节序格式读取一个 signed 32 位整数。 若参数 noAssert 为
										true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是
										false。</td>
								</tr>
								<tr>
									<td>30</td>
									<td><b>buf.readInt32BE(offset[, noAssert])</b> --
										根据指定的偏移量，使用指定的 endian 字节序格式读取一个 signed 32 位整数。 若参数 noAssert 为
										true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是
										false。</td>
								</tr>
								<tr>
									<td>31</td>
									<td><b>buf.readFloatLE(offset[, noAssert])</b> --
										根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位浮点数。 若参数 noAssert 为 true
										将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td>
								</tr>
								<tr>
									<td>32</td>
									<td><b>buf.readFloatBE(offset[, noAssert])</b> --
										根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位浮点数。 若参数 noAssert 为 true
										将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td>
								</tr>
								<tr>
									<td>33</td>
									<td><b>buf.readDoubleLE(offset[, noAssert])</b> --
										根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位double。 若参数 noAssert 为 true
										将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td>
								</tr>
								<tr>
									<td>34</td>
									<td><b>buf.readDoubleBE(offset[, noAssert])</b> --
										根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位double。 若参数 noAssert 为 true
										将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td>
								</tr>
								<tr>
									<td>35</td>
									<td><b>buf.writeUInt8(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量将 value 写入 buffer。注意：value 必须是一个合法的有符号 8 位整数。
										若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 value 可能过大，或者
										offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。
										除非你对这个参数非常有把握，否则不要使用。默认是 false。</td>
								</tr>
								<tr>
									<td>36</td>
									<td><b>buf.writeUInt16LE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value
										必须是一个合法的有符号 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset
										偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。
										除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
								</tr>
								<tr>
									<td>37</td>
									<td><b>buf.writeUInt16BE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value
										必须是一个合法的有符号 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset
										偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。
										除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
								</tr>
								<tr>
									<td>38</td>
									<td><b>buf.writeUInt32LE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式(LITTLE-ENDIAN:小字节序)将 value
										写入buffer。注意：value 必须是一个合法的有符号 32 位整数。 若参数 noAssert 为 true
										将不会验证 value 和 offset 偏移量参数。 这意味着value
										可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。
										除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
								</tr>
								<tr>
									<td>39</td>
									<td><b>buf.writeUInt32BE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式(Big-Endian:大字节序)将 value
										写入buffer。注意：value 必须是一个合法的有符号 32 位整数。 若参数 noAssert 为 true
										将不会验证 value 和 offset 偏移量参数。 这意味着 value
										可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。
										除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
								</tr>
								<tr>
									<td>40</td>
									<td><b>buf.writeInt8(value, offset[, noAssert])</b> <br根据传入的
											offset="" 偏移量将="" value="" 写入="" buffer="" 。注意：value=""
											必须是一个合法的="" signed="" 8="" 位整数。="" 若参数="" noassert="" 为=""
											true="" 将不会验证="" 和="" 偏移量参数。="" 这意味着="" 可能过大，或者="" 可能会超出=""
											的末尾从而造成="" 被丢弃。="" 除非你对这个参数非常有把握，否则尽量不要使用。默认是=""false。<=""
										td=""></br根据传入的></td>
								</tr>
								<tr>
									<td>41</td>
									<td><b>buf.writeInt16LE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value
										必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和
										offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成
										value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td>
								</tr>
								<tr>
									<td>42</td>
									<td><b>buf.writeInt16BE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value
										必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和
										offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成
										value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td>
								</tr>
								<tr>
									<td>43</td>
									<td><b>buf.writeInt32LE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value
										必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和
										offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成
										value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
								</tr>
								<tr>
									<td>44</td>
									<td><b>buf.writeInt32BE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value
										必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和
										offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成
										value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
								</tr>
								<tr>
									<td>45</td>
									<td><b>buf.writeFloatLE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value
										不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和
										offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成
										value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
								</tr>
								<tr>
									<td>46</td>
									<td><b>buf.writeFloatBE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value
										不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和
										offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成
										value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
								</tr>
								<tr>
									<td>47</td>
									<td><b>buf.writeDoubleLE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value
										必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和
										offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer
										的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
								</tr>
								<tr>
									<td>48</td>
									<td><b>buf.writeDoubleBE(value, offset[, noAssert])</b> --
										根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value
										必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和
										offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer
										的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
								</tr>
								<tr>
									<td>49</td>
									<td><b>buf.fill(value[, offset][, end])</b> -- 使用指定的 value
										来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length)
										，将会填充整个buffer。</td>
								</tr>
							</tbody>
						</table>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-Stream" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Stream</h3>
					</div>
					<div class="panel-body">
						<p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request
							对象就是一个 Stream，还有stdout（标准输出）。</p>
						<p>Node.js，Stream 有四种流类型：</p>
						<ul>
							<li>
								<p>
									<b>Readable</b> - 可读操作。
								</p>
							</li>
							<li>
								<p>
									<b>Writable</b> - 可写操作。
								</p>
							</li>
							<li>
								<p>
									<b>Duplex</b> - 可读可写操作.
								</p>
							</li>
							<li>
								<p>
									<b>Transform</b> - 操作被写入数据，然后读出结果。
								</p>
							</li>
						</ul>
						<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>
						<ul>
							<li>
								<p>
									<b>data</b> - 当有数据可读时触发。
								</p>
							</li>
							<li>
								<p>
									<b>end</b> - 没有更多的数据可读时触发。
								</p>
							</li>
							<li>
								<p>
									<b>error</b> - 在接收和写入过程中发生错误时触发。
								</p>
							</li>
							<li>
								<p>
									<b>finish</b> - 所有数据已被写入到底层系统时触发。
								</p>
							</li>
						</ul>
						<p>读取和写入文件实例:</p>
						<pre class="brush: js;">
var fs = require("fs");

/** 写入数据 */
var writeStream = fs.createWriteStream("res/output.txt");

writeStream.write("This is write test!");
writeStream.write("Stream 写入测试!");

writeStream.end();

writeStream.on('finish', function() {
    console.log("写入完成。");
});

writeStream.on('error', function(err){
   console.log(err.stack);
});

/** 读取数据 */
var readerStream = fs.createReadStream("res/input.txt");
var data = '';

readerStream.on("data", function(trunk){
    data += trunk;
});

readerStream.on("end", function(){
    console.log(data);
});

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-get-post" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">GET 和 POST 请求</h3>
					</div>
					<div class="panel-body">
						<p>GET 请求</p>
						<pre class="brush: js;">
var http = require('http');
var url = require('url');
var util = require('util');

http.createServer(function(req, res){
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end(util.inspect(url.parse(req.url, true)));
}).listen(3000);						
</pre>
						<p>GET 请求</p>
						<pre class="brush: js;">
var http = require('http');
var querystring = require('querystring');
var util = require('util');

http.createServer(function(req, res){
	// 定义了一个post变量，用于暂存请求体的信息
    var post = '';

    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    req.on('data', function(chunk) {
        post += chunk;
    });

	// 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    req.on('end', function() {
        post = querystring.parse(post);
        res.end(util.inspect(post));
    });
}).listen(3000);
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-global" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">全局对象</h3>
					</div>
					<div class="panel-body">
						<p>JavaScript 中有一个特殊的对象，称为全局对象（Global
							Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>
						<p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：
						</p>
						<ul>
							<li>在最外层定义的变量；</li>
							<li>全局对象的属性；</li>
							<li>隐式定义的变量（未定义直接赋值的变量）。</li>
						</ul>
						<div class="sub-item">
							<pre class="brush: js;">
// 输出全局变量 __filename 的值
console.log( __filename );      // 当前正在执行的脚本的文件名
console.log( __dirname );       // 当前执行脚本所在的目录

function printHello(){
   console.log( "Hello, World!");
}

var t = setTimeout(printHello, 2000);   // 全局函数在指定的毫秒(ms)数后执行指定函数

clearTimeout(t);                // 全局函数用于停止一个之前通过 setTimeout() 创建的定时器

// setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭
var m = setInterval(printHello, 1000); 

clearInterval(m);
</pre>
						</div>
						<div class="sub-item">
							<p class="h5 text-primary">console -- 用于提供控制台标准输出</p>
							<table class="table table-condensed table-bordered">
								<tbody>
									<tr>
										<th>序号</th>
										<th>方法 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>console.log([data][, ...])</b> --
											向标准输出流打印字符并以换行符结束。该方法接收若干
											个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf()
											命令的格式输出。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>console.info([data][, ...])</b> --
											P该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>console.error([data][, ...])</b> --
											输出错误消息的。控制台在出现错误时会显示是红色的叉子。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>console.warn([data][, ...])</b> --
											输出警告消息。控制台出现有黄色的惊叹号。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>console.dir(obj[, options])</b> --
											用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>console.time(label)</b> -- 输出时间，表示计时开始。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>console.timeEnd(label)</b> -- 结束时间，表示计时结束。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>console.trace(message[, ...])</b> --
											当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace
											就行了。</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>console.assert(value[, message][, ...])</b> --
											用于判断某个表达式或变量是否为真，接手两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: js;">
console.info("程序开始执行：");

var counter = 10;
console.log("计数: %d", counter);

console.time("获取数据");
//
// 执行一些代码
// 
console.timeEnd('获取数据');

console.info("程序执行完毕。")
</pre>
						</div>
						<div class="sub-item">
							<p class="h5 text-primary">process -- 用于描述当前Node.js
								进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道</p>
							<table class="table table-condensed table-bordered">
								<tbody>
									<tr>
										<th>序号</th>
										<th>事件 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>exit</b> -- 当进程准备退出时触发。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>beforeExit</b> -- 当 node
											清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 'beforeExit'
											的监听器可以异步调用，这样 node 就会继续执行。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>uncaughtException</b> --
											当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>Signal 事件</b> -- 当进程接收到信号时就触发。信号列表详见标准的 POSIX
											信号名，如 SIGINT、SIGUSR1 等。</td>
									</tr>
								</tbody>
							</table>

							<h5>退出状态码</h5>
							<p>退出状态码如下所示：</p>
							<table class="table table-condensed table-bordered">

								<tbody>
									<tr>
										<th>状态码</th>
										<th>名称 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>Uncaught Fatal Exception</b> -- 有未捕获异常，并且没有被域或
											uncaughtException 处理函数处理。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>Unused</b> -- 保留</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>Internal JavaScript Parse Error</b> --
											JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>Internal JavaScript Evaluation Failure</b> --
											JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>Fatal Error</b> -- V8 里致命的不可恢复的错误。通常会打印到 stderr
											，内容为： FATAL ERROR</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>Non-function Internal Exception Handler</b> --
											未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>Internal Exception Handler Run-Time Failure</b> --
											未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果
											process.on('uncaughtException') 或 domain.on('error') 抛出了异常。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>Unused</b> -- 保留</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>Invalid Argument</b> -- 可能是给了未知的参数，或者给的参数没有值。</td>
									</tr>
									<tr>
										<td>10</td>
										<td><b>Internal JavaScript Run-Time Failure</b> --
											JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。</td>
									</tr>
									<tr>
										<td>12</td>
										<td><b>Invalid Debug Argument</b> <br>设置了参数--debug
											和/或 --debug-brk，但是选择了错误端口。</td>
									</tr>
									<tr>
										<td>&gt;128</td>
										<td><b>Signal Exits</b> -- 如果 Node 接收到致命信号，比如SIGKILL 或
											SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。</td>
									</tr>
								</tbody>
							</table>
							<h5>Process 属性</h5>
							<p>Process 提供了很多有用的属性，便于我们更好的控制系统的交互：</p>
							<table class="table table-condensed table-bordered">
								<tbody>
									<tr>
										<th>序号.</th>
										<th>属性 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>stdout</b> -- 标准输出流。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>stderr</b> -- 标准错误流。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>stdin</b> -- 标准输入流。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>argv</b> -- argv
											属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>execPath</b> -- 返回执行当前脚本的 Node 二进制文件的绝对路径。</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>execArgv</b> --
											返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>env</b> -- 返回一个对象，成员为当前 shell 的环境变量</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>exitCode</b> -- 进程退出时的代码，如果进程优通过 process.exit()
											退出，不需要指定退出码。</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>version</b> -- Node 的版本，比如v0.10.18。</td>
									</tr>
									<tr>
										<td>10</td>
										<td><b>versions</b> -- 一个属性，包含了 node 的版本和依赖.</td>
									</tr>
									<tr>
										<td>11</td>
										<td><b>config</b> -- 一个包含用来编译当前 node 执行文件的 javascript
											配置选项的对象。它与运行 ./configure 脚本生成的 "config.gypi" 文件相同。</td>
									</tr>
									<tr>
										<td>12</td>
										<td><b>pid</b> -- 当前进程的进程号。</td>
									</tr>
									<tr>
										<td>13</td>
										<td><b>title</b> -- 进程名，默认值为"node"，可以自定义该值。</td>
									</tr>
									<tr>
										<td>14</td>
										<td><b>arch</b> -- 当前 CPU 的架构：'arm'、'ia32' 或者 'x64'。</td>
									</tr>
									<tr>
										<td>15</td>
										<td><b>platform</b> -- 运行程序所在的平台系统 'darwin', 'freebsd',
											'linux', 'sunos' 或 'win32'</td>
									</tr>
									<tr>
										<td>16</td>
										<td><b>mainModule</b> -- require.main
											的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。</td>
									</tr>
								</tbody>
							</table>
							<h5>方法参考手册</h5>
							<p>Process 提供了很多有用的方法，便于我们更好的控制系统的交互：</p>
							<table class="table table-condensed table-bordered">
								<tbody>
									<tr>
										<th>序号</th>
										<th>方法 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>abort()</b> -- 这将导致 node 触发 abort 事件。会让 node
											退出并生成一个核心文件。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>chdir(directory)</b> -- 改变当前工作进程的目录，如果操作失败抛出异常。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>cwd()</b> -- 返回当前进程的工作目录</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>exit([code])</b> -- 使用指定的 code 结束进程。如果忽略，将会使用 code
											0。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>getgid()</b> -- 获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字
											id，而不是名字。<br>注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和
											Android)。</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>setgid(id)</b> -- 设置进程的群组标识（参见 setgid(2)）。可以接收数字
											ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。<br>注意：这个函数仅在 POSIX
											平台上可用(例如，非Windows 和 Android)。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>getuid()</b> -- 获取进程的用户标识(参见 getuid(2))。这是数字的用户
											id，不是用户名。<br>注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和
											Android)。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>setuid(id)</b> -- 设置进程的用户标识（参见setuid(2)）。接收数字
											ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。<br>注意：这个函数仅在 POSIX
											平台上可用(例如，非Windows 和 Android)。</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>getgroups()</b> -- 返回进程的群组 iD 数组。POSIX
											系统没有保证一定有，但是 node.js 保证有。<br>注意：这个函数仅在 POSIX
											平台上可用(例如，非Windows 和 Android)。</td>
									</tr>
									<tr>
										<td>10</td>
										<td><b>setgroups(groups)</b> -- 设置进程的群组 ID。这是授权操作，所有你需要有
											root 权限，或者有 CAP_SETGID 能力。<br>注意：这个函数仅在 POSIX
											平台上可用(例如，非Windows 和 Android)。</td>
									</tr>
									<tr>
										<td>11</td>
										<td><b>initgroups(user, extra_group)</b> -- 读取 /etc/group
											，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID
											能力。<br>注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
									</tr>
									<tr>
										<td>12</td>
										<td><b>kill(pid[, signal])</b> -- 发送信号给进程. pid 是进程id，并且
											signal 是发送的信号的字符串描述。信号名是字符串，比如 'SIGINT' 或 'SIGHUP'。如果忽略，信号会是
											'SIGTERM'。</td>
									</tr>
									<tr>
										<td>13</td>
										<td><b>memoryUsage()</b> -- 返回一个对象，描述了 Node
											进程所用的内存状况，单位为字节。</td>
									</tr>
									<tr>
										<td>14</td>
										<td><b>nextTick(callback)</b> -- 一旦当前事件循环结束，调用回到函数。</td>
									</tr>
									<tr>
										<td>15</td>
										<td><b>umask([mask])</b> --
											设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。</td>
									</tr>
									<tr>
										<td>16</td>
										<td><b>uptime()</b> -- 返回 Node 已经运行的秒数。</td>
									</tr>
									<tr>
										<td>17</td>
										<td><b>hrtime()</b> -- 返回当前进程的高分辨时间，形式为 [seconds,
											nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。<br>你可以将之前的结果传递给当前的
											process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: js;">
process.on('exit', function(code) {

  // 以下代码永远不会执行
  setTimeout(function() {
    console.log("该代码不会执行");
  }, 0);
  
  console.log('退出码为:', code);
});
console.log("程序执行结束");

// 输出到终端
process.stdout.write("Hello World!" + "\n");

// 通过参数读取
process.argv.forEach(function(val, index, array) {
   console.log(index + ': ' + val);
});

// 获取执行路局
console.log(process.execPath);


// 平台信息
console.log(process.platform);

// 输出当前目录
console.log('当前目录: ' + process.cwd());

// 输出当前版本
console.log('当前版本: ' + process.version);

// 输出内存使用情况
console.log(process.memoryUsage());
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-util" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">常用工具</h3>
					</div>
					<div class="panel-body">
						<p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能
							过于精简的不足。</p>
						<pre class="brush: js;">var util = require('util');</pre>
						<ul>
							<li>
								<p>
									<code>util.inherits</code>
									-- 是一个实现对象间原型继承 的函数
								</p>
								<pre class="brush: js;">
var util = require('util'); 
function Base() { 
	this.name = 'base'; 
	this.base = 1991; 
	this.sayHello = function() { 
	console.log('Hello ' + this.name); 
	}; 
} 
Base.prototype.showName = function() { 
	console.log(this.name);
}; 
function Sub() { 
	this.name = 'sub'; 
} 
util.inherits(Sub, Base); 
var objBase = new Base(); 
objBase.showName(); 
objBase.sayHello(); 
console.log(objBase); 
var objSub = new Sub(); 
objSub.showName(); 
//objSub.sayHello(); 
console.log(objSub); 
</pre>
							</li>

							<li>
								<p>
									<code>util.inspect</code>
									-- 是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。
								</p>
								<pre class="brush: js;">
var util = require('util'); 
function Person() { 
	this.name = 'byvoid'; 
	this.toString = function() { 
	return this.name; 
	}; 
} 
var obj = new Person(); 
console.log(util.inspect(obj)); 
console.log(util.inspect(obj, true)); 
</pre>
							</li>
						</ul>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-file-system" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">文件系统</h3>
					</div>
					<div class="panel-body">
						<p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的
							fs.readFile() 和同步的 fs.readFileSync()。</p>
						<pre class="brush: bash;">var fs = require("fs");</pre>
						<div class="sub-item">
							<p>打开文件</p>
							<pre class="brush: js;">fs.open(path, flags[, mode], callback)</pre>
							<p>参数使用说明如下：</p>
							<ul>
								<li>
									<p>
										<b>path</b> - 文件的路径。
									</p>
								</li>
								<li>
									<p>
										<b>flags</b> - 文件打开的行为。具体值详见下文。
									</p>
								</li>
								<li>
									<p>
										<b>mode</b> - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。
									</p>
								</li>
								<li>
									<p>
										<b>callback</b> - 回调函数，带有两个参数如：callback(err, fd)。
									</p>
								</li>
							</ul>
							<p>flags 参数可以是以下值：</p>
							<table class="table table-condensed table-bordered">
								<tbody>
									<tr>
										<th>Flag</th>
										<th>描述</th>
									</tr>
									<tr>
										<td>r</td>
										<td>以读取模式打开文件。如果文件不存在抛出异常。</td>
									</tr>
									<tr>
										<td>r+</td>
										<td>以读写模式打开文件。如果文件不存在抛出异常。</td>
									</tr>
									<tr>
										<td>rs</td>
										<td>以同步的方式读取文件。</td>
									</tr>
									<tr>
										<td>rs+</td>
										<td>以同步的方式读取和写入文件。</td>
									</tr>
									<tr>
										<td>w</td>
										<td>以写入模式打开文件，如果文件不存在则创建。</td>
									</tr>
									<tr>
										<td>wx</td>
										<td>类似 'w'，但是如果文件路径存在，则文件写入失败。</td>
									</tr>
									<tr>
										<td>w+</td>
										<td>以读写模式打开文件，如果文件不存在则创建。</td>
									</tr>
									<tr>
										<td>wx+</td>
										<td>类似 'w+'， 但是如果文件路径存在，则文件读写失败。</td>
									</tr>
									<tr>
										<td>a</td>
										<td>以追加模式打开文件，如果文件不存在则创建。</td>
									</tr>
									<tr>
										<td>ax</td>
										<td>类似 'a'， 但是如果文件路径存在，则文件追加失败。</td>
									</tr>
									<tr>
										<td>a+</td>
										<td>以读取追加模式打开文件，如果文件不存在则创建。</td>
									</tr>
									<tr>
										<td>ax+</td>
										<td>类似 'a+'， 但是如果文件路径存在，则文件读取追加失败。</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: js;">
var fs = require("fs");

// 异步打开文件
console.log("准备打开文件！");
fs.open('input.txt', 'r+', function(err, fd) {
   if (err) {
       return console.error(err);
   }
  console.log("文件打开成功！");     
});
</pre>
						</div>
						<div class="sub-item">
							<p>获取文件信息</p>
							<pre class="brush: js;">fs.stat(path, callback)</pre>
							<table class="table table-condensed table-bordered">
								<tbody>
									<tr>
										<th>方法</th>
										<th>描述</th>
									</tr>
									<tr>
										<td>stats.isFile()</td>
										<td>如果是文件返回 true，否则返回 false。</td>
									</tr>
									<tr>
										<td>stats.isDirectory()</td>
										<td>如果是目录返回 true，否则返回 false。</td>
									</tr>
									<tr>
										<td>stats.isBlockDevice()</td>
										<td>如果是块设备返回 true，否则返回 false。</td>
									</tr>
									<tr>
										<td>stats.isCharacterDevice()</td>
										<td>如果是字符设备返回 true，否则返回 false。</td>
									</tr>
									<tr>
										<td>stats.isSymbolicLink()</td>
										<td>如果是软链接返回 true，否则返回 false。</td>
									</tr>
									<tr>
										<td>stats.isFIFO()</td>
										<td>如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。</td>
									</tr>
									<tr>
										<td>stats.isSocket()</td>
										<td>如果是 Socket 返回 true，否则返回 false。</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: js;">
var fs = require("fs");

console.log("准备打开文件！");
fs.stat('input.txt', function (err, stats) {
   if (err) {
       return console.error(err);
   }
   console.log(stats);
   console.log("读取文件信息成功！");
   
   // 检测文件类型
   console.log("是否为文件(isFile) ? " + stats.isFile());
   console.log("是否为目录(isDirectory) ? " + stats.isDirectory());    
});


</pre>
						</div>
						<div class="sub-item">
							<p>写入文件</p>
							<pre class="brush: js;">fs.writeFile(filename, data[, options], callback)</pre>
							<p>参数使用说明如下：</p>
							<ul>
								<li>
									<p>
										<b>path</b> - 文件路径。
									</p>
								</li>
								<li>
									<p>
										<b>data</b> - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。
									</p>
								</li>
								<li>
									<p>
										<b>options</b> - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为
										utf8, 模式为 0666 ， flag 为 'w'
									</p>
								</li>
								<li>
									<p>
										<b>callback</b> - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。
									</p>
								</li>
							</ul>
							<pre class="brush: js;">
var fs = require("fs");

console.log("准备写入文件");
fs.writeFile('input.txt', '我是通过写入的文件内容！',  function(err) {
   if (err) {
       return console.error(err);
   }
   console.log("数据写入成功！");
   console.log("--------我是分割线-------------")
   console.log("读取写入的数据！");
   fs.readFile('input.txt', function (err, data) {
      if (err) {
         return console.error(err);
      }
      console.log("异步读取文件数据: " + data.toString());
   });
});
</pre>
						</div>
						<div class="sub-item">
							<p>读取文件</p>
							<pre class="brush: js;">fs.read(fd, buffer, offset, length, position, callback)</pre>
							<p>参数使用说明如下：</p>
							<ul>
								<li>
									<p>
										<b>fd</b> - 通过 fs.open() 方法返回的文件描述符。
									</p>
								</li>
								<li>
									<p>
										<b>buffer</b> - 数据写入的缓冲区。
									</p>
								</li>
								<li>
									<p>
										<b>offset</b> - 缓冲区写入的写入偏移量。
									</p>
								</li>
								<li>
									<p>
										<b>length</b> - 要从文件中读取的字节数。
									</p>
								</li>
								<li>
									<p>
										<b>position</b> - 文件读取的起始位置，如果 position 的值为
										null，则会从当前文件指针的位置读取。
									</p>
								</li>
								<li>
									<p>
										<b>callback</b> - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息，
										bytesRead 表示读取的字节数，buffer 为缓冲区对象。
									</p>
								</li>
							</ul>
							<pre class="brush: js;">
var fs = require("fs");
var buf = new Buffer(1024);

console.log("准备打开已存在的文件！");
fs.open('input.txt', 'r+', function(err, fd) {
   if (err) {
       return console.error(err);
   }
   console.log("文件打开成功！");
   console.log("准备读取文件：");
   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){
      if (err){
         console.log(err);
      }
      console.log(bytes + "  字节被读取");
      
      // 仅输出读取的字节
      if(bytes > 0){
         console.log(buf.slice(0, bytes).toString());
      }
   });
});
</pre>
						</div>
						<div class="sub-item">
							<p>创建目录</p>
							<pre class="brush: js;">fs.mkdir(path[, mode], callback)</pre>
							<pre class="brush: js;">
var fs = require("fs");

console.log("创建目录 /tmp/test/");
fs.mkdir("/tmp/test/",function(err){
   if (err) {
       return console.error(err);
   }
   console.log("目录创建成功。");
});
</pre>

						</div>
						<div class="sub-item">
							<p>删除文件</p>
							<pre class="brush: js;">fs.unlink(path, callback)</pre>
							<pre class="brush: js;">
var fs = require("fs");

console.log("准备删除文件！");
fs.unlink('input.txt', function(err) {
   if (err) {
       return console.error(err);
   }
   console.log("文件删除成功！");
});
</pre>
						</div>
						<div class="sub-item">
							<p>读取目录</p>
							<pre class="brush: js;">fs.readdir(path, callback)</pre>
							<pre class="brush: js;">
var fs = require("fs");

console.log("查看 /tmp 目录");
fs.readdir("/tmp/",function(err, files){
   if (err) {
       return console.error(err);
   }
   files.forEach( function (file){
       console.log( file );
   });
});
</pre>
						</div>
						<div class="sub-item">
							<p>删除目录</p>
							<pre class="brush: js;">fs.rmdir(path, callback)</pre>
							<pre class="brush: js;">
var fs = require("fs");

console.log("准备删除目录 /tmp/test");
fs.rmdir("/tmp/test",function(err){
   if (err) {
       return console.error(err);
   }
   console.log("读取 /tmp 目录");
   fs.readdir("/tmp/",function(err, files){
      if (err) {
          return console.error(err);
      }
      files.forEach( function (file){
          console.log( file );
      });
   });
});
</pre>
						</div>
						<div class="sub-item">
							<h5>文件模块方法参考手册</h5>
							<p>以下为 Node.js 文件模块相同的方法列表：</p>
							<table class="table table-striped table-bordered">
								<tbody>
									<tr>
										<th>序号</th>
										<th>方法 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>fs.rename(oldPath, newPath, callback)</b> -- 异步
											rename().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>fs.ftruncate(fd, len, callback)</b> -- 异步
											ftruncate().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>fs.ftruncateSync(fd, len)</b> -- 同步 ftruncate()</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>fs.truncate(path, len, callback)</b> -- 异步
											truncate().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>fs.truncateSync(path, len)</b> -- 同步 truncate()</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>fs.chown(path, uid, gid, callback)</b> -- 异步
											chown().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>fs.chownSync(path, uid, gid)</b> -- 同步 chown()</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>fs.fchown(fd, uid, gid, callback)</b> -- 异步
											fchown().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>fs.fchownSync(fd, uid, gid)</b> -- 同步 fchown()</td>
									</tr>
									<tr>
										<td>10</td>
										<td><b>fs.lchown(path, uid, gid, callback)</b> -- 异步
											lchown().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>11</td>
										<td><b>fs.lchownSync(path, uid, gid)</b> -- 同步 lchown()</td>
									</tr>
									<tr>
										<td>12</td>
										<td><b>fs.chmod(path, mode, callback)</b> -- 异步
											chmod().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>13</td>
										<td><b>fs.chmodSync(path, mode)</b> -- 同步 chmod().</td>
									</tr>
									<tr>
										<td>14</td>
										<td><b>fs.fchmod(fd, mode, callback)</b> -- 异步
											fchmod().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>15</td>
										<td><b>fs.fchmodSync(fd, mode)</b> -- 同步 fchmod().</td>
									</tr>
									<tr>
										<td>16</td>
										<td><b>fs.lchmod(path, mode, callback)</b> -- 异步
											lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X.</td>
									</tr>
									<tr>
										<td>17</td>
										<td><b>fs.lchmodSync(path, mode)</b> -- 同步 lchmod().</td>
									</tr>
									<tr>
										<td>18</td>
										<td><b>fs.stat(path, callback)</b> -- 异步 stat().
											回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
									</tr>
									<tr>
										<td>19</td>
										<td><b>fs.lstat(path, callback)</b> -- 异步 lstat().
											回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
									</tr>
									<tr>
										<td>20</td>
										<td><b>fs.fstat(fd, callback)</b> -- 异步 fstat().
											回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
									</tr>
									<tr>
										<td>21</td>
										<td><b>fs.statSync(path)</b> -- 同步 stat(). 返回 fs.Stats
											的实例。</td>
									</tr>
									<tr>
										<td>22</td>
										<td><b>fs.lstatSync(path)</b> -- 同步 lstat(). 返回 fs.Stats
											的实例。</td>
									</tr>
									<tr>
										<td>23</td>
										<td><b>fs.fstatSync(fd)</b> -- 同步 fstat(). 返回 fs.Stats
											的实例。</td>
									</tr>
									<tr>
										<td>24</td>
										<td><b>fs.link(srcpath, dstpath, callback)</b> -- 异步
											link().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>25</td>
										<td><b>fs.linkSync(srcpath, dstpath)</b> -- 同步 link().</td>
									</tr>
									<tr>
										<td>26</td>
										<td><b>fs.symlink(srcpath, dstpath[, type], callback)</b>
											-- 异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 'dir', 'file',
											或 'junction' (默认为 'file') 。</td>
									</tr>
									<tr>
										<td>27</td>
										<td><b>fs.symlinkSync(srcpath, dstpath[, type])</b> -- 同步
											symlink().</td>
									</tr>
									<tr>
										<td>28</td>
										<td><b>fs.readlink(path, callback)</b> -- 异步 readlink().
											回调函数有两个参数 err, linkString。</td>
									</tr>
									<tr>
										<td>29</td>
										<td><b>fs.realpath(path[, cache], callback)</b> -- 异步
											realpath(). 回调函数有两个参数 err, resolvedPath。</td>
									</tr>
									<tr>
										<td>30</td>
										<td><b>fs.realpathSync(path[, cache])</b> -- 同步
											realpath()。返回绝对路径。</td>
									</tr>
									<tr>
										<td>31</td>
										<td><b>fs.unlink(path, callback)</b> -- 异步
											unlink().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>32</td>
										<td><b>fs.unlinkSync(path)</b> -- 同步 unlink().</td>
									</tr>
									<tr>
										<td>33</td>
										<td><b>fs.rmdir(path, callback)</b> -- 异步
											rmdir().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>34</td>
										<td><b>fs.rmdirSync(path)</b> -- 同步 rmdir().</td>
									</tr>
									<tr>
										<td>35</td>
										<td><b>fs.mkdir(path[, mode], callback)</b> -- S异步
											mkdir(2).回调函数没有参数，但可能抛出异常。 mode defaults to 0777.</td>
									</tr>
									<tr>
										<td>36</td>
										<td><b>fs.mkdirSync(path[, mode])</b> -- 同步 mkdir().</td>
									</tr>
									<tr>
										<td>37</td>
										<td><b>fs.readdir(path, callback)</b> -- 异步 readdir(3).
											读取目录的内容。</td>
									</tr>
									<tr>
										<td>38</td>
										<td><b>fs.readdirSync(path)</b> -- 同步 readdir().返回文件数组列表。</td>
									</tr>
									<tr>
										<td>39</td>
										<td><b>fs.close(fd, callback)</b> -- 异步
											close().回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>40</td>
										<td><b>fs.closeSync(fd)</b> -- 同步 close().</td>
									</tr>
									<tr>
										<td>41</td>
										<td><b>fs.open(path, flags[, mode], callback)</b> --
											异步打开文件。</td>
									</tr>
									<tr>
										<td>42</td>
										<td><b>fs.openSync(path, flags[, mode])</b> -- 同步 version
											of fs.open().</td>
									</tr>
									<tr>
										<td>43</td>
										<td><b>fs.utimes(path, atime, mtime, callback)</b> --
											&nbsp;</td>
									</tr>
									<tr>
										<td>44</td>
										<td><b>fs.utimesSync(path, atime, mtime)</b> --
											修改文件时间戳，文件通过指定的文件路径。</td>
									</tr>
									<tr>
										<td>45</td>
										<td><b>fs.futimes(fd, atime, mtime, callback)</b> --
											&nbsp;</td>
									</tr>
									<tr>
										<td>46</td>
										<td><b>fs.futimesSync(fd, atime, mtime)</b> --
											修改文件时间戳，通过文件描述符指定。</td>
									</tr>
									<tr>
										<td>47</td>
										<td><b>fs.fsync(fd, callback)</b> -- 异步
											fsync.回调函数没有参数，但可能抛出异常。</td>
									</tr>
									<tr>
										<td>48</td>
										<td><b>fs.fsyncSync(fd)</b> -- 同步 fsync.</td>
									</tr>
									<tr>
										<td>49</td>
										<td><b>fs.write(fd, buffer, offset, length[,
												position], callback)</b> -- 将缓冲区内容写入到通过文件描述符指定的文件。</td>
									</tr>
									<tr>
										<td>50</td>
										<td><b>fs.write(fd, data[, position[, encoding]],
												callback)</b> -- 通过文件描述符 fd 写入文件内容。</td>
									</tr>
									<tr>
										<td>51</td>
										<td><b>fs.writeSync(fd, buffer, offset, length[,
												position])</b> -- 同步版的 fs.write()。</td>
									</tr>
									<tr>
										<td>52</td>
										<td><b>fs.writeSync(fd, data[, position[, encoding]])</b>
											-- 同步版的 fs.write().</td>
									</tr>
									<tr>
										<td>53</td>
										<td><b>fs.read(fd, buffer, offset, length, position,
												callback)</b> -- 通过文件描述符 fd 读取文件内容。</td>
									</tr>
									<tr>
										<td>54</td>
										<td><b>fs.readSync(fd, buffer, offset, length,
												position)</b> -- 同步版的 fs.read.</td>
									</tr>
									<tr>
										<td>55</td>
										<td><b>fs.readFile(filename[, options], callback)</b> --
											异步读取文件内容。</td>
									</tr>
									<tr>
										<td>56</td>
										<td><b>fs.readFileSync(filename[, options])</b> <br同步版的
												fs.readfile.<="" td=""></br同步版的></td>
									</tr>
									<tr>
										<td>57</td>
										<td><b>fs.writeFile(filename, data[, options],
												callback)</b> -- 异步写入文件内容。</td>
									</tr>
									<tr>
										<td>58</td>
										<td><b>fs.writeFileSync(filename, data[, options])</b> --
											同步版的 fs.writeFile。</td>
									</tr>
									<tr>
										<td>59</td>
										<td><b>fs.appendFile(filename, data[, options],
												callback)</b> -- 异步追加文件内容。</td>
									</tr>
									<tr>
										<td>60</td>
										<td><b>fs.appendFileSync(filename, data[, options])</b>
											-- The 同步 version of fs.appendFile.</td>
									</tr>
									<tr>
										<td>61</td>
										<td><b>fs.watchFile(filename[, options], listener)</b> --
											查看文件的修改。</td>
									</tr>
									<tr>
										<td>62</td>
										<td><b>fs.unwatchFile(filename[, listener])</b> -- 停止查看
											filename 的修改。</td>
									</tr>
									<tr>
										<td>63</td>
										<td><b>fs.watch(filename[, options][, listener])</b> --
											查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。</td>
									</tr>
									<tr>
										<td>64</td>
										<td><b>fs.exists(path, callback)</b> -- 检测给定的路径是否存在。</td>
									</tr>
									<tr>
										<td>65</td>
										<td><b>fs.existsSync(path)</b> -- 同步版的 fs.exists.</td>
									</tr>
									<tr>
										<td>66</td>
										<td><b>fs.access(path[, mode], callback)</b> --
											测试指定路径用户权限。</td>
									</tr>
									<tr>
										<td>67</td>
										<td><b>fs.accessSync(path[, mode])</b> -- 同步版的 fs.access。</td>
									</tr>
									<tr>
										<td>68</td>
										<td><b>fs.createReadStream(path[, options])</b> --
											返回ReadStream 对象。</td>
									</tr>
									<tr>
										<td>69</td>
										<td><b>fs.createWriteStream(path[, options])</b> -- 返回
											WriteStream 对象。</td>
									</tr>
									<tr>
										<td>70</td>
										<td><b>fs.symlink(srcpath, dstpath[, type], callback)</b>
											-- 异步 symlink().回调函数没有参数，但可能抛出异常。</td>
									</tr>
								</tbody>
							</table>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-tools" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">工具模块</h3>
					</div>
					<div class="panel-body">
						<ul>
							<li>
								<a href="#tools-os">OS 模块</a>
								-- 提供基本的系统操作函数。
							</li>
							<li>
								<a href="#tools-path">Path 模块</a>
								-- 提供了处理和转换文件路的工具。
							</li>
							<li>
								<a href="#tools-net">Net 模块</a>
								-- 用于底层的网络通信。提供了服务端和客户端的的操作。
							</li>
							<li>
								<a href="#tools-dns">DNS 模块</a>
								-- 用于解析域名。
							</li>
							<li>
								<a href="#tools-domain">Domain 模块</a>
								-- 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。
							</li>
						</ul>
						<div class="sub-item">
							<a class="offset" id="tools-os"></a>
							<p class="h5 text-primary">OS 模块</p>
							<table
								class="table table-bordered table-responsive table-striped">
								<tbody>
									<tr>
										<th width="8%">序号</th>
										<th>方法 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>os.tmpdir()</b> -- 返回操作系统的默认临时文件夹。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>os.endianness()</b> -- 返回 CPU 的字节序，可能的是 "BE" 或
											"LE"。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>os.hostname()</b> -- 返回操作系统的主机名。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>os.type()</b> -- 返回操作系统名</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>os.platform()</b> -- 返回操作系统名</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>os.arch()</b> -- 返回操作系统 CPU 架构，可能的值有 "x64"、"arm" 和
											"ia32"。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>os.release()</b> -- 返回操作系统的发行版本。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>os.uptime()</b> -- 返回操作系统运行的时间，以秒为单位。</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>os.loadavg()</b> -- 返回一个包含 1、5、15 分钟平均负载的数组。</td>
									</tr>
									<tr>
										<td>10</td>
										<td><b>os.totalmem()</b> -- 返回系统内存总量，单位为字节。</td>
									</tr>
									<tr>
										<td>11</td>
										<td><b>os.freemem()</b> -- 返回操作系统空闲内存量，单位是字节。</td>
									</tr>
									<tr>
										<td>12</td>
										<td><b>os.cpus()</b> -- 返回一个对象数组，包含所安装的每个
											CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用
											CPU/内核毫秒数的对象）。</td>
									</tr>
									<tr>
										<td>13</td>
										<td><b>os.networkInterfaces()</b> -- 获得网络接口列表。</td>
									</tr>
								</tbody>
							</table>

							<pre class="brush: js;">
var os = require("os");

// CPU 的字节序
console.log('endianness : ' + os.endianness());
// 操作系统名
console.log('type : ' + os.type());
// 操作系统名
console.log('platform : ' + os.platform());
// 系统内存总量
console.log('total memory : ' + os.totalmem() + " bytes.");
// 操作系统空闲内存量
console.log('free memory : ' + os.freemem() + " bytes.");
</pre>
						</div>
						<div class="sub-item">
							<a class="offset" id="tools-path"></a>
							<p class="h5 text-primary">Path 模块</p>
							<table
								class="table table-bordered table-responsive table-striped">
								<tbody>
									<tr>
										<th width="8%">序号</th>
										<th>方法 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>path.normalize(p)</b><br>规范化路径，注意'..' 和 '.'。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>path.join([path1][, path2][, ...])</b><br>用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是"/"，Windows系统是"\"。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>path.resolve([from ...], to)</b><br>将 <b>to</b>
											参数解析为绝对路径。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>path.isAbsolute(path)</b><br>判断参数 <b>path</b>
											是否是绝对路径。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>path.relative(from, to)</b><br>用于将相对路径转为绝对路径。</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>path.dirname(p)</b><br>返回路径中代表文件夹的部分，同 Unix
											的dirname 命令类似。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>path.basename(p[, ext])</b><br>返回路径中的最后一部分。同
											Unix 命令 bashname 类似。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>path.extname(p)</b><br>返回路径中文件的后缀名，即路径中最后一个'.'之后的部分。如果一个路径中并不包含'.'或该路径只包含一个'.'
											且这个'.'为路径的第一个字符，则此命令返回空字符串。</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>path.parse(pathString)</b><br>返回路径字符串的对象。</td>
									</tr>
									<tr>
										<td>10</td>
										<td><b>path.format(pathObject)</b><br>从对象中返回路径字符串，和
											path.parse 相反。</td>
									</tr>
									<tr>
										<th>序号</th>
										<th>属性 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>path.sep</b><br>平台的文件路径分隔符，'\\' 或 '/'。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>path.delimiter</b><br>平台的分隔符, ; or ':'.</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>path.posix</b><br>提供上述 path 的方法，不过总是以 posix
											兼容的方式交互。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>path.win32</b><br>提供上述 path 的方法，不过总是以 win32
											兼容的方式交互。</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: js;">
var path = require("path");
// 格式化路径
console.log('normalization : ' + path.normalize('/test/test1//2slashes/1slash/tab/..'));
// 连接路径
console.log('joint path : ' + path.join('/test', 'test1', '2slashes/1slash', 'tab', '..'));
// 转换为绝对路径
console.log('resolve : ' + path.resolve('main.js'));
// 路径中文件的后缀名
console.log('ext name : ' + path.extname('main.js'));
</pre>
						</div>
						<div class="sub-item">
							<a class="offset" id="tools-net"></a>
							<p class="h5 text-primary">Net 模块</p>
							<h5>方法</h5>
							<table
								class="table table-bordered table-responsive table-striped">
								<tbody>
									<tr>
										<th width="8%">序号</th>
										<th>方法 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>net.createServer([options][,
												connectionListener])</b><br>创建一个 TCP 服务器。参数
											connectionListener 自动给 'connection' 事件创建监听器。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>net.connect(options[, connectionListener])</b><br>返回一个新的
											'net.Socket'，并连接到指定的地址和端口。<br> 当 socket 建立的时候，将会触发
											'connect' 事件。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>net.createConnection(options[,
												connectionListener])</b><br>创建一个到端口 port 和 主机 host的 TCP 连接。
											host 默认为 'localhost'。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>net.connect(port[, host][, connectListener])</b><br>创建一个端口为
											port 和主机为 host的 TCP 连接 。host 默认为 'localhost'。参数
											connectListener 将会作为监听器添加到 'connect' 事件。返回 'net.Socket'。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>net.createConnection(port[, host][,
												connectListener])</b><br>创建一个端口为 port 和主机为 host的 TCP 连接
											。host 默认为 'localhost'。参数 connectListener 将会作为监听器添加到 'connect'
											事件。返回 'net.Socket'。</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>net.connect(path[, connectListener])</b><br>创建连接到
											path 的 unix socket 。参数 connectListener 将会作为监听器添加到 'connect'
											事件上。返回 'net.Socket'。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>net.createConnection(path[, connectListener])</b><br>创建连接到
											path 的 unix socket 。参数 connectListener 将会作为监听器添加到 'connect'
											事件。返回 'net.Socket'。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>net.isIP(input)</b><br>检测输入的是否为 IP 地址。 IPV4
											返回 4， IPV6 返回 6，其他情况返回 0。</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>net.isIPv4(input)</b><br>如果输入的地址为 IPV4， 返回
											true，否则返回 false。</td>
									</tr>
									<tr>
										<td>10</td>
										<td><b>net.isIPv6(input)</b><br>如果输入的地址为 IPV6， 返回
											true，否则返回 false。</td>
									</tr>
								</tbody>
							</table>
							<hr>
							<h5>net.Server</h5>
							<p>net.Server通常用于创建一个 TCP 或本地服务器。</p>
							<table
								class="table table-bordered table-responsive table-striped">
								<tbody>
									<tr>
										<th width="8%">序号</th>
										<th>方法 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>server.listen(port[, host][, backlog][,
												callback])</b><br>监听指定端口 port 和 主机 host ac连接。 默认情况下 host
											接受任何 IPv4 地址(INADDR_ANY)的直接连接。端口 port 为 0 时，则会分配一个随机端口。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>server.listen(path[, callback])</b><br>通过指定
											path 的连接，启动一个本地 socket 服务器。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>server.listen(handle[, callback])</b><br>通过指定句柄连接。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>server.listen(options[, callback])</b><br>options
											的属性：端口 port, 主机 host, 和 backlog, 以及可选参数 callback 函数,
											他们在一起调用server.listen(port, [host], [backlog],
											[callback])。还有，参数 path 可以用来指定 UNIX socket。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>server.close([callback])</b><br>服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发
											'close' 事件。</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>server.address()</b><br>操作系统返回绑定的地址，协议族名和服务器端口。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>server.unref()</b><br>如果这是事件系统中唯一一个活动的服务器，调用
											unref 将允许程序退出。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>server.ref()</b><br>与 unref
											相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被
											ref，则再次调用 ref 并不会产生影响。</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>server.getConnections(callback)</b><br>异步获取服务器当前活跃连接的数量。当
											socket 发送给子进程后才有效；回调函数有 2 个参数 err 和 count。</td>
									</tr>
								</tbody>
							</table>
							<h5>事件</h5>
							<table
								class="table table-bordered table-responsive table-striped">
								<tbody>
									<tr>
										<th width="8%">序号</th>
										<th>事件 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>listening</b><br>当服务器调用 server.listen 绑定后会触发。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>connection</b><br>当新连接创建后会被触发。socket 是
											net.Socket实例。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>close</b><br>服务器关闭时会触发。注意，如果存在连接，这个事件不会被触发直到所有的连接关闭。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>error</b><br>发生错误时触发。'close' 事件将被下列事件直接调用。</td>
									</tr>
								</tbody>
							</table>

							<hr>
							<h5>net.Socket</h5>
							<p>net.Socket 对象是 TCP 或 UNIX Socket 的抽象。net.Socket
								实例实现了一个双工流接口。 他们可以在用户创建客户端(使用 connect())时使用, 或者由 Node 创建它们，并通过
								connection 服务器事件传递给用户。</p>

							<h5>事件</h5>
							<p>net.Socket 事件有：</p>
							<table
								class="table table-bordered table-responsive table-striped">
								<tbody>
									<tr>
										<th width="8%">序号</th>
										<th>事件 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>lookup</b><br> 在解析域名后，但在连接前，触发这个事件。对 UNIX
											sokcet 不适用。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>connect</b><br>成功建立 socket 连接时触发。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>data</b><br>当接收到数据时触发。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>end</b><br>当 socket 另一端发送 FIN 包时，触发该事件。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>timeout</b><br>当 socket 空闲超时时触发，仅是表明 socket
											已经空闲。用户必须手动关闭连接。</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>drain</b><br>当写缓存为空得时候触发。可用来控制上传。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>error</b><br>错误发生时触发。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>close</b><br>当 socket 完全关闭时触发。参数 had_error
											是布尔值，它表示是否因为传输错误导致 socket 关闭。</td>
									</tr>
								</tbody>
							</table>

							<h5>属性</h5>
							<p>net.Socket 提供了很多有用的属性，便于控制 socket 交互：</p>
							<table
								class="table table-bordered table-responsive table-striped">
								<tbody>
									<tr>
										<th width="8%">序号</th>
										<th>属性 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>socket.bufferSize</b><br>该属性显示了要写入缓冲区的字节数。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>socket.remoteAddress</b><br>远程的 IP
											地址字符串，例如：'74.125.127.100' or '2001:4860:a005::68'。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>socket.remoteFamily</b><br>远程IP协议族字符串，比如
											'IPv4' or 'IPv6'。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>socket.remotePort</b><br>远程端口，数字表示，例如：80 or
											21。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>socket.localAddress</b><br>网络连接绑定的本地接口
											远程客户端正在连接的本地 IP
											地址，字符串表示。例如，如果你在监听'0.0.0.0'而客户端连接在'192.168.1.1'，这个值就会是
											'192.168.1.1'。</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>socket.localPort</b><br>本地端口地址，数字表示。例如：80 or
											21。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>socket.bytesRead</b><br>接收到得字节数。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>socket.bytesWritten</b><br>发送的字节数。</td>
									</tr>
								</tbody>
							</table>
							<h5>方法</h5>

							<table
								class="table table-bordered table-responsive table-striped">
								<tbody>
									<tr>
										<th width="8%">序号</th>
										<th>方法 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>new net.Socket([options])</b><br>构造一个新的
											socket 对象。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>socket.connect(port[, host][,
												connectListener])</b><br> 指定端口 port 和 主机 host，创建 socket 连接
											。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开
											socket。只有你实现了自己的 socket 时才会用到。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>socket.connect(path[, connectListener])</b><br>打开指定路径的
											unix socket。通常情况不需要使用 net.createConnection 打开
											socket。只有你实现了自己的 socket 时才会用到。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>socket.setEncoding([encoding])</b><br>设置编码</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>socket.write(data[, encoding][, callback])</b><br>在
											socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>socket.end([data][, encoding])</b><br>半关闭
											socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>socket.destroy()</b><br>确保没有 I/O
											活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>socket.pause()</b><br>暂停读取数据。就是说，不会再触发 data
											事件。对于控制上传非常有用。</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>socket.resume()</b><br>调用 pause() 后想恢复读取数据。</td>
									</tr>
									<tr>
										<td>10</td>
										<td><b>socket.setTimeout(timeout[, callback])</b><br>socket
											闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。</td>
									</tr>
									<tr>
										<td>11</td>
										<td><b>socket.setNoDelay([noDelay])</b><br>禁用纳格（Nagle）算法。默认情况下
											TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用
											socket.write() 时立即发送数据。noDelay 默认值为 true。</td>
									</tr>
									<tr>
										<td>12</td>
										<td><b>socket.setKeepAlive([enable][, initialDelay])</b><br>禁用/启用长连接功能，并在发送第一个在闲置
											socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay
											（毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay
											设为0，将会保留默认（或者之前）的值。默认值为0.</td>
									</tr>
									<tr>
										<td>13</td>
										<td><b>socket.address()</b><br>操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有
											3 个属性，比如{ port: 12346, family: 'IPv4', address: '127.0.0.1'
											}。</td>
									</tr>
									<tr>
										<td>14</td>
										<td><b>socket.unref()</b><br>如果这是事件系统中唯一一个活动的服务器，调用
											unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。</td>
									</tr>
									<tr>
										<td>15</td>
										<td><b>socket.ref()</b><br>与 unref
											相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被
											ref，则再次调用 ref 并不会产生影响。</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: js;">
// server.js
var net = require('net');
var server = net.createServer(function(connection) { 
   console.log('client connected');
   connection.on('end', function() {
      console.log('客户端关闭连接');
   });
   connection.write('Hello World!\r\n');
   connection.pipe(connection);
});
server.listen(8080, function() { 
  console.log('server is listening');
});

// client.js
var net = require('net');
var client = net.connect({port: 8080}, function() {
   console.log('连接到服务器！');  
});
client.on('data', function(data) {
   console.log(data.toString());
   client.end();
});
client.on('end', function() { 
   console.log('断开与服务器的连接');
});
</pre>
						</div>
						<div class="sub-item">
							<a class="offset" id="tools-dns"></a>
							<p class="h5 text-primary">DNS 模块</p>
							<table
								class="table table-bordered table-responsive table-striped">
								<tbody>
									<tr>
										<th width="8%">序号</th>
										<th>方法 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>dns.lookup(hostname[, options], callback)</b><br>将域名（比如
											'runoob.com'）解析为第一条找到的记录 A （IPV4）或 AAAA(IPV6)。参数
											options可以是一个对象或整数。如果没有提供 options，IP v4 和 v6 地址都可以。如果 options
											是整数，则必须是 4 或 6。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>dns.lookupService(address, port, callback)</b><br>使用
											getnameinfo 解析传入的地址和端口为域名和服务。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>dns.resolve(hostname[, rrtype], callback)</b><br>将一个域名（如
											'runoob.com'）解析为一个 rrtype 指定记录类型的数组。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>dns.resolve4(hostname, callback)</b><br>和
											dns.resolve() 类似, 仅能查询 IPv4 (A 记录）。 addresses IPv4 地址数组
											(比如，['74.125.79.104', '74.125.79.105', '74.125.79.106']）。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>dns.resolve6(hostname, callback)</b><br>和
											dns.resolve4() 类似， 仅能查询 IPv6( AAAA 查询）</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>dns.resolveMx(hostname, callback)</b><br>和
											dns.resolve() 类似, 仅能查询邮件交换(MX 记录)。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>dns.resolveTxt(hostname, callback)</b><br>和
											dns.resolve() 类似, 仅能进行文本查询 (TXT 记录）。 addresses 是 2-d
											文本记录数组。(比如，[ ['v=spf1 ip4:0.0.0.0 ', '~all' ] ]）。
											每个子数组包含一条记录的 TXT 块。根据使用情况可以连接在一起，也可单独使用。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>dns.resolveSrv(hostname, callback)</b><br>和
											dns.resolve() 类似, 仅能进行服务记录查询 (SRV 记录）。 addresses 是
											hostname可用的 SRV 记录数组。 SRV 记录属性有优先级（priority），权重（weight）,
											端口（port）, 和名字（name） (比如，[{'priority': 10, 'weight': 5,
											'port': 21223, 'name': 'service.example.com'}, ...]）。</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>dns.resolveSoa(hostname, callback)</b><br>和
											dns.resolve() 类似, 仅能查询权威记录(SOA 记录）。</td>
									</tr>
									<tr>
										<td>10</td>
										<td><b>dns.resolveNs(hostname, callback)</b><br>和
											dns.resolve() 类似, 仅能进行域名服务器记录查询(NS 记录）。 addresses
											是域名服务器记录数组（hostname 可以使用） (比如, ['ns1.example.com',
											'ns2.example.com']）。</td>
									</tr>
									<tr>
										<td>11</td>
										<td><b>dns.resolveCname(hostname, callback)</b><br>和
											dns.resolve() 类似, 仅能进行别名记录查询 (CNAME记录)。addresses 是对 hostname
											可用的别名记录数组 (比如，, ['bar.example.com']）。</td>
									</tr>
									<tr>
										<td>12</td>
										<td><b>dns.reverse(ip, callback)</b><br>反向解析 IP
											地址，指向该 IP 地址的域名数组。</td>
									</tr>
									<tr>
										<td>13</td>
										<td><b>dns.getServers()</b><br>返回一个用于当前解析的 IP
											地址数组的字符串。</td>
									</tr>
									<tr>
										<td>14</td>
										<td><b>dns.setServers(servers)</b><br>指定一组 IP
											地址作为解析服务器。</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: js;">
var dns = require('dns');

dns.lookup('www.github.com', function onLookup(err, address, family) {
   console.log('ip 地址:', address);
   dns.reverse(address, function (err, hostnames) {
	   if (err) {
	      console.log(err.stack);
	   }
	
	   console.log('反向解析 ' + address + ': ' + JSON.stringify(hostnames));
	});  
});
</pre>
						</div>
						<div class="sub-item">
							<a class="offset" id="tools-domain"></a>
							<p class="h5 text-primary">Domain 模块</p>
							<table
								class="table table-bordered table-responsive table-striped">
								<tbody>
									<tr>
										<th width="8%">序号</th>
										<th>方法 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>domain.run(function)</b><br>
											在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>domain.add(emitter)</b><br>显式的增加事件</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>domain.remove(emitter)</b><br>删除事件。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>domain.bind(callback)</b><br>返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数被时，所有被抛出的错误都会被导向到这个域的
											error 事件。</td>
									</tr>
									<tr>
										<td>5</td>
										<td><b>domain.intercept(callback)</b><br>和
											domain.bind(callback) 类似。除了捕捉被抛出的错误外，它还会拦截 Error
											对象作为参数传递到这个函数。</td>
									</tr>
									<tr>
										<td>6</td>
										<td><b>domain.enter()</b><br>
											进入一个异步调用的上下文，绑定到domain。</td>
									</tr>
									<tr>
										<td>7</td>
										<td><b>domain.exit()</b><br>退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。</td>
									</tr>
									<tr>
										<td>8</td>
										<td><b>domain.dispose()</b><br>
											释放一个domain对象，让node进程回收这部分资源。</td>
									</tr>
									<tr>
										<td>9</td>
										<td><b>domain.create()</b><br>返回一个domain对象。</td>
									</tr>
									<tr>
										<th>序号</th>
										<th>属性 &amp; 描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>domain.members</b><br>
											已加入domain对象的域定时器和事件发射器的数组。</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: js;">
var EventEmitter = require("events").EventEmitter;
var domain = require("domain");

var emitter1 = new EventEmitter();

// 创建域
var domain1 = domain.create();

domain1.on('error', function(err){
   console.log("domain1 处理这个错误 ("+err.message+")");
});

// 显式绑定
domain1.add(emitter1);

emitter1.on('error',function(err){
   console.log("监听器处理此错误 ("+err.message+")");
});

emitter1.emit('error',new Error('通过监听器来处理'));

emitter1.removeAllListeners('error');

emitter1.emit('error',new Error('通过 domain1 处理'));

var domain2 = domain.create();

domain2.on('error', function(err){
   console.log("domain2 处理这个错误 ("+err.message+")");
});

// 隐式绑定
domain2.run(function(){
   var emitter2 = new EventEmitter();
   emitter2.emit('error',new Error('通过 domain2 处理'));   
});


domain1.remove(emitter1);
emitter1.emit('error', new Error('转换为异常，系统将崩溃!'));
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-express" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">express 模块</h3>
					</div>
					<div class="panel-body">
						<p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web
							应用，和丰富的 HTTP 工具。</p>
						<p>使用 Express 可以快速地搭建一个完整功能的网站。</p>
						<p>Express 框架核心特性：</p>
						<ul>
							<li>
								<p>可以设置中间件来响应 HTTP 请求。</p>
							</li>
							<li>
								<p>定义了路由表用于执行不同的 HTTP 请求动作。</p>
							</li>
							<li>
								<p>可以通过向模板传递参数来动态渲染 HTML 页面。</p>
							</li>
						</ul>
						<div class="sub-item">
							<p class="h5 text-primary">Request 和 Response</p>
							<p>
								<b>Request 对象</b> - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP
								头部等属性。常见属性有：
							</p>
							<ol>
								<li>req.app：当callback为外部文件时，用req.app访问express的实例</li>
								<li>req.baseUrl：获取路由当前安装的URL路径</li>
								<li>req.body / req.cookies：获得「请求主体」/ Cookies</li>
								<li>req.fresh / req.stale：判断请求是否还「新鲜」</li>
								<li>req.hostname / req.ip：获取主机名和IP地址</li>
								<li>req.originalUrl：获取原始请求URL</li>
								<li>req.params：获取路由的parameters</li>
								<li>req.path：获取请求路径</li>
								<li>req.protocol：获取协议类型</li>
								<li>req.query：获取URL的查询参数串</li>
								<li>req.route：获取当前匹配的路由</li>
								<li>req.subdomains：获取子域名</li>
								<li>req.accpets（）：检查请求的Accept头的请求类型</li>
								<li>req.acceptsCharsets / req.acceptsEncodings /
									req.acceptsLanguages</li>
								<li>req.get（）：获取指定的HTTP请求头</li>
								<li>req.is（）：判断请求头Content-Type的MIME类型</li>
							</ol>

							<p>
								<strong>Response 对象</strong> - response 对象表示 HTTP
								响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：
							</p>
							<ol>
								<li>res.app：同req.app一样</li>
								<li>res.append（）：追加指定HTTP头</li>
								<li>res.set（）在res.append（）后将重置之前设置的头</li>
								<li>res.cookie（name，value [，option]）：设置Cookie</li>
								<li>opition: domain / expires / httpOnly / maxAge / path /
									secure / signed</li>
								<li>res.clearCookie（）：清除Cookie</li>
								<li>res.download（）：传送指定路径的文件</li>
								<li>res.get（）：返回指定的HTTP头</li>
								<li>res.json（）：传送JSON响应</li>
								<li>res.jsonp（）：传送JSONP响应</li>
								<li>res.location（）：只设置响应的Location HTTP头，不设置状态码或者close
									response</li>
								<li>res.redirect（）：设置响应的Location HTTP头，并且设置状态码302</li>
								<li>res.send（）：传送HTTP响应</li>
								<li>res.sendFile（path [，options] [，fn]）：传送指定路径的文件
									-会自动根据文件extension设定Content-Type</li>
								<li>res.set（）：设置HTTP头，传入object可以一次设置多个头</li>
								<li>res.status（）：设置HTTP状态码</li>
								<li>res.type（）：设置Content-Type的MIME类型</li>
							</ol>
						</div>
						<div class="sub-item">
							<p class="h5 text-primary">路由</p>
							<pre class="brush: js;">
var express = require('express');
var app = express();

//  主页输出 "Hello World"
app.get('/', function (req, res) {
   console.log("主页 GET 请求");
   res.send('Hello GET');
})


//  POST 请求
app.post('/', function (req, res) {
   console.log("主页 POST 请求");
   res.send('Hello POST');
})

//  /del_user 页面响应
app.get('/del_user', function (req, res) {
   console.log("/del_user 响应 DELETE 请求");
   res.send('删除页面');
})

//  /list_user 页面 GET 请求
app.get('/list_user', function (req, res) {
   console.log("/list_user GET 请求");
   res.send('用户列表页面');
})

// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求
app.get('/ab*cd', function(req, res) {   
   console.log("/ab*cd GET 请求");
   res.send('正则匹配');
})


var server = app.listen(8081, function () {

  var host = server.address().address
  var port = server.address().port

  console.log("应用实例，访问地址为 http://%s:%s", host, port)

})							
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="node-js-" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">...</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->


				<!-- item start -->
				<a id="node-js-" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">...</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushBash.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJScript.js"></script>
	<script src="../commons/js/common.js"></script>
	<script src="res/menu.js"></script>
</body>
</html>
