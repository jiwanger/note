<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--KOTLIN</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">

<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">KOTLIN</h3>
					</div>
					<div class="list-group">
						<a href="#" class="list-group-item">简介</a>
						<a href="#kotlin-cmd" class="list-group-item"><code>kotlinc</code> && <code>kotlin</code></a>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#kotlin-base" aria-expanded="true">
							基础语法<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="kotlin-base" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#kotlin-base-constructor" class="list-group-item">基本语法</a>
							<a href="#kotlin-base-type" class="list-group-item">基本类型</a>
							<a href="#kotlin-base-class" class="list-group-item">类和对象</a>
							<a href="#" class="list-group-item">...</a>
						</div>
						<a href="#kotlin-" class="list-group-item">...</a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-3"></div>
			<div class="col-md-9" style="float: left;">

				<!-- item start -->
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p><b>Kotlin 官网：</b> <a href="http://kotlinlang.org/" target="_blank">Kotlin</a></p>
							<p><b>Kotlin 源码：</b> <a href="https://github.com/JetBrains/kotlin" target="_blank">Kotlin</a></p>
							<p><b>Kotlin 中文站及中文教程：</b> <a href="https://www.kotlincn.net/" target="_blank">kotlincn.net</a>， <a href="https://www.kotlincn.net/docs/reference/" target="_blank">Kotlin Rreference</a></p>
							<p><b>Kotlin</b> 安装及更新：</p>
							<pre class="brush: bash;">
$ curl -s https://get.sdkman.io | bash
$ sdk install kotlin
</pre>
							<p><b>Kotlin</b> 是一个基于 JVM 的新的编程语言，由 JetBrains 开发。</p>
							<p><b>Kotlin</b> 可以编译成 Java 字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p>
							<p><b>Kotlin</b> 一般使用两种后缀: <code>kt</code> && <code>kts</code>, 表示将编译成 Kotlin 应用程序和 KotlinScript。</p>
							<p><b>JetBrains</b>，作为目前广受欢迎的 Java IDE IntelliJ 的提供商，在 Apache 许可下已经开源其 Kotlin 编程语言。</p>
							<p><b>Kotlin</b> 已正式成为 Android 官方支持开发语言。</p>
							<p><b>Kotlin</b> 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码，并且在 Java 代码中也可以很顺利地调用 Kotlin 代码。</p>
							<p><b>Kotlin</b> 可用于以下开发：</p>
							<ul>
								<li><p><b>Kotlin</b> 非常适合开发服务器端应用程序，允许编写简明且表现力强的代码， 同时保持与现有基于 Java 的技术栈的完全兼容性以及平滑的学习曲线；</p></li>
								<li><p><b>Kotlin</b> 非常适合开发 Android 应用程序，将现代语言的所有优势带入 Android 平台而不会引入任何新的限制；</p></li>
								<li><p><b>Kotlin</b> 提供了 JavaScript 作为目标平台的能力。它通过将 Kotlin 转换为 JavaScript 来实现；</p></li>
								<li><p><b>Kotlin/Native</b> 是一种将 Kotlin 代码编译为无需虚拟机就可运行的原生二进制文件的技术。 它是一个基于 LLVM 的 Kotlin 编译器后端以及 Kotlin 标准库的原生实现。</p></li>
							</ul>
						</div>

						<div class="sub-item">
							<h3>Kotlin 编码规范</h3>
							<p><b>目录结构</b></p>
							<p>在混合语言项目中，Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中 ）。</p>
							<p>在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构 （例如，如果项目中的所有代码都位于 <code>io.kotlin</code> 包及其子包中，那么 <code>io.kotlin</code> 包的文件应该直接放在源代码根目录下，而 <code>io.kotlin.foo</code> 中的文件应该放在源代码根目录下的 <code>foo</code> 子目录中）。</p>

							<p><b>源文件名称</b></p>
							<p>如果 Kotlin 文件包含单个类（以及可能相关的顶层声明），那么文件名应该与该类的名称相同，并追加 .kt 扩展名。如果文件包含多个类或只包含顶层声明， 那么选择一个描述该文件所包含内容的名称，并以此命名该文件。</p>

							<p><b>源文件组织</b></p>
							<p>鼓励多个声明（类、顶级函数或者属性）放在同一个 Kotlin 源文件中， 只要这些声明在语义上彼此紧密关联并且文件保持合理大小 （不超过几百行）。</p>
							<p>特别是在为类定义与类的所有客户都相关的扩展函数时， 请将它们放在与类自身定义相同的地方。而在定义仅对指定客户有意义的扩展函数时，请将它们放在紧挨该客户代码之后。</p>

							<p><b>类布局</b></p>
							<p>通常，一个类的内容按以下顺序排列：属性声明与初始化块 -> 次构造函数 -> 方法声明 -> 伴生对象，将嵌套类放在紧挨使用这些类的代码之后。</p>

							<p><b>有多个包会默认导入到每个 Kotlin 文件中：</b></p>
							<ul>
								<li><p><a href="" target="_blank">kotlin.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.annotation.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.collections.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.comparisons.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.io.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.ranges.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.sequences.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.text.*</a></p></li>
							</ul>
							<p><b>根据目标平台还会导入额外的包：</b></p>
							<p><b>JVM:</b> -- <a href="" target="_blank">java.lang.*</a>, <a href="" target="_blank">kotlin.jvm.*</a></p>
							<p><b>JS:</b> -- <a href="" target="_blank">kotlin.js.*</a></p>
						</div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="kotlin-cmd"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title"><code>kotlinc</code> && <code>kotlin</code></h3>
					</div>
					<div class="panel-body">
							<div class="sub-item">
								<pre class="brush: bash;">
$ kotlinc app.kt -include-runtime -d app.jar  # 生成可以运行的 jar 文件（包含 kotlin 运行库）
$ java -jar app.jar

$ kotlinc -help(kotlinc-java -help)           # 查看帮助
-classpath (-cp) &lt;path>    指定查找用户类的路径
-d &lt;directory|jar>         指定生成类的路径
-include-runtime              指定生成的 .jar 文件中包含 kotlin 的类
-java-parameters              为 Java1.8 生成方法注解
-jdk-home &lt;path>           指定 JDK 路径
-kotlin-home &lt;path>        指定 kotlin 路径
-jvm-target &lt;version>      指定 JVM 的版本
-module-name &lt;name>        指定 .kotlin_module 模块名

-no-jdk                       不将 JDK 包含到类路径
-no-reflect                   不将 kotlin-stdlib.jarkotlin-reflect.jar 包含到类路径
-no-stdlib                    不将 kotlin-stdlib.jar 或 kotlin-reflect.jar 包含到类路径

-script                       指定为脚本文件
-script-templates &lt;fully qualified class name[,]>  指定脚本定义模板类
-api-version &lt;version>     指定编译版本
-language-version &lt;version> 提供与指定语言版本的源兼容性
-P plugin:&lt;pluginId>:&lt;optionName>=&lt;value> 使用插件 

-nowarn                       忽略警告
-Werror                    	  有警告则报告一个错误
-verbose                      打开 verbose 级别日志输出

-version                      显示版本
-help (-h)                    打印标准选项摘要
-X                            打印高级选项摘要
</pre>
							</div>

							<div class="sub-item">
									<pre class="brush: bash;">
$ kotlin -cp app/build/libs/app.jar AppKt
$ kotlin -cp app/build/libs/app.jar:library/build/libs/library.jar AppKt
</pre>
							</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="kotlin-base-constructor"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">基本语法</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
								<p><b>目录结构</b></p>
								<p>在混合语言项目中，Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中 ）。</p>
								<p>在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构 （例如，如果项目中的所有代码都位于 <code>io.kotlin</code> 包及其子包中，那么 <code>io.kotlin</code> 包的文件应该直接放在源代码根目录下，而 <code>io.kotlin.foo</code> 中的文件应该放在源代码根目录下的 <code>foo</code> 子目录中）。</p>
	
								<p><b>源文件名称</b></p>
								<p>如果 Kotlin 文件包含单个类（以及可能相关的顶层声明），那么文件名应该与该类的名称相同，并追加 .kt 扩展名。如果文件包含多个类或只包含顶层声明， 那么选择一个描述该文件所包含内容的名称，并以此命名该文件。</p>
	
								<p><b>源文件组织</b></p>
								<p>鼓励多个声明（类、顶级函数或者属性）放在同一个 Kotlin 源文件中， 只要这些声明在语义上彼此紧密关联并且文件保持合理大小 （不超过几百行）。</p>
								<p>特别是在为类定义与类的所有客户都相关的扩展函数时， 请将它们放在与类自身定义相同的地方。而在定义仅对指定客户有意义的扩展函数时，请将它们放在紧挨该客户代码之后。</p>
						</div>

						<div class="sub-item">
							<pre class="brush: java;">
package util

import java.util.*

/** 1.函数定义 */
fun sum(a: Int, b: Int): Int {            // 带有两个 Int 参数、返回 Int 的函数
	return a + b
}

funn sum(a: Int, b: Int) = a + b          // 表达式作为函数体、返回值类型自动推断的函数：

fun printSum(a: Int, b: Int): Unit {      // 函数返回无意义的值
	println("sum of $a and $b is ${a + b}")
}

fun printSum(a: Int, b: Int) {            // Unit 返回类型可以省略   
	println("sum of $a and $b is ${a + b}")
}

/** 2.定义只读局部变量使用关键字 val 定义 */
val a: Int = 1  // 立即赋值
val b = 2   // 自动推断出 `Int` 类型
val c: Int  // 如果没有初始值类型不能省略
c = 3       // 明确赋值

/** 3.可重新赋值的变量使用 var 关键字 */
var x = 5 // 自动推断出 `Int` 类型
x += 1

/** 4.当某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空 */
fun sum(a: Int, b: Int): Int? {
	return a + b
}

fun concat(a: String, b: String?) {       // 第一个参数 a 不能传入 null, b 可以为 null
	println(a + b)
}

/** 5.区间 */
for (i in 1..100) { …… }       // 闭区间：包含 100
for (i in 1 until 100) { …… }  // 半开区间：不包含 100
for (x in 2..10 step 2) { …… } // 步进为 2
for (x in 10 downTo 1) { …… }  // 步退
if (x in 1..10) { …… }         // 范围判断

/** 6.if not null / if not null and else 缩写 */
val files = File("Test").listFiles()
println(files?.size)
println(files?.size ?: "empty")

/** 7.if not null 执行代码 */
value?.let {
	…… // 代码会执行到此处, 假如 value 不为 null
}
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="kotlin-base-type"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">基本类型</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p>在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。 一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。</p>
							<p><b>数字</b> -- Kotlin 处理数字在某种程度上接近 Java，但是并不完全相同。例如，对于数字没有隐式拓宽转换（如 Java 中 int 可以隐式转换为long)，另外有些情况的字面值略有不同。</p>
							<p>Kotlin 不支持八进制，在 Kotlin 中字符不是数字，数字字面值支持下划线(123_456_78L,0b11010010_01101001)。</p>
							<table class="table table-bordered table-response">
								<thead>
								<tr>
									<th>Type</th>
									<th>Bit width</th>
								</tr>
								</thead>
								<tbody>
								<tr>
									<td>Double</td>
									<td>64</td>
								</tr>
								<tr>
									<td>Float</td>
									<td>32</td>
								</tr>
								<tr>
									<td>Long</td>
									<td>64</td>
								</tr>
								<tr>
									<td>Int</td>
									<td>32</td>
								</tr>
								<tr>
									<td>Short</td>
									<td>16</td>
								</tr>
								<tr>
									<td>Byte</td>
									<td>8</td>
								</tr>
								</tbody>
							</table>
							<p>每个数字类型都是 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-number/index.html" target="_blank">Number</a> 的子类，因此支持如下的转换:</p>
							<pre class="brush: java;">
package kotlin

public abstract class Number {
	public abstract fun toDouble(): Double
	public abstract fun toFloat(): Float
	public abstract fun toLong(): Long
	public abstract fun toInt(): Int
	public abstract fun toChar(): Char
	public abstract fun toShort(): Short
	public abstract fun toByte(): Byte
}
</pre>
							<p>完整的位运算列表（只用于 Int 与 Long）：</p>
							<ul>
								<li><code>shl(bits)</code> – 有符号左移 (Java 的 <code>&lt;&lt;</code>)</li>
								<li><code>shr(bits)</code> – 有符号右移 (Java 的 <code>&gt;&gt;</code>)</li>
								<li><code>ushr(bits)</code> – 无符号右移 (Java 的 <code>&gt;&gt;&gt;</code>)</li>
								<li><code>and(bits)</code> – 位与</li>
								<li><code>or(bits)</code> – 位或</li>
								<li><code>xor(bits)</code> – 位异或</li>
								<li><code>inv()</code> – 位非</li>
							</ul>
							<p><b>字符串</b> 用 String 类型表示。字符串是不可变的。 </p>
							<p>可以用 + 操作符连接字符串。这也适用于连接字符串与其他类型的值， 只要表达式中的第一个元素是字符串(在大多数情况下，优先使用字符串模板或原始字符串而不是字符串连接。)</p>
							<pre class="brush: java;">val s = "abc" + 1</pre>
							<p><b>原始字符串</b> 使用三个引号（"""）分界符括起来，内部没有转义并且可以包含换行以及任何其他字符:</p>
							<pre class="brush: java;">
val text = """
	for (c in "foo")
		print(c)
"""
</pre>
							<p><b>字符串模板</b> -- 字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成:</p>
							<pre class="brush: java;">
val i = 10
println("i = $i") // 输出“i = 10”

val s = "abc"
println("$s.length is ${s.length}") // 输出“abc.length is 3”
</pre>
						</div>

						<div class="sub-item">
							<p><b>If 表达式</b></p>
							<p>在 Kotlin 中，if是一个表达式，即它会返回一个值。 因此就不需要三元运算符（条件 ? 然后 : 否则），因为普通的 if 就能胜任这个角色。</p>
							<pre class="brush: java;">
var max = a
if (a < b) max = b

// With else
var max: Int
if (a > b) {
	max = a
} else {
	max = b
}

// 作为表达式
val max = if (a > b) a else b
</pre>

							<p><b>When 表达式</b></p>
							<p>when 取代了类 C 语言的 switch 操作符。其最简单的形式如下：</p>
							<pre class="brush: java;">
when (x) {
	1 -> print("x == 1")
	2 -> print("x == 2")
	else -> { // 注意这个块
		print("x is neither 1 nor 2")
	}
}

// 我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：
when (x) {
	in 1..10 -> print("x is in the range")
	in validNumbers -> print("x is valid")
	!in 10..20 -> print("x is outside the range")
	else -> print("none of the above")
}

// when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式
fun hasPrefix(x: Any) = when(x) {
	is String -> x.startsWith("prefix")
	else -> false
}
</pre>
							<p><b>For 循环</b></p>
							<p>for 循环可以对任何提供迭代器（iterator）的对象进行遍历，这相当于像 C# 这样的语言中的 foreach 循环。</p>
							<p>for 可以循环遍历任何提供了迭代器的对象。即：</p>
							<ul>
								<li>有一个成员函数或者扩展函数 <code>iterator()</code>，它的返回类型
									<ul>
										<li>有一个成员函数或者扩展函数 <code>next()</code>，并且</li>
										<li>有一个成员函数或者扩展函数 <code>hasNext()</code> 返回 <code>Boolean</code>。</li>
									</ul>
								</li>
							</ul>
							<p>这三个函数都需要标记为 <code>operator</code>。</p>
							<pre class="brush: java;">
for (item in collection) print(item)

for (i in 1..3) {
	println(i)
}
for (i in 6 downTo 0 step 2) {
	println(i)
}
</pre>
							<p>While 循环</p>
							<p>while 与 do..while 照常使用</p>
							<p>在循环中 Kotlin 支持传统的 break 与 continue 操作符。</p>
							<pre class="brush: java;">
while (x > 0) {
	x--
}

do {
	val y = retrieveData()
} while (y != null) // y 在此处可见
							</pre>
						</div>

						<div class="sub-item">
							<p><b>返回和跳转</b></p>
							<p>Kotlin 有三种结构化跳转表达式：</p>
							<ul>
								<li><code>return</code> -- 默认从最直接包围它的函数或者匿名函数返回。</li>
								<li><code>break</code> -- 终止最直接包围它的循环。</li>
								<li><code>continue</code> -- 继续下一次最直接包围它的循环。</li>
							</ul>
							<p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签（参见语法）。 要为一个表达式加标签，我们只要在其前加标签即可。</p>
							<pre class="brush: java;">
loop@ for (i in 1..100) {// ……}

loop@ for (i in 1..100) {
	for (j in 1..100) {
		if (……) break@loop
	}
}
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="kotlin-base-class"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">类和对象</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<div class="split-item">
								<p><b>类与继承</b></p>
								<p>Kotlin 中使用关键字 <code>class</code> 声明类</p>
								<pre class="brush: java;">class Person {...}</pre>
								<p>类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的； 如果一个类没有类体，可以省略花括号。</p>
								<pre class="brush: java;">class Empty</pre>
								<p>在 Kotlin 中的一个类可以有一个主构造函数以及一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后。</p>
								<pre class="brush: java;">class Person constructor(firstName: String) { ... }</pre>
								<p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 <code>constructor</code> 关键字。</p>
								<pre class="brush: java;">class Person(firstName: String) { ... }</pre>
								<p><b>主构造函数不能包含任何的代码</b>。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。</p>
								<pre class="brush: java;">
// 主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用：
class Customer(name: String) {

    val customerKey = name.toUpperCase()

	init {
		println("First initializer block that prints ${name}")
	}
}

// 事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法，可以访问实例 p.name 和 p.age
class Person(var name: String, var age: Int) {}
</pre>
								<p>与普通属性一样，主构造函数中声明的属性可以是可变的（<code>var</code>）或只读的（<code>val</code>）。</p>
								<p>如果构造函数有注解或可见性修饰符，这个 <code>constructor</code> 关键字是必需的，并且这些修饰符在它前面：</p>
								<pre class="brush: java;">class Customer public @Inject constructor(name: String) { …… }</pre>
								<p>类也可以声明前缀有 <code>constructor</code> 的次构造函数：</p>
								<pre class="brush: java;">
class Person {
    constructor(name: String) {
        println(name)
    }
}
</pre>
								<p>如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 <code>this</code> 关键字即可：</p>
								<pre class="brush: java;">
fun main() {
    val s1 = Person("jiwanger", 30)
    println(String.format("%s:%s", s1.name, s1.age))

    val s2 = Person("jiwanger", 30, "08420229")
    println(String.format("%s:%s:%s", s2.name, s2.age, s2.number))
}

class Person(var name: String, var age: Int) {
    lateinit var number: String

    constructor(name: String, age: Int, number: String) : this(name, age) {
        this.number = number
    }
}
</pre>
								<p><b>注意，初始化块中的代码实际上会成为主构造函数的一部分。</b>委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：</p>
								<pre class="brush: java;">
class Constructors {
    init { println("Init block") } // 先执行此句

    constructor(i: Int) { println("Constructor") }
}
</pre>
							</div>

							<div class="split-item">
								<p><b>继承</b></p>
								<p>在 Kotlin 中所有类都有一个共同的超类 Any，这对于没有超类型声明的类是默认超类。</p>
								<p><b>注意</b>：Any 并不是 java.lang.Object；尤其是，它除了 equals()、hashCode() 与 toString() 外没有任何成员。 </p>
								<p>如果派生类有一个主构造函数，其基类型可以（并且必须） 用基类的主构造函数参数就地初始化。</p>
								<pre class="brush: java;">
open class Person(var name: String, var age: Int)

// 如果派生类有一个主构造函数，其基类型可以（并且必须） 用基类的主构造函数参数就地初始化。
class Student(name: String, age: Int, var number: String) :Person(name, age)

fun main() {
    val p1 = Person("jiwanger", 30)
    println(String.format("%s:%s", p1.name, p1.age))
    val s1 = Student("jiwanger", 30, "08420229")
    println(String.format("%s:%s:%s", s1.name, s1.age, s1.number))
    s1.number = "13823039350"
    println(String.format("%s:%s:%s", s1.name, s1.age, s1.number))
}
</pre>
								<p><p>如果类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：</p>
								<pre class="brush: java;">
// 比如 android.view.View 类
class MyView : View {
    constructor(ctx: Context) : super(ctx)
    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}
								</pre>
								<p><b>覆盖方法</b></p>
								<p>Kotlin 力求清晰显式。与 Java 不同，Kotlin 对于可覆盖的成员（我们称之为开放）以及覆盖后的成员需要显式修饰符：</p>
<!--								<pre class="brush: java;">-->
								<pre class="brush: java;">
open class Base {
    open fun v() { ... } // 使用 open 修饰，表示可以覆盖
    open fun nv() { ... }
	fun m() {...}        // 子类不能覆盖此方法
}

class Derived() : Base() {
    override fun v() { ... }        // 使用 override 修饰，表示覆盖基类的方法
	final override fun nv() { ... } // 使用 final 修饰，表示不能再次覆盖
}
</pre>
								<p><b>覆盖规则</b></p>
								<p>在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super&lt;Base>：</p>
								<pre class="brush: java;">
open class A {
    open fun f() { print("A") }
    fun a() { print("a") }
}

interface B {
    fun f() { print("B") } // 接口成员默认就是“open”的
    fun b() { print("b") }
}

class C() : A(), B {
    // 编译器要求覆盖 f()：
	override fun f() {
        super&lt;A>.f() // 调用 A.f()
        super&lt;B>.f() // 调用 B.f()
	}
}
</pre>
								<p><b>抽象类</b></p>
								<p>类以及其中的某些成员可以声明为 <code>abstract</code>。 抽象成员在本类中可以不用实现。 需要注意的是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻。</p>
								<pre class="brush: java;">
open class Base {
    open fun f() {}
}

abstract class Derived : Base() {
    override abstract fun f()
}
</pre>
							</div>
						</div>

						<div class="sub-item">
							<p><b>属性与字段</b></p>
							<div class="split-item">
								<p><b>声明属性</b></p>
								<p>Kotlin 的类可以有属性。 属性可以用关键字 <code>var</code> 声明为可变的，否则使用只读关键字 <code>val</code>。</p>
								<pre class="brush: java;">
class Address {
    var name: String = ……
    var street: String = ……
    var city: String = ……
    var state: String? = ……
    var zip: String = ……
}

// 使用属性
fun copyAddress(address: Address): Address {
    val result = Address() // Kotlin 中没有“new”关键字
    result.name = address.name // 将调用访问器
    result.street = address.street
    // ……
    return result
}
</pre>
								<p>声明一个属性的完整语法是:</p>
								<pre class="brush: java;">
var &lt;propertyName>[: &lt;PropertyType>] [= &lt;property_initializer>]
    [&lt;getter>]
    [&lt;setter>]

fun main() {
    val p = Person("jiwanger")
    println(String.format("%s:%s:%s", p.name, p.age)) // 访问属性会调用其 get() 方法
    p.age = 30  // 修改属性会调用其 set() 方法
    println(String.format("%s:%s:%s", p.name, p.age, p.description))
}

class Person(var name: String) {
    lateinit var description: String   // 延迟初始化属性与变量(在初始化前不能访问)

	// 使用 val 申明的属性不能有 set() 方法
    var age: Int = -1
        get() {                                     // 在 set() 中可以使用 filed
            return if(field > 150 || field < 0) {
                0
            } else {
                field
            }
        }
        set(value){
            field = value                           // 在 get() 中可以使用 filed
            description = when(age) {
                in 0..6 -> "宝宝"
                in 7..18 -> "学生"
                in 19..60 -> "青年"
                in 61..150 -> "老年"
                else -> "未知"
            }
        }
}
</pre>
							</div>
						</div>

						<div class="sub-item">
							<p><b>接口</b></p>
							<p>Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。</p>
							<p>使用关键字 interface 来定义接口：</p>
							<pre class="brush: java;">
interface MyInterface {
    fun bar()
    fun foo() { // 可选的方法体 }
}

// 实现接口
class Child : MyInterface {
    override fun bar() { // 方法体 }
}
</pre>
							<p><b>接口中的属性</b></p>
							<p>在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们。</p>
							<pre class="brush: java;">
interface MyInterface {
    val prop: Int // 抽象的

    val propertyWithImplementation: String
        get() = "foo"

    fun foo() { print(prop) }
}

class Child : MyInterface {
    override val prop: Int = 29
}
</pre>
							<p><b>接口继承</b></p>
							<p>一个接口可以从其他接口派生，从而既提供基类型成员的实现也声明新的函数与属性。很自然地，实现这样接口的类只需定义所缺少的实现：</p>
							<pre class="brush: java;">
interface Named {
    val name: String
}

interface Person : Named {
    val firstName: String
    val lastName: String

    override val name: String get() = "$firstName $lastName"
}

data class Employee(
    // 不必实现“name”
    override val firstName: String,
    override val lastName: String,
    val position: Position
) : Person
</pre>
							<p><b>解决覆盖冲突</b></p>
							<p>实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如</p>
							<pre class="brush: java;">
interface A {
    fun foo() { print("A") }
    fun bar()
}

interface B {
    fun foo() { print("B") }
    fun bar() { print("bar") }
}

class C : A {
    override fun bar() { print("bar") }
}

class D : A, B {
    override fun foo() {
        super&lt;A>.foo()
        super&lt;B>.foo()
    }

    override fun bar() {
        super&lt;B>.bar()
    }
}
</pre>
						</div>

						<div class="sub-item">
							<p><b>可见性修饰符</b></p>
							<p>类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有 可见性修饰符。 （getter 总是与属性有着相同的可见性。） 在 Kotlin 中有这四个可见性修饰符：private、 protected、 internal 和 public。 如果没有显式指定修饰符的话，默认可见性是 public。</p>
							<p><b>internal</b> 会在相同"模块"内随处可见，"模块"具体地说， 一个模块是编译在一起的一套 Kotlin 文件：</p>
							<ul>
								<li><p>一个 IntelliJ IDEA 模块；</p></li>
								<li><p>一个 Maven 项目；</p></li>
								<li><p>一个 Gradle 源集（例外是 test 源集可以访问 main 的 internal 声明）；</p></li>
								<li><p>一次 &lt;kotlinc> Ant 任务执行所编译的一套文件。</p></li>
							</ul>
							<p>修饰符如何应用到不同类型的声明作用域:</p>
							<ul>
								<li>
									<p><b>包</b> -- 函数、属性和类、对象和接口可以在顶层声明，即直接在包内，要使用另一包中可见的顶层声明，仍需将其导入进来。</p>
									<ul>
										<li><p>如果你不指定任何可见性修饰符，默认为 public，这意味着你的声明将随处可见；</p></li>
										<li><p>如果你声明为 private，它只会在声明它的文件内可见；</p></li>
										<li><p>如果你声明为 internal，它会在相同模块内随处可见；</p></li>
										<li><p>protected 不适用于顶层声明。</p></li>
									</ul>
								</li>
								<li>
									<p><b>类和接口</b> -- 对于Java用户：Kotlin 中外部类不能访问内部类的 private 成员。</p>
									<ul>
										<li><p>private 意味着只在这个类内部（包含其所有成员）可见；</p></li>
										<li><p>protected—— 和 private一样 + 在子类中可见。</p></li>
										<li><p>internal —— 能见到类声明的 本模块内 的任何客户端都可见其 internal 成员；</p></li>
										<li><p>public —— 能见到类声明的任何客户端都可见其 public 成员。</p></li>
									</ul>

								</li>
								<li>
									<p><b>构造函数</b> -- 要指定一个类的的主构造函数的可见性，使用以下语法:</p>
									<pre class="brush: java;">class C private constructor(a: Int) { …… }</pre>
									<p>默认情况下，所有构造函数都是 public，这实际上等于类可见的地方它就可见（即 一个 internal 类的构造函数只能在相同模块内可见).</p>
								</li>

							</ul>
						</div>

						<div class="sub-item">
							<p><b>扩展</b></p>
							<p>Kotlin 能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式。 这通过叫做 扩展 的特殊声明完成。Kotlin 支持 <b>扩展函数</b> 与 <b>扩展属性</b>。</p>
							<p><b>扩展函数</b> -- 声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。</p>
							<pre class="brush: java;">
fun main() {
    val p = Person("jiwanger")
    println(String.format("%s:%s", p.name, p.length()))
}

/** 此函数为 Person 类添加了一个 length() 的函数 */
fun Person.length(): Int {
    return this.name.length
}

class Person(var name: String)
							</pre>
							<p>如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、相同的名字，都适用给定的参数，这种情况总是取成员函数。</p>
							<pre class="brush: java;">
class C { fun foo() { println("member") } }

fun C.foo() { println("extension") }
							</pre>
							<p>如果我们调用 C 类型 c 的 c.foo()，它将输出 “member”，而不是 “extension”。</p>

							<p><b>扩展属性</b> -- 由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 getters/setters 定义。</p>
							<pre class="brush: java;">
fun main() {
    val p = Person("jiwanger")
    println(String.format("%s:%s", p.name, p.length))
}

val Person.length: Int        // 这里用 val 来定义属性，因为此属性的值根据 name 来确定，只有 get() 方法
    get() = this.name.length

class Person(var name: String)
</pre>
						</div>

						<div class="sub-item">
							<p><b>数据类</b></p>
							<p>我们经常创建一些只保存数据的类。 在这些类中，一些标准函数往往是从数据机械推导而来的。</p>
							<p>在 Kotlin 中，这叫做 数据类 并标记为 data：</p>
							<pre class="brush: java;">data class User(var name: String, var age: Int)</pre>
							<p>数据类的 toString() 格式是 "User(name=John, age=42)"。</p>
							<p>为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求：</p>
							<ul>
								<li><p>主构造函数需要至少有一个参数；</p></li>
								<li><p>主构造函数的所有参数需要标记为 val 或 var；</p></li>
								<li><p>数据类不能是抽象、开放、密封或者内部的；(数据类没有子类)</p></li>
								<li><p>在 JVM 中，如果生成的类需要含有一个无参的构造函数，则所有的属性必须指定默认值。 </p></li>
							</ul>
							<p><code>copy()</code> 方法可以复制对象，并修改其属性</p>
							<pre class="brush: java;">
fun main() {
	val s1 = Student("08420229", 30)
    val s2 = s1.copy(age = 32)
    println(String.format("%s:%s:%s", s1 == s2, s1.age, s2.age))
}

data class Student(var number: String, var age: Int)
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="kotlin-base-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">...</h3>
					</div>
					<div class="panel-body">

					</div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
		<a href="https://kotlinlang.org/api/latest/jvm/stdlib/index.html" target="_blank" type="button"
		   class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> CORE </a>
		<a href="https://www.kotlincn.net/docs/reference/" target="_blank" type="button"
		   class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> REF </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushBash.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
