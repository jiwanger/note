<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<meta name="keywords" content="key1, key2" />
<meta name="description" content=”” />
<meta name="author" content="nate" />
<meta name="author" content="nate &lt;jiwanger@126.com&gt;" />
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--KOTLIN</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">

<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">KOTLIN</h3>
					</div>
					<div class="list-group">
						<a href="#" class="list-group-item">简介</a>
						<a href="#kotlin-cmd" class="list-group-item"><code>kotlinc</code> && <code>kotlin</code></a>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#kotlin-base" aria-expanded="true">
							基础语法<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="kotlin-base" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#kotlin-base-syntax" class="list-group-item">基本语法</a>
							<a href="#kotlin-base-keyword" class="list-group-item">关键字和操作符</a>
							<a href="#kotlin-base-type" class="list-group-item">基本类型和流程控制</a>
							<a href="#kotlin-base-class" class="list-group-item">类和对象</a>
							<a href="#kotlin-base-fun" class="list-group-item">函数和 Lambda 表达式</a>
							<a href="#kotlin-base-collection" class="list-group-item">集合</a>
							<a href="#kotlin-base-" class="list-group-item">...</a>
						</div>
						<a href="#kotlin-" class="list-group-item">...</a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-3"></div>
			<div class="col-md-9" style="float: left;">

				<!-- item start -->
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p><b>Kotlin 官网：</b> <a href="http://kotlinlang.org/" target="_blank">Kotlin</a></p>
							<p><b>Kotlin 源码：</b> <a href="https://github.com/JetBrains/kotlin" target="_blank">Kotlin</a></p>
							<p><b>Kotlin 中文站及中文教程：</b> <a href="https://www.kotlincn.net/" target="_blank">kotlincn.net</a>， <a href="https://www.kotlincn.net/docs/reference/" target="_blank">Kotlin Rreference</a></p>
							<p><b>Kotlin</b> 安装及更新：</p>
							<pre class="brush: bash;">
$ curl -s https://get.sdkman.io | bash
$ sdk install kotlin
</pre>
							<p><b>Kotlin</b> 是一个基于 JVM 的新的编程语言，由 JetBrains 开发。</p>
							<p><b>Kotlin</b> 可以编译成 Java 字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p>
							<p><b>Kotlin</b> 一般使用两种后缀: <code>kt</code> && <code>kts</code>, 表示将编译成 Kotlin 应用程序和 KotlinScript。</p>
							<p><b>JetBrains</b>，作为目前广受欢迎的 Java IDE IntelliJ 的提供商，在 Apache 许可下已经开源其 Kotlin 编程语言。</p>
							<p><b>Kotlin</b> 已正式成为 Android 官方支持开发语言。</p>
							<p><b>Kotlin</b> 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码，并且在 Java 代码中也可以很顺利地调用 Kotlin 代码。</p>
							<p><b>Kotlin</b> 可用于以下开发：</p>
							<ul>
								<li><p><b>Kotlin</b> 非常适合开发服务器端应用程序，允许编写简明且表现力强的代码， 同时保持与现有基于 Java 的技术栈的完全兼容性以及平滑的学习曲线；</p></li>
								<li><p><b>Kotlin</b> 非常适合开发 Android 应用程序，将现代语言的所有优势带入 Android 平台而不会引入任何新的限制；</p></li>
								<li><p><b>Kotlin</b> 提供了 JavaScript 作为目标平台的能力。它通过将 Kotlin 转换为 JavaScript 来实现；</p></li>
								<li><p><b>Kotlin/Native</b> 是一种将 Kotlin 代码编译为无需虚拟机就可运行的原生二进制文件的技术。 它是一个基于 LLVM 的 Kotlin 编译器后端以及 Kotlin 标准库的原生实现。</p></li>
							</ul>
						</div>

						<div class="sub-item">
							<h3>Kotlin 编码规范</h3>
							<p><b>目录结构</b></p>
							<p>在混合语言项目中，Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中 ）。</p>
							<p>在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构 （例如，如果项目中的所有代码都位于 <code>io.kotlin</code> 包及其子包中，那么 <code>io.kotlin</code> 包的文件应该直接放在源代码根目录下，而 <code>io.kotlin.foo</code> 中的文件应该放在源代码根目录下的 <code>foo</code> 子目录中）。</p>

							<p><b>源文件名称</b></p>
							<p>如果 Kotlin 文件包含单个类（以及可能相关的顶层声明），那么文件名应该与该类的名称相同，并追加 .kt 扩展名。如果文件包含多个类或只包含顶层声明， 那么选择一个描述该文件所包含内容的名称，并以此命名该文件。</p>

							<p><b>源文件组织</b></p>
							<p>鼓励多个声明（类、顶级函数或者属性）放在同一个 Kotlin 源文件中， 只要这些声明在语义上彼此紧密关联并且文件保持合理大小 （不超过几百行）。</p>
							<p>特别是在为类定义与类的所有客户都相关的扩展函数时， 请将它们放在与类自身定义相同的地方。而在定义仅对指定客户有意义的扩展函数时，请将它们放在紧挨该客户代码之后。</p>

							<p><b>类布局</b></p>
							<p>通常，一个类的内容按以下顺序排列：属性声明与初始化块 -> 次构造函数 -> 方法声明 -> 伴生对象，将嵌套类放在紧挨使用这些类的代码之后。</p>

							<p><b>有多个包会默认导入到每个 Kotlin 文件中：</b></p>
							<ul>
								<li><p><a href="" target="_blank">kotlin.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.annotation.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.collections.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.comparisons.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.io.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.ranges.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.sequences.*</a></p></li>
								<li><p><a href="" target="_blank">kotlin.text.*</a></p></li>
							</ul>
							<p><b>根据目标平台还会导入额外的包：</b></p>
							<p><b>JVM:</b> -- <a href="" target="_blank">java.lang.*</a>, <a href="" target="_blank">kotlin.jvm.*</a></p>
							<p><b>JS:</b> -- <a href="" target="_blank">kotlin.js.*</a></p>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="kotlin-cmd"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title"><code>kotlinc</code> && <code>kotlin</code></h3>
					</div>
					<div class="panel-body">
							<div class="sub-item">
								<pre class="brush: bash;">
$ kotlinc App.kt
$ kotlinc src/App.kt -d build/

$ kotlinc -help(kotlinc-jvm -help)           # 查看帮助
# kotlinc/kotlinc-jvm &lt;options> &lt;source files>	
# options 有以下选项
	-classpath (-cp) &lt;path>    # 指定查找用户类的路径
	-d &lt;directory|jar>         # 指定生成类的路径
	-include-runtime              # 指定生成的 .jar 文件中包含 kotlin 的类
	-java-parameters              # 为 Java1.8 生成方法注解
	-jdk-home &lt;path>           # 指定 JDK 路径
	-kotlin-home &lt;path>        # 指定 kotlin 路径
	-jvm-target &lt;version>      # 指定 JVM 的版本
	-module-name &lt;name>        # 指定 .kotlin_module 模块名

	-no-jdk                       # 不将 JDK 包含到类路径
	-no-reflect                   # 不将 kotlin-stdlib.jarkotlin-reflect.jar 包含到类路径
	-no-stdlib                    # 不将 kotlin-stdlib.jar 或 kotlin-reflect.jar 包含到类路径

	-script                       # 指定为脚本文件
	-script-templates &lt;fully qualified class name[,]>  # 指定脚本定义模板类
	-api-version &lt;version>     # 指定编译版本
	-language-version &lt;version># 提供与指定语言版本的源兼容性
	-P plugin:&lt;pluginId>:&lt;optionName>=&lt;value> # 使用插件 

	-nowarn                       # 忽略警告
	-Werror                    	  # 有警告则报告一个错误
	-verbose                      # 打开 verbose 级别日志输出

	-version                      # 显示版本
	-help (-h)                    # 打印标准选项摘要
	-X                            # 打印高级选项摘要
</pre>
							</div>

							<div class="sub-item">
									<pre class="brush: bash;">
$ kotlin AppKt
$ kotlin -d build/ AppKt

$ kotlin -help
# kotlin &lt;options> &lt;command> &lt;arguments>
	-classpath (-cp) &lt;path>    # 指定查找用户类的路径
	-Dname=value               # 设置一个 JVM 属性值
	-J&lt;option>              # 将选项直接传递给 JVM
	-no-reflect                # 不将 kotlin-stdlib.jarkotlin-reflect.jar 包含到类路径
	-version                   # 显示版本
	-help (-h)                 # 打印标准选项摘要


$ kotlinc app.kt -include-runtime -d app.jar  # 生成可以运行的 jar 文件（包含 kotlin 运行库）
$ java -jar app.jar

$ kotlin -cp app/build/libs/app.jar AppKt
$ kotlin -cp app/build/libs/app.jar:library/build/libs/library.jar AppKt
</pre>
							</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="kotlin-base-syntax"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">基本语法</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
								<p><b>目录结构</b></p>
								<p>在混合语言项目中，Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中 ）。</p>
								<p>在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构 （例如，如果项目中的所有代码都位于 <code>io.kotlin</code> 包及其子包中，那么 <code>io.kotlin</code> 包的文件应该直接放在源代码根目录下，而 <code>io.kotlin.foo</code> 中的文件应该放在源代码根目录下的 <code>foo</code> 子目录中）。</p>
	
								<p><b>源文件名称</b></p>
								<p>如果 Kotlin 文件包含单个类（以及可能相关的顶层声明），那么文件名应该与该类的名称相同，并追加 .kt 扩展名。如果文件包含多个类或只包含顶层声明， 那么选择一个描述该文件所包含内容的名称，并以此命名该文件。</p>
	
								<p><b>源文件组织</b></p>
								<p>鼓励多个声明（类、顶级函数或者属性）放在同一个 Kotlin 源文件中， 只要这些声明在语义上彼此紧密关联并且文件保持合理大小 （不超过几百行）。</p>
								<p>特别是在为类定义与类的所有客户都相关的扩展函数时， 请将它们放在与类自身定义相同的地方。而在定义仅对指定客户有意义的扩展函数时，请将它们放在紧挨该客户代码之后。</p>
						</div>

						<div class="sub-item">
							<pre class="brush: kotlin;">
package util

import java.util.*

/** 1.函数定义 */
fun sum(a: Int, b: Int): Int {            // 带有两个 Int 参数、返回 Int 的函数
	return a + b
}

funn sum(a: Int, b: Int) = a + b          // 表达式作为函数体、返回值类型自动推断的函数：

fun printSum(a: Int, b: Int): Unit {      // 函数返回无意义的值
	println("sum of $a and $b is ${a + b}")
}

fun printSum(a: Int, b: Int) {            // Unit 返回类型可以省略   
	println("sum of $a and $b is ${a + b}")
}

/** 2.定义只读局部变量使用关键字 val 定义 */
val a: Int = 1  // 立即赋值
val b = 2   // 自动推断出 `Int` 类型
val c: Int  // 如果没有初始值类型不能省略
c = 3       // 明确赋值

/** 3.可重新赋值的变量使用 var 关键字 */
var x = 5 // 自动推断出 `Int` 类型
x += 1

/** 4.当某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空 */
fun sum(a: Int, b: Int): Int? {
	return a + b
}

fun concat(a: String, b: String?) {       // 第一个参数 a 不能传入 null, b 可以为 null
	println(a + b)
}

/** 5.区间 */
for (i in 1..100) { …… }       // 闭区间：包含 100
for (i in 1 until 100) { …… }  // 半开区间：不包含 100
for (x in 2..10 step 2) { …… } // 步进为 2
for (x in 10 downTo 1) { …… }  // 步退
if (x in 1..10) { …… }         // 范围判断

/** 6.if not null / if not null and else 缩写 */
val files = File("Test").listFiles()
println(files?.size)
println(files?.size ?: "empty")

/** 7.if not null 执行代码 */
value?.let {
	…… // 代码会执行到此处, 假如 value 不为 null
}
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="kotlin-base-keyword"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">关键字和操作符</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
                            <h3>Kotlin 关键字, 参见：<a href="https://www.kotlincn.net/docs/reference/keyword-reference.html" target="_blank">关键字与操作符</a></h3>
                            <ul>
                                <li><p><b>硬关键字</b> -- 无论在什么情况下都不能用作标识符</p></li>
                                <li><p><b>软关键字</b> -- 可以在它们不起作用的上下文中作标识符</p></li>
                                <li><p><b>修饰符关键字</b> -- 可以在代码中作标识符</p></li>
                                <li><p><b>特殊标识符</b> -- <code>field</code>(用在属性访问器内部来引用该属性的幕后字段) 和 <code>it</code>(用在 lambda 表达式内部来隐式引用其参数)</p></li>
                            </ul>
                        </div>

						<div class="sub-item">
							<div class="split-item">
								<p><b>Kotlin 的硬关键字</b></p>
								<ul>
									<li><p><code>package</code> -- 用于为当前文件指定包</p></li>

									<li><p><code>as</code> -- 用于做类型转换或为 import 语句指定别名</p></li>
									<li><p><code>fun</code> -- 声明函数</p></li>
									<li><p><code>val</code> -- 声明只读属性或变量</p></li>
									<li><p><code>var</code> -- 声明可变属性或变量</p>
										<pre class="brush: kotlin;">
package main

import util.LogUtil
import model.Person as ModelPerson    // 两个不同包下的 Person, 使用 as 指定别名避免冲突
import entity.Person as EntityPerson

fun main() {
    val p1 = ModelPerson("jiwanger")
    LogUtil.log(p1.name, p1.age)

    val p2 = EntityPerson("431122198903241712")
    LogUtil.log(p2.id)

    var code = ErrorCode(1)
    LogUtil.log(code.code, code.message)
    code = ErrorCode(0, "请求成功！")
    LogUtil.log(code.code, code.message)
}
</pre>
									</li>
									<li><p><code>true</code> -- 在 Boolean 类型中表式真的直接量</p></li>
									<li><p><code>false</code> -- 在 Boolean 类型中表式假的直接量</p></li>
									<li><p><code>as?</code> -- 类型安全的类型转换运算符</p>
										<pre class="brush: kotlin;">
val x: String? = y as? String

fun main() {
    val name = "jiwanger"
    val age = 30

    LogUtil.log(name, age, safeConvert(name), safeConvert(age) // jiwanger:30:jiwanger:null
	// 异常， age 不能转换为 String
    LogUtil.log(name, age, unsafeConvert(name), unsafeConvert(age))
}

fun unsafeConvert(src: Any): String? {
    return src as String   // 转换失败报异常
}

fun safeConvert(src: Any): String? {
    return src as? String  // 类型安全转换，如果 src 转换失败，返回 null
}
</pre>
									</li>
									<li><p><code>null</code> -- 代表空的直接量</p></li>
									<li><p><code>return</code> -- 声明函数的返回</p></li>
									<li><p><code>continue</code> -- 忽略本次循环剩下的语句，重新开始下一次循环</p></li>
									<li><p><code>break</code> -- 中断循环</p></li>
									<li><p><code>if</code> -- 在 if 分支中使用</p></li>
									<li><p><code>else</code> -- 在 if 分支中使用</p></li>
									<li><p><code>for</code> -- 用于 for 循环</p></li>
									<li><p><code>in</code> -- 在 for 循环中使用；作为双目运算符，检查是否处于区间或者集合内；用于修饰泛型参数，表式该泛型参数支持逆变</p></li>
									<li><p><code>do</code> -- 用于 do while 循环</p></li>
									<li><p><code>while</code> -- 用于 while 循环或 do while 循环</p></li>
									<li><p><code>when</code> -- 取代了 switch 操作符</p></li>
									<li><p><code>is</code> -- 用于做类型检查（类似 Java 的 instanceof）或在 when 表达式中使用</p></li>
									<li><p><code>!is</code> -- 用于做类型检查（is 的反义词）或在 when 表达式中使用</p>
										<pre class="brush: kotlin;">
fun main() {
    val base = Base()
    val child = Child()

    LogUtil.log(base is Base, child is Base)   // true, true
    LogUtil.log(base !is Base, child !is Base) // false, false
}

open class Base {}

class Child: Base() {}
</pre>
									</li>

									<li><p><code>object</code> -- 用于声明对象表达式或定义命名对象</p>
										<pre class="brush: kotlin;">
// 1.object 作为对象表达式使用
val textView = findViewById&lt;TextView>(R.id.tv)
textView.setOnClickListener(object : OnClickListener {
	override fun onClick(v: View?) {
		...
	}

})

// 2.用 object 修饰的类为静态类，里面的方法和变量都为静态的
object Const {
    const val SERVER = "http://api.lesson1234.com"

    fun resGet(path: String): String {
        return "$SERVER/$path"
    }
}

// 3. companion object 修饰为伴生对象,伴生对象在类中只能存在一个(参见以下实例， s1 和 s2 的 name 值都为一个了)
class Shared {
    companion object {
        const val NAME = "name"

        val map = HashMap&lt;String, Any>()
    }

    fun save(key: String, value: Any) {
        map[key] = value
    }

    fun read(key: String) : Any? {
        return map[key]
    }
}

fun main() {
    LogUtil.log(Const.SERVER, Const.resGet("image/001.png"))
    // val cst = Const() // 编译报错，不允许构造实例

    val s1 = Shared()
    s1.save(Shared.NAME, "jiwanger")
    LogUtil.log(s1.read(Shared.NAME)) // jiwanger

    val s2 = Shared()
    s2.save(Shared.NAME, "nate")
    LogUtil.log(s1.read(Shared.NAME), s2.read(Shared.NAME)) // nate, nate
}
</pre>
									</li>


									<li><p><code>interface</code> -- 声明接口</p></li>
									<li><p><code>class</code> -- 声明类</p></li>
                                    <li><p><code>typeof</code> --  保留以供未来使用</p></li>
                                    <li><p><code>super</code> -- 用于引用父类实现的方法或属性，或者在子类构造器中调用父类构造器</p></li>

									<li><p><code>this</code> -- 代表当前类的对象或在构造器中调用当前类的其他构造器</p>
										<pre class="brush: kotlin;">
fun main() {
    var sub = Sub()
    sub.tag()

    sub = Sub("nate")
    sub.tag()
}

interface Base { fun print() }

open class Child: Base {
    override fun print() { LogUtil.log("Child:print") }

    open fun tag() { LogUtil.log("Child:tag") }
}

class Sub(): Child() {
    var tag = ""

    init { tag = "jiwanger" }

    constructor(tag: String) : this() { this.tag = tag }

    override fun print() { LogUtil.log("Sub:print") }

    override fun tag() {
        super.tag() // Child:tag
        LogUtil.log("Sub:tag:$tag") // Child:tag:jiwanger/Sub:tag:nate
        this.print() // Sub:print
        super.print() // Child:print
    }
}
</pre>
									</li>
									<li><p><code>try</code> -- 开始异常处理</p></li>
									<li><p><code>throw</code> -- 用于抛出异常</p></li>
									<li><p><code>typealias</code> -- 用于定义类型别名</p>
										<pre class="brush: kotlin;">
// 泛型别名
typealias NodeSet = Set&lt;Network.Node>
typealias FileTable&lt;K> = MutableMap&lt;K, MutableList&lt;File>>

// 函数别名
typealias MyHandler = (Int, String, Any) -> Unit
typealias Predicate&lt;T> = (T) -> Boolean

class A { inner class Inner }
class B { inner class Inner }

// 同名类型别名
typealias AInner = A.Inner
typealias BInner = B.Inner
</pre>
									</li>
								</ul>
							</div>


                            <div class="split-item">
                                <p><b>Kotlin 的软关键字</b></p>
                                <ul>
                                    <li><p><code>by</code> -- 用于将接口或祖先类的实现代理给其他对象</p>
                                        <pre class="brush: kotlin;">
// 创建接口
interface Base { fun print() }

// 实现此接口的被委托的类
class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}

// 建立委托类, 将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b
class Derived(b: Base) : Base by b

fun main(args: Array&lt;String>) {
    val b = BaseImpl(10)
    Derived(b).print() // 输出 10
}
</pre>
                                    </li>
                                    <li><p><code>catch</code> -- 在异常处理中用于捕捉异常</p></li>
                                    <li><p><code>constructor</code> -- 用于声明构造器</p></li>
                                    <li><p><code>delegate</code> -- 用于指定该注解修饰委托属性存储其委托实例的字段</p></li>
                                    <li><p><code>dynamic</code> -- 主要用于在 Kotlin/JavaScript 中引用一个动态类型</p></li>
                                    <li><p><code>file</code> -- 用于指定该注解修饰该源文件本身</p></li>
                                    <li><p><code>field</code> -- 用作注解使用处目标</p></li>

                                    <li><p><code>finally</code> -- 异常处理中的 finally 块</p></li>

                                    <li><p><code>set</code> -- 用于申明属性的 setter 方法，或者用于指定该注解修饰属性的 setter 方法</p></li>
                                    <li><p><code>get</code> -- 用于申明属性的 getter 方法，或者用于指定该注解修饰属性的 getter 方法</p>
                                        <pre class="brush: kotlin;">
class Person(var name: String) {
    lateinit var description: String   // 延迟初始化属性与变量(在初始化前不能访问)

    // 使用 val 申明的属性不能有 set() 方法
    var age: Int = -1
        get() = if (field > 150 || field < 0) 0 else field // 在 get() 中可以使用 field
        set(value) {
            field = value                           // 在 set() 中可以使用 field
            description = when (age) {
                in 0..6 -> "宝宝"
                in 7..18 -> "学生"
                in 19..60 -> "青年"
                in 61..150 -> "老年"
                else -> "未知"
            }
        }
}
</pre>
                                    </li>
                                    <li><p><code>setparam</code> -- 用于指定该注解修饰 setter 方法参数</p></li>
                                    <li><p><code>import</code> -- 用于导包</p></li>
                                    <li><p><code>init</code> -- 用于声明初始化块</p></li>
                                    <li><p><code>param</code> -- 用于指定该注解修饰构造器参数</p></li>
                                    <li><p><code>property</code> -- 用于指定该注解修饰整个属性</p></li>
                                    <li><p><code>receiveris</code> -- 用于指定该注解修饰扩展方法或扩展属性的接收者</p></li>

                                    <li><p><code>where</code> -- 用于为泛型参数增加限制，单个上界不需要，当泛型有多个上界的时候，需要用 where 子句指定</p>
                                        <pre class="brush: kotlin;">
// 使用 where 约束泛型的多个上边界
fun &lt;T> copyWhenGreater(list: List&lt;T>, threshold: T): List&lt;String>
    where T : CharSequence,
          T : Comparable&lt;T> {
    return list.filter { it > threshold }.map { it.toString() }
}
</pre>
                                    </li>

                                </ul>
                            </div>

							<div class="split-item">
								<p><b>Kotlin 的修饰符关键字</b></p>
								<ul>
									<li><p><code>private</code> -- private 访问权限</p></li>
									<li><p><code>protected</code> -- protected 访问权限</p></li>
									<li><p><code>public</code> -- public 访问权限</p></li>
                                    <li><p><code>actual</code> -- 表示多平台项目中的一个平台相关实现</p></li>
                                    <li><p><code>expect</code> -- 将一个声明标记为平台相关，并期待在平台模块中实现</p></li>
                                    <li><p><code>operator</code> -- 将一个函数标记为重载一个操作符或者实现一个约定</p></li>
									<li><p><code>abstract</code> -- 用于修饰抽象类或者抽象成员</p></li>
									<li><p><code>annotation</code> -- 用于修饰一个注解类</p></li>
									<li><p><code>open</code> -- 用于修饰类，表示该类可派生子类； 或者用于修饰成员，表示该成员可以被重写</p></li>
									<li><p><code>companion</code> -- 用于声明一个伴生对象</p></li>
									<li><p><code>const</code> -- 用于声明编译时常量</p></li>
									<li><p><code>data</code> -- 用于声明数据类</p></li>
									<li><p><code>enum</code> -- 用于声明枚举</p></li>
									<li><p><code>final</code> -- 用于禁止被重写</p></li>
									<li><p><code>infix</code> -- 声明该函数能以双目运算符的格式执行</p></li>
									<li><p><code>inline</code> -- 用于声明内联函数，Lambda 表达式可在内联函数中执行局部返回</p></li>
									<li><p><code>crossinline</code> -- 用于禁止在传给内联函数的 Lambda 表达式中执行非局部返回</p></li>
									<li><p><code>noinline</code> -- 用于禁止内联函数中个别 Lambda 表达式被内联化</p></li>
									<li><p><code>inner</code> -- 用于声明内部类，内部类可以访问外部类的实例</p></li>
									<li><p><code>internal</code> -- 用于表示被修饰的声明只能在当前模板内可见</p></li>
									<li><p><code>external</code> -- 用于声明某个方法不由 Kotlin 实现（与 Java 的 native 相似）</p></li>
									<li><p><code>lateinit</code> -- 用于修饰一个 non-null 属性，用于指定该属性可在构造器以外的地方完成初始化</p></li>
									<li><p><code>out</code> -- 用于修饰泛型参数，表明该泛型参数支持协变</p>
                                        <pre class="brush: kotlin;">
// 型变注解: out -- 协变,  Producer&lt;Number> 可以安全地作为 Producer&lt;Int> 的超类
class Producer&lt;out T>(val t: T) {
    fun produce(): T {
        return t
    }
}

// 型变注解: in -- 逆变, 使得泛型 T 只可以被消费而不可以被生产(不允许作为返回值)
class Consumer&lt;in T>{
    fun consumer(t: T) {
        LogUtil.log(t)
    }
}
</pre>
                                    </li>
									<li><p><code>override</code> -- 用于声明重写父类的成员</p></li>
									<li><p><code>reified</code> -- 用于修饰内联函数中的泛型形参，接下里在该函数中就可像使用普通类型一样使用该类型参数</p></li>
									<li><p><code>sealed</code> -- 用于声明一个密封类</p></li>
									<li><p><code>suspend</code> -- 用于标识一个函数后 Lambda 表达式可作为暂停</p></li>
									<li><p><code>tailrec</code> -- 用于修改一个函数可作为尾随递归函数使用</p></li>
									<li><p><code>vararg</code> -- 用于修饰形参，表明该参数是个数可变的形参</p></li>
								</ul>
							</div>
						</div>

                        <div class="sub-item">
                            <h3>操作符和特殊符号</h3>
                        </div>
                    </div>
				</div>
				<!-- item end -->

				<!-- item start -->
				<a class="offset" id="kotlin-base-type"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">基本类型和流程控制</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p>在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。 一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。</p>
							<p><b>数字</b> -- Kotlin 处理数字在某种程度上接近 Java，但是并不完全相同。例如，对于数字没有隐式拓宽转换（如 Java 中 int 可以隐式转换为long)，另外有些情况的字面值略有不同。</p>
							<p>Kotlin 不支持八进制，在 Kotlin 中字符不是数字，数字字面值支持下划线(123_456_78L,0b11010010_01101001)。</p>
							<table class="table table-bordered table-response">
								<thead>
								<tr>
									<th>Type</th>
									<th>Bit width</th>
								</tr>
								</thead>
								<tbody>
								<tr>
									<td>Double</td>
									<td>64</td>
								</tr>
								<tr>
									<td>Float</td>
									<td>32</td>
								</tr>
								<tr>
									<td>Long</td>
									<td>64</td>
								</tr>
								<tr>
									<td>Int</td>
									<td>32</td>
								</tr>
								<tr>
									<td>Short</td>
									<td>16</td>
								</tr>
								<tr>
									<td>Byte</td>
									<td>8</td>
								</tr>
								</tbody>
							</table>
							<p>每个数字类型都是 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-number/index.html" target="_blank">Number</a> 的子类，因此支持如下的转换:</p>
							<pre class="brush: kotlin;">
package kotlin

public abstract class Number {
	public abstract fun toDouble(): Double
	public abstract fun toFloat(): Float
	public abstract fun toLong(): Long
	public abstract fun toInt(): Int
	public abstract fun toChar(): Char
	public abstract fun toShort(): Short
	public abstract fun toByte(): Byte
}
</pre>
							<p>完整的位运算列表（只用于 Int 与 Long）：</p>
							<ul>
								<li><code>shl(bits)</code> – 有符号左移 (Java 的 <code>&lt;&lt;</code>)</li>
								<li><code>shr(bits)</code> – 有符号右移 (Java 的 <code>&gt;&gt;</code>)</li>
								<li><code>ushr(bits)</code> – 无符号右移 (Java 的 <code>&gt;&gt;&gt;</code>)</li>
								<li><code>and(bits)</code> – 位与</li>
								<li><code>or(bits)</code> – 位或</li>
								<li><code>xor(bits)</code> – 位异或</li>
								<li><code>inv()</code> – 位非</li>
							</ul>
							<p><b>字符串</b> 用 String 类型表示。字符串是不可变的。 </p>
							<p>可以用 + 操作符连接字符串。这也适用于连接字符串与其他类型的值， 只要表达式中的第一个元素是字符串(在大多数情况下，优先使用字符串模板或原始字符串而不是字符串连接。)</p>
							<pre class="brush: kotlin;">val s = "abc" + 1</pre>
							<p><b>原始字符串</b> 使用三个引号（"""）分界符括起来，内部没有转义并且可以包含换行以及任何其他字符:</p>
							<pre class="brush: kotlin;">
val text = """
	for (c in "foo")
		print(c)
"""
</pre>
							<p><b>字符串模板</b> -- 字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成:</p>
							<pre class="brush: kotlin;">
val i = 10
println("i = $i") // 输出“i = 10”

val s = "abc"
println("$s.length is ${s.length}") // 输出“abc.length is 3”
</pre>
						</div>

						<div class="sub-item">
							<p><b>If 表达式</b></p>
							<p>在 Kotlin 中，if是一个表达式，即它会返回一个值。 因此就不需要三元运算符（条件 ? 然后 : 否则），因为普通的 if 就能胜任这个角色。</p>
							<pre class="brush: kotlin;">
var max = a
if (a < b) max = b

// With else
var max: Int
if (a > b) {
	max = a
} else {
	max = b
}

// 作为表达式
val max = if (a > b) a else b
</pre>

							<p><b>When 表达式</b></p>
							<p>when 取代了类 C 语言的 switch 操作符。其最简单的形式如下：</p>
							<pre class="brush: kotlin;">
when (x) {
	1 -> print("x == 1")
	2 -> print("x == 2")
	else -> { // 注意这个块
		print("x is neither 1 nor 2")
	}
}

// 我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：
when (x) {
	in 1..10 -> print("x is in the range")
	in validNumbers -> print("x is valid")
	!in 10..20 -> print("x is outside the range")
	else -> print("none of the above")
}

// when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式
fun hasPrefix(x: Any) = when(x) {
	is String -> x.startsWith("prefix")
	else -> false
}
</pre>
							<p><b>For 循环</b></p>
							<p>for 循环可以对任何提供迭代器（iterator）的对象进行遍历，这相当于像 C# 这样的语言中的 foreach 循环。</p>
							<p>for 可以循环遍历任何提供了迭代器的对象。即：</p>
							<ul>
								<li>有一个成员函数或者扩展函数 <code>iterator()</code>，它的返回类型
									<ul>
										<li>有一个成员函数或者扩展函数 <code>next()</code>，并且</li>
										<li>有一个成员函数或者扩展函数 <code>hasNext()</code> 返回 <code>Boolean</code>。</li>
									</ul>
								</li>
							</ul>
							<p>这三个函数都需要标记为 <code>operator</code>。</p>
							<pre class="brush: kotlin;">
for (item in collection) print(item)

for (i in 1..4) print(i)                // 输出“1234”
for (i in 4 downTo 1) print(i)          // 输出“4321”
for (i in 1..4 step 2) print(i)         // 输出“13”
for (i in 4 downTo 1 step 2) print(i)   // 输出“42”
</pre>
							<p><b>While 循环</b></p>
							<p>while 与 do..while 照常使用</p>
							<p>在循环中 Kotlin 支持传统的 break 与 continue 操作符。</p>
							<pre class="brush: kotlin;">
while (x > 0) {
	x--
}

do {
	val y = retrieveData()
} while (y != null) // y 在此处可见
							</pre>
						</div>

						<div class="sub-item">
							<p><b>返回和跳转</b></p>
							<p>Kotlin 有三种结构化跳转表达式：</p>
							<ul>
								<li><code>return</code> -- 默认从最直接包围它的函数或者匿名函数返回。</li>
								<li><code>break</code> -- 终止最直接包围它的循环。</li>
								<li><code>continue</code> -- 继续下一次最直接包围它的循环。</li>
							</ul>
							<p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签（参见语法）。 要为一个表达式加标签，我们只要在其前加标签即可。</p>
							<pre class="brush: kotlin;">
loop@ for (i in 1..100) {// ……}

loop@ for (i in 1..100) {
	for (j in 1..100) {
		if (……) break@loop
	}
}
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="kotlin-base-class"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">类和对象</h3>
					</div>
					<div class="panel-body">
                        <a id="class-define" class="offset"></a>
						<div class="sub-item">
                            <p><b>类和对象</b></p>
                            <ul>
                                <li><p><a href="#class-define">类与继承</a></p></li>
                                <li><p><a href="#class-attr">属性与字段</a></p></li>
                                <li><p><a href="#class-interface">接口</a></p></li>
                                <li><p><a href="#class-modifier">可见性修饰符</a></p></li>
                                <li><p><a href="#class-extends">扩展</a></p></li>
                                <li><p><a href="#class-data">数据类</a></p></li>
                                <li><p><a href="#class-sealed">密封类</a></p></li>
                                <li><p><a href="#class-generics">泛型</a></p></li>
                                <li><p><a href="#class-nested">嵌套类</a></p></li>
                                <li><p><a href="#class-enum">枚举类</a></p></li>
                                <li><p><a href="#class-object">对象</a></p></li>
                                <li><p><a href="#class-typealias">类型别名</a></p></li>
                                <li><p><a href="#class-inline">内联类</a></p></li>
                                <li><p><a href="#class-delegate">委托</a></p></li>
                                <li><p><a href="#class-delegate-attr">委托属性</a></p></li>
                            </ul>


							<div class="split-item">
                                <p><b>类声明</b></p>
								<p>Kotlin 中使用关键字 <code>class</code> 声明类</p>
								<pre class="brush: kotlin;">class Person {...}</pre>
								<p>类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的； 如果一个类没有类体，可以省略花括号。</p>
								<pre class="brush: kotlin;">class Empty</pre>
								<p>在 Kotlin 中的一个类可以有一个主构造函数以及一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后。</p>
								<pre class="brush: kotlin;">class Person constructor(firstName: String) { ... }</pre>
								<p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 <code>constructor</code> 关键字。</p>
								<pre class="brush: kotlin;">class Person(firstName: String) { ... }</pre>
								<p><b>主构造函数不能包含任何的代码</b>。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。</p>
								<pre class="brush: kotlin;">
// 主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用：
class Customer(name: String) {

    val customerKey = name.toUpperCase()

	init {
		println("First initializer block that prints ${name}")
	}
}

// 事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法，可以访问实例 p.id, p.name 和 p.age
class Person(var id: String) { // 可以在主构造函数声明属性
    var name: String? = null
    var age: Int = -1

    constructor(id: String, name: String, age: Int) : this(id) {
        this.name = name
        this.age = age
    }
}
</pre>
								<p>与普通属性一样，主构造函数中声明的属性可以是可变的（<code>var</code>）或只读的（<code>val</code>）。</p>
								<p>如果构造函数有注解或可见性修饰符，这个 <code>constructor</code> 关键字是必需的，并且这些修饰符在它前面：</p>
								<pre class="brush: kotlin;">class Customer public @Inject constructor(name: String) { …… }</pre>
								<p>类也可以声明前缀有 <code>constructor</code> 的次构造函数：</p>
								<pre class="brush: kotlin;">
class Person {
    constructor(name: String) {
        println(name)
    }
}
</pre>
								<p>如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 <code>this</code> 关键字即可：</p>
								<pre class="brush: kotlin;">
fun main() {
    val s1 = Person("jiwanger", 30)
    println(String.format("%s:%s", s1.name, s1.age))

    val s2 = Person("jiwanger", 30, "08420229")
    println(String.format("%s:%s:%s", s2.name, s2.age, s2.number))
}

class Person(var name: String, var age: Int) {
    lateinit var number: String

    constructor(name: String, age: Int, number: String) : this(name, age) {
        this.number = number
    }
}
</pre>
								<p><b>注意，初始化块中的代码实际上会成为主构造函数的一部分。</b>委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：</p>
								<pre class="brush: kotlin;">
class Constructors {
    init { println("Init block") } // 先执行此句

    constructor(i: Int) { println("Constructor") }
}
</pre>
							</div>

							<div class="split-item">
								<p><b>继承</b></p>
                                <p>在 Kotlin 中所有类都有一个共同的超类 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html" target="_blank">Any</a>，这对于没有超类型声明的类是默认超类。</p>
								<p><b>注意</b>：<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html" target="_blank">Any</a> 并不是 java.lang.Object；尤其是，它除了 equals()、hashCode() 与 toString() 外没有任何成员。 </p>
								<p>如果派生类有一个主构造函数，其基类型可以（并且必须） 用基类的主构造函数参数就地初始化。</p>
								<pre class="brush: kotlin;">
open class Person(var name: String, var age: Int)

// 如果派生类有一个主构造函数，其基类型可以（并且必须） 用基类的主构造函数参数就地初始化。
class Student(name: String, age: Int, var number: String) :Person(name, age)

fun main() {
    val p1 = Person("jiwanger", 30)
    println(String.format("%s:%s", p1.name, p1.age))
    val s1 = Student("jiwanger", 30, "08420229")
    println(String.format("%s:%s:%s", s1.name, s1.age, s1.number))
    s1.number = "13823039350"
    println(String.format("%s:%s:%s", s1.name, s1.age, s1.number))
}
</pre>
								<p><p>如果类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：</p>
								<pre class="brush: kotlin;">
// 比如 android.view.View 类
class MyView : View {
    constructor(ctx: Context) : super(ctx)
    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}
								</pre>
								<p><b>覆盖方法</b></p>
								<p>Kotlin 力求清晰显式。与 Java 不同，Kotlin 对于可覆盖的成员（我们称之为开放）以及覆盖后的成员需要显式修饰符：</p>
								<pre class="brush: kotlin;">
open class Base {
    open fun v() { ... } // 使用 open 修饰，表示可以覆盖
    open fun nv() { ... }
	fun m() {...}        // 子类不能覆盖此方法
}

class Derived() : Base() {
    override fun v() { ... }        // 使用 override 修饰，表示覆盖基类的方法
	final override fun nv() { ... } // 使用 final 修饰，表示不能再次覆盖
}
</pre>
								<p><b>覆盖规则</b></p>
								<p>在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super&lt;Base>：</p>
								<pre class="brush: kotlin;">
open class A {
    open fun f() { print("A") }
    fun a() { print("a") }
}

interface B {
    fun f() { print("B") } // 接口成员默认就是“open”的
    fun b() { print("b") }
}

class C() : A(), B {
    // 编译器要求覆盖 f()：
	override fun f() {
        super&lt;A>.f() // 调用 A.f()
        super&lt;B>.f() // 调用 B.f()
	}
}
</pre>
								<p><b>抽象类</b></p>
								<p>类以及其中的某些成员可以声明为 <code>abstract</code>。 抽象成员在本类中可以不用实现。 需要注意的是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻。</p>
								<pre class="brush: kotlin;">
open class Base {
    open fun f() {}
}

abstract class Derived : Base() {
    override abstract fun f()
}
</pre>
							</div>
						</div>

                        <a id="class-attr" class="offset"></a>
						<div class="sub-item">
							<p><b>属性与字段</b></p>
							<div class="split-item">
								<p><b>声明属性</b></p>
								<p>Kotlin 的类可以有属性。 属性可以用关键字 <code>var</code> 声明为可变的，否则使用只读关键字 <code>val</code>。</p>
								<pre class="brush: kotlin;">
class Address {
    var name: String = ……
    var street: String = ……
    var city: String = ……
    var state: String? = ……
    var zip: String = ……
}

// 使用属性
fun copyAddress(address: Address): Address {
    val result = Address() // Kotlin 中没有“new”关键字
    result.name = address.name // 将调用访问器
    result.street = address.street
    // ……
    return result
}
</pre>
								<p>声明一个属性的完整语法是:</p>
								<pre class="brush: kotlin;">
var &lt;propertyName>[: &lt;PropertyType>] [= &lt;property_initializer>]
    [&lt;getter>]
    [&lt;setter>]

fun main() {
    val p = Person("jiwanger")
    p.age = 9 // 在此句后才能使用 p.description 属性，因为在 age 的 set() 方法中初始化
    LogUtil.log(p.name, p.age, p.description)
}

class Person(var name: String) {
    lateinit var description: String   // 延迟初始化属性与变量(在初始化前不能访问)

    // 使用 val 申明的属性不能有 set() 方法
    var age: Int = -1  // 可以省略(: Int), 因为可以推断处属性类型
        get() = if (field > 150 || field < 0) 0 else field  // 在 set() 中可以使用幕后字段 field
        set(value) {
            field = value                                   // 在 get() 中可以使用幕后字段 field
            description = when (age) {
                in 0..6 -> "宝宝"
                in 7..18 -> "学生"
                in 19..60 -> "青年"
                in 61..150 -> "老年"
                else -> "未知"
            }
        }
}
</pre>
							</div>
						</div>

                        <a id="class-interface" class="offset"></a>
						<div class="sub-item">
							<p><b>接口</b></p>
							<p>Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。</p>
							<p>使用关键字 interface 来定义接口：</p>
							<pre class="brush: kotlin;">
interface MyInterface {
    fun bar()
    fun foo() { // 可选的方法体 }
}

// 实现接口
class Child : MyInterface {
    override fun bar() { // 方法体 }
}
</pre>
							<p><b>接口中的属性</b></p>
							<p>在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们。</p>
							<pre class="brush: kotlin;">
interface MyInterface {
    val prop: Int // 抽象的

    val propertyWithImplementation: String
        get() = "foo"

    fun foo() { print(prop) }
}

class Child : MyInterface {
    override val prop: Int = 29
}
</pre>
							<p><b>接口继承</b></p>
							<p>一个接口可以从其他接口派生，从而既提供基类型成员的实现也声明新的函数与属性。很自然地，实现这样接口的类只需定义所缺少的实现：</p>
							<pre class="brush: kotlin;">
interface Named {
    val name: String
}

interface Person : Named {
    val firstName: String
    val lastName: String

    override val name: String get() = "$firstName $lastName"
}

data class Employee (
    // 不必实现“name”
    override val firstName: String,
    override val lastName: String,
    val position: Position
) : Person
</pre>
							<p><b>解决覆盖冲突</b></p>
							<p>实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如</p>
							<pre class="brush: kotlin;">
interface A {
    fun foo() { print("A") }
    fun bar()
}

interface B {
    fun foo() { print("B") }
    fun bar() { print("bar") }
}

class C : A {
    override fun bar() { print("bar") }
}

class D : A, B {
    override fun foo() {
        super&lt;A>.foo()
        super&lt;B>.foo()
    }

    override fun bar() {
        super&lt;B>.bar()
    }
}
</pre>
						</div>

                        <a id="class-modifier" class="offset"></a>
						<div class="sub-item">
							<p><b>可见性修饰符</b></p>
							<p>类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有 可见性修饰符。 （getter 总是与属性有着相同的可见性。） 在 Kotlin 中有这四个可见性修饰符：private、 protected、 internal 和 public。 如果没有显式指定修饰符的话，默认可见性是 public。</p>
							<p><b>internal</b> 会在相同"模块"内随处可见，"模块"具体地说， 一个模块是编译在一起的一套 Kotlin 文件：</p>
							<ul>
								<li><p>一个 IntelliJ IDEA 模块；</p></li>
								<li><p>一个 Maven 项目；</p></li>
								<li><p>一个 Gradle 源集（例外是 test 源集可以访问 main 的 internal 声明）；</p></li>
								<li><p>一次 &lt;kotlinc> Ant 任务执行所编译的一套文件。</p></li>
							</ul>
							<p>修饰符如何应用到不同类型的声明作用域:</p>
							<ul>
								<li>
									<p><b>包</b> -- 函数、属性和类、对象和接口可以在顶层声明，即直接在包内，要使用另一包中可见的顶层声明，仍需将其导入进来。</p>
									<ul>
										<li><p>如果你不指定任何可见性修饰符，默认为 public，这意味着你的声明将随处可见；</p></li>
										<li><p>如果你声明为 private，它只会在声明它的文件内可见；</p></li>
										<li><p>如果你声明为 internal，它会在相同模块内随处可见；</p></li>
										<li><p>protected 不适用于顶层声明。</p></li>
									</ul>
								</li>
								<li>
									<p><b>类和接口</b> -- 对于Java用户：Kotlin 中外部类不能访问内部类的 private 成员。</p>
									<ul>
										<li><p>private 意味着只在这个类内部（包含其所有成员）可见；</p></li>
										<li><p>protected—— 和 private一样 + 在子类中可见。</p></li>
										<li><p>internal —— 能见到类声明的 本模块内 的任何客户端都可见其 internal 成员；</p></li>
										<li><p>public —— 能见到类声明的任何客户端都可见其 public 成员。</p></li>
									</ul>

								</li>
								<li>
									<p><b>构造函数</b> -- 要指定一个类的的主构造函数的可见性，使用以下语法:</p>
									<pre class="brush: kotlin;">class C private constructor(a: Int) { …… }</pre>
									<p>默认情况下，所有构造函数都是 public，这实际上等于类可见的地方它就可见（即 一个 internal 类的构造函数只能在相同模块内可见).</p>
								</li>

							</ul>
						</div>

                        <a id="class-extends" class="offset"></a>
						<div class="sub-item">
                            <div class="split-item">
                                <p><b>扩展</b></p>
                                <p>Kotlin 能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式。 这通过叫做 扩展 的特殊声明完成。Kotlin 支持 <b>扩展函数</b> 与 <b>扩展属性</b>。</p>
                                <p><b>扩展函数</b> -- 声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。</p>
                                <pre class="brush: kotlin;">
fun main() {
    val p = Person("jiwanger")
    println(String.format("%s:%s", p.name, p.length()))
}

/** 此函数为 Person 类添加了一个 length() 的函数 */
fun Person.length(): Int {
    return this.name.length
}

class Person(var name: String)
</pre>
                                <p>如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、相同的名字，都适用给定的参数，这种情况总是取成员函数。</p>
                                <pre class="brush: kotlin;">
class C { fun foo() { println("member") } }

fun C.foo() { println("extension") }
</pre>
                                <p>如果我们调用 C 类型 c 的 c.foo()，它将输出 “member”，而不是 “extension”。</p>

                                <p><b>扩展属性</b> -- 由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 getters/setters 定义。</p>
                                <pre class="brush: kotlin;">
fun main() {
    val p = Person("jiwanger")
    println(String.format("%s:%s", p.name, p.length))
}

val Person.length: Int        // 这里用 val 来定义属性，因为此属性的值根据 name 来确定，只有 get() 方法
    get() = this.name.length

class Person(var name: String)
</pre>
                            </div>

                            <div class="split-item">
                                <p><b>伴生对象的扩展</b></p>
                                <p>如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数与属性。</p>
                                <pre class="brush: kotlin;">
class MyClass {
    companion object { }  // 将被称为 "Companion"
}

fun MyClass.Companion.printCompanion() { println("companion") }

fun main() {
    MyClass.printCompanion()
}
</pre>
                            </div>

                            <div class="split-item">
                                <p><b>扩展的作用域</b></p>
                                <p>大多数时候我们在顶层定义扩展——直接在包里：</p>
                                <pre class="brush: kotlin;">
package org.example.declarations

fun List&lt;String>.getLongestString() { } // 为 List 类扩展了一个 getLongestString() 的方法
</pre>

                                <p>要使用所定义包之外的一个扩展，我们需要在调用方导入它：</p>
                                <pre class="brush: kotlin;">
package org.example.usage

import org.example.declarations.getLongestString

fun main() {
    val list = listOf("red", "green", "blue")
    list.getLongestString()
}
</pre>
                            </div>

                            <div class="split-item">
                                <p><b>扩展声明为成员</b></p>
                                <p>在一个类内部你可以为另一个类声明扩展。在这样的扩展内部，有多个 隐式接收者 —— 其中的对象成员可以无需通过限定符访问。扩展声明所在的类的实例称为 分发接收者，扩展方法调用所在的接收者类型的实例称为 扩展接收者 。</p>
                                <pre class="brush: kotlin;">
class Host(val hostname: String) {
    fun printHostname() { print(hostname) }
}

class Connection(val host: Host, val port: Int) {
     fun printPort() { print(port) }

     fun Host.printConnectionString() {
         printHostname()   // 调用 Host.printHostname()
         print(":")
         printPort()   // 调用 Connection.printPort()
     }

     fun connect() {
         /*……*/
         host.printConnectionString()   // 调用扩展函数
     }
}

fun main() {
    Connection(Host("kotl.in"), 443).connect()
    // Host("kotl.in").printConnectionString(443)  // 错误，该扩展函数再 Connection 外不可用
}
</pre>
                            </div>
						</div>

                        <a id="class-data" class="offset"></a>
						<div class="sub-item">
							<p><b>数据类</b></p>
							<p>我们经常创建一些只保存数据的类。 在这些类中，一些标准函数往往是从数据机械推导而来的。</p>
							<p>在 Kotlin 中，这叫做 数据类 并标记为 data：</p>
							<pre class="brush: kotlin;">data class User(var name: String, var age: Int)</pre>
							<p>数据类的 toString() 格式是 "User(name=John, age=42)"。</p>
							<p>为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求：</p>
							<ul>
								<li><p>主构造函数需要至少有一个参数；</p></li>
								<li><p>主构造函数的所有参数需要标记为 val 或 var；</p></li>
								<li><p>数据类不能是抽象、开放、密封或者内部的；(数据类没有子类)</p></li>
								<li><p>在 JVM 中，如果生成的类需要含有一个无参的构造函数，则所有的属性必须指定默认值。 </p></li>
							</ul>
							<p><code>copy()</code> 方法可以复制对象，并修改其属性</p>
							<pre class="brush: kotlin;">
fun main() {
	val s1 = Student("08420229", 30)
    val s2 = s1.copy(age = 32)
    println(String.format("%s:%s:%s", s1 == s2, s1.age, s2.age))
}

data class Student(var number: String, var age: Int)
</pre>
                            <p><b>数据类与解构声明</b></p>
                            <p>为数据类生成的 Component 函数 使它们可在解构声明中使用：</p>
                            <pre class="brush: kotlin;">
val jane = User("Jane", 35)
val (name, age) = jane
println("$name, $age years of age") // 输出 "Jane, 35 years of age"
 </pre>
						</div>

                        <a id="class-sealed" class="offset"></a>
                        <div class="sub-item">
                            <p><b>密封类</b></p>
                            <p>密封类用来表示受限的类继承结构：当一个值为有限几种的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而<b>密封类的一个子类可以有可包含状态的多个实例</b>。</p>
                            <p>要声明一个密封类，需要在类名前面添加 <code>sealed</code> 修饰符。虽然密封类也可以有子类，但是<b>所有子类都必须在与密封类自身相同的文件中声明。</b></p>
                            <pre class="brush: kotlin;">
sealed class Expr
data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()
object NotANumber : Expr()
</pre>
                            <p>一个密封类是自身抽象的，它不能直接实例化并可以有抽象（<code>abstract</code>）成员。</p>
                            <p>密封类不允许有非 <code>private</code> 构造函数（其构造函数默认为 <code>private</code>）。</p>
                            <p>请注意，扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在同一个文件中。</p>
                            <p>使用密封类的关键好处在于使用 <code>when</code> 表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 <code>else</code> 子句了。当然，这只有当你用 <code>when</code> 作为表达式（使用结果）而不是作为语句时才有用。</p>
                            <pre class="brush: kotlin;">
fun main() {
    val c1 = Const(10.0)
    val c2 = Const(5.0)
    val sum = Sum(c1, c2)

    LogUtil.log(eval(sum))
}

fun eval(expr: Expr): Double = when (expr) {
    is Const -> expr.number
    is Sum -> eval(expr.e1) + eval(expr.e2)
    NotANumber -> Double.NaN
    // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况
}
</pre>
                        </div>

                        <a id="class-generics" class="offset"></a>
                        <div class="sub-item">
                            <div class="split-item">
                                <p><b>泛型</b></p>
                                <p>与 Java 类似，Kotlin 中的类也可以有类型参数：</p>
                                <pre class="brush: kotlin;">
class Box&lt;T>(var t: T)

val box: Box&lt;Int> = Box&lt;Int>(1)
val box = Box(1) // 1 具有类型 Int，所以编译器知道我们说的是 Box&lt;Int>
</pre>
							    <p>Java 类型系统中最棘手的部分之一是通配符类型，参见：<a href="../java/index.html#java-generics" target="_blank">Java 泛型</a>。 而 Kotlin 中没有。 相反，它有两个其他的东西：<b>声明处型变</b>（declaration-site variance）与<b>类型投影</b>（type projections）。</p>
                            </div>

                            <div class="split-item">
                                <p><b>声明处型变</b></p>
                                <ul>
                                    <li><p><code>out</code> -- <b>协变</b>, 泛型 T 只能出现在 C 的输出位置</p></li>
                                    <li><p><code>in</code> -- <b>逆变</b>, 泛型 T 只可以被消费而不可以被生产</p></li>
                                </ul>
                                <pre class="brush: kotlin;">
fun main() {
    val genericsInt = Generics(2)
//  val genericsNumber: Generics&lt;Number> = genericsInt // ERROR

    val producerInt = Producer(2)
    val genericsNumber: Producer&lt;Number> = producerInt // OK， 子类转父类

    val consumerNumber = Consumer&lt;Number>()
    consumerNumber.consumer(3.0f)
    val consumerInt: Consumer&lt;Int> = consumerNumber    // OK, 注意，这里是父类转子类
    consumerInt.consumer(2)
}

// 普通泛型
class Generics&lt;T>(var t: T)

// 型变注解: out -- 协变, 泛型 T 只能出现在 C 的输出位置，回报是 Producer&lt;Number> 可以安全地作为 Producer&lt;Int> 的超类
class Producer&lt;out T>(val t: T) {
    fun produce(): T {
        return t
    }
}

// 型变注解: in -- 逆变, 使得泛型 T 只可以被消费而不可以被生产(不允许作为返回值)
class Consumer&lt;in T>{
    fun consumer(t: T) {
        LogUtil.log(t)
    }
}
</pre>
                            </div>

                            <div class="split-item">
                                <p><b>类型投影</b></p>
                                <p>将类型参数 T 声明为 out 非常方便，并且能避免使用处子类型化的麻烦，但是有些类实际上不能限制为只返回 T！ 一个很好的例子是 Array：</p>
                                <pre class="brush: kotlin;">
class Array&lt;T>(val size: Int) {
    fun get(index: Int): T { …… }
    fun set(index: Int, value: T) { …… }
}
</pre>
                                <p>这里我们遇到同样熟悉的问题：Array&lt;T> 在 T 上是不型变的，因此 Array&lt;Int> 和 Array&lt;Any> 都不是另一个的子类型。为什么？ 再次重复，因为 copy 可能做坏事，也就是说，例如它可能尝试写一个 String 到 from， 并且如果我们实际上传递一个 Int 的数组，一段时间后将会抛出一个 ClassCastException 异常。</p>
                                <p>那么，我们唯一要确保的是 copy() 不会做任何坏事。我们想阻止它写到 from，我们可以：</p>
                                <pre class="brush: kotlin;">fun copy(from: Array&lt;out Any>, to: Array&lt;Any>) { …… } // 限制 from 只能读</pre>
                                <p>这里发生的事情称为类型投影：我们说 from 不仅仅是一个数组，而是一个受限制的（投影的）数组：我们只可以调用返回类型为类型参数 T 的方法，如上，这意味着我们只能调用 get()。这就是我们的使用处型变的用法，并且是对应于 Java 的 Array&lt;? extends Object>、 但使用更简单些的方式。</p>
                                <p>你也可以使用 in 投影一个类型：</p>
                                <pre class="brush: kotlin;">fun fill(dest: Array&lt;in String>, value: String) { …… }  // 限制 dest 只能写</pre>
                                <p>Array&lt;in String> 对应于 Java 的 Array&lt;? super String>，也就是说，你可以传递一个 CharSequence 数组或一个 Object 数组给 fill() 函数。</p>
                            </div>

                            <div class="split-item">
                                <p><b>星投影( * 投影)</b></p>
                                <p>Kotlin 提供了所谓的星投影语法：</p>
                                <ul>
                                    <li><p>对于 <code>Foo&lt;out T : TUpper></code>，其中 T 是一个具有上界 TUpper 的协变类型参数，<code>Foo&lt;*></code> 等价于 <code>Foo&lt;out TUpper></code>。 这意味着当 T 未知时，你可以安全地从 <code>Foo&lt;*></code> 读取 TUpper 的值。</p></li>
                                    <li><p>对于 <code>Foo&lt;in T></code>，其中 T 是一个逆变类型参数，<code>Foo&lt;*></code> 等价于 <code>Foo&lt;in Nothing></code>。 这意味着当 T 未知时，没有什么可以以安全的方式写入 <code>Foo&lt;*></code>。</p></li>
                                    <li><p>对于 <code>Foo&lt;T : TUpper></code>，其中 T 是一个具有上界 TUpper 的不型变类型参数，<code>Foo&lt;*></code> 对于读取值时等价于 <code>Foo&lt;out TUpper></code> 而对于写值时等价于 <code>Foo&lt;in Nothing></code>。</p></li>
                                </ul>
                            </div>

                            <div class="split-item">
                                <p><b>泛型函数和约束</b></p>
                                <p>泛型函数</p>
                                <pre class="brush: kotlin;">
fun &lt;T> singletonList(item: T): List&lt;T> { ... } // 泛型函数

fun &lt;T> T.basicToString(): String { ... }          // 扩展函数
                                </pre>
                                <p>泛型约束</p>
                                <p>上界约束；如果同一类型参数需要多个上界，我们需要一个单独的 where 子句, 所传递的类型必须同时满足 where 子句的所有条件。</p>
                                <pre class="brush: kotlin;">
fun &lt;T: Comparable&lt;T>> sort(list: List&lt;T>) {  …… } // 单个上界约束

fun &lt;T> copyWhenGreater(list: List&lt;T>, threshold: T): List&lt;String>
    where T : CharSequence,
          T : Comparable&lt;T> {
    return list.filter { it > threshold }.map { it.toString() }
}
</pre>
                            </div>


                        </div>

                        <a id="class-nested" class="offset"></a>
                        <div class="sub-item">
                            <p><b>嵌套类和内部类</b></p>
                            <pre class="brush: kotlin;">
fun main() {
    val nested = Outer.Nested()     // 嵌套类不能够访问其外部类的成员
    val inner = Outer().Inner()     // 内部类会带有一个对外部类的对象的引用，因此可以访问外部类的成员

    Outer().onClick(object: Base {  // 匿名内部类
        override fun show() {
            LogUtil.log("onClick")
        }
    })

}

interface Base {
    fun show()
}

class Outer {
    class Nested            // 嵌套类
    inner class Inner       // 内部类

    fun onClick(base: Base) {
        base.show()
    }
}
</pre>

                        </div>

                        <a id="class-enum" class="offset"></a>
                        <div class="sub-item">
                            <p><b>枚举类</b></p>
							<p>每个枚举常量都是一个对象。枚举常量用逗号分隔: </p>
							<pre class="brush: kotlin;">
enum class Direction {
    NORTH, SOUTH, WEST, EAST
}
</pre>
							<p>因为每一个枚举都是枚举类的实例，所以他们可以是这样初始化过的: </p>
							<pre class="brush: kotlin;">
enum class Color(val rgb: Int) {
	RED(0xFF0000),
	GREEN(0x00FF00),
	BLUE(0x0000FF)
}
</pre>

							<p>枚举常量还可以声明其带有相应方法以及覆盖了基类方法的匿名类。</p>
							<p>如果枚举类定义任何成员，那么使用分号将成员定义中的枚举常量定义分隔开: </p>
							<pre class="brush: kotlin;">
enum class ProtocolState {
    WAITING {
        override fun signal() = TALKING
    },

    TALKING {
        override fun signal() = WAITING
    }; // 此处必须有分号

	// 枚举类可以有抽象函数
    abstract fun signal(): ProtocolState
}
</pre>
							<p>一个枚举类可以实现接口（但不能从类继承），可以为所有条目提供统一的接口成员实现，也可以在相应匿名类中为每个条目提供各自的实现。</p>
							<p>枚举常量还实现了 Comparable 接口， 其中自然顺序是它们在枚举类中定义的顺序。</p>
							<pre class="brush: kotlin;">
enum class IntArithmetics : BinaryOperator&lt;Int>, IntBinaryOperator {
    PLUS {
        override fun apply(t: Int, u: Int): Int = t + u
    },
    TIMES {
        override fun apply(t: Int, u: Int): Int = t * u
    }; // 此处必须有分号

    override fun applyAsInt(t: Int, u: Int) = apply(t, u)
}
</pre>

                        </div>

                        <a id="class-object" class="offset"></a>
                        <div class="sub-item">
                            <p><b>对象</b></p>
							<div class="split-item">
								<p><b>对象表达式</b></p>
								<p>对象表达式就像 Java 中的匿名类，但有不同之处。</p>
								<pre class="brush: kotlin;">
fun main() {
	// val listener = object : Listener { override fun event() { ... } } // 这样写也行
    val v1 = View(object : Listener {
        override fun notify() { LogUtil.log("Listener") }
    })
    v1.doEvent()

	// val listener = object : DefaultListener { override fun event() { ... } } // 这样写也行
    val v2 = View(object : DefaultListener() {
        override fun notify() {
            super.event()
            LogUtil.log("Listener")
        }
    })
    v2.doEvent()
}

interface Listener { fun notify() }

open class DefaultListener : Listener {
    override fun notify() { LogUtil.log("DefaultListener") }
}

class View(var listener : Listener) {
    fun doEvent() {
        LogUtil.log("doEvent")
        listener.notify()
    }
}
</pre>
								<p>如果超类型有一个构造函数，则必须传递适当的构造函数参数给它。 多个超类型可以由跟在冒号后面的逗号分隔的列表指定：</p>
								<pre class="brush: kotlin;">
open class A(x: Int) { public open val y : Int = x }

interface B { ... }

val ab: A = object : A(1), B { // 和 Java 的不同之处是对象表达式可以有多个超类
    override val y = 15
}
</pre>
								<p>任何时候，如果我们只需要“一个对象而已”，并不需要特殊超类型，那么我们可以简单地写：</p>
								<pre class="brush: kotlin;">
fun foo() {
    val adHoc = object {
        var x: Int = 0
        var y: Int = 0
    }
    print(adHoc.x + adHoc.y)
}
</pre>
								<p>请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象中添加的成员将无法访问。</p>
								<pre class="brush: kotlin;">
class C {
    // 私有函数，所以其返回类型是匿名对象类型
    private fun foo() = object { val x: String = "x" }

    // 公有函数，所以其返回类型是 Any
    fun publicFoo() = object { val x: String = "x" }

    fun bar() {
        val x1 = foo().x           // 没问题
        // val x2 = publicFoo().x  // 错误：未能解析的引用“x”
    }
}
</pre>
							</div>

							<div class="split-item">
								<p><b>对象声明</b></p>
								<p>对象声明总是在 <code>object</code> 关键字后跟一个名称。 就像变量声明一样，对象声明不是一个表达式，不能用在赋值语句的右边。</p>
								<p><b>对象声明的初始化过程是线程安全的。</b></p>
								<p><b>注意：对象声明不能在局部作用域（即直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或非内部类中。</b></p>
								<pre class="brush: kotlin;">
class A {
    // 类内部的对象声明
    object B { fun show() { LogUtil.log("B") } }

    // 伴生对象，一个类的伴生对象只能有一个，通过类名直接调用 A.show() / A.Factory.show()
    companion object Factory { fun show() { LogUtil.log("A") } }
    // 可以直接省略名字，如果省略名字，可以这样调用: A.Companion.show() / A.show()
    // companion object { fun show() { LogUtil.log("A") } }
}
</pre>

							</div>

                        </div>

                        <a id="class-typealias" class="offset"></a>
                        <div class="sub-item">
                            <p><b>类型别名</b></p>
							<p>类型别名为现有类型提供替代名称。 如果类型名称太长，你可以另外引入较短的名称，并使用新的名称替代原类型名。</p>
							<pre class="brush: kotlin;">
/** 为内部类和嵌套类创建新名称 */
class A { class Inner { fun show() {} } }
class B { class Inner { fun show() {} } }
typealias AInner = A.Inner
typealias BInner = B.Inner

/** 通常缩减集合类型是很有吸引力的 */
typealias AInnerList = ArrayList&lt;A.Inner>
typealias BHashMapList&lt;K> = HashMap&lt;K, AInnerList>

/** 函数类型提供另外的别名 */
typealias Predicate&lt;T> = (T) -> Boolean
typealias MyHandler = (Int, String, Any) -> String

fun main() {
    AInner().show()
    BInner().show()

    val aInnerList: AInnerList = ArrayList()
    aInnerList.add(AInner())

    val bHashMapListInt: BHashMapList&lt;Int> = HashMap()
    bHashMapListInt[1] = aInnerList
    val bHashMapListString: BHashMapList&lt;String> = HashMap()
    bHashMapListString["first"] = aInnerList

    val f : Predicate&lt;Int> = { it > 0 } // 等价于 val f: (Int) -> Boolean = { it > 0 }
    LogUtil.log(f(20)) // true

    // 等价于 val myHandler: (Int, String, Any) -> String = { i, s, any -> "$any, $s, age is $i." }
    val myHandler : MyHandler = { i, s, any -> "$any, $s, age is $i." }
    LogUtil.log(myHandler(30, "jiwanger", "Hello"))
}
</pre>
                        </div>

                        <a id="class-inline" class="offset"></a>
                        <div class="sub-item">
                            <p><b>内联类</b></p>
							<p class="text-warning">内联类仅在 Kotlin 1.3 之后版本可用，目前还是实验性的。</p>
							<p>有时候，业务逻辑需要围绕某种类型创建包装器。然而，由于额外的堆内存分配问题，它会引入运行时的性能开销。此外，如果被包装的类型是原生类型，性能的损失是很糟糕的，因为原生类型通常在运行时就进行了大量优化，然而他们的包装器却没有得到任何特殊的处理。</p>
							<p>为了解决这类问题，Kotlin 引入了一种被称为 内联类 的特殊类，它通过在类的前面定义一个 inline 修饰符来声明：</p>
							<pre class="brush: kotlin;">inline class Password(val value: String)</pre>
							<p><b>内联类必须含有唯一的一个属性在主构造函数中初始化。在运行时，将使用这个唯一属性来表示内联类的实例。</b></p>
							<pre class="brush: kotlin;">
// 不存在 'Password' 类的真实实例对象
// 在运行时，'securePassword' 仅仅包含 'String'
val securePassword = Password("Hello World")
LogUtil.log(securePassword) // Hello World
</pre>
							<ul>
								<li><p><b>内联类不能含有 init 代码块</b></p></li>
								<li><p><b>内联类不能含有幕后字段</b> 因此，内联类只能含有简单的计算属性（不能含有延迟初始化/委托属性）</p></li>
								<li><p><b>内联类允许去继承接口，禁止内联类参与到类的继承关系结构中。这就意味着内联类不能继承其他的类而且必须是 final。</b></p></li>
								<li><p>内联类支持普通类中的一些功能。特别是，内联类可以声明属性与函数：</p>
							<pre class="brush: kotlin;">
inline class Name(val s: String) {
    val length: Int
        get() = s.length

    fun greet() { LogUtil.log("Hello, $s") }
}

fun main() {
    val name = Name("Kotlin")
    name.greet()		 // `greet` 方法会作为一个静态方法被调用
    println(name.length) // 属性的 get 方法会作为一个静态方法被调用
}
</pre>
								</li>
							</ul>

							<p><b>内联类与类型别名</b></p>
							<p>初看起来，内联类似乎与类型别名非常相似。实际上，两者似乎都引入了一种新的类型，并且都在运行时表示为基础类型。</p>
							<p>然而，关键的区别在于类型别名与其基础类型(以及具有相同基础类型的其他类型别名)是 赋值兼容 的，而内联类却不是这样。</p>
							<p>换句话说，内联类引入了一个真实的新类型，与类型别名正好相反，类型别名仅仅是为现有的类型取了个新的替代名称(别名)：</p>
							<pre class="brush: kotlin;">
typealias NameTypeAlias = String
inline class NameInlineClass(val s: String)

fun acceptString(s: String) {}
fun acceptNameTypeAlias(n: NameTypeAlias) {}
fun acceptNameInlineClass(p: NameInlineClass) {}

fun main() {
    val nameAlias: NameTypeAlias = ""
    val nameInlineClass = NameInlineClass("")
    val string = ""

    acceptString(nameAlias)             // 正确: 传递别名类型的实参替代函数中基础类型的形参
    // acceptString(nameInlineClass)    // 错误: 不能传递内联类的实参替代函数中基础类型的形参

    acceptNameTypeAlias(string)         // 正确: 传递基础类型的实参替代函数中别名类型的形参
    // acceptNameInlineClass(string)    // 错误: 不能传递基础类型的实参替代函数中内联类类型的形参
}
</pre>

                        </div>

                        <a id="class-delegate" class="offset"></a>
                        <div class="sub-item">
                            <p><b>委托</b></p>
							<p>委托模式已经证明是实现继承的一个很好的替代方式， 而 Kotlin 可以零样板代码地原生支持它。 </p>
							<div class="row">
								<div class="col-md-6">
									<p><b>Kotlin 中的委托</b></p>
									<pre class="brush: kotlin;">
interface Base { fun print() }

class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}

class Derived(b: Base) : Base by b // 只能是接口

// 如果重写 print() 方法，需要 override
class Derived2(b: Base) : Base by b	{
	override fun print() { print("abc") }
}

class Derived3(b: Base) : Base by b	{
	// 在 b 的 `print` 实现中不会访问到这个属性
    override val x = 20
}

fun main() {
    Derived(BaseImpl(10)).print()
}
</pre>
								</div>
								<div class="col-md-6">
									<p><b>Java 中的委托</b>(没有语言级别的支持)</p>
									<pre class="brush: java;">
interface Base { void print(); }

class BaseImpl implements Base {
    int x;
    BaseImpl(int x) { this.x = x; }
    public void print() {
		System.out.println(x);
	}
}

class Derived {
    Base base;
    Derived(Base base) { this.base = base; }
    void print() { base.print(); }
}

public class App {
    public static void main(String[] args) {
        new Derived(new BaseImpl(10)).print();
    }
}

</pre>
								</div>
							</div>
                        </div>

                        <a id="class-delegate-attr" class="offset"></a>
                        <div class="sub-item">
							<div class="split-item">
								<p><b>委托属性</b></p>
								<p>属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（与 setValue() -- 对于 var 属性）</p>
								<pre class="brush: kotlin;">
class Person {
    var name: String by Delegate() // 将 p 属性的 set/get 方法委托给 Delegate 类实现
}

class Delegate {
    private var name = "Default" // 可以提供一个默认值

    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        LogUtil.log("委托属性的实例：$thisRef, 委托属性的名字：'${property.name}'")
        return name
    }

    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        LogUtil.log("委托属性的实例：$thisRef, 委托属性的名字：'${property.name}, 传入的值：$value'")
        this.name = value
    }
}

fun main() {
    val p = Person()
    p.name = "jiwanger" // 将会调用 Delegate 的 setValue 方法
    LogUtil.log(p.name) // 返回的值由 Delegate 类的 getValue 方法返回
}
</pre>
							</div>
							<div class="split-item">
								<p><b>标准委托</b></p>
								<p>Kotlin 标准库为几种有用的委托提供了工厂方法:</p>
								<ul>
									<li><p><b>延迟属性 Lazy</b> -- 接受一个 lambda 并返回一个 Lazy&lt;T> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果</p>
										<pre class="brush: kotlin;">
val lazyValue: String by lazy {
    println("computed!")
    "Hello"
}

fun main() {
    println(lazyValue) // computed! \n hello
    println(lazyValue) // hello(这里是第二次方法，直接返回记录的结果)
}
</pre>
									</li>
									<li><p><b>可观察属性 Observable</b> -- 每次修改都会回调</p>
										<pre class="brush: kotlin;">
fun main() {
    val p = Person()
    println(p.name)   // none
    p.name = "first"  // none -> first
    p.name = "second" // first -> second
    println(p.name)   // second
}

class Person {
    var name: String by Delegates.observable("none") {
        prop, old, new ->
        println("$old -> $new")
    }
}
</pre>
									</li>
									<li><p><b>属性储存在映射中</b> -- 映射实例自身作为委托来实现委托属性</p>
										<pre class="brush: kotlin;">
class User(val map: Map&lt;String, Any?>) {
    val name: String by map
    val age: Int     by map
}

fun main() {
    val user = User(mapOf(
            "name" to "John Doe",
            "age"  to 25
    ))

    println(user.name) // "John Doe"
    println(user.age)  // 25
}
</pre>
									</li>
								</ul>
							</div>


							<div class="split-item">
								<p><b>属性委托要求</b></p>
								<ul>
									<li><p>对于一个只读属性（即 val 声明的），委托必须提供一个名为 getValue 的函数，该函数接受以下参数：</p>
										<pre class="brush: kotlin;">
/**
 * thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型
 * property —— 必须是类型 KProperty<*> 或其超类型
 */
operator fun getValue(thisRef: Any?, property: KProperty<*>): String { ... }
</pre>
									</li>
									<li><p>对于一个可变属性（即 var 声明的），委托必须额外提供一个名为 setValue 的函数，该函数接受以下参数：</p>
										<pre class="brush: kotlin;">
/**
 * thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型
 * property —— 必须是类型 KProperty<*> 或其超类型
 * value —— 必须与属性同类型或者是它的子类型
 */
operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) { ... }
</pre>
									</li>
								</ul>
							</div>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="kotlin-base-fun"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">函数和 Lambda 表达式</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p><b>函数</b></p>
							<p>Kotlin 中的函数使用 fun 关键字声明：</p>
							<pre class="brush: kotlin;">
fun double(x: Int): Int {
    return 2 * x
}

fun max(x: Int, y: Int): Int {
    return if (x > y) x else y
}
</pre>
							<p>函数参数使用 Pascal 表示法定义，即 name: type。参数用逗号隔开。每个参数必须有显式类型：</p>
							<pre class="brush: kotlin;">fun powerOf(number: Int, exponent: Int) { /*……*/ }</pre>
							<p><b>默认值</b> -- 函数参数可以有默认值，当省略相应的参数时使用默认值。与其他语言相比，这可以减少重载数量：</p>
							<pre class="brush: kotlin;">
fun show(name: String, age: Int, sex: Char = '男') {
    print("Name is $name, age is $age, sex is $sex")
}

show("jiwanger", 30)
show("Jane", 30, '女')
</pre>
							<p><b>覆盖方法</b> -- 覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值：</p>
							<pre class="brush: kotlin;">
open class A {
    open fun foo(i: Int = 10) { ... }
}

class B : A() {
    override fun foo(i: Int) { ... }  // 不能有默认值
}
</pre>
							<p>如果一个默认参数在一个无默认值的参数之前，那么该默认值只能通过使用命名参数调用该函数来使用：</p>
							<pre class="brush: kotlin;">
fun foo(bar: Int = 0, baz: Int) { ... }
foo(baz = 1) // 使用默认值 bar = 0
</pre>
							<p>如果在默认参数之后的最后一个参数是 lambda 表达式，那么它既可以作为命名参数在括号内传入，也可以在括号外传入：</p>
							<pre class="brush: kotlin;">
fun foo(bar: Int = 0, baz: Int = 1, qux: () -> Unit) { /*……*/ }

foo(1) { println("hello") }     // 使用默认值 baz = 1
foo(qux = { println("hello") }) // 使用两个默认值 bar = 0 与 baz = 1
foo { println("hello") }        // 使用两个默认值 bar = 0 与 baz = 1
</pre>
							<p><b>命名参数</b> -- 当一个函数有大量的参数或默认参数时这会非常方便</p>
							<pre class="brush: kotlin;">
fun show(name: String, age: Int = 0, score: Int = 0) {

show("jiwanger", 30)      // age = 0, score = 0
show("Jane", 30)          // age = 30, score = 0
show("Jane", score = 30)  // age = 0, score = 30
</pre>
							<p><b>当一个函数调用混用位置参数与命名参数时，所有位置参数都要放在第一个命名参数之前。</b></p>
							<p><b>对于 JVM 平台：在调用 Java 函数时不能使用命名参数语法，因为 Java 字节码并不总是保留函数参数的名称。</b></p>
							<p>如果一个函数不返回任何有用的值，它的返回类型是 Unit。Unit 是一种只有一个值——Unit 的类型。这个值不需要显式返回。</p>
							<p><b>单表达式函数</b> -- 当函数返回单个表达式时，可以省略花括号并且在 = 符号之后指定代码体即可：</p>
							<pre class="brush: kotlin;">
fun double(x: Int): Int = x * 2
// 当返回值类型可由编译器推断时，显式声明返回类型是可选的：
fun double(x: Int) = x * 2
</pre>
							<p><b>可变参数</b> -- 函数的参数（通常是最后一个）可以用 vararg 修饰符标记，允许将可变数量的参数传递给函数：：</p>
							<pre class="brush: kotlin;">
fun &lt;T> asList(vararg ts: T): List&lt;T> {
    val result = ArrayList&lt;T>()
    for (t in ts)
        result.add(t)
    return result
}

val list = asList(1, 2, 3)
</pre>
							<p>只有一个参数可以标注为 vararg。如果 vararg 参数不是列表中的最后一个参数， 可以使用命名参数语法传递其后的参数的值</p>
							<p>当我们调用 vararg-函数时，我们可以一个接一个地传参，例如 asList(1, 2, 3)，或者，如果我们已经有一个数组并希望将其内容传给该函数，我们使用伸展（spread）操作符（在数组前面加 *）：</p>
							<pre class="brush: kotlin;">
val a = arrayOf(1, 2, 3)         // 1, 2, 3
val list = asList(-1, 0, *a, 4)  // [-1, 0, 1, 2, 3, 4]
</pre>
							<p><b>中缀表示法</b> -- 标有 <code>infix</code> 关键字的函数也可以使用中缀表示法（忽略该调用的点与圆括号）调用。中缀函数必须满足以下要求：</p>
							<ul>
								<li><p>它们必须是成员函数或扩展函数；</p></li>
								<li><p>它们必须只有一个参数；</p></li>
								<li><p>其参数不得接受可变数量的参数且不能有默认值。</p></li>
							</ul>
							<pre class="brush: kotlin;">
fun main() {
    val u1 = User("jiwanger", 80)
    val u2 = User("nate", 90)

    println(u1.add(u2)) // 170
}

class User(var id: String, var score: Int = 0) {
    infix fun add(u: User): Int {
        return score + u.score
    }
}
</pre>
							<p>中缀函数调用的优先级低于算术操作符、类型转换以及 rangeTo 操作符。</p>
							<p><b>尾递归函数</b> -- Kotlin 支持一种称为尾递归的函数式编程风格。 这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。</p>
							<p>当一个函数用 tailrec 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本。</p>
							<pre class="brush: kotlin;">
// 用 tailrec 修饰符后编译器会优化该递归，留下一个快速而高效的基于循环的版本（如果没有此修饰符则不优化）
tailrec fun sum(count: Int, result: Int = 0): Int { // 求 n 个正整数的和
    return if(count == 1) result + 1
    else sum(count-1, result + count)
}

println(sum(100)) // 5050
</pre>
								<p>要符合 tailrec 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，并且不能用在 try/catch/finally 块中。目前在 Kotlin for JVM 与 Kotlin/Native 中支持尾递归。</p>
						</div>

						<div class="sub-item">
							<p><b>高阶函数与 Lambda 表达式</b></p>
							<p>Kotlin 函数都是<b>头等的</b>，这意味着它们可以存储在变量与数据结构中、作为参数传递给其他高阶函数以及从其他高阶函数返回。可以像操作任何其他非函数值一样操作函数。</p>
							<p><b>高阶函数</b>是将函数用作参数或返回值的函数。</p>
							<p><b>函数类型</b> -- Kotlin 使用类似 <code>(Int) -> String</code> 的一系列函数类型来处理函数的声明：</p>
							<pre class="brush: kotlin;">
fun exe(lam: () -> Unit) { ... }              // exe { ... } 无参数，无返回，Unit 返回类型不可省略
fun exe(lam: (String) -> Int) { ... }         // exe { s -> ... }
fun exe(lam: (Int, Int) -> Int) { ... }       // exe { x, y -> ... }

fun exe(lam: (() -> Unit)?) { ... }           // exe(null) 函数类型也可以指定为可空

// 返回函数类型，右结合，等价于: (Int) -> ((Int) -> Unit)
fun exe(lam: (Int) -> (Int) -> Unit) { ... }  // exe { i -> ... }
</pre>
							<p>函数类型声明规则</p>
							<ul>
								<li><p>所有函数类型都有一个圆括号括起来的参数类型列表以及一个返回类型：(A, B) -> C 表示接受类型分别为 A 与 B 两个参数并返回一个 C 类型值的函数类型。 参数类型列表可以为空，如 () -> A。Unit 返回类型不可省略。</p></li>
								<li><p>函数类型可以有一个额外的接收者类型，它在表示法中的点之前指定： 类型 A.(B) -> C 表示可以在 A 的接收者对象上以一个 B 类型参数来调用并返回一个 C 类型值的函数。</p>
									<pre class="brush: kotlin;">
fun show(user: User, pux: User.(String) -> Int) { // 指定接受者类型
    println(user.pux(user.name))
}

class User(var name: String, var age: Int)

fun main() {
    val u = User("jiwanger", 30)
    show(u) { this.name.length }
    show(u) { this.age }
}
</pre>
								</li>
								<li><p>挂起函数属于特殊种类的函数类型，它的表示法中有一个 suspend 修饰符 ，例如 suspend () -> Unit。</p></li>
							</ul>
							<p><b>函数类型实例化和调用</b></p>
							<pre class="brush: kotlin;">
fun main() {
    val max: (Int, Int) -> Int = { x, y -> if (x > y) x else y } // lambda
    println(max(3, 4))

    val result = compute(20, 10) { x, y -> x + y } // lambda
    println(result)

    val sum = fun(x: Int, y: Int): Int = x + y // 匿名函数，等价： fun(x: Int, y: Int): Int { return x + y }
    println(sum(20, 10))

    val intFunction: (Int) -> Int = IntTransformer() // 使用实现函数类型接口的自定义类的实例
    println("${intFunction.invoke(30)}, ${intFunction.invoke(-30)}")

    val s: (String) -> Int = String::toInt // 使用已有声明的可调用引用
    println(s("30"))
}

fun compute(x: Int, y: Int, lam: (Int, Int) -> Int): Int { return lam(x, y) }

class IntTransformer: (Int) -> Int {
    override operator fun invoke(x: Int): Int {
        return if (x > 0) x else -x
    }
}
</pre>
							<p>如果有足够信息，编译器可以推断变量的函数类型：</p>
							<pre class="brush: kotlin;">val a = { i: Int -> i + 1 } // 推断出的类型是 (Int) -> Int</pre>
							<p>带与不带接收者的函数类型非字面值可以互换，其中接收者可以替代第一个参数，反之亦然。例如，(A, B) -> C 类型的值可以传给或赋值给期待 A.(B) -> C 的地方，反之亦然：</p>
							<pre class="brush: kotlin;">
val repeatFun: String.(Int) -> String = { times -> this.repeat(times) }
val twoParameters: (String, Int) -> String = repeatFun // OK

fun runTransformation(f: (String, Int) -> String): String {
    return f("hello", 3)
}
val result = runTransformation(repeatFun) // OK
</pre>
							<p><b>Lambda 表达式</b></p>
							<p>Lambda 表达式的完整语法形式如下：</p>
							<pre class="brush: kotlin;">
val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y }
// 可以省略 Lambda 中的参数类型
val sum: (Int, Int) -> Int = { x, y -> x + y }
// 如果有足够的信息，编译器可以推断变量的函数类型：
val sum = { x: Int, y: Int -> x + y }
</pre>
							<p><b>拖尾 lambda 表达式</b></p>
							<p>在 Kotlin 中有一个约定：如果函数的最后一个参数是函数，那么作为相应参数传入的 lambda 表达式可以放在圆括号之外；如果该 lambda 表达式是调用时唯一的参数，那么圆括号可以完全省略：</p>
							<pre class="brush: kotlin;">
fun compute(x: Int, y: Int, op: (Int, Int) -> Int): Int { // 此函数的最后一个参数是函数
    return op(x, y)
}

fun compute(op: () -> Int): Int { // 此函数只有一个函数参数
    return -op()
}

fun compute(value: Int, op: (Int) -> Int): Int {
    return op(value)
}

fun main() {
    compute(30, 40) { x, y -> x + y }           // 最后一个参数可以放在圆括号之外
	compute { 30 }                              // 只有一个函数参数那么可以省略圆括号
	compute(-30) { if (it > 0) it else -it }    // 单个参数的隐式名称可以省略，隐式声明为 it
}
</pre>
						</div>

						<div class="sub-item">
							<p><b>内联函数</b></p>
							<p>内联函数和普通函数最大的区别在于内部的实现方面，当普通函数在被调用时，系统首先跳跃到该函数的入口地址，执行函数体，执行完成后，再返回到函数调用的地方，函数始终只有一个拷贝； 而内联函数则不需要进行一个寻址的过程，当执行到内联函数时，此函数展开（很类似宏的使用），如果在 N 处调用了此内联函数，则此函数就会有 N 个代码段的拷贝。</p>
							<p>使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。 即那些在函数体内会访问到的变量。 内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。</p>
							<pre class="brush: kotlin;">
// 用 inline 标识的高阶函数会在调用处展开，可能导致生成的代码增加
inline fun op(x: Int, y: Int, lam: (Int, Int) -> Int): Int {
    return lam(x, y)
}

fun main() {
    op(2, 3) { x, y -> x + y } // 此处会有函数展开
}
</pre>
							<p>如果希望只内联一部分传给内联函数的 lambda 表达式参数，那么可以用 <code>noinline</code> 修饰符标记不希望内联的函数参数：</p>
							<pre class="brush: kotlin;">inline fun op(inlined: () -> Unit, noinline noInlined: (Int, Int) -> Int): Int { ... }</pre>
							<p>如果一个内联函数没有可内联的函数参数并且没有具体化的类型参数(没有函数类型的参数)，编译器会产生一个警告，因为内联这样的函数很可能并无益处。</p>
							<p><b>内联属性</b></p>
							<p>inline 修饰符可用于<b>没有幕后字段的属性</b>的访问器。 你可以标注独立的属性访问器：</p>
							<pre class="brush: kotlin;">
val foo: Foo
    inline get() = Foo()

var bar: Bar
    get() = ……
    inline set(v) { …… }
</pre>
							<p>也可以标注整个属性，将它的两个访问器都标记为内联：</p>
							<pre class="brush: kotlin;">
inline var bar: Bar
    get() = ……
    set(v) { …… }
</pre>
							<p><b>公有 API 内联函数的限制</b></p>
							<p>当一个内联函数是 public 或 protected 而不是 private 或 internal 声明的一部分时，就会认为它是一个模块级的公有 API。可以在其他模块中调用它，并且也可以在调用处内联这样的调用。</p>
							<p>这带来了一些由模块做这样变更时导致的二进制兼容的风险——声明一个内联函数但调用它的模块在它修改后并没有重新编译。</p>
							<p>为了消除这种由非公有 API 变更引入的不兼容的风险，公有 API 内联函数体内不允许使用非公有声明，即，不允许使用 private 与 internal 声明以及其部件。</p>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="kotlin-base-collection"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">集合</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
                            <p><b>集合</b></p>
                            <p>Kotlin 没有自己的集合库，完全依赖 Java 标准库中的集合类，并通过扩展函数增加特性来增强集合。意味着 Kotlin 与 Java 交互时，永远不需要包装或者转换这些集合对象，大大增强与 Java 的互操作性。</p>
                            <p>Kotlin 与 Java 最大的不同之一就是：Kotlin 将集合分为只读集合和可变集合。这种区别源自最基础的集合接口：<code>Collection</code>。该接口可以对集合进行一些基本操作，但无任何添加和移除元素的方法。</p>
                            <p>只有实现 <code>MutableCollection</code> 接口才可以修改集合的数据。<code>MutableCollection</code> 接口继承自 <code>Collection</code>，并提供添加、移除和清空集合元素的方法。当一个函数接收 <code>Collection</code>，而不是 <code>MutableCollection</code>，即意味着函数不对集合做修改操作。</p>
                        </div>
                        <div class="sub-item">

                        </div>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="kotlin-base-"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">...</h3>
                    </div>
                    <div class="panel-body">

                    </div>
                </div>
                <!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
		<a href="https://kotlinlang.org/api/latest/jvm/stdlib/index.html" target="_blank" type="button"
		   class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> CORE </a>
		<a href="https://www.kotlincn.net/docs/reference/" target="_blank" type="button"
		   class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> REF </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushBash.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushKotlin.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
