<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--ANIMATION</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle"
					data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
                     id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">ANIMATION</h3>
					</div>
					<div class="list-group">
						<a href="#" class="list-group-item">简介</a>
						<a href="#animation-Activity" class="list-group-item">Activity 跳转动画</a>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#animation-tools" aria-expanded="true">
							补间动画<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="animation-tools" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#android-view-animation-Animation" class="list-group-item">Animation 及子类</a>
                            <a href="#android-view-animation-AnimationUtils" class="list-group-item">AnimationUtils</a>
                            <a href="#android-view-animation-Interpolator" class="list-group-item">Interpolator 及子类</a>
                            <a href="#android-view-animation-Transformation" class="list-group-item">Transformation</a>
                            <a href="#android-view-animation-LayoutAnimationController" class="list-group-item">LayoutAnimationController 及子类</a>
						</div>
						<a class="list-group-item active dropdown" data-toggle="collapse"
						   data-parent="#accordion" href="#animation-frame" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							逐帧动画<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="animation-frame" class="panel-collapse collapse"
							 role="tabpanel">
							<a href="#anim-AnimationDrawable" class="list-group-item">AnimationDrawable</a>
						</div>
						<a class="list-group-item active dropdown" data-toggle="collapse"
						   data-parent="#accordion" href="#animation-attr" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							属性动画<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="animation-attr" class="panel-collapse collapse"
							 role="tabpanel">
							<a href="#android-animation-Animator" class="list-group-item">Animator</a>
                            <a href="#android-animation-AnimatorSet" class="list-group-item">AnimatorSet</a>
                            <a href="#android-animation-ValueAnimator" class="list-group-item">ValueAnimator</a>
                            <a href="#android-animation-PropertyValuesHolder" class="list-group-item">PropertyValuesHolder</a>
                            <a href="#android-animation-ObjectAnimator" class="list-group-item">ObjectAnimator</a>
                            <a href="#android-animation-TimeAnimator" class="list-group-item">TimeAnimator</a>
                            <a href="#android-animation-TypeEvaluator" class="list-group-item">TypeEvaluator 及子类</a>
                            <a href="#android-animation-LayoutTransition" class="list-group-item">LayoutTransition</a>
                            <a href="#android-animation-example" class="list-group-item">属性动画实例</a>
                        </div>
						<a class="list-group-item active dropup" data-toggle="collapse"
						   data-parent="#accordion" href="#android-transition" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							转场动画<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="android-transition" class="panel-collapse collapse in"
							 role="tabpanel">
							<a href="#android-transition-TransitionManager" class="list-group-item">TransitionManager</a>
							<a href="#android-transition-Transition" class="list-group-item">Transition 及子类</a>
                            <a href="#android-transition-Scene" class="list-group-item">Scene</a>
							<a href="#android-transition-PathMotion" class="list-group-item">PathMotion 及子类</a>
                            <a href="#android-transition-TransitionPropagation" class="list-group-item">TransitionPropagation 及子类</a>
                            <a href="#android-transition-example" class="list-group-item">转场动画实例</a>
						</div>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<p>Android 动画体系可分如下三种：</p>
						<ul>
							<li><p><b>补间动画</b> -- 对 View 进行一系列的动画操作，包括淡入淡出、缩放、平移、旋转四种。</p></li>
							<li><p><b>逐帧动画</b> -- 将一个完整的动画拆分成多张单独的图片，然后再将它们连贯起来进行播放，类似于动画片的工作原理。</p></li>
							<li><p><b>属性动画</b> -- 通过改变任何一个对象的属性实现动画效果，API 11 添加。</p></li>
						</ul>
						<p>另外，还有一种 <b>转场动画</b>，在 Android 4.4 就已经引入，但在 5.0 才得以真正的实现。</p>
                        <p>补间动画有两个缺陷：</p>

                        <ul>
                            <li><p>补间动画只能对 View 设置动画，对非 View 的对象不能设置动画；</p></li>
                            <li><p>补间动画只是改变了 View 的显示效果而没有真正的改变 View 的属性。例如，我们想使用补间动画将一个按钮从一个位置移动到一个新的位置，那么当移动完成之后我们点击这个按钮，是不会触发其点击事件的，而当我们点击移动前的位置时，会触发其点击事件，即补间动画只是在另一个地方重新绘制了这个 View，其他的东西都没有改变。
                            </p></li>
                        </ul>

                    </div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="animation-Activity"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Activity 跳转动画</h3>
					</div>
					<div class="panel-body">
                        <p><b>Activity 的切换动画的两种场景：</b></p>
                        <ul>
                            <li><p>当调用 startActivity 方法的时候启动一个新的 Activity，这时候就涉及到了旧的 Activity 的退出动画和新的 Activity 的显示动画；</p></li>
                            <li><p>当调用 finish 方法的时候，销毁当前 Acitivity，就涉及到了当前 Activity 的退出动画和前一个 Activity 的显示动画。</p></li>
                        </ul>
                        <p><b>实现 Activity 跳转动画的五种方式:</b> <a href="http://blog.csdn.net/qq_23547831/article/details/51821159">参照此文</a></p>
                        <ol type="I">
                            <li><p>使用 overridePendingTransition 方法实现 Activity 跳转动画;</p></li>
                            <li><p>使用 style 的方式定义 Activity 的切换动画;</p></li>
                            <li><p>使用 ActivityOptions 切换动画实现 Activity 跳转动画;</p></li>
                            <li><p>使用 ActivityOptions 之后内置的动画效果通过 style 的方式;</p></li>
                            <li><p>使用 ActivityOptions 动画共享组件的方式实现跳转 Activity 动画.</p></li>
                        </ol>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="android-view-animation-Animation"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Animation</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
						<pre class="brush: java;">
java.lang.Object
	android.view.animation.Animation

public abstract class Animation implements Cloneable {
	// 动画监听器
	public static interface AnimationListener {
		void onAnimationStart(Animation animation);
		void onAnimationEnd(Animation animation);
        void onAnimationRepeat(Animation animation);
	}
}

/** XML 属性 */
android:duration -- 动画时长
android:fillAfter -- 应用于 AnimationSet，动画完成后停留在最后一帧
android:fillBefore -- 应用于 AnimationSet，动画完成后停留在第一帧
android:fillEnabled -- 是否开启
android:interpolator -- 插值器
android:repeatCount -- 重复次数
android:repeatMode -- 重复模式，RESTART | REVERSE
android:startOffset -- 动画开始前延迟时长
android:zAdjustment -- 设置动画的内容运行时在 Z 轴上的位置(层):ZORDER_NORMAL:-0, ZORDER_TOP:1, ZORDER_BOTTOM: -1
android:detachWallpaper -- 窗口动画的特殊选项：如果这个窗口在墙纸的顶部，是否用它来装饰墙纸。
</pre>
						</div>

						<div class="sub-item">
							<p><a href="" target="_blank">Animation</a> API</p>
							<ol>
                                <li><p><code>Interpolator getInterpolator()</code> -- 获取插入器</p></li>
								<li><p><code>void setInterpolator(Context context, int resID)</code> -- 设置插入器</p></li>
								<li><p><code>void setInterpolator(Interpolator i)</code> -- 设置插入器</p></li>

                                <li class="group"><p><code>int getRepeatCount()</code> -- 重复次数</p></li>
								<li><p><code>void setRepeatCount(int repeatCount)</code> -- 设置重复次数</p></li>
                                <li><p><code>void reset()</code> -- 重置动画</p></li>

                                <li class="group"><p><code>int getRepeatMode()</code> -- 重复模式</p></li>
								<li><p><code>void setRepeatMode(int repeatMode)</code> -- 设置重复模式</p></li>
								<li class="group"><p><code>void start()</code> -- 启动动画</p></li>
								<li><p><code>void startNow()</code> -- 立即启动动画</p></li>
								<li><p><code>void cancel()</code> -- 取消动画</p></li>
                                <li class="group"><p><code>boolean getFillAfter()</code> -- 是否 fillAfter</p></li>
                                <li><p><code>boolean getFillBefore()</code> -- 是否 fillBefore</p></li>
                                <li><p><code>boolean isFillEnabled()</code> -- 是否开启 Fill</p></li>
                                <li><p><code>void setFillAfter(boolean fillAfter)</code> -- 应用于 AnimationSet, 若为 true, 结束后停留最后一帧</p></li>
                                <li><p><code>void setFillBefore(boolean fillBefore)</code> -- 应用于 AnimationSet, 若为 true, 结束后停留第一帧</p></li>
                                <li><p><code>void setFillEnabled(boolean fillEnabled)</code> -- 开启 / 关闭 Fill</p></li>
                                <li class="group"><p><code>boolean hasEnded()</code> -- 是否已结束</p></li>
                                <li><p><code>boolean hasStarted()</code> -- 是否已开始</p></li>
                                <li><p><code>void setAnimationListener(Animation.AnimationListener listener)</code> -- 设置动画监听器</p></li>

                                <li class="group"><p><code>void setDuration(long durationMillis)</code> -- 设置时长</p></li>
                                <li><p><code>long getDuration()</code> -- 获取动画时长</p></li>
                                <li><p><code>void scaleCurrentDuration(float scale)</code> -- 比列更改动画时长(duration * scale)</p></li>
                                <li><p><code>void restrictDuration(long durationMillis)</code> -- 确保该动画将运行时间不超过指定的时间</p></li>
								<li><p><code>long computeDurationHint()</code> -- 计算动画总时长，可能由多个动画同时执行，或者执行次数为多次</p></li>

                                <li class="group"><p><code>long getStartOffset()</code> -- 获取延迟时间</p></li>
                                <li><p><code>void setStartOffset(long startOffset)</code> -- 设置延迟时间</p></li>

                                <li class="group"><p><code>long getStartTime()</code> -- 获取开始时间，View 的 <code>setAnimation()</code> 方法</p></li>
                                <li><p><code>void setStartTime(long startTimeMillis)</code> -- 设置开始时间，View 的 <code>setAnimation()</code> 方法</p></li>

                                <li><p><code>int getZAdjustment()</code> -- 获取动画层次</p></li>
                                <li><p><code>void setZAdjustment(int zAdjustment)</code> -- 设置层次(ZORDER_TOP:0, ZORDER_NORMAL:1, ZORDER_BOTTOM:-1)</p></li>

								<li class="group"><p><code>int getBackgroundColor()</code> -- 无效，获取背景</p></li>
                                <li><p><code>void setBackgroundColor(int bg)</code> -- 无效，设置背景</p></li>

								<li class="group"><p><code>boolean getDetachWallpaper()</code> -- 获取选项</p></li>
                                <li><p><code>void setDetachWallpaper(boolean detachWallpaper)</code> -- 窗口动画的特殊选项：如果这个窗口在墙纸的顶部，是否用它来装饰墙纸。</p></li>

								<li class="group"><p><code>void initialize(int width, int height, int parentWidth, int parentHeight)</code> -- 本身只调用 reset(), 将 initialized 设置为 true，看子类的实现</p></li>
								<li><p><code>boolean isInitialized()</code> -- 是否已经初始化</p></li>

                                <li class="group"><p><code>boolean getTransformation(long currentTime, Transformation outTransformation, float scale)</code> -- 获取在指定时间点应用的转换</p></li>
                                <li><p><code>boolean getTransformation(long currentTime, Transformation outTransformation)</code> -- 获取在指定时间点应用的转换</p></li>

								<li class="group"><p><code>boolean willChangeBounds()</code> -- 指示此动画是否会影响动画视图的边界</p></li>
								<li><p><code>boolean willChangeTransformationMatrix()</code> -- 指示此动画是否会影响转换矩阵</p></li>
							</ol>
						</div>

                        <div class="sub-item">
                            <p>Animation 子类</p>
                            <ul>
                                <li><p><a href="docs/reference/android/view/animation/AlphaAnimation.html" target="_blank">AlphaAnimation</a> -- 透明动画，不会影响动画视图的边界和改变转换矩阵</p>
                                <pre class="brush: java;">
/** AlphaAnimation 值得关注的只有两个属性：
 * fromAlpha -- 开始透明度
 * toAlpha; -- 结束透明度
 */
AlphaAnimation(float fromAlpha, float toAlpha)
AlphaAnimation(Context context, AttributeSet attrs)
</pre>
                                </li>
                                <li><p><a href="docs/reference/android/view/animation/TranslateAnimation.html" target="_blank">TranslateAnimation</a> -- 移动动画</p>
                                    <pre class="brush: java;">
TranslateAnimation(Context context, AttributeSet attrs)
/** 使用绝对位置指定动画开始和结束的位置 */
TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)

/** 提供了参考点， Type 的类型有三种：
 * Animation.ABSOLUTE -- 默认，绝对位置，直接使用像素为单位
 * Animation.RELATIVE_TO_SELF -- 相对自身, value 为一个比列值，如： fromX = width * fromXValue ...
 * Animation.RELATIVE_TO_PARENT -- 相对父布局, value 为一个比列值，如： fromX = parentWidth * xValue ...
 */
TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue,
                   int fromYType, float fromYValue, int toYType, float toYValue)
</pre>
                                </li>
                                <li><p><a href="docs/reference/android/view/animation/RotateAnimation.html" target="_blank">RotateAnimation</a> -- 旋转动画</p>
                                    <pre class="brush: java;">
/** Type 同 TranslateAnimation，指定角度和旋转中心点 */
RotateAnimation(float fromDegrees, float toDegrees)
RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)
RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue,
                                        int pivotYType, float pivotYValue)
</pre>
                                </li>
                                <li><p><a href="docs/reference/android/view/animation/ScaleAnimation.html" target="_blank">ScaleAnimation</a> -- 缩放动画</p>
                                    <pre class="brush: java;">
/** Type 同 TranslateAnimation，指定缩放中心点和缩放因子 */
ScaleAnimation(Context context, AttributeSet attrs)
ScaleAnimation(float fromX, float toX, float fromY, float toY)
ScaleAnimation(float fromX, float toX, float fromY, float toY, float pivotX, float pivotY)
ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType,
                                        float pivotXValue, int pivotYType, float pivotYValue)
</pre>
                                </li>
                                <li><p><a href="docs/reference/android/view/animation/AnimationSet.html" target="_blank">AnimationSet</a> -- 组合动画，每个动画的变换被组合成一个单一的变换。</p>
                                    <pre class="brush: java;">
AnimationSet(Context context, AttributeSet attrs)
/** 参数为是否所有动画共享一个插值器 */
AnimationSet(boolean shareInterpolator)
</pre>
                                </li>
                            </ul>
                        </div>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="android-view-animation-AnimationUtils"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">AnimationUtils</h3>
                    </div>
                    <div class="panel-body">
                        <p><a href="docs/reference/android/view/animation/AnimationUtils.html">AnimationUtils</a> 有一些静态方法，用来生成动画。</p>
                        <ul>
                            <li><p><code>static Animation loadAnimation(Context context, int id)</code> -- 从 <code>res/anim</code> 加载动画</p></li>
                            <li><p><code>static Interpolator loadInterpolator(Context context, int id) </code> -- 从 <code>res/interpolator</code> 加载插值器</p></li>
                            <li><p><code>static LayoutAnimationController loadLayoutAnimation(Context context, int id)</code> -- 从 <code>res/anim</code> 加载布局动画</p></li>
                            <li><p><code>static Animation makeInAnimation(Context c, boolean fromLeft)</code> -- 从 <code>com.android.internal.R.anim</code> 加载动画</p></li>
                            <li><p><code>static Animation makeInChildBottomAnimation(Context c)</code> -- 同上</p></li>
                            <li><p><code>static Animation makeOutAnimation(Context c, boolean toRight)</code> -- 同上</p></li>
                            <li><p><code>static long currentAnimationTimeMillis()</code> -- 这个时间应用于 <code>Animation.setStartTime(millis)</code></p></li>
                        </ul>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="android-view-animation-Interpolator"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Interpolator 及子类</h3>
                    </div>
                    <div class="panel-body">
                        <pre class="brush: java;">
android.animation.TimeInterpolator
    android.view.animation.Interpolator
        android.view.animation.BaseInterpolator
            AccelerateInterpolator  PathInterpolator .....

public interface TimeInterpolator {
    // 不断调用这个方法，来实现速度变化
    float getInterpolation(float input);
}
                        </pre>

                        <p><a href="ocs/reference/android/view/animation/Interpolator.html" target="_blank">Interpolator</a> 用于控制动画的速度变化。只有一个方法，来自于: <a href="docs/reference/android/animation/TimeInterpolator.html" target="_blank">TimeInterpolator</a>。直接来看其子类：</p>
                        <ul>
                            <li><p><a href="docs/reference/android/view/animation/AccelerateInterpolator.html" target="_blank">AccelerateInterpolator</a> -- 加速</p>
                            <pre class="brush: java;">
/** 加速速度和 factor 相关：
 * factor >= 1 时，值越大，加速越快；
 * 0 < factor < 1 时，实际为减速，值越小，减速越快。
 */
AccelerateInterpolator()    //  factor = 1.0f
AccelerateInterpolator(float factor)
AccelerateInterpolator(Context context, AttributeSet attrs)

public float getInterpolation(float input) {
    if (mFactor == 1.0f) {
        return input * input;
    } else {
        return (float)Math.pow(input, mDoubleFactor);   // mDoubleFactor = 2 * mFactor;
    }
}
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/view/animation/DecelerateInterpolator.html" target="_blank">DecelerateInterpolator</a> -- 减速</p>
                                <pre class="brush: java;">
/** 减速速度和 factor 相关：
 * factor >= 1 时，值越大，减速越快；
 * 0 < factor < 1 时，实际为加速，值越小，加速越快。
 */
DecelerateInterpolator()    //  factor = 1.0f
DecelerateInterpolator(float factor)
DecelerateInterpolator(Context context, AttributeSet attrs)

public float getInterpolation(float input) {
    float result;
    if (mFactor == 1.0f) {
        result = (float)(1.0f - (1.0f - input) * (1.0f - input));
    } else {
        result = (float)(1.0f - Math.pow((1.0f - input), 2 * mFactor));
    }
    return result;
}
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/view/animation/AccelerateDecelerateInterpolator.html" target="_blank">AccelerateDecelerateInterpolator</a> -- 先加速，后加速</p>
                                <pre class="brush: java;">
AccelerateDecelerateInterpolator()
AccelerateDecelerateInterpolator(Context context, AttributeSet attrs)

public float getInterpolation(float input) {
    return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;
}
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/view/animation/AnticipateInterpolator.html" target="_blank">AnticipateInterpolator</a> -- 开始的时候向后，然后向前甩</p>
                                <pre class="brush: java;">
AnticipateInterpolator()    //  tension = 2.0f
AnticipateInterpolator(float tension)
AnticipateInterpolator(Context context, AttributeSet attrs)

public float getInterpolation(float t) {
    return t * t * ((mTension + 1) * t - mTension);
}
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/view/animation/AnticipateOvershootInterpolator.html" target="_blank">AnticipateOvershootInterpolator</a> -- 开始的时候向后，然后向前甩一定值，再返回最后的值</p>
                                <pre class="brush: java;">
AnticipateOvershootInterpolator() { mTension = 2.0f * 1.5f; }
AnticipateOvershootInterpolator(float tension) { mTension = tension * 1.5f; }
AnticipateOvershootInterpolator(float tension, float extraTension) {
    mTension = tension * extraTension;
}
AnticipateOvershootInterpolator(Context context, AttributeSet attrs)

private static float a(float t, float s) {
    return t * t * ((s + 1) * t - s);
}

private static float o(float t, float s) {
    return t * t * ((s + 1) * t + s);
}

public float getInterpolation(float t) {
    if (t < 0.5f) return 0.5f * a(t * 2.0f, mTension);
    else return 0.5f * (o(t * 2.0f - 2.0f, mTension) + 2.0f);
}
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/view/animation/BounceInterpolator.html" target="_blank">BounceInterpolator</a> -- 动画结束的时候弹起</p>
                                <pre class="brush: java;">
BounceInterpolator()
BounceInterpolator(Context context, AttributeSet attrs)

private static float bounce(float t) {
    return t * t * 8.0f;
}

public float getInterpolation(float t) {
    t *= 1.1226f;
    if (t < 0.3535f) return bounce(t);
    else if (t < 0.7408f) return bounce(t - 0.54719f) + 0.7f;
    else if (t < 0.9644f) return bounce(t - 0.8526f) + 0.9f;
    else return bounce(t - 1.0435f) + 0.95f;
}
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/view/animation/CycleInterpolator.html" target="_blank">CycleInterpolator</a> -- 动画循环播放特定的次数，速率改变沿着正弦曲线</p>
                                <pre class="brush: java;">
CycleInterpolator(float cycles)
CycleInterpolator(Context context, AttributeSet attrs)

public float getInterpolation(float input) {
    return (float)(Math.sin(2 * mCycles * Math.PI * input));
}
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/view/animation/LinearInterpolator.html" target="_blank">LinearInterpolator</a> -- 以常量速率改变</p>
                                <pre class="brush: java;">
LinearInterpolator()
LinearInterpolator(Context context, AttributeSet attrs)

public float getInterpolation(float input) {
    return input;
}
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/view/animation/OvershootInterpolator.html" target="_blank">OvershootInterpolator</a> -- 向前甩一定值后再回到原来位置</p>
                                <pre class="brush: java;">
OvershootInterpolator()     // tension = 2.0f
OvershootInterpolator(float tension)
OvershootInterpolator(Context context, AttributeSet attrs)

public float getInterpolation(float t) {
    t -= 1.0f;
    return t * t * ((mTension + 1) * t + mTension) + 1.0f;
}
                            </pre>
                            </li><li><p><a href="docs/reference/android/view/animation/PathInterpolator.html" target="_blank">PathInterpolator</a> -- 贝塞尔曲线控制速度，API 21 添加</p>
                            <pre class="brush: java;">
PathInterpolator(Path path)
PathInterpolator(float controlX, float controlY)    // 一个控制点的贝塞尔曲线
// 两个控制点的贝塞尔曲线
PathInterpolator(float controlX1, float controlY1, float controlX2, float controlY2)
PathInterpolator(Context context, AttributeSet attrs)
                            </pre>
                        </li>

                        </ul>

                    </div>
                </div>
                <!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="android-view-animation-Transformation"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Transformation</h3>
					</div>
					<div class="panel-body">
                        <pre class="brush: java;">
java.lang.Object
    android.view.animation.Transformation

public class Transformation {
    protected Matrix mMatrix;
    protected float mAlpha;
    protected int mTransformationType;
}
                        </pre>
                        <p><a href="docs/reference/android/view/animation/Transformation.html" target="_blank">Transformation</a> 定义要在动画的某个时间点应用的转换。每个 Animation 的子类都重载了其 <code>applyTransformation(float interpolatedTime, Transformation t)</code> 方法，接收一个 Transformation 作为参数。</p>
                        <p><a href="docs/reference/android/view/animation/Transformation.html" target="_blank">Transformation</a> 有一个透明度变化的 <code>mAlpha</code> 和应用变化的 <code>mMatrix</code> 矩阵。</p>
                        <p></p>
                        <ol>
                            <li><p><code>Matrix getMatrix()</code> -- 获取变换矩阵</p></li>
                            <li><p><code>float getAlpha()</code> -- 获取透明度值</p></li>
                            <li><p><code>void setAlpha(float alpha)</code> -- 设置透明度值</p></li>
                            <li><p><code>void set(Transformation t)</code> -- 重置为 t 变换</p></li>
                            <li><p><code>void setTransformationType(int type)</code> -- 变换类型: <code>TYPE_ALPHA</code>, <code>TYPE_IDENTITY</code>, <code>TYPE_MATRIX</code>, <code>TYPE_BOTH</code></p></li>
                            <li><p><code>int getTransformationType()</code> -- 获取变换类型</p></li>
                            <li><p><code>void compose(Transformation t)</code> -- 将此转换应用于现有的转换，例如将缩放效果应用于已经旋转的内容。 </p></li>
                            <li><p><code>void clear()</code> -- 重置变换</p></li>
                        </ol>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="android-view-animation-LayoutAnimationController"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">LayoutAnimationController 及子类</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
						<pre class="brush: java;">
java.lang.Object
    android.view.animation.LayoutAnimationController

public class LayoutAnimationController {
    protected Animation mAnimation;
    protected Interpolator mInterpolator;
    protected Random mRandomizer;

    LayoutAnimationController(Context context, AttributeSet attrs) {}
    LayoutAnimationController(Animation animation) {}
    LayoutAnimationController(Animation animation, float delay) {}

    public static class AnimationParameters {
        public int count;// ViewGroup 中的 View 个数
        public int index;// ViewGroup 中的 View 索引
    }
}

/** XML 属性 */
android:animation // 动画的名称
android:animationOrder // 动画播放顺序
android:delay // 延迟时间
android:interpolator // 动画的插值，有加速，减速等
</pre>
                            <p><a href="docs/reference/android/view/animation/LayoutAnimationController.html" target="_blank">LayoutAnimationController</a> 用于一个 ViewGroup 的动画控制器，它能够让每个子 View 在不同的时间点分别执行相同的动画，ViewGroup 通过 LayoutAnimationController 计算每个子 View 的动画开始的时间间隔，这个时间的间隔是通过某种规律特点进行计算，比如它在 ViewGroup 中的 index 顺序。</p>
                            <p>间隔时间的计算是通过 View 在 Viewgroup 的 index 顺序乘以单位时间间隔计算得出。它的子类应该重写：</p>
                            <ul>
                                <li><p><code>long getDelayForView(View view)</code> -- 实现一种不同的计算 delay 的延迟时间方式。例如子类: GridLayoutAnimationController，它基于 child view 的 column 和 row 值来计算延迟。</p></li>
                            </ul>
                            <p><a href="docs/reference/android/view/animation/LayoutAnimationController.html" target="_blank">LayoutAnimationController</a> 类中对应的播放顺序：</p>
                            <pre class="brush: java;">
                                ORDER_NORMAL: 按照 View 添加到 ViewGroup 中的顺序进行播放动画展示;
                                ORDER_REVERSE: 按照 View 添加到 ViewGroup中倒叙进行播放动画展示;
                                ORDER_RANDOM: 随机顺序播放 View 的动画。
                            </pre>
                            <ol>
                                <li><p><code>void setAnimation(Animation animation)</code> -- 设置动画</p></li>
                                <li><p><code>void setAnimation(Context context, int resourceID)</code> -- 设置动画</p></li>
                                <li><p><code>Animation getAnimation()</code> -- 获取动画</p></li>
                                <li><p><code>void setInterpolator(Context context, int resourceID)</code> -- 设置动画速度控制器</p></li>
                                <li><p><code>void setInterpolator(Interpolator interpolator)</code> -- 设置动画速度控制器</p></li>
                                <li><p><code>Interpolator getInterpolator()</code> -- 获取动画速度控制器</p></li>
                                <li><p><code>void setOrder(int order)</code> -- 顺序：<code>ORDER_NORMAL</code>, <code>ORDER_REVERSE</code>, <code>ORDER_RANDOM</code></p></li>
                                <li><p><code>int getOrder()</code> -- 获取顺序</p></li>
                                <li><p><code>void start()</code> -- 开始，应该使用：<code>layout.startLayoutAnimation()</code></p></li>
                                <li><p><code>boolean isDone()</code> -- 是否完成</p></li>
                                <li><p><code>void setDelay(float delay)</code> -- 设置延时</p></li>
                                <li><p><code>float getDelay()</code> -- 获取延时</p></li>
                                <li><p><code>final Animation getAnimationForView(View view)</code> -- 从 View 中获取动画</p></li>
                                <li><p><code>boolean willOverlap()</code> -- 指示子 View 的动画是否会重叠</p></li>
                            </ol>

                        </div>

                        <div class="sub-item">
                            <p><a href="docs/reference/android/view/animation/LayoutAnimationController.html" target="_blank">LayoutAnimationController</a> 实例：</p>
                            <div class="row">
                                <div class="col-md-9">
                                    <p><b>I. 子 View 顺序飞入效果:</b></p>
<pre class="brush: java;gutter: false;">
/** 实现思路：
 *   1. 先把展开后样式布局好，然后隐藏；
 *   2. 点击按钮时，先设置布局可见，然后开启动画；
 * 注意：退出时，不用设置 layout 为不可见，
 *   因为 Animation.fillBefore 为 true；
 * !!!问题：右下角按钮为 ImageButton 可行，为 ImageView 就是不行，未找到原因!!!
 */

if(visiable) {  // 标识是否可见
    layout.setVisibility(View.VISIBLE)
    Animation animation = AnimationUtils.loadAnimation(getApplication(),
                    R.anim.botton_out); // translate 动画
    LayoutAnimationController c = new LayoutAnimationController(animation);
    layout.setLayoutAnimation(c);
    content.startLayoutAnimation();
    visiable = false;
} else {
    Animation animation = AnimationUtils.loadAnimation(getApplication(),
                    R.anim.botton_out); // translate 动画
    // 创建一个 LayoutAnimationController 对象
    LayoutAnimationController controller = new LayoutAnimationController(animation);
    // 设置 Order 顺序
    controller.setOrder(LayoutAnimationController.ORDER_REVERSE);
    // 将 controller 赋值给 ViewGroup
    content.setLayoutAnimation(controller);
    // 开启动画
    content.startLayoutAnimation();
    visiable = true;
}
</pre>
                                </div>
                                <div class="col-md-3"><img src="images/LayoutAnimationController-1.gif" class="img-responsive"></div>
                            </div>
                            <div class="row">
                                <div class="col-md-9">
                                    <p><b>II. ListView 的 Item 飞入效果:</b></p>
<pre class="brush: java;">
String[] datas = {"item 1", "item 2", "item 3", "item 4", "item 5"};

ListView listView = (ListView) findViewById(R.id.listView);
listView.setAdapter(new ArrayAdapter&lt;String>(this,
    android.R.layout.simple_expandable_list_item_1, datas));

AnimationUtils.loadAnimation(getApplication(), R.anim.right_in)
LayoutAnimationController controller = new LayoutAnimationController();
listView.setLayoutAnimation(controller);
listView.startLayoutAnimation();
</pre>
                                </div>
                                <div class="col-md-3"><img src="images/LayoutAnimationController-2.gif" class="img-responsive"></div>
                            </div>
                            <div class="row">
                                <div class="col-md-9">
                                    <p><b>III. GridView 动画效果:</b></p>
                                    <p>子类 <a href="docs/reference/android/view/animation/GridLayoutAnimationController.html">GridLayoutAnimationController</a> 专门为 GridView 的加载动画。</p>
<pre class="brush: java;">
/** XML 属性 */
android:columnDelay -- 列延迟
android:direction -- 方向
android:directionPriority -- 方向优先级
android:rowDelay -- 行延迟

/** 可以同时设置多个方向进行操作 */
DIRECTION_LEFT_TO_RIGHT -- 从左到右
DIRECTION_RIGHT_TO_LEFT -- 从右到左
DIRECTION_TOP_TO_BOTTOM -- 从上到下
DIRECTION_BOTTOM_TO_TOP -- 从下到上
DIRECTION_HORIZONTAL_MASK -- 水平方向
DIRECTION_VERTICAL_MASK -- 竖直方向

/** 行列优先级, 调用此方法: setDirectionPriority(int directionPriority) */
PRIORITY_NONE -- 行列同级，默认值
PRIORITY_COLUMN  -- 列优先
PRIORITY_ROW -- 行优先

/** 实例: */
String[] datas = {
    "item 1", "item 2", "item 3",
    "item 4", "item 5", "item 6",
    "item 7", "item 8", "item 9",
    "item 10", "item 11", "item 12",
};

GridView gridView = (GridView) findViewById(R.id.gridView);
gridView.setAdapter(new ArrayAdapter&lt;String>(this,
    android.R.layout.simple_expandable_list_item_1, datas));

GridLayoutAnimationController c = new GridLayoutAnimationController(
    AnimationUtils.loadAnimation(getApplication(), R.anim.bottom_in));
// 设置动画播放顺序
c.setOrder(LayoutAnimationController.ORDER_NORMAL);
// 设置动画播放方向
c.setDirection(GridLayoutAnimationController.DIRECTION_LEFT_TO_RIGHT);
// 设置动画播放顺序的优先级
c.setDirectionPriority(GridLayoutAnimationController.PRIORITY_NONE);

gridView.setLayoutAnimation(controller);
gridView.startLayoutAnimation();
</pre>
                                </div>
                                <div class="col-md-3"><img src="images/LayoutAnimationController-3.gif" class="img-responsive" style="margin-top: 20px;"></div>
                            </div>
                            <div class="row">
                                <div class="col-md-7">
                                    <p><b>IV. 自定义 LayoutAnimationController:</b></p>
<pre class="brush: java;gutter: false;">
&lt;scale
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="100"
    android:fromXScale="0"
    android:toXScale="1"
    android:fromYScale="0"
    android:toYScale="1"
    android:fillAfter="true"
    android:pivotX="50%"
    android:pivotY="50%" />
</pre>
                                </div>
                                <div class="col-md-5"><img src="images/LayoutAnimationController-4.gif" class="img-responsive"></div>
<pre class="brush: java;">
public class MyLayoutAnimationController extends LayoutAnimationController {
    public static final int ORDER_CUSTOM  = 6;

    public MyLayoutAnimationController(Animation anim) {
        super(anim);
    }
    public MyLayoutAnimationController(Animation anim, float delay) {
        super(anim, delay);
    }
    public MyLayoutAnimationController(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    protected int getTransformedIndex(AnimationParameters params) {
        if(getOrder() == ORDER_CUSTOM){//view顺序以1开头
            if(params.index == 2) return 4;
            else if(params.index == 3) return 5;
            else if(params.index == 4) return 2;
            else if(params.index == 5) return 6;
            else if(params.index == 6) return 3;
            else return params.index;
        } else {
            return super.getTransformedIndex(params);
        }
    }
}
</pre>

                            </div>
                        </div>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="anim-AnimationDrawable"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">AnimationDrawable</h3>
					</div>
					<div class="panel-body">
						<p><a href="docs/reference/android/graphics/drawable/AnimationDrawable.html" target="_blank">AnimationDrawable</a> 实现了 Android 的逐帧动画，请查看：<a href="drawable.html" target="_blank">DRAWABLE</a></p>
                        <pre class="brush: xml">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;animation-list android:id="@+id/selected" android:oneshot="false">
    &lt;item android:drawable="@drawable/wheel0" android:duration="50" />
    &lt;item android:drawable="@drawable/wheel1" android:duration="50" />
    &lt;item android:drawable="@drawable/wheel2" android:duration="50" />
    &lt;item android:drawable="@drawable/wheel3" android:duration="50" />
    &lt;item android:drawable="@drawable/wheel4" android:duration="50" />
    &lt;item android:drawable="@drawable/wheel5" android:duration="50" />
&lt;/animation-list>
                        </pre>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="android-animation-Animator"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Animator</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
<pre class="brush: java;">
java.lang.Object
    android.animation.Animator
        ├── AnimatorSet
        └── ValueAnimator
            ├── ObjectAnimator
            └──TimeAnimator

public abstract class Animator implements Cloneable {
    /** 动画监听器，AnimatorListenerAdapter 实现了此接口，可以只监听感兴趣的状态 */
    public static interface AnimatorListener {
        void onAnimationCancel(Animator animation);
        void onAnimationEnd(Animator animation);
        void onAnimationRepeat(Animator animation);
        void onAnimationStart(Animator animation);
    }

    /** 暂停/恢复监听器，AnimatorListenerAdapter 实现了此接口，可以只监听感兴趣的状态 */
    public static interface AnimatorPauseListener {
        void onAnimationPause(Animator animation);
        void onAnimationResume(Animator animation);
    }
}
</pre>
                            <p><a href="docs/reference/android/animation/Animator.html" target="_blank">Animator</a> 属性动画，在属性动画中，我们不仅可以像补间动画那样设置控件的透明度、缩放、平移或旋转的动画，还可以做到将这些动画联合起来播放、将一组动画按顺序播放、控制动画的播放速度，甚至可以对非 View 设置动画等等。</p>
                        <p><a href="docs/reference/android/animation/Animator.html" target="_blank">Animator</a> API:</p>
                            <ol>
                                <li><p><code>void addListener(Animator.AnimatorListener listener)</code> -- 添加动画监听器，<code>AnimatorListenerAdapter</code> 实现了此接口，可以只监听感兴趣的状态。</p></li>
                                <li><p><code>void removeListener(Animator.AnimatorListener listener)</code> -- 移除监听器</p></li>
                                <li><p><code>ArrayList&lt;Animator.AnimatorListener> getListeners()</code> -- 获取所有监听器</p></li>
                                <li><p><code>void removeAllListeners()</code> -- 移除所有监听器</p></li>
                                <li><p><code>void addPauseListener(Animator.AnimatorPauseListener listener)</code> -- 添加停/恢复监听器，<code>AnimatorListenerAdapter</code> 实现了此接口，可以只监听感兴趣的状态。</p></li>
                                <li><p><code>void removePauseListener(Animator.AnimatorPauseListener listener)</code> -- 移除停/恢复监听器</p></li>
                                <li class="group"><p><code>abstract Animator setDuration(long duration)</code> -- 设置动画时长</p></li>
                                <li><p><code>abstract long getDuration()</code> -- 获取动画时长</p></li>
                                <li><p><code>long getTotalDuration()</code> -- 动画总时长</p></li>
                                <li><p><code>abstract void setStartDelay(long startDelay)</code> -- 设置延时</p></li>
                                <li><p><code>abstract long getStartDelay()</code> -- 获取延时时间</p></li>
                                <li class="group"><p><code>abstract void setInterpolator(TimeInterpolator value)</code> -- 设置插值器</p></li>
                                <li><p><code>TimeInterpolator getInterpolator()</code> -- 获取插值器</p></li>
                                <li class="group"><p><code>void start()</code> -- 开始动画</p></li>
                                <li><p><code>void pause()</code> -- 暂停动画</p></li>
                                <li><p><code>void resume()</code> -- 恢复动画</p></li>
                                <li><p><code>void cancel()</code> -- 取消动画</p></li>
                                <li><p><code>void end()</code> -- 结束动画</p></li>
                                <li><p><code>boolean isPaused()</code> -- 是否暂停</p></li>
                                <li><p><code>abstract boolean isRunning()</code> -- 是否正在运行</p></li>
                                <li><p><code>boolean isStarted()</code> -- 是否已经开始</p></li>
                                <li class="group"><p><code>Animator clone()</code> -- 复制动画，但不包括监听器</p></li>
                                <li><p><code>void setTarget(Object target)</code> -- 设置作用目标</p></li>
                                <li><p><code>void setupEndValues()</code> -- 告诉对象使用适当的信息提取动画的结束值</p></li>
                                <li><p><code>void setupStartValues()</code> -- 告诉对象使用适当的信息来提取动画的起始值</p></li>
                            </ol>
                    </div>
                        <div class="sub-item">
                            <p><a href="docs/reference/android/animation/AnimatorInflater.html" target="_blank">AnimatorInflater</a> 用于将动画 XML 文件实例化为动画对象。</p>
                            <ol>
                                <li><p><code>static Animator loadAnimator(Context context, int id)</code> -- 从资源加载动画</p></li>
                                <li><p><code>static StateListAnimator loadStateListAnimator(Context context, int id)</code> -- 从资源加载状态动画</p></li>
                            </ol>
                        </div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="android-animation-AnimatorSet"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">AnimatorSet</h3>
					</div>
					<div class="panel-body">
						<pre class="brush:java;">
java.lang.Object
    android.animation.Animator
  	    android.animation.AnimatorSet

public final class AnimatorSet extends Animator {
    public AnimatorSet() {}

    public class Builder {
        AnimatorSet.Builder after(long delay) {}
        AnimatorSet.Builder after(Animator anim) {}
        AnimatorSet.Builder before(Animator anim) {}
        AnimatorSet.Builder with(Animator anim) {}
    }
}
</pre>
                        <p><a href="docs/reference/android/animation/AnimatorSet.html" target="_blank">AnimatorSet</a> 以指定的顺序播放一组动画对象。</p>
                        <ol>
                            <li><p><code>void playSequentially(List&lt;Animator> items)</code> -- 顺序播放</p></li>
                            <li><p><code>void playSequentially(Animator... items)</code> -- 顺序播放</p></li>
                            <li><p><code>void playTogether(Collection&lt;Animator> items)</code> -- 同时播放</p></li>
                            <li><p><code>void playTogether(Animator... items)</code> -- 同时播放</p></li>
                            <li class="group"><p><code>void start()</code> -- 开始所有动画</p></li>
                            <li><p><code>void pause()</code> -- 挂起所有动画</p></li>
                            <li><p><code>void resume()</code> -- 恢复所有动画</p></li>
                            <li><p><code>void cancel()</code> -- 取消所有动画</p></li>
                            <li><p><code>void end()</code> -- 结束所有动画</p></li>
                            <li><p><code>boolean isRunning()</code> -- 是否处于运行状态</p></li>
                            <li><p><code>boolean isStarted()</code> -- 是否开始</p></li>

                            <li class="group"><p><code>long getDuration()</code> -- 动画时长</p></li>
                            <li><p><code>AnimatorSet setDuration(long duration)</code> -- 设置时长</p></li>
                            <li><p><code>TimeInterpolator getInterpolator()</code> -- 获取插值器</p></li>
                            <li><p><code>void setInterpolator(TimeInterpolator interpolator)</code> -- 设置插值器</p></li>
                            <li><p><code>long getStartDelay()</code> -- 获取延时时间</p></li>
                            <li><p><code>void setStartDelay(long startDelay)</code> -- 设置延时</p></li>
                            <li><p><code>long getTotalDuration()</code> -- 动画总时长</p></li>

                            <li class="group"><p><code>ArrayList&lt;Animator> getChildAnimations()</code> -- 获取所有子动画</p></li>
                            <li><p><code>void setTarget(Object target)</code> -- 设置作用目标</p></li>
                            <li><p><code>void setupEndValues()</code> -- 诉对象使用适当的信息提取动画的结束值</p></li>
                            <li><p><code>void setupStartValues()</code> --  告诉对象使用适当的信息来提取动画的起始值</p></li>
                            <li><p><code>AnimatorSet clone()</code> -- 复制</p></li>
                            <li><p><code>AnimatorSet.Builder play(Animator anim)</code> -- 返回 Builder，动画不为空： <code>new Builder(anim)</code></p>
                            <pre class="brush: java;">
AnimatorSet s = new AnimatorSet();
s.play(anim1).with(anim2);
s.play(anim2).before(anim3);
s.play(anim4).after(anim3);

s.start();
</pre>
                            </li>
                        </ol>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="android-animation-ValueAnimator"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">ValueAnimator</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    android.animation.Animator
  	    android.animation.ValueAnimator

public class ValueAnimator extends Animator implements AnimationHandler.AnimationFrameCallback {
    // 动画更新回调
    public static interface AnimatorUpdateListener {
        void onAnimationUpdate(ValueAnimator animation);
    }
}
                        </pre>
                        <p><a href="docs/reference/android/animation/ValueAnimator.html" target="_blank">ValueAnimator</a> 提供了一个运行动画的简单时间引擎，它计算动画值并将其设置在目标对象上。</p>
                        <p>默认情况下，<a href="docs/reference/android/animation/ValueAnimator.html" target="_blank">ValueAnimator</a> 采用非线性时域插值，通过 AccelerateDecelerateInterpolator 类，加速和减速的动画。动画可以从代码或资源文件中创建，位置为: <code>res/animator/</code>。</p>
                        <pre class="brush: java;">
&lt;animator xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="1000"
    android:valueFrom="1"
    android:valueTo="0"
    android:valueType="floatType"
    android:repeatCount="1"
    android:repeatMode="reverse"/>
</pre>
                        <p>ValueAnimator 是整个属性动画最核心的类，<a href="#android-animation-ObjectAnimator">ObjectAnimator</a> 类就是 ValueAnimator 类的一个子类。属性动画的原理就是通过不断改变对象的属性值来实现过渡的，而这种过渡就是通过 ValueAnimator 类来负责计算的。除此之外，ValueAnimator 还负责管理动画的播放次数、播放模式和动画监听等。</p>
                        <p>ValueAnimator 的使用方法和 ObjectAnimator 的使用方法基本类似，不同的是 ValueAnimator 中不能指定运行动画的对象，因此 ValueAnimator 往往需要设置一个动画监听，通过不断监听当前动画运行到的属性值来动态的进行处理。代码如下：</p>
                        <pre class="brush: java;">
ValueAnimator animator = ValueAnimator.ofInt(0, 100); // 产生一个从 0 到 100 变化的整数的动画
animator.setDuration(2000);
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        Integer value = (Integer) animation.getAnimatedValue(); // 动态的获取当前运行到的属性值
        ((Button) view).setText(value + "");
    }
});
animator.start(); // 开始播放动画
                        </pre>
                        <ol>
                            <li><p><code>static ValueAnimator ofInt(int... values)</code> -- 生成一个指定开始和结束值的 ValueAnimator，一般使用两个参数</p></li>
                            <li><p><code>static ValueAnimator ofFloat(float... values)</code> -- 生成一个指定开始和结束值的 ValueAnimator</p></li>
                            <li><p><code>static ValueAnimator ofArgb(int... values)</code> -- 生成一个指定开始和结束值的 ValueAnimator</p></li>
                            <li><p><code>static ValueAnimator ofObject(TypeEvaluator evaluator, Object... values)</code> -- 使用自定也的 TypeEvaluator</p></li>
                            <li><p><code>static ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder... values)</code> -- 直接使用 PropertyValuesHolder</p></li>
                            <li class="group"><p><code>static void setFrameDelay(long frameDelay)</code> -- 设置每个帧之间的时间</p></li>
                            <li><p><code>static long getFrameDelay()</code> -- 获取每个帧之间的时间</p></li>
                            <li class="group"><p><code>void setFloatValues(float... values)</code> -- 指定开始和结束值</p></li>
                            <li><p><code>void setIntValues(int... values)</code> -- 指定开始和结束值</p></li>
                            <li><p><code>void setObjectValues(Object... values)</code> -- 指定开始和结束值</p></li>
                            <li><p><code>void setValues(PropertyValuesHolder... values)</code> -- 指定 PropertyValuesHolder</p></li>
                            <li class="group"><p><code>void addUpdateListener(ValueAnimator.AnimatorUpdateListener listener)</code> -- 添加动画监听器</p></li>
                            <li><p><code>void removeUpdateListener(ValueAnimator.AnimatorUpdateListener listener)</code> -- 移除指定监听器</p></li>
                            <li><p><code>void removeAllUpdateListeners()</code> -- 移除所有监听器</p></li>
                            <li class="group"><p><code>float getAnimatedFraction()</code> -- 获取当前分量</p></li>
                            <li><p><code>void setCurrentFraction(float fraction)</code> -- 设置当前分量，属性值会被设置为当前分量上的值</p></li>
                            <li class="group"><p><code>Object getAnimatedValue()</code> -- 获取当前值</p></li>
                            <li><p><code>Object getAnimatedValue(String propertyName)</code> -- 获取当前指定属性上的值</p></li>
                            <li class="group"><p><code>long getCurrentPlayTime()</code> -- 获取当前播放时间</p></li>
                            <li><p><code>void setCurrentPlayTime(long playTime)</code> -- 设置当前播放时间</p></li>
                            <li class="group"><p><code>int getRepeatCount()</code> -- 获取重复次数</p></li>
                            <li><p><code>void setRepeatCount(int value)</code> -- 设置重复次数</p></li>
                            <li><p><code>int getRepeatMode()</code> -- 获取重复模式</p></li>
                            <li><p><code>void setRepeatMode(int value)</code> -- 重复模式：<code>RESTART</code>, <code>REVERSE</code></p></li>
                            <li class="group"><p><code>void reverse()</code> -- 反转动画</p></li>
                            <li class="group"><p><code>void setEvaluator(TypeEvaluator value)</code> -- 设置动画值使用的类型计算器</p></li>

                        </ol>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="android-animation-PropertyValuesHolder"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">PropertyValuesHolder</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
<pre class="brush: java;">
java.lang.Object
    android.animation.PropertyValuesHolder

public class PropertyValuesHolder implements Cloneable {
    /** 这几个类为其 */
    static class IntPropertyValuesHolder extends PropertyValuesHolder {}
    static class FloatPropertyValuesHolder extends PropertyValuesHolder {}
    static class MultiIntValuesHolder extends PropertyValuesHolder {}
    static class MultiFloatValuesHolder extends PropertyValuesHolder {}

    public static class PropertyValues {}
}
</pre>
                            <p><a href="docs/reference/android/animation/PropertyValuesHolder.html" target="_blank">PropertyValuesHolder</a> 是用来保存某个属性 <code>property</code> 对应的一组值，这些值对应了一个动画周期中的所有关键帧。</p>
                            <p>动画说到底是由动画帧组成的，Animator 可以设定并保存整个动画周期中的关键帧，然后根据这些关键帧计算出动画周期中任一时间点对应的动画帧的动画数据，而每一帧的动画数据里都包含了一个时间点属性 <code>fraction</code> 以及一个动画值 <code>mValue</code>，从而实现根据当前的时间点计算当前的动画值，然后用这个动画值去更新 property 对应的属性，这也是为什么 Animator 被称为属性动画的原因，因为它的整个动画过程实际上就是不断计算并更新对象的属性。
                            </p>
                            <p><code>PropertyValuesHolder</code> 由 <code>Property</code> 及 <code>Keyframes</code> 组成，其中 <code>Property</code> 用于描述属性的特征：如属性名以及属性类型，并提供 set 及 get 方法用于获取及设定给定 Target 的对应属性值；<code>Keyframes</code> 由一组关键帧 <code>Keyframe</code> 组成，每一个关键帧由 fraction 及 value 来定量描述，
                                于是 <code>Keyframes</code> 可以根据给定的 fraction 定位到两个关键帧，这两个关键帧的 fraction 组成的区间包含给定的 fraction，然后根据定位到的两个关键帧以及设定插间器及求值器就可以计算出给定 fraction 对应的 value。</p>
                            <p>于是，
                                <code>PropertyValuesHolder</code> 的整个工作流程也就呼之欲出了，首先通过 <code>setObjectValues</code> 等函数来初始化关键帧组 <code>mKeyframes</code>，必要的情况下（如: <code>ObjectAnimator</code>）可以通过
                                <code>setStartValue</code> 及 <code>setEndValue</code> 来设定第一帧及最末帧的 value，以上工作只是完成了 <code>PropertyValuesHolder</code> 的初始化，之后就可以由 <code>Animator</code> 在绘制动画帧的时候通过 fraction 来调用 <code>calculateValue</code> 计算该 fraction 对应的 value（实际上是由 <code>mKeyframes</code> 的 <code>getValue</code> 方法做出最终计算），
                                获得对应的 value 之后，一方面可以通过 <code>getAnimatedValue</code> 提供给 <code>Animator</code> 使用，另一方面也可以通过 <code>setAnimatedValue</code> 方法直接将该值设定到相应 Target 中去，这样 <code>PropertyValuesHolder</code> 的职责也就完成了。</p>
                        </div>

                        <div class="sub-item">
                            <p><b>PropertyValuesHolder</b> API:</p>
                            <p class="text-warning">注意： 如果下面的可变长参数的只有一个值，这个值将作为结束值，而不是开始值。比如：</p>
                            <pre class="brush: java;">
/** 这个动画的运行为：
 * translationX -- X 轴由 0f 在 2 秒内移动到 200f(不是一直保持在 200f);
 * translationY -- Y 轴由 0f 在 2 秒内先移动到 100f, 再回到 0f;
 * translationY -- Y 轴由 0f 在 2 秒内先缩放 0.5f, 再回到 0f;
 * alpha -- 由 1f 在 2 秒内透明度变为 0.8f, 再回到 1f;
 */
ObjectAnimator mObjectAnimator = ObjectAnimator.ofPropertyValuesHolder(image,
    PropertyValuesHolder.ofFloat("translationX", 200f),
    PropertyValuesHolder.ofFloat("translationY", 0f, 100f, 0f),
    PropertyValuesHolder.ofFloat("alpha", 1f, 0.8f, 1f));

mObjectAnimator.setDuration(2000);
mObjectAnimator.start();
                            </pre>

                            <ol>
                                <li><p><code>static PropertyValuesHolder ofInt(String propertyName, int... values)</code> -- 属性名和 int 值构造</p></li>
                                <li><p><code>static PropertyValuesHolder ofFloat(String propertyName, float... values)</code> -- 属性名和 float 值构造</p></li>
                                <li><p><code>static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</code> -- 属性名和 Keyframe 值构造</p></li>
                                <li><p><code>static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator, Object... values)</code> -- 属性名和自定义对象构造，需要指定对象的变换计算方法</p>
                                    <pre class="brush: java;">
Person p1 = new Person("001", "aaa", 0);
Person p2 = new Person("002", "bbb", 80);
Person p3 = new Person("003", "ccc", 0);

PropertyValuesHolder holder = PropertyValuesHolder.ofObject("translationX",
                                new TypeEvaluator&lt;Person>() {
    @Override
    public Person evaluate(float fraction, Person startValue, Person endValue) {
        Person p = new Person();
        // 下面两行为 IntEvaluate 的代码
        int startInt = startValue.age;
        p.age = (int)(startInt + fraction * (endValue.age - startInt));
        return p;
    }
}, p1, p2, p3);

/** 必须设置一个转换器 */
holder.setConverter(new TypeConverter&lt;Person, Integer>(Person.class, Integer.class) {
    @Override
    public Integer convert(Person value) {
        return value.age;
    }
});

mObjectAnimator = ObjectAnimator.ofPropertyValuesHolder(image, holder);
mObjectAnimator.setDuration(3000);
mObjectAnimator.start();

                                </pre>
                                </li>
                                <li class="group"><p><code>static PropertyValuesHolder ofInt(Property&lt;?, Integer> property, int... values)</code> -- <code>?</code> 属性作用对象的类型，如果要让 ImageView 移动，操作的是 <code>setTranslateX()</code> 方法，这个方法是 View 类的，那么这个 <code>? == View</code></p></li>
                                <li><p><code>static PropertyValuesHolder ofFloat(Property&lt;?, Float> property, float... values)</code> -- 同上/p></li>
                                <li><p><code>static PropertyValuesHolder ofKeyframe(Property property, Keyframe... values)</code> -- 参见下面的 KeyFrame 类</p></li>
                                <li><p><code>static &lt;V> PropertyValuesHolder ofObject(Property property, TypeEvaluator&lt;V> evaluator, V... values)</code> -- 见下面的实例</p></li>
                                <li><p><code>static &lt;T, V> PropertyValuesHolder ofObject(Property&lt;?, V> property, TypeConverter&lt;T, V> converter, TypeEvaluator&lt;T> evaluator, T... values)</code> -- 见下面的实例:</p>
                                    <pre class="brush: java;">
Person p1 = new Person("001", "aaa", 0);
Person p2 = new Person("002", "bbb", 200);
Person p3 = new Person("003", "ccc", 0);

Property&lt;View, Integer> property = new Property&lt;View, Integer>(Integer.class, "translationX") {
    @Override
    public void set(View object, Integer value) {
        object.setTranslationX(value);
    }

    @Override
    public Integer get(View object) {
        return (int)object.getTranslationX();
    }
};

TypeConverter&lt;Person, Integer> cvt = new TypeConverter&lt;Person, Integer>(Person.class,
                                        Integer.class) {
    @Override
    public Integer convert(Person value) {
        return value.age;
    }
};

TypeEvaluator&lt;Person> evaluator = new TypeEvaluator&lt;Person>() {
    @Override
    public Person evaluate(float fraction, Person startValue, Person endValue) {
        Person p = new Person();
        int startInt = startValue.age;
        p.age = (int)(startInt + fraction * (endValue.age - startInt));
        return p;
    }
};

PropertyValuesHolder holder = PropertyValuesHolder.ofObject(property, cvt, evaluator, p1, p2, p3);

mObjectAnimator = ObjectAnimator.ofPropertyValuesHolder(image, holder);
mObjectAnimator.setDuration(3000);
mObjectAnimator.start();
                                    </pre>
                                </li>

                                <li class="group"><p><code>static PropertyValuesHolder ofMultiInt(String propertyName, int[][] values)</code> -- propertyName 类型为 int[][] 数组</p></li>
                                <li><p><code>static PropertyValuesHolder ofMultiFloat(String propertyName, float[][] values)</code> -- propertyName 类型为 float[][] 数组</p>
                                    <pre class="brush: java;">
/** 产生一个多维度同时变换的 PropertyValuesHolder */
float[][] arr = {{0, 0}, {300, 100}, {500, 0}, {0, 0}};

PropertyValuesHolder holder = PropertyValuesHolder.ofMultiFloat("move", arr);

mValueAnimator = ValueAnimator.ofPropertyValuesHolder(holder);
mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        float[] arr = (float[]) animation.getAnimatedValue();
        image.setTranslationX(arr[0]); // arr 数组的第一维： 0 - 300 - 500 - 0
        image.setTranslationY(arr[1]); // arr 数组的第二维： 0 - 100 - 0 - 0
    }
});
mValueAnimator.setDuration(3000);
mValueAnimator.start();
                                </pre>
                                </li>

                                <li class="group"><p><code>static PropertyValuesHolder ofMultiInt(String propertyName, <a href="graphics.html#graphics-Path" target="_blank">Path</a> path)</code> -- 参见下面的实例</p></li>
                                <li><p><code>static PropertyValuesHolder ofMultiFloat(String propertyName, <a href="graphics.html#graphics-Path" target="_blank">Path</a> path)</code> -- 参见下面的实例</p></li>
                                <li><p><code>static PropertyValuesHolder ofObject(String propertyName, TypeConverter&lt;PointF, ?> converter, <a href="graphics.html#graphics-Path" target="_blank">Path</a> path)</code> -- 参见下面的实例</p></li>
                                <li><p><code>static &lt;V> PropertyValuesHolder ofObject(Property&lt;?, V> property, TypeConverter&lt;PointF, V> converter, <a href="graphics.html#graphics-Path" target="_blank">Path</a> path)</code> -- 参见下面的实例</p>
                                    <pre class="brush: java;">
/** Path 不能使用 add... 方法，因为没有起点和终点 */
Path path = new Path();
path.quadTo(200,400, 600, 200);
path.close();

path.rLineTo(600, 0);
path.rLineTo(0, 400);
path.close();

PropertyValuesHolder holder = PropertyValuesHolder.ofMultiFloat("path", path);

mObjectAnimator = ValueAnimator.ofPropertyValuesHolder(holder);

mObjectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        float[] arr = (float[]) animation.getAnimatedValue(); // 不断返回路径上的坐标
        image.setTranslationX(arr[0]);
        image.setTranslationY(arr[1]);
    }
});

mObjectAnimator.setDuration(6000);
mObjectAnimator.start();
</pre>
                                </li>



                                <li class="group"><p><code>static &lt;T> PropertyValuesHolder ofMultiFloat(String propertyName, TypeConverter&lt;T, float[]> converter, TypeEvaluator&lt;T> evaluator, Keyframe... values)</code> -- Keyframe 类型</p></li>
                                <li><p><code>static &lt;T> PropertyValuesHolder ofMultiInt(String propertyName, TypeConverter&lt;T, int[]> converter, TypeEvaluator&lt;T> evaluator, Keyframe... values)</code> -- Keyframe 类型</p></li>

                                <li class="group"><p><code>static &lt;V> PropertyValuesHolder ofMultiFloat(String propertyName, TypeConverter&lt;V, float[]> converter, TypeEvaluator&lt;V> evaluator, V... values)</code> -- 自定义类型</p></li>
                                <li><p><code>static &lt;V> PropertyValuesHolder ofMultiInt(String propertyName, TypeConverter&lt;V, int[]> converter, TypeEvaluator&lt;V> evaluator, V... values)</code> -- 自定义类型</p></li>

                                <li class="group"><p><code>void setFloatValues(float... values)</code> -- 设置 float 值</p></li>
                                <li><p><code>void setIntValues(int... values)</code> -- 设置 int 值</p></li>
                                <li><p><code>void setKeyframes(Keyframe... values)</code> -- 设置 Keyframe 值</p></li>
                                <li><p><code>void setObjectValues(Object... values)</code> -- 设置 Object 值</p></li>
                                <li class="group"><p><code>void setConverter(TypeConverter converter)</code> -- 设置转换器</p></li>
                                <li><p><code>void setEvaluator(TypeEvaluator evaluator)</code> -- 设置计算方法</p></li>
                                <li class="group"><p><code>void setProperty(Property property)</code> -- 设置属性</p></li>
                                <li><p><code>void setPropertyName(String propertyName)</code> -- 设置属性名</p></li>
                                <li><p><code>String getPropertyName()</code> -- 获取属性名</p></li>
                                <li><p><code>PropertyValuesHolder clone()</code> -- 复制</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <p><b>PropertyValuesHolder 相关类：</b></p>
                            <ul>
                                <li><p><a href="docs/reference/android/animation/Keyframe.html" target="_blank">Keyframe</a> -- 保存一个 <b>时间点/值</b> 对。</p>
                                    <pre class="brush: java;">
/** float 类型的 mFraction 表示时间，每个 Value 类型为其 Class
 * float mFraction; // 时间点
 * Class mValueType; // 值类型
 * abstract Object getValue() / setValue(Object value); // 值由其子类实现
 * 定义了三个默认保护静态内部类(自身的子类)：
 */
static class IntKeyframe extends Keyframe {...}
static class FloatKeyframe extends Keyframe {...}
static class ObjectKeyframe extends Keyframe {...}

/** 提供了静态方法用于构造： */
static Keyframe ofFloat(float fraction);
static Keyframe ofFloat(float fraction, float value);

static Keyframe ofInt(float fraction, int value);
static Keyframe ofInt(float fraction);

static Keyframe ofObject(float fraction, Object value);
static Keyframe ofObject(float fraction);
</pre>
                                </li>
                                <li><p><a href="docs/reference/android/util/Property.html" target="_blank">Property</a> -- 用于描述属性的特征,如:属性名以及属性类型，并提供 set 及 get 方法用于获取及设定给定 Target 的对应属性值。</p>
                                </li>
                                <li><p><a href="docs/reference/android/animation/TypeConverter.html" target="_blank">TypeConverter</a> -- 抽象基类，用于将转换类型 T 到另一类型 V，当动画中的值类型与属性类型不同时，这是必要的。</p>
                                    <pre class="brush: java;">
public TypeConverter(Class&lt;T> fromClass, Class&lt;V> toClass) {}

/** 只有一个抽象方法 */
abstract V convert(T value) {}

/** 有一个子类: BidirectionalTypeConverter */
abstract T convertBack(V value) {}
BidirectionalTypeConverter&lt;V, T> invert() {}
</pre>
                                </li>

                            </ul>
                        </div>
                    </div>
                </div>
                <!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="android-animation-ObjectAnimator"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">ObjectAnimator</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    android.animation.Animator
        android.animation.ValueAnimator
  	  	    android.animation.ObjectAnimator

public final class ObjectAnimator extends ValueAnimator {}
</pre>
                            <p><a href="docs/reference/android/animation/ObjectAnimator.html" target="_blank">ObjectAnimator</a> 为 ValueAnimator 的子类，它能直接绑定一个 Object，并通过反射修改绑定对象的属性。</p>
                        </div>

                        <div class="sub-item">
                            <p><a href="docs/reference/android/animation/ObjectAnimator.html" target="_blank">ObjectAnimator</a> API:</p>
                            <ol>

                                <li><p><code>static ObjectAnimator ofInt(Object target, String propertyName, int... values)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static ObjectAnimator ofFloat(Object target, String propertyName, float... values)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static ObjectAnimator ofArgb(Object target, String propertyName, int... values)</code> -- 调用 <code>ofInt</code>, 但是使用的为: <a href="docs/reference/android/animation/ArgbEvaluator.html" target="_blank">ArgbEvaluator</a></p></li>
                                <li><p><code>static &lt;T> ObjectAnimator ofArgb(T target, Property&lt;T, Integer> property, int... values)</code> -- 同上，自定义 <code>Property</code></p></li>

                                <li class="group"><p><code>static ObjectAnimator ofFloat(Object target, String xPropertyName, String yPropertyName, <a href="graphics.html#graphics-Path" target="_blank">Path</a> path)</code> -- 将 <code>Path</code> 上的 x 应用到 <code>xPropertyName</code>,  y 应用到 <code>yPropertyName</code>, </p></li>
                                <li><p><code>static ObjectAnimator ofInt(Object target, String xPropertyName, String yPropertyName, <a href="graphics.html#graphics-Path" target="_blank">Path</a> path)</code> -- 同上</p></li>
                                <li><p><code>static &lt;T> ObjectAnimator ofFloat(T target, Property&lt;T, Float> xProperty, Property&lt;T, Float> yProperty, <a href="graphics.html#graphics-Path" target="_blank">Path</a> path)</code> -- 参少上面</p></li>
                                <li><p><code>static &lt;T> ObjectAnimator ofInt(T target, Property&lt;T, Integer> xProperty, Property&lt;T, Integer> yProperty, <a href="graphics.html#graphics-Path" target="_blank">Path</a> path)</code> -- 参少上面</p></li>
                                <li><p><code>static &lt;T> ObjectAnimator ofFloat(T target, Property&lt;T, Float> property, float... values)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static &lt;T> ObjectAnimator ofInt(T target, Property&lt;T, Integer> property, int... values)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>

                                <li class="group"><p><code>static ObjectAnimator ofMultiFloat(Object target, String propertyName, float[][] values)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static ObjectAnimator ofMultiFloat(Object target, String propertyName, <a href="graphics.html#graphics-Path" target="_blank">Path</a> path)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static &lt;T> ObjectAnimator ofMultiFloat(Object target, String propertyName, TypeConverter&lt;T, float[]> converter, TypeEvaluator&lt;T> evaluator, T... values)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static ObjectAnimator ofMultiInt(Object target, String propertyName, int[][] values)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static ObjectAnimator ofMultiInt(Object target, String propertyName, Path path)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static &lt;T> ObjectAnimator ofMultiInt(Object target, String propertyName, TypeConverter&lt;T, int[]> converter, TypeEvaluator&lt;T> evaluator, T... values)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>

                                <li class="group"><p><code>static &lt;T, V> ObjectAnimator ofObject(T target, Property&lt;T, V> property, TypeEvaluator&lt;V> evaluator, V... values)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static ObjectAnimator ofObject(Object target, String propertyName, TypeConverter&lt;PointF, ?> converter, <a href="graphics.html#graphics-Path" target="_blank">Path</a> path)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static &lt;T, V> ObjectAnimator ofObject(T target, Property&lt;T, V> property, TypeConverter&lt;PointF, V> converter, <a href="graphics.html#graphics-Path" target="_blank">Path</a> path)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static &lt;T, V, P> ObjectAnimator ofObject(T target, Property&lt;T, P> property, TypeConverter&lt;V, P> converter, TypeEvaluator&lt;V> evaluator, V... values)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>static ObjectAnimator ofObject(Object target, String propertyName, TypeEvaluator evaluator, Object... values)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>

                                <li class="group"><p><code>static ObjectAnimator ofPropertyValuesHolder(Object target, PropertyValuesHolder... values)</code> -- 参照 <code>ValueAnimator</code></p></li>

                                <li class="group"><p><code>void setProperty(Property property)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>void setPropertyName(String propertyName)</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>String getPropertyName()</code> -- 参照 <a href="#android-animation-PropertyValuesHolder">PropertyValuesHolder</a></p></li>
                                <li><p><code>void setTarget(Object target)</code> -- 设置作用目标</p></li>
                                <li><p><code>Object getTarget()</code> -- 获取作用目标</p></li>
                                <li class="group"><p><code>void setAutoCancel(boolean cancel)</code> -- 其他具有相同的目标和属性的任何其他 Objectanimator 开始时，是否自动取消本身</p></li>
                            </ol>
                        </div>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="android-animation-TimeAnimator"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">TimeAnimator</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    android.animation.Animator
  	    android.animation.ValueAnimator
  	  	    android.animation.TimeAnimator

public class TimeAnimator extends ValueAnimator {
    public TimeAnimator() {}

    public static interface TimeListener {
        /** animation -- 发出通知的动画
         * totalTime -- 动画开始以来的总时间
         * deltaTime -- 从前一帧到现在的运行时间
         */
        void onTimeUpdate(TimeAnimator animation, long totalTime, long deltaTime);
    }
}
                        </pre>
                        <p><a href="docs/reference/android/animation/TimeAnimator.html" target="_blank">TimeAnimator</a> 提供了一个简单的回调机制，通过 <code>TimeAnimator.TimeListener</code>，在动画的每一帧处通知你。</p>

                        <ol>
                            <li><p><code>void setCurrentPlayTime(long playTime)</code> -- 将动画的位置设置为指定的时间点</p></li>
                            <li><p><code>void setTimeListener(TimeAnimator.TimeListener listener)</code> -- 注册回调接口</p></li>
                            <li><p><code>void start()</code> -- 开始动画</p></li>
                        </ol>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="android-animation-TypeEvaluator"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">TypeEvaluator</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    android.animation.TypeEvaluator

public interface TypeEvaluator&lt;T> {
    T evaluate(float fraction, T startValue, T endValue);
}
</pre>
                            <p><a href="docs/reference/android/animation/TypeEvaluator.html" target="_blank">TypeEvaluator</a> 允许开发人员在任意属性类型上创建动画，允许它们为那些未被动画系统自动理解和使用的类型提供定制的计算方法。</p>
                        </div>

                        <div class="sub-item">
                            <p><a href="docs/reference/android/animation/TypeEvaluator.html" target="_blank">TypeEvaluator</a> 实现类：</p>
                            <ul>
                                <li><p><a href="docs/reference/android/animation/ArgbEvaluator.html" target="_blank">ArgbEvaluator</a> -- 计算的十六进制值颜色属性的默认计算器</p>
                                <pre class="brush: java;">
public Object evaluate(float fraction, Object startValue, Object endValue) {
    int startInt = (Integer) startValue;
    int startA = (startInt >> 24) & 0xff;
    int startR = (startInt >> 16) & 0xff;
    int startG = (startInt >> 8) & 0xff;
    int startB = startInt & 0xff;

    int endInt = (Integer) endValue;
    int endA = (endInt >> 24) & 0xff;
    int endR = (endInt >> 16) & 0xff;
    int endG = (endInt >> 8) & 0xff;
    int endB = endInt & 0xff;

    return (int)((startA + (int)(fraction * (endA - startA))) << 24) |
            (int)((startR + (int)(fraction * (endR - startR))) << 16) |
            (int)((startG + (int)(fraction * (endG - startG))) << 8) |
            (int)((startB + (int)(fraction * (endB - startB))));
}
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/animation/FloatEvaluator.html" target="_blank">FloatEvaluator</a> -- 计算 float 属性值的默认计算器。</p>
                                    <pre class="brush: java;">
public Float evaluate(float fraction, Number startValue, Number endValue) {
    float startFloat = startValue.floatValue();
    return startFloat + fraction * (endValue.floatValue() - startFloat);
}
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/animation/FloatArrayEvaluator.html" target="_blank">FloatArrayEvaluator</a> -- 计算 float 数组属性值的默认计算器。</p>
                                    <pre class="brush: java;">
public float[] evaluate(float fraction, float[] startValue, float[] endValue) {
    float[] array = mArray; // mArray 为构造方法传入参数
    if (array == null) {
        array = new float[startValue.length];
    }

    for (int i = 0; i < array.length; i++) {
        float start = startValue[i];
        float end = endValue[i];
        array[i] = start + (fraction * (end - start));
    }
    return array;
}
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/animation/IntEvaluator.html" target="_blank">IntEvaluator</a> -- 计算 int 属性值的默认计算器。</p>
                                    <pre class="brush: java;">
public Integer evaluate(float fraction, Integer startValue, Integer endValue) {
    int startInt = startValue;
    return (int)(startInt + fraction * (endValue - startInt));
}
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/animation/IntArrayEvaluator.html" target="_blank">IntArrayEvaluator</a> -- 计算 int 数组属性值的默认计算器。</p>
                                    <pre class="brush: java;">
public int[] evaluate(float fraction, int[] startValue, int[] endValue) {
    int[] array = mArray; // mArray 为构造方法传入参数
    if (array == null) {
        array = new int[startValue.length];
    }
    for (int i = 0; i < array.length; i++) {
        int start = startValue[i];
        int end = endValue[i];
        array[i] = (int) (start + (fraction * (end - start)));
    }
    return array;
}
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/animation/PointFEvaluator.html" target="_blank">PointFEvaluator</a> -- 进行类型之间的插值 PointF 值计算器。</p>
                                    <pre class="brush: java;">
public PointF evaluate(float fraction, PointF startValue, PointF endValue) {
    float x = startValue.x + (fraction * (endValue.x - startValue.x));
    float y = startValue.y + (fraction * (endValue.y - startValue.y));

    if (mPoint != null) { // mPoint 为构造方法传入参数
        mPoint.set(x, y);
        return mPoint;
    } else {
        return new PointF(x, y);
    }
}
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/animation/RectEvaluator.html" target="_blank">RectEvaluator</a> -- 进行类型之间的插值 Rect 值计算器。</p>
                                    <pre class="brush: java;">
public Rect evaluate(float fraction, Rect startValue, Rect endValue) {
    int left = startValue.left + (int) ((endValue.left - startValue.left) * fraction);
    int top = startValue.top + (int) ((endValue.top - startValue.top) * fraction);
    int right = startValue.right + (int) ((endValue.right - startValue.right) * fraction);
    int bottom = startValue.bottom + (int) ((endValue.bottom - startValue.bottom) * fraction);

    if (mRect == null) { // mRect 为构造方法传入参数
        return new Rect(left, top, right, bottom);
    } else {
        mRect.set(left, top, right, bottom);
        return mRect;
    }
}
                                </pre>
                                </li>
                            </ul>
                        </div>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="android-animation-LayoutTransition"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">LayoutTransition</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    android.animation.LayoutTransition

public class LayoutTransition {
    /** transitionType: */
    int APPEARING -- 容器中出现一个视图时的动画
    int DISAPPEARING -- 容器中消失一个视图时的动画
    int CHANGING -- 布局改变导致某个视图随之改变时的动画时的动画，例如调整大小，但不包括添加或者移除视图
    int CHANGE_APPEARING -- 其他视图的出现导致某个视图改变时的动画
    int CHANGE_DISAPPEARING -- 其他视图的消失导致某个视图改变时的动画

    public LayoutTransition() {}

    public interface TransitionListener {
        void startTransition(LayoutTransition trans, ViewGroup container, View view, int transitionType);

        void endTransition(LayoutTransition trans, ViewGroup container, View view, int transitionType);
    }
}
</pre>
                            <p><a href="docs/reference/android/animation/LayoutTransition.html" target="_blank">LayoutTransition</a> 和补间动画的 <a href="#android-view-animation-LayoutAnimationController">LayoutAnimationController</a> 一样，用于一个 ViewGroup 的动画控制器。</p>
                            <p>只要在布局文件的 <code>ViewGroup</code> 中加上 <code>android:animateLayoutChanges="true"</code> 属性，就会有一个 渐入/渐出 的默认动画。比如：添加一个子 View 会出现渐入动画，移除一个子 View  会出现渐出动画，而周围的视图则会平滑地填充移除时的空隙。 </p>
                        </div>

                        <div class="sub-item">
                            <p><a href="docs/reference/android/animation/LayoutTransition.html" target="_blank">LayoutTransition</a> API:</p>
                            <ol>

                                <li><p><code>void addChild(ViewGroup parent, View child)</code> -- 添加一个 child 到 parent 中</p></li>
                                <li><p><code>void removeChild(ViewGroup parent, View child)</code> -- 从 parent 中移除一个 child</p></li>
                                <li><p><code>void showChild(ViewGroup parent, View child)</code> -- 显示 child</p></li>
                                <li><p><code>void showChild(ViewGroup parent, View child, int oldVisibility)</code> -- 显示 child</p></li>
                                <li><p><code>void hideChild(ViewGroup parent, View child)</code> -- 隐藏 child</p></li>
                                <li><p><code>void hideChild(ViewGroup parent, View child, int newVisibility)</code> -- 隐藏 child</p></li>

                                <li class="group"><p><code>void addTransitionListener(LayoutTransition.TransitionListener listener)</code> -- 添加监听器</p></li>
                                <li><p><code>void removeTransitionListener(LayoutTransition.TransitionListener listener)</code> -- 移除监听器</p></li>
                                <li><p><code>List&lt;LayoutTransition.TransitionListener> getTransitionListeners()</code> -- 获取监听器列表</p></li>

                                <li class="group"><p><code>void disableTransitionType(int transitionType)</code> -- 关闭某种类型的动画</p></li>
                                <li><p><code>void enableTransitionType(int transitionType)</code> -- 开启某种类型的动画</p></li>
                                <li><p><code>boolean isTransitionTypeEnabled(int transitionType)</code> -- 获取指定类型的状态</p></li>

                                <li class="group"><p><code>Animator getAnimator(int transitionType)</code> -- 获取指定类型的动画</p></li>
                                <li><p><code>void setAnimator(int transitionType, Animator animator)</code> -- 设置指定类型的动画</p></li>

                                <li class="group"><p><code>long getDuration(int transitionType)</code> -- 获取动画时长</p></li>
                                <li><p><code>void setDuration(int transitionType, long duration)</code> -- 设置指定类型的动画时长</p></li>
                                <li><p><code>void setDuration(long duration)</code> -- 设置时长</p></li>
                                <li><p><code>long getStartDelay(int transitionType)</code> -- 获取指定类型的动画延迟</p></li>
                                <li><p><code>void setStartDelay(int transitionType, long delay)</code> -- 设置指定类型的动画延迟</p></li>
                                <li><p><code>long getStagger(int transitionType)</code> -- 获取在更改动画期间启动每个动画之间的延迟时间长度</p></li>
                                <li><p><code>void setStagger(int transitionType, long duration)</code> -- 设置在启动每个动画之间的延迟时间长度</p></li>

                                <li class="group"><p><code>void setInterpolator(int transitionType, TimeInterpolator interpolator)</code> -- 设置插值器</p></li>
                                <li><p><code>TimeInterpolator getInterpolator(int transitionType)</code> -- 获取插值器</p></li>

                                <li class="group"><p><code>boolean isChangingLayout()</code> -- 是否会改变布局</p></li>
                                <li><p><code>boolean isRunning()</code> -- 是否运行状态</p></li>
                                <li><p><code>void setAnimateParentHierarchy(boolean animateParentHierarchy)</code> -- 是否允许改变父级层次</p></li>
                            </ol>
                        </div>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="android-animation-example"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">属性动画实例</h3>
                    </div>
                    <div class="panel-body">
                        <ol>
                            <li><p><b>Java 代码实现补间动画的 平移，缩放，旋转，透明效果：</b></p>
                            <pre class="brush: java;">
/** 1.Alpha */
Animator alpha = ObjectAnimator.ofFloat(image, "alpha",  1f, 0.2f, 1f).setDuration(3000);

/** 2.Translate */
PropertyValuesHolder x_trans = PropertyValuesHolder.ofFloat("translationX", 0, 500, 0);
PropertyValuesHolder y_trans = PropertyValuesHolder.ofFloat("translationY", 0, 100, 0);
Animator translate = ObjectAnimator.ofPropertyValuesHolder(image, x_trans, y_trans).setDuration(3000);

/** 3.Scale: 中心点缩放 */
PropertyValuesHolder x_scale = PropertyValuesHolder.ofFloat("scaleX", 1f, 0.5f, 1f);
PropertyValuesHolder y_scale = PropertyValuesHolder.ofFloat("scaleY", 1f, 0.5f, 1f);
Animator scale = ObjectAnimator.ofPropertyValuesHolder(image, x_scale, y_scale).setDuration(3000);

/** 4.Ratotion: 中心点旋转 */
Animator rotation = ObjectAnimator.ofFloat(image, "rotation", 0, 60f, -60f, 30f, -30f, 0f)
                                .setDuration(3000);

/** 5.Scale: 定点缩放，在动画开始的时候设置为右上角，为了不影响后面的动画，在动画结束后还原为默认位置 */
Animator scale_xy = ObjectAnimator.ofPropertyValuesHolder(image, x_scale, y_scale).setDuration(3000);

/** 获取 缩放/旋转 的参考点，默认为 View 的中心点 */
final float pivotX = image.getPivotX();
final float pivotY = image.getPivotY();
scale_xy.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationStart(Animator animation) {
        super.onAnimationStart(animation);
        // 设置参考点为右上角
        image.setPivotX(pivotX * 2);
        image.setPivotY(0);
    }

    @Override
    public void onAnimationEnd(Animator animation) {
        super.onAnimationEnd(animation);
        // 为了不影响后面的动画，还原为默认位置
        image.setPivotX(pivotX);
        image.setPivotY(pivotY);
    }
});

/** 6.Ratotion: X 轴旋转 */
Animator rotation_X = ObjectAnimator.ofFloat(image, "rotationX", 0, 60f, -60f, 0).setDuration(3000);
/** 7.Ratotion: Y 轴旋转 */
Animator rotation_Y = ObjectAnimator.ofFloat(image, "rotationY", 0, 30f, -30f, 0).setDuration(3000);

AnimatorSet mAnimatorSet = new AnimatorSet();
// 顺序播放
mAnimatorSet.playSequentially(alpha, translate, scale, rotation, scale_xy, rotation_X, rotation_Y);
mAnimatorSet.start();
                            </pre>
                            </li>
                            <li><p><b>XML 实现补间动画的 平移，缩放，旋转，透明效果：</b></p>
                                <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;set xmlns:android="http://schemas.android.com/apk/res/android"  &lt;!-- set 可嵌套 -->
    android:ordering="sequentially"> &lt;!-- 顺序播放 -->
    &lt;!-- Alpha -->
    &lt;objectAnimator android:duration="3000">
        &lt;propertyValuesHolder android:propertyName="alpha">
            &lt;keyframe android:fraction="0" android:value="1" />
            &lt;keyframe android:fraction="0.5" android:value="0.2" />
            &lt;keyframe android:fraction="1" android:value="1" />
        &lt;/propertyValuesHolder>
    &lt;/objectAnimator>

    &lt;!-- Translate -->
    &lt;objectAnimator android:duration="3000">
        &lt;propertyValuesHolder android:propertyName="x">
            &lt;keyframe android:fraction="0" android:value="0" />
            &lt;keyframe android:fraction="0.5" android:value="500" />
            &lt;keyframe android:fraction="1" android:value="0" />
        &lt;/propertyValuesHolder>
        &lt;propertyValuesHolder android:propertyName="y">
            &lt;keyframe android:fraction="0" android:value="0" />
            &lt;keyframe android:fraction="0.5" android:value="100" />
            &lt;keyframe android:fraction="1" android:value="0" />
        &lt;/propertyValuesHolder>
    &lt;/objectAnimator>

    &lt;!-- Scale: 中心点缩放 -->
    &lt;objectAnimator android:duration="3000">
        &lt;propertyValuesHolder android:propertyName="scaleX">
            &lt;keyframe android:fraction="0" android:value="1" />
            &lt;keyframe android:fraction="0.5" android:value="0.5" />
            &lt;keyframe android:fraction="1" android:value="1" />
        &lt;/propertyValuesHolder>
        &lt;propertyValuesHolder android:propertyName="scaleY">
            &lt;keyframe android:fraction="0" android:value="1" />
            &lt;keyframe android:fraction="0.5" android:value="0.5" />
            &lt;keyframe android:fraction="1" android:value="1" />
        &lt;/propertyValuesHolder>
    &lt;/objectAnimator>

    &lt;!-- Ratotion: 中心点旋转 -->
    &lt;objectAnimator android:duration="3000">
        &lt;propertyValuesHolder android:propertyName="rotation">
            &lt;keyframe android:fraction="0" android:value="0" />
            &lt;keyframe android:fraction=".2" android:value="60" />
            &lt;keyframe android:fraction=".4" android:value="-60" />
            &lt;keyframe android:fraction=".6" android:value="30" />
            &lt;keyframe android:fraction=".8" android:value="-30" />
            &lt;keyframe android:fraction="1" android:value="0" />
        &lt;/propertyValuesHolder>
    &lt;/objectAnimator>
&lt;/set>
                            </pre>
                            </li>
                            <li><p><b>动画沿着路径走</b></p>
                                <pre class="brush: java;">
/** V 形正弦曲线，注意: 不能使用 Path 的 addXX 方法，因为不知道哪里是起点，哪里是终点 */
Path path = new Path();
path.moveTo(0, 0);
path.quadTo(50, 0, 100, 100);
path.quadTo(150, 200, 200, 200);
path.quadTo(250, 200, 300, 100);
path.quadTo(350, 0, 400, 0);
path.close(); // 回到原位

// 动画沿着路径走
ObjectAnimator mAnimator = ObjectAnimator.ofFloat(image, "x", "y", path);
mAnimator.setDuration(5000);

mAnimator.start();
                            </pre>
                            </li>

                        </ol>
                    </div>
                </div>
                <!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="android-transition-TransitionManager"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">TransitionManager</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    android.transition.TransitionManager

public class TransitionManager {}
                            </pre>
                            <p>Android Transition 框架有三个核心的类，分别是 <b>Scene</b>、<b>Transition</b> 和 <b>TransitionManager</b>。</p>
                            <p><img src="images/android-transition.png" class="img-responsive center-block"></p>
                            <p><a href="docs/reference/android/transition/Scene.html" target="_blank">Scene</a> 是场景，用于保存布局中所有 View 的属性值。</p>
                            <p><a href="docs/reference/android/transition/Transition.html" target="_blank">Transition</a> 是对这些属性值的改变定义过渡的效果。</p>
                            <p><a href="docs/reference/android/transition/TransitionManager.html" target="_blank">TransitionManager</a> 用于将 Scene 和 Transition 联系起来，它提供了一系列的方法指明起始场景和结束场景，他们的过渡动画是什么? 到指定的场景所使用的过渡动画是什么? 在当前场景到下一帧的过渡效果是什么?</p>
                            <p>可以以 XML 的形式保存在 <code>res/transition</code> 目录下。下面为一个实例：</p>
                            <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;transitionManager xmlns:android="http://schemas.android.com/apk/res/android">
    &lt;transition android:fromScene="@layout/transition_scene1"
                android:toScene="@layout/transition_scene2"
                android:transition="@transition/changebounds"/>
    &lt;transition android:fromScene="@layout/transition_scene2"
                android:toScene="@layout/transition_scene1"
                android:transition="@transition/changebounds"/>
&lt;/transitionManager>
                            </pre>
                            <p><a href="docs/reference/android/transition/TransitionInflater.html" target="_blank">TransitionInflater</a> 用于从资源文件中(<code>res/transition</code>)解析变换，有以下几个方法：</p>
                            <ol>
                                <li><p><code>static TransitionInflater from(Context context)</code> -- 获得 TransitionInflater</p></li>
                                <li><p><code>Transition inflateTransition(int resource)</code> -- 从资源加载一个 Transition</p></li>
                                <li><p><code>TransitionManager inflateTransitionManager(int resource, ViewGroup sceneRoot)</code> -- 从资源加载一个 TransitionManager</p></li>
                            </ol>
                            <p><a href="docs/reference/android/transition/TransitionManager.html" target="_blank">TransitionManager</a> API:</p>
                            <ol>

                                <li><p><code>static void beginDelayedTransition(ViewGroup sceneRoot, Transition transition)</code> -- 指定当前场景到下一帧的过渡效果</p></li>
                                <li><p><code>static void beginDelayedTransition(ViewGroup sceneRoot)</code> -- 指定当前场景到下一帧的过渡效果为默认 Transition(<a href="docs/reference/android/transition/AutoTransition.html" target="_blank">AutoTransition</a>)</p></li>
                                <li class="group"><p><code>static void endTransitions(ViewGroup sceneRoot)</code> -- 结束 sceneRoot 上的所有挂起和正在进行的转换</p></li>
                                <li><p><code>static void go(Scene scene, Transition transition)</code> -- 到指定的场景所使用的过渡动画</p></li>
                                <li><p><code>static void go(Scene scene)</code> -- 使用默认的 Transition(<a href="docs/reference/android/transition/AutoTransition.html" target="_blank">AutoTransition</a>) 到指定的场景</p></li>
                                <li class="group"><p><code>void setTransition(Scene scene, Transition transition)</code> -- 为一个场景指定变换</p></li>
                                <li><p><code>void setTransition(Scene fromScene, Scene toScene, Transition transition)</code> -- 指明起始场景和结束场景</p></li>
                                <li><p><code>void transitionTo(Scene scene)</code> -- 使用适当的过渡在这个给定的场景变化，如：指定 TransitionManager 已有的变换，如果 TransitionManager 没有指定变换则使用默认的 Transition(<a href="docs/reference/android/transition/AutoTransition.html" target="_blank">AutoTransition</a>)</p></li>

                            </ol>
                        </div>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="android-transition-Transition"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Transition 及子类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    android.transition.Transition

public abstract class Transition implements Cloneable {
    public Transition() {}
    public Transition(Context context, AttributeSet attrs) {}

    // 变换中心回调
    public static abstract class EpicenterCallback {
        Rect onGetEpicenter(Transition transition);
    }

    // 变换回调
    public static interface TransitionListener {
        void onTransitionCancel(Transition transition);
        void onTransitionEnd(Transition transition);
        void onTransitionPause(Transition transition);
        void onTransitionResume(Transition transition);
        void onTransitionStart(Transition transition);
    }
}

/** XML 属性
 * android:duration
 * android:interpolator
 * android:startDelay
 */
</pre>
                            <p><a href="docs/reference/android/transition/Transition.html" target="_blank">Transition</a> 是对这些属性值的改变定义过渡的效果。</p>
                            <p>除了系统内置的 Transition，我们还可以自定义 Transition 效果。</p>
                            <ol>
                                <li><p>需要继承 Transition;</p></li>
                                <li><p>其工作原理是在 <code>captureStartValues()</code> 和 <code>captureEndValues()</code> 中分别记录 View 的属性值，官网建议确保属性值不冲突，属性值的命名格式参考：</p>
                                    <pre class="brush: java;">package_name:transition_name:property_name</pre>
                                </li>
                                 <li><p>在 <code>createAnimator()</code> 中创建动画，对比属性值的改变执行动画效果。</p></li>
                            </ol>
                            <p><b>注意事项：</b></p>
                            <ol>
                                <li><p>Android 版本在 4.0 到 4.4.2 要使用 Android Support Library's；</p></li>
                                <li><p>对于 SurfaceView 可能不起效果，因为 SurfaceView 的实例是在非UI线程更新的，因此会造成和其他视图动画不同步；</p></li>
                                <li><p>某些特定的转换类型在应用到 TextureView 时可能不会产生所需的动画效果；</p></li>
                                <li><p>继承自 AdapterView 的如 ListView，与该框架不兼容</p></li>
                                <li><p>不要对包含文本的视图的大小进行动画；</p></li>
                                <li><p>一些效果可能需要硬件加速的支持，如下面的 ChangeTransform 实例。</p></li>
                            </ol>
                            <p><a href="docs/reference/android/transition/TransitionValues.html" target="_blank">TransitionValues</a> 为转换保存缓存值的数据结构。保存变换的 View 和其属性。</p>
                            <pre class="brush: java;">
public class TransitionValues {
    public TransitionValues() {}

    public final Map&lt;String, Object> values;
    public View view;
}
                            </pre>
                            <p><a href="docs/reference/android/transition/Transition.html" target="_blank">Transition</a> API:</p>
                            <ol>

                                <li><p><code>Transition addListener(Transition.TransitionListener listener)</code> -- 添加变换监听器</p></li>
                                <li><p><code>Transition removeListener(Transition.TransitionListener listener)</code> -- 一处变换监听器</p></li>

                                <li class="group"><p><code>long getStartDelay()</code> -- 获取延迟</p></li>
                                <li><p><code>Transition setStartDelay(long startDelay)</code> -- 设置延迟</p></li>
                                <li><p><code>long getDuration()</code> -- 获取时长</p></li>
                                <li><p><code>Transition setDuration(long duration)</code> -- 设置时长</p></li>
                                <li><p><code>TimeInterpolator getInterpolator()</code> -- 获取时间插值器</p></li>
                                <li><p><code>Transition setInterpolator(TimeInterpolator interpolator)</code> -- 设置时间插值器</p></li>

                                <li class="group"><p><code>Transition addTarget(View target)</code> -- 添加作用对象</p></li>
                                <li><p><code>Transition removeTarget(View target)</code> -- 移除作用对象</p></li>
                                <li><p><code>Transition addTarget(int targetId)</code> -- 添加作用对象</p></li>
                                <li><p><code>Transition removeTarget(int targetId)</code> -- 移除作用对象</p></li>
                                <li><p><code>Transition addTarget(Class targetType)</code> -- 添加作用对象</p></li>
                                <li><p><code>Transition removeTarget(Class target)</code> -- 移除作用对象</p></li>
                                <li><p><code>Transition addTarget(String targetName)</code> -- 添加作用对象</p></li>
                                <li><p><code>Transition removeTarget(String targetName)</code> -- 移除作用对象</p></li>
                                <li><p><code>List&lt;Integer> getTargetIds()</code> -- 获取作用对象的 ID</p></li>
                                <li><p><code>List&lt;String> getTargetNames()</code> -- 获取作用对象的 Name</p></li>
                                <li><p><code>List&lt;Class> getTargetTypes()</code> -- 获取作用对象的 Type</p></li>
                                <li><p><code>List&lt;View> getTargets()</code> -- 获取作用对象</p></li>

                                <li class="group"><p><code>Transition excludeChildren(int targetId, boolean exclude)</code> -- 是否排除指定目标的子对象</p></li>
                                <li><p><code>Transition excludeChildren(Class type, boolean exclude)</code> -- 是否排除指定目标的子对象</p></li>
                                <li><p><code>Transition excludeChildren(View target, boolean exclude)</code> -- 是否排除指定目标的子对象</p></li>
                                <li><p><code>Transition excludeTarget(View target, boolean exclude)</code> -- 是否排除作用对象</p></li>
                                <li><p><code>Transition excludeTarget(Class type, boolean exclude)</code> -- 是否排除作用对象</p></li>
                                <li><p><code>Transition excludeTarget(String targetName, boolean exclude)</code> -- 是否排除作用对象</p></li>
                                <li><p><code>Transition excludeTarget(int targetId, boolean exclude)</code> -- 是否排除作用对象</p></li>

                                <li class="group"><p><code>PathMotion getPathMotion()</code> -- 参见: <a href="#android-transition-PathMotion">PathMotion</a></p></li>
                                <li><p><code>void setPathMotion(PathMotion pathMotion)</code> -- 参见: <a href="#android-transition-PathMotion">PathMotion</a></p></li>
                                <li><p><code>TransitionPropagation getPropagation()</code> -- 参见: <a href="#android-transition-TransitionPropagation">TransitionPropagation</a></p></li>
                                <li><p><code>void setPropagation(TransitionPropagation transitionPropagation)</code> -- 参见: <a href="#android-transition-TransitionPropagation">TransitionPropagation</a></p></li>

                                <li class="group"><p><code>Animator createAnimator(ViewGroup sceneRoot, TransitionValues startValues, TransitionValues endValues)</code> -- 从 <code>TransitionValues</code> 创建属性动画</p></li>
                                <li><p><code>TransitionValues getTransitionValues(View view, boolean start)</code> -- 获取指定 View 的 <code>TransitionValues</code></p></li>
                                <li><p><code>abstract void captureEndValues(TransitionValues transitionValues)</code> -- 捕获结束场景中该转换监视器的属性值</p></li>
                                <li><p><code>abstract void captureStartValues(TransitionValues transitionValues)</code> -- 捕获起始场景中该转换监视器的属性值</p></li>
                                <li><p><code>boolean isTransitionRequired(TransitionValues startValues, TransitionValues endValues)</code> -- 变换是否应该创建一个 Animator</p></li>
                                <li><p><code>String[] getTransitionProperties()</code> -- 获取变换使用的所有属性值</p></li>

                                <li class="group"><p><code>void setEpicenterCallback(Transition.EpicenterCallback epicenterCallback)</code> -- 设置变换中心回调</p></li>
                                <li><p><code>Transition.EpicenterCallback getEpicenterCallback()</code> -- 返回用于查找转换中心的回调</p></li>
                                <li><p><code>Rect getEpicenter()</code> -- 获取变换中心</p></li>

                                <li class="group"><p><code>void setMatchOrder(int... matches)</code> -- 设置转换与视图起始值和结束值匹配的顺序</p></li>
                                <li><p><code>String getName()</code> -- 返回此转换的名称，这个名称在内部用于区分不同的转换，以确定何时中断转换重叠</p></li>
                                <li><p><code>boolean canRemoveViews()</code> -- 是否可以移除 View</p></li>
                                <li><p><code>Transition clone()</code> -- 复制</p></li>


                            </ol>
                        </div>

                        <div class="sub-item">
                            <div class="row">
                                <div class="col-md-3">
                                    <img src="images/transition-ChangBounds.gif" class="img-responsive">
                                    <p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">ChangeBounds</span></p>
                                </div>
                                <div class="col-md-3">
                                    <img src="images/transition-ChangClipBounds.gif" class="img-responsive">
                                    <p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">ChangeClipBounds</span></p>
                                </div>
                                <div class="col-md-3">
                                    <img src="images/transition-ChangeImageTransform.gif" class="img-responsive">
                                    <p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">ChangeImageTransform</span></p>
                                </div>
                                <div class="col-md-3">
                                    <img src="images/transition-ChangeScoll.gif" class="img-responsive">
                                    <p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">ChangeScoll</span></p>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-3">
                                    <img src="images/transition-ChangeTransform.gif" class="img-responsive">
                                    <p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">ChangeTransform</span></p>
                                </div>

                                <div class="col-md-3">
                                    <img src="images/transition-AutoTransition.gif" class="img-responsive">
                                    <p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">AutoTransition</span></p>
                                </div>

                                <div class="col-md-3">
                                    <img src="images/transition-Visibility.gif" class="img-responsive">
                                    <p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">Explode / Fade / Slide</span></p>
                                </div>
                            </div>

                            <p><a href="docs/reference/android/transition/Transition.html" target="_blank">Transition</a> 的子类和间接子类：</p>
                            <ol>
                                <li><p><a href="docs/reference/android/transition/ChangeBounds.html" target="_blank">ChangeBounds</a> -- 检测 View 的位置边界创建移动和缩放动画(关注布局边界的变化)</p>
                                <pre class="brush: java;">
/** XML 属性
 * android:resizeClip="true" -- 通过调整剪辑边界来调整视图的大小，而不是改变视图本身的尺寸。默认为 'false'
 */
/** 改变子 View 在 layout 中的位置，icon 会有一个移动动画 */
&lt;FrameLayout
    android:id="@+id/layout"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:minHeight="120dp">
    &lt;ImageView
        android:id="@+id/icon"
        android:layout_width="60dp"
        android:layout_height="60dp"
        android:contentDescription="@string/app_name"
        android:padding="5dp"
        android:src="@drawable/ic_launcher_android" />
&lt;/FrameLayout>

TransitionManager.beginDelayedTransition(layout, new ChangeBounds());
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) icon.getLayoutParams();
if ((lp.gravity & Gravity.START) == Gravity.START) {
    lp.gravity = Gravity.BOTTOM | Gravity.END;
} else {
    lp.gravity = Gravity.TOP | Gravity.START;
}
icon.setLayoutParams(lp);
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/transition/ChangeClipBounds.html" target="_blank">ChangeClipBounds</a> -- 捕捉对象：View 的 <code>getClipBounds()</code> 属性值，根据这个值的改变前后变化执行动画。</p>
                                    <pre class="brush: java;">
/** 裁剪 ImageView，会有一个裁剪动画，感觉从边界一直裁剪到  Rect 区域 */
Rect BOUNDS = new Rect(400, 200, 700, 400); // 裁剪中心区域
TransitionManager.beginDelayedTransition(container, new ChangeClipBounds());
if (BOUNDS.equals(ViewCompat.getClipBounds(image))) {
    ViewCompat.setClipBounds(image, null);
} else {
    ViewCompat.setClipBounds(image, BOUNDS);
}
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/transition/ChangeImageTransform.html" target="_blank">ChangeImageTransform</a> -- 捕捉对象：ImageView 的 <code>matrix</code>属性值。</p>
                                    <pre class="brush: java;">
/** 注意，要达到图三的效果，ImageView 的宽高要比图片大 */
Transition transition = new ChangeImageTransform();
TransitionManager.beginDelayedTransition(container, transition);

// image.setScaleType(ImageView.ScaleType.FIT_XY);
// image.setScaleType(ImageView.ScaleType.CENTER);
// image.setScaleType(ImageView.ScaleType.CENTER_CROP);
// image.setScaleType(ImageView.ScaleType.FIT_START);
// image.setScaleType(ImageView.ScaleType.FIT_END);
image.setScaleType(ImageView.ScaleType.MATRIX);
final Matrix matrix = new Matrix();
matrix.setRotate(30);
matrix.postTranslate(200, 0);
image.setImageMatrix(matrix);
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/transition/ChangeScroll.html" target="_blank">ChangeScroll</a> -- 捕捉对象：View 的 <code>scroll</code> 属性值。创建移动动画。</p>
                                    <pre class="brush: java;">
TransitionManager.beginDelayedTransition(mRoot, new ChangeScroll());
image.scrollBy(-60, -100);

// 回退
image.scrollBy(60, 100);
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/transition/ChangeTransform.html" target="_blank">ChangeTransform</a> -- 检测对象：View 的 <code>scale</code> 和 <code>rotation</code> 属性值。创建缩放和旋转动画。<span class="text-warning"><b>注意：这个动画需要硬件加速的支持。</b></span></p>
                                    <pre class="brush: java;">
/** XML 属性
 * android:reparent -- 是否允许目标 View 切换 Parent，默认为 true；如果为 false，则动画在 Parent 切换后再开始
 * android:reparentWithOverlay -- 默认为 true，如果为 false，则动画在 Parent 切换后才能看到
 */
/** ImageView 在两个 ViewGroup 中产生移动的动画效果 */
TransitionManager.beginDelayedTransition(container, mTransition);
if (mContainer2.getChildCount() > 0) {
    mContainer2.removeAllViews();
    change(mContainer1);
} else {
    mContainer1.removeAllViews();
    change(mContainer2);
    mContainer2.getChildAt(0).setRotation(45);
}

private void change(ViewGroup container) {
    final View view = LayoutInflater.from(this).inflate(R.layout.image, container, false);
    container.addView(view);
}
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/transition/TransitionSet.html" target="_blank">TransitionSet</a> -- 变换组合，可以指定其中的变换为同时或顺序播放。</p>
                                    <pre class="brush: java;">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;transitionSet xmlns:android="http://schemas.android.com/apk/res/android"
               android:transitionOrdering="together" >
    &lt;fade android:fadingMode="fade_out" />
    &lt;changeBounds android:resizeClip="true" />
    &lt;fade android:fadingMode="fade_in" />
&lt;/transitionSet>
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/transition/Visibility.html" target="_blank">Visibility</a> -- 是一个抽象类，针对其可见行的动画，看下面的几个子类。</p>
                                <pre class="brush: java;">
/** XML 属性
 * android:transitionVisibilityMode="mode_in|mode_out" -- 可见模式为进入或退出
 */
                                </pre>
                            </li>
                                <li class="group"><p><a href="docs/reference/android/transition/AutoTransition.html" target="_blank">AutoTransition</a> -- 是 <code>TransitionSet</code> 的子类，其实是以下几个动画组合顺序执行：</p>
                                    <pre class="brush: java;">
&lt;transitionSet xmlns:android="http://schemas.android.com/apk/res/android"
               android:transitionOrdering="sequential">
    &lt;fade android:fadingMode="fade_out" />
    &lt;changeBounds />
    &lt;fade android:fadingMode="fade_in" />
&lt;/transitionSet>

/** 当 image 在可见和不可间间切换时，container 中元素自动平移 */
TransitionSet trans = new TransitionSet();
trans.setOrdering(TransitionSet.ORDERING_TOGETHER);
trans.addTransition(new Fade(Fade.OUT)); // 淡出
trans.addTransition(new ChangeBounds()); // 改变边界(可见时，下面的元素向下推；不可见时，下面的元素向上推。)
trans.addTransition(new Fade(Fade.IN)); // 淡入

TransitionManager.beginDelayedTransition(container, trans);

if (image.getVisibility() != View.VISIBLE) {
    image.setVisibility(View.VISIBLE);
} else {
    image.setVisibility(View.GONE);
}
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/transition/Explode.html" target="_blank">Explode</a> -- 爆炸效果，爆炸中心点为 container 的中心点。 是 <code>Visibility</code> 的子类，作用对象：View 的 <code>Visibility</code> 属性值。</p>
                                    <pre class="brush: java;">
/** 如果爆炸中心点刚好由 View，那么它的方向是随机的 */
TransitionManager.beginDelayedTransition(container, new Explode());
// TransitionManager.beginDelayedTransition(container, new Fade());
// TransitionManager.beginDelayedTransition(container, new Slide());

// container 为 ViewGroup，包括了如图三个色快
int visiable = container.getChildAt(0).getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE;
for (int i = 0; i < container.getChildCount(); i++) {
    container.getChildAt(i).setVisibility(visiable);
}
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/transition/Fade.html" target="_blank">Fade</a> -- 透明度效果，是 <code>Visibility</code> 的子类，作用对象：View 的 <code>Visibility</code> 属性值。可以在初始化是指定 IN 或者 OUT 分别对应淡入和淡出，若不指定默认为淡入淡出效果。</p>
                                    <pre class="brush: java;">
/** XML 属性
 * android:fadingMode="fade_in|fade_out|fade_in_out"
 */
                                </pre>
                                </li>
                                <li><p><a href="docs/reference/android/transition/Slide.html" target="_blank">Slide</a> -- 下滑效果，是 <code>Visibility</code> 的子类，作用对象：View 的 <code>Visibility</code> 属性值。</p>
                                    <pre class="brush: java;">
/** XML 属性
 * android:slideEdge="left|right|top|bottom|start|end" -- 下滑方向
 */
                                </pre>
                                </li>

                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="android-transition-Scene"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Scene</h3>
                    </div>
                    <div class="panel-body">
<pre class="brush: java;">
java.lang.Object
    android.transition.Scene

public final class Scene {
    public Scene(ViewGroup sceneRoot) {}
    public Scene(ViewGroup sceneRoot, View layout) {}
}
</pre>
                        <p><a href="docs/reference/android/transition/Scene.html" target="_blank">Scene</a> 是场景，用于保存布局中所有 View 的属性值。</p>
                        <p>场景代表层次结构中各种属性在场景应用时所具有的值集合。场景可以被配置为在应用时自动运行转换，这将激活场景变化期间发生的各种属性更改。</p>
                        <ol>
                            <li><p><code>static Scene getSceneForLayout(ViewGroup sceneRoot, int layoutId, Context context)</code> -- 获取 Scene 对象</p></li>
                            <li><p><code>void setEnterAction(Runnable action)</code> -- 设置进入回调</p></li>
                            <li><p><code>void setExitAction(Runnable action)</code> -- 设置退出回调</p></li>
                            <li><p><code>void enter()</code> -- 进入，先清空 sceneRoot，再将 layoutId 对应的 View 加入 sceneRoot, 如果设置了 EnterAction, 则调用其 <code>run()</code> 方法</p></li>
                            <li><p><code>void exit()</code> -- 退出，如果设置了 ExitAction, 则调用其 <code>run()</code> 方法</p></li>
                            <li><p><code>ViewGroup getSceneRoot()</code> -- 获取 sceneRoot</p></li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="android-transition-PathMotion"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">PathMotion 及子类</h3>
                    </div>
                    <div class="panel-body">
                        <pre class="brush: java;">
java.lang.Object
    android.transition.PathMotion

public abstract class PathMotion {
    public PathMotion() {}
    public PathMotion(Context context, AttributeSet attrs) {}

    public abstract Path getPath(float startX, float startY, float endX, float endY);
}
                        </pre>
                        <p><a href="docs/reference/android/transition/PathMotion.html" target="_blank">PathMotion</a> 是 Transition 的辅助工具，以 Path 的方式指定过渡效果，两个具体实现类 <b>ArcMotion</b> 和 <b>PatternPathMotion</b>。</p>
                        <p><a href="docs/reference/android/transition/PathMotion.html" target="_blank">PathMotion</a> 可以在 XML 文件出现：</p>
                        <pre class="brush: xml;">
&lt;changeBounds>
    &lt;pathMotion class="my.app.transition.MyPathMotion"/>
&lt;/changeBounds>
                        </pre>
                        <div class="row">
                            <div class="col-md-3 col-md-push-2"><img src="images/transition-ArcPathMotion.gif" class="img-responsive">
                                <p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">ArcPathMotion</span></p>
                            </div>
                            <div class="col-md-3 col-md-push-4"><img src="images/transition-PatternPathMotion.gif" class="img-responsive">
                                <p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">PatternPathMotion</span></p>
                            </div>
                        </div>
                        <ul>
                            <li>
                                <p><a href="docs/reference/android/transition/ArcMotion.html" target="_blank">ArcMotion</a> 是曲线路径，将会有一个曲线移动效果；如果点之间的水平距离小于垂直距离，那么圆的中心点将与端点水平对齐。如果垂直距离小于水平距离，则圆的中心点将与终点垂直对齐。(已知两个点和一条直线，那么圆弧是确定的)</p>
                                <p>当两点接近水平或垂直时，运动曲线将变小，因为圆的中心将远离这两点。如果要强制改变路径曲率，则使用 <code>setMinimumHorizontalAngle(float)</code> 或 <code>setMinimumVerticalAngle(float)</code> 设置两点之间弧的最小角度。</p>
                            <pre class="brush: xml;">
<!-- XML 属性，对应三个 get / set 方法 -->
&lt;changeBounds>
   &lt;arcMotion
        <!-- 以下三个值： 0 < value < 90，意味着最大接近 1/4 个圆 -->
       android:minimumHorizontalAngle="15" <!-- 两点水平时，起点和终点之间的弧角。(圆心在两点中线垂直方向) -->
       android:minimumVerticalAngle="0" <!-- 两点垂直时，起点和终点之间的弧角。(圆心在两点中线水平方向) -->
       android:maximumAngle="90" /> <!-- 在起始点和结束点之间的弧角(不知什么用)，默认为 70 -->
&lt;/changeBounds>
                            </pre>
                                <pre class="brush: java;">
Transition arcTransition = new AutoTransition();
ArcMotion arcMotion = new ArcMotion();
arcMotion.setMinimumHorizontalAngle(89.99f);
arcMotion.setMinimumVerticalAngle(89.99f);
arcTransition.setPathMotion(arcMotion);
TransitionManager.beginDelayedTransition(container, arcTransition);

FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) image.getLayoutParams();
switch (v.getId()) {
    case R.id.explode:// 左上 -- 右下
        if ((lp.gravity & Gravity.START) == Gravity.START) {
            lp.gravity = Gravity.END | Gravity.BOTTOM;
        } else {
            lp.gravity = Gravity.START;
        }
        break;
    case R.id.fade: // 左 -- 右
        if ((lp.gravity & Gravity.START) == Gravity.START) {
            lp.gravity = Gravity.END;
        } else {
            lp.gravity = Gravity.START;
        }
        break;
    case R.id.slide: // 上 -- 下
        if ((lp.gravity & Gravity.TOP) == Gravity.TOP) {
            lp.gravity = Gravity.BOTTOM;
        } else {
            lp.gravity = Gravity.TOP;
        }
        break;
}
image.setLayoutParams(lp);
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/transition/PatternPathMotion.html" target="_blank">PatternPathMotion</a> 是模式路径，可以使用模式指定路径；路径的起始点将被移动到原点，终点将被缩放和旋转，使之与目标端点匹配。(这句话比较难理解，比如(M0 0 L100 100), 那么这个位置是相对的，终点在 100, 100 的位置， 如果要在中间加值,如(M0 0 L0 50 L100 100), 那么这个效果就是在动画的 50% 分量处有一个转折。还有一点要注意，在缩放的时候，左上角为 (0,0),右下角为(100, 100),这里没有计算 View 本身的宽度和高度)</p>
                                <pre class="brush: xml;">
<!-- XML 属性，对应一个 get / set 方法 -->
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;transitionSet xmlns:android="http://schemas.android.com/apk/res/android"
               android:transitionOrdering="sequential">
    &lt;fade android:fadingMode="fade_out" />
    &lt;changeBounds>
        <!-- 这里的写法相当于 moveto(0, 0), lineTo(0, 50), lineto(100, 100)  -->
        &lt;patternPathMotion android:patternPathData="M0 0 L0 50 L100 100" />
    &lt;/changeBounds>
    &lt;fade android:fadingMode="fade_in" />
&lt;/transitionSet>
                                </pre>
                                <pre class="brush: java;">
/** 下面的写法和上面的 xml 是一样的效果 */
Transition changeBounds = new ChangeBounds();

PatternPathMotion pathMotion = new PatternPathMotion();
Path path = new Path();
path.moveTo(0, 0);
path.lineTo(0, 50); // 如果去掉这一句，就相当于直线移动了
path.lineTo(100, 100);
pathMotion.setPatternPath(path);

changeBounds.setPathMotion(pathMotion);

TransitionSet transition = new TransitionSet();
transition.addTransition(new Fade(Fade.OUT));
transition.addTransition(changeBounds);
transition.addTransition(new Fade(Fade.IN));
TransitionManager.beginDelayedTransition(container, transition);

... // 省略的代码同 ArcPathMotion
                            </pre>
                            </li>
                        </ul>


                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="android-transition-TransitionPropagation"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">TransitionPropagation  及子类</h3>
                    </div>
                    <div class="panel-body">
<pre class="brush: java;">
java.lang.Object
    android.transition.TransitionPropagation
        └── android.transition.VisibilityPropagation
            ├── android.transition.CircularPropagation
            └── android.transition.SidePropagation

public abstract class TransitionPropagation {
    // sceneRoot 中参与动画的每个子 View 都有一次计算
    public abstract long getStartDelay(ViewGroup sceneRoot, Transition transition,
            TransitionValues startValues, TransitionValues endValues);

    public abstract String[] getPropagationProperties();

    public abstract void captureValues(TransitionValues transitionValues);
}
</pre>
                        <p><a href="docs/reference/android/transition/TransitionPropagation.html" target="_blank">TransitionPropagation</a> 用于计算 sceneRoot 中每个<b>子 View 的相对启动延时。</b></p>
                        <p>Explode 变换默认使用了 <a href="docs/reference/android/transition/CircularPropagation.html" target="_blank">CircularPropagation</a>。</p>
                        <p>Slide 变换默认使用了 <a href="docs/reference/android/transition/SidePropagation.html" target="_blank">SidePropagation</a>。</p>
                        <ul>
                            <li><p><a href="docs/reference/android/transition/VisibilityPropagation.html" target="_blank">VisibilityPropagation</a> -- 提供了获取位置和可见性的方法</p>
                            <pre class="brush: java;">
/** VisibilityPropagation 方法，可以根据其位置计算延时
 * int getViewVisibility(TransitionValues values) -- 获取 View 的可见性
 * int getViewX(TransitionValues values) -- 获取 View 在 sceneRoot 中的 X 位置
 * int getViewY(TransitionValues values) -- 获取 View 在 sceneRoot 中的 Y 位置
 */
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/transition/CircularPropagation.html" target="_blank">CircularPropagation</a> -- 可以根据其到 sceneRoot 中心点的位置计算延时</p>
                                <pre class="brush: java;">
/** CircularPropagation 方法
 * void setPropagationSpeed(float propagationSpeed) -- 设置速度
 */
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/transition/SidePropagation.html" target="_blank">SidePropagation</a> 可以根据其方向计算延时</p>
                                <pre class="brush: java;">
/** SidePropagation 方法
 * void setPropagationSpeed(float propagationSpeed) -- 设置速度
 * void setSide(int side) -- 设置其方向，Gravity.LEFT, Gravity.TOP...
 */
                            </pre>
                            </li>
                        </ul>
                        <div class="row">
                            <div class="col-md-9">
                                <p><b>自定义一个 VisibilityPropagation，不同的子 View 返回一个不同的延时：</b></p>
<pre class="brush: java;">
public class MyVisibilityPropagation extends VisibilityPropagation {
    @Override
    public long getStartDelay(ViewGroup sceneRoot, Transition transition,
        TransitionValues startValues, TransitionValues endValues) {
        // 如果计算的是左上角的 ImageView，则返回 100；否则返回 500;
        if(startValues.view.equals(image)) {
            return 100;
        } else {
            return 200;
        }
    }
}

// Explode
Explode explode = new Explode();
explode.setPropagation(new MyVisibilityPropagation());
TransitionManager.beginDelayedTransition(container, explode);

// Fade
Fade fade = new Fade();
fade.setPropagation(new MyVisibilityPropagation());
TransitionManager.beginDelayedTransition(container, fade);

// Slide
Slide slide = new Slide();
slide.setPropagation(new MyVisibilityPropagation());
TransitionManager.beginDelayedTransition(container, slide);

if(image.getVisibility() == View.GONE) {
    image.setVisibility(View.VISIBLE);
    icon.setVisibility(View.GONE);
} else {
    image.setVisibility(View.GONE);
    icon.setVisibility(View.VISIBLE);
}
</pre>
                            </div>
                            <div class="col-md-3">
                                <img class="img-responsive" src="images/transition-TransitionPropagation.gif">
                            </div>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="android-transition-example"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">转场动画实例</h3>
                    </div>
                    <div class="panel-body">

                    </div>
                </div>
                <!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button" class="btn btn-default dropdown-toggle dropup"
			data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button" class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup">
			TOP
		</a>
		<a href="docs/reference/index.html" type="button"
			class="btn btn-default dropdown-toggle btn-primary" target="_blank"
			data-toggle="dropup"> DOCS </a>
		<a href="docs/guide/index.html" type="button"
		   class="btn btn-default dropdown-toggle btn-primary" target="_blank"
		   data-toggle="dropup"> GUIDE </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
    <script src="../support/syntaxhighlighter/scripts/shBrushXml.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
