<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport"
          content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="keywords" content="key1, key2"/>
    <meta name="description" content=””>
    <meta name="author" content="nate">
    <meta name="author" content="nate &lt;jiwanger@126.com&gt;">
    <link href="images/favicon.ico" rel="bookmark" type="image/x-icon"/>
    <link href="images/favicon.ico" rel="icon" type="image/x-icon"/>
    <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
    <title>NATE--笔记--SDK</title>
    <!-- Bootstrap -->
    <link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
          rel="stylesheet">
    <!--
    <link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
    -->
    <link type="text/css" rel="stylesheet"
          href="../support/syntaxhighlighter/styles/shCoreDefault.css"/>
    <link href="../commons/css/common.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<!-- nav start -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle"
                    data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="icon-bar"></span> <span class="icon-bar"></span> <span
                    class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../index.html">
                <img src="../commons/images/icon.png">
            </a>
        </div>

        <div class="collapse navbar-collapse"
             id="bs-example-navbar-collapse-1">
            <ul id="my-nav" class="nav navbar-nav">

            </ul>
        </div>
    </div>
</nav>
<!-- nav end -->


<div class="container">
    <div class="row">
        <!-- left-menu start -->
        <div class="col-md-3">
            <div class="panel panel-default"
                 style="position: fixed; top: 70px; width: 260px; height: 85%; overflow: auto; float: left;">
                <div class="panel-heading">
                    <h3 class="panel-title">SDK</h3>
                </div>
                <div class="list-group">
                    <a href="#" class="list-group-item">简介</a>
                    <a class="list-group-item active dropup" data-toggle="collapse"
                       data-parent="#accordion" href="#android" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        <code>android</code><span class="caret pull-right"
                                                          style="margin-top: 5px;"></span>
                    </a>
                    <div id="android" class="panel-collapse collapse in"
                         role="tabpanel">
                        <a href="#android-Manifest" class="list-group-item">Manifest</a>
                        <a href="#android-R" class="list-group-item">R</a>
                    </div>
                    <a class="list-group-item active dropdown" data-toggle="collapse"
                       data-parent="#accordion" href="#android-content" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        <code>android.content</code><span class="caret pull-right"
                                                          style="margin-top: 5px;"></span>
                    </a>
                    <div id="android-content" class="panel-collapse collapse"
                         role="tabpanel">
                        <a href="#android-content-Context" class="list-group-item">Context</a>
                        <a href="#android-content-Resources" class="list-group-item">Recources</a>
                        <a href="#android-content-pm-PackageManager" class="list-group-item">PackageManager</a>
                        <a href="#android-content-Intent" class="list-group-item">Intent</a>
                        <a href="#" class="list-group-item">...</a>
                    </div>
                    <a class="list-group-item active dropdown" data-toggle="collapse"
                       data-parent="#accordion" href="#android-app" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        <code>android.app</code><span class="caret pull-right"
                                                      style="margin-top: 5px;"></span>
                    </a>
                    <div id="android-app" class="panel-collapse collapse"
                         role="tabpanel">
                        <a href="#android-app-Application" class="list-group-item">Application</a>
                        <a href="#android-app-Activity" class="list-group-item">Activity</a>
                        <a href="#" class="list-group-item">...</a>
                        <a href="#" class="list-group-item">...</a>
                    </div>
                    <a class="list-group-item active dropdown" data-toggle="collapse"
                       data-parent="#accordion" href="#android-view" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        <code>android.view</code><span class="caret pull-right"
                                                       style="margin-top: 5px;"></span>
                    </a>
                    <div id="android-view" class="panel-collapse collapse"
                         role="tabpanel">
                        <a href="#android-view-View" class="list-group-item">View</a>
                        <a href="#android-view-Fragment" class="list-group-item">Fragment</a>
                        <a href="#android-view-SufaceView" class="list-group-item">SufaceView</a>
                        <a href="#android-view-Window" class="list-group-item">Window</a>
                        <a href="#android-view-KeyEvent" class="list-group-item">KeyEvent</a>
                        <a href="#android-view-MotionEvent" class="list-group-item">MotionEvent</a>
                        <a href="#android-view-DragEvent" class="list-group-item">DragEvent</a>
                        <a href="#android-view-GestureDetector" class="list-group-item">GestureDetector</a>
                        <a href="#android-view-ActionMode" class="list-group-item">ActionMode</a>
                        <a href="#android-view-LayoutInflater" class="list-group-item">LayoutInflater</a>
                        <a href="#android-view-Menu" class="list-group-item">Menu</a>
                        <a href="#android-view-MenuInflater"
                           class="list-group-item">MenuInflater</a>
                    </div>
                    <a class="list-group-item active dropdown" data-toggle="collapse"
                       data-parent="#accordion" href="#android-os" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        <code>android.os</code><span class="caret pull-right"
                                                     style="margin-top: 5px;"></span>
                    </a>
                    <div id="android-os" class="panel-collapse collapse"
                         role="tabpanel">
                        <a href="#android-os-AsyncTask" class="list-group-item">AsyncTask</a>
                        <a href="#android-os-Handler" class="list-group-item">Handler 机制</a>
                        <a href="#" class="list-group-item">...</a>
                    </div>
                    <a class="list-group-item active dropdown" data-toggle="collapse"
                       data-parent="#accordion" href="#android-net" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        <code>android.net</code><span class="caret pull-right"
                                                      style="margin-top: 5px;"></span>
                    </a>
                    <div id="android-net" class="panel-collapse collapse"
                         role="tabpanel">
                        <a href="#android-net-wifi-WifiManager"
                           class="list-group-item">WifiManager 及相关类</a>
                        <a href="#android-net-wifi-WifiConfiguration" class="list-group-item">WifiConfiguration</a>
                        <a href="#android-net-wifi-p2p-WifiP2pManager" class="list-group-item">WifiP2pManager
                            及相关类</a>
                        <a href="#android-net-ConnectivityManager" class="list-group-item">ConnectivityManager
                            及相关类</a>
                        <a href="#android-net-Uri" class="list-group-item">Uri</a>
                    </div>


                    <a class="list-group-item active dropdown" data-toggle="collapse"
                       data-parent="#accordion" href="#android-support-v4" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        <code>android.support.v4</code><span class="caret pull-right"
                                                             style="margin-top: 5px;"></span>
                    </a>
                    <div id="android-support-v4" class="panel-collapse collapse"
                         role="tabpanel">
                        <a href="#" class="list-group-item">...</a>
                        <a href="#" class="list-group-item">...</a>
                        <a href="#" class="list-group-item">...</a>
                    </div>
                    <a class="list-group-item active dropdown" data-toggle="collapse"
                       data-parent="#accordion" href="#android-support-v7" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        <code>android.support.v7</code><span class="caret pull-right"
                                                             style="margin-top: 5px;"></span>
                    </a>
                    <div id="android-support-v7" class="panel-collapse collapse"
                         role="tabpanel">
                        <a href="#android-support-v7-widget-RecyclerView" class="list-group-item">RecyclerView</a>
                        <a href="#" class="list-group-item">...</a>
                        <a href="#" class="list-group-item">...</a>
                    </div>
                    <a class="list-group-item active dropdown" data-toggle="collapse"
                       data-parent="#accordion" href="#android-" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        <code>...</code><span class="caret pull-right"
                                              style="margin-top: 5px;"></span>
                    </a>
                    <div id="android-" class="panel-collapse collapse"
                         role="tabpanel">
                        <a href="#" class="list-group-item">...</a>
                        <a href="#" class="list-group-item">...</a>
                        <a href="#" class="list-group-item">...</a>
                    </div>
                    <a href="#java-class-loader" class="list-group-item">...</a>
                </div>
            </div>
        </div>
        <!-- left-menu over -->
    </div>
</div>


<div class="container" style="margin-top: 70px;">
    <div class="row">
        <div class="col-md-3"></div>
        <div class="col-md-9" style="float: left;">

            <!-- item start -->
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">简介</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <p>Android SDK 核心包简介:</p>
                        <ul>
                            <li><p><a href="docs/reference/android/package-summary.html">android</a>
                                -- 只有一个: <code>Manifest</code> 和引用系统资源的 <code>R</code> 类(类外每个应用也会根据包名生成一个): ，主要是其内部类：<code>Manifest.permission</code>, <code>Manifest.permission_group</code>,
                                <code>R.anim</code>, <code>R.animator</code>, <code>R.array</code>,
                                <code>R.attr</code>, <code>R.bool</code>,
                                <code>R.color</code>, <code>R.dimen</code>,
                                <code>R.drawable</code>, <code>R.fraction</code>,
                                <code>R.id</code>, <code>R.integer</code>,
                                <code>R.interpolator</code>, <code>R.layout</code>, <code>R.menu</code>,
                                <code>R.mipmap</code>, <code>R.plurals</code>, <code>R.raw</code>,
                                <code>R.string</code>, <code>R.style</code>, <code>R.styleable</code>,
                                <code>R.xml</code>, <code>R.transition</code>
                            </p></li>
                            <li><p><a href="docs/reference/android/os/package-summary.html">android.os</a>
                                -- 在设备上提供基本的操作系统服务、消息传递和进程间通信。 包括的类和接口：<code>IBinder</code>, <code>Binder</code>,
                                <code>Build</code>, <code>Bundle</code>, <code>Handler</code>,
                                <code>HandlerThread</code>, <code>Message</code>,
                                <code>MessageQueue</code>, <code>Looper</code>,
                                <code>Environment</code>, <code>Process</code>,
                                <code>PowerManager</code>, <code>BatteryManager</code>,
                                <code>StatFs</code>, <code>AsyncTask</code>, <code>StrictMode</code>,
                                <code>FileObserver</code> ...</p></li>
                            <li><p><a href="docs/reference/android/app/package-summary.html">android.app</a>
                                -- 实现 Android 的应用程序模型。包括的类和接口：<code>Activity</code>, <code>ActivityManager</code>,
                                <code>ActivityGroup</code>, <code>Application</code>, <code>DownloadManager</code>,
                                <code>WallpaperManager</code>, <code>Service</code>, <code>IntentService</code>,
                                <code>Dialog</code>, <code>Fragment</code>,
                                <code>FragmentManager</code>, <code>FragmentTransaction</code>,
                                <code>DialogFragment</code>, <code>ListFragment</code>, <code>ActionBar</code>,
                                <code>Notification</code>, <code>Instrumentation</code> ...</p></li>
                            <li><p><a href="docs/reference/android/content/package-summary.html">android.content</a>
                                -- 实现 ContentProvider 概念。包括的类和接口：<code>Context</code>, <code>ContextWrapper</code>,
                                <code>ContentProvider</code>, <code>ContentResolver</code>, <code>ContentValues</code>,
                                <code>UriMatcher</code>, <code>ServiceConnection</code>, <code>SharedPreferences</code>,
                                <code>Intent</code>, <code>IntentFilter</code>, <code>BroadcastReceiver</code>,
                                <code>ComponentName</code>, <code>ClipboardManager</code>, <code>ClipData</code>
                                ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/content/res/package-summary.html">android.content.res</a>
                                -- 用于访问结构化和非结构化资源文件。包括的类和接口：<code>Resources</code>, <code>AssetManager</code>,
                                <code>ColorStateList</code>, <code>Configuration</code>, <code>TypedArray</code>,
                                <code>XmlResourceParser</code>, <code>AssetFileDescriptor</code> ...
                            </p></li>
                            <li><p><a href="docs/reference/android/content/pm/package-summary.html">android.content.pm</a>
                                --
                                实现与包管理器相关的类。包管理器知道各种权限、安装的包、安装的提供程序、安装的服务、安装的组件和安装的应用程序。包括的类和接口：<code>PackageManager</code>,
                                <code>PackageInstaller</code>, <code>PackageInfo</code>, <code>PackageItemInfo</code>,
                                <code>ApplicationInfo</code>, <code>ComponentInfo</code>, <code>ActivityInfo</code>,
                                <code>ServiceInfo</code>, <code>ProviderInfo</code>, <code>PermissionInfo</code>,
                                <code>ResolveInfo</code> ...</p></li>
                            <li><p><a href="docs/reference/android/graphics/package-summary.html">android.graphics</a>
                                -- 提供低级别的图形工具, 包括的类和接口：<code>Canvas</code>, <code>Paint</code>,
                                <code>Bitmap</code>, <code>BitmapFactory</code>, <code>Matrix</code>,
                                <code>Path</code>, <code>Color</code>, <code>ColorMatrix</code>,
                                <code>Shader</code>, <code>LinearGradient</code>,
                                <code>Picture</code>, <code>PathEffect</code>, <code>CornerPathEffect</code>,
                                <code>DashPathEffect</code>, <code>MaskFilter</code>, <code>PorterDuffXfermode</code>,
                                <code>PorterDuffColorFilter</code>, <code>Rect</code>,
                                <code>Point</code> ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a>
                                -- 提供的类来管理各种视觉元素, 包括的类和接口：<code>Drawable</code>,
                                <code>Animatable</code>, <code>BitmapDrawable</code>, <code>ColorDrawable</code>,
                                <code>AnimationDrawable</code>, <code>ClipDrawable</code>, <code>DrawableWrapper</code>,
                                <code>PaintDrawable</code>, <code>StateListDrawable</code>, <code>TransitionDrawable</code>,
                                <code>RotateDrawable</code>, <code>ScaleDrawable</code>, <code>NinePatchDrawable</code>
                                ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/graphics/drawable/shapes/package-summary.html">android.graphics.drawable.shapes</a>
                                -- 实现各种形状。包括的类：<code>Shape</code>, <code>ArcShape</code>, <code>OvalShape</code>,
                                <code>PathShape</code>, <code>RectShape</code>,
                                <code>RoundRectShape</code></p></li>
                            <li><p><a href="docs/reference/android/opengl/package-summary.html">android.opengl</a>
                                -- 包含围绕 OpenGL ES 操作的实用程序类。包括的类和接口：<code>GLUtils</code>, <code>GLSurfaceView</code>,
                                <code>GLSurfaceView.Renderer</code>,
                                <code>GLSurfaceView.GLWrapper</code>, <code>Matrix</code>, <code>GLES32</code>,
                                <code>GLES31</code>, <code>GLES30</code>, <code>GLES20</code> ...
                            </p></li>
                            <li><p><a href="docs/reference/android/view/package-summary.html">android.view</a>
                                -- View 的管理和一系列监听器和回调。包括的类和接口：<code>View</code>,
                                <code>ViewGroup</code>, <code>SurfaceView</code>,
                                <code>Window</code>, <code>WindowManager</code>,
                                <code>ViewStub</code>, <code>ViewTreeObserver</code>, <code>LayoutInflater</code>,
                                <code>KeyEvent</code>, <code>Gravity</code>,
                                <code>GestureDetector</code>, <code>Display</code>, <code>ContextThemeWrapper</code>,
                                <code>Menu</code>, <code>MenuItem</code>, <code>ContextMenu</code>,
                                <code>SubMenu</code>, <code>SurfaceHolder</code>, <code>View.OnClickListener</code>,
                                <code>View.OnDragListener</code>, <code>View.OnHoverListener</code>,
                                <code>View.OnTouchListener</code>, <code>ViewTreeObserver.OnGlobalLayoutListener</code>,
                                <code>ViewTreeObserver.OnDrawListener</code> ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/view/animation/package-summary.html">android.view.animation</a>
                                -- 提供对补间动画的支持。包括的类和接口：<code>Animation</code>,
                                <code>AnimationSet</code>, <code>AnimationUtils</code>, <code>Transformation</code>,
                                <code>TranslateAnimation</code>, <code>ScaleAnimation</code>, <code>RotateAnimation</code>,
                                <code>PathInterpolator</code>, <code>LinearInterpolator</code>,
                                <code>LayoutAnimationController</code>, <code>AlphaAnimation</code>,
                                <code>Animation.AnimationListener</code> ...</p></li>
                            <li><p><a href="docs/reference/android/animation/package-summary.html">android.animation</a>
                                -- 提供对属性动画的支持。包括的类和接口：<code>Animator</code>, <code>Animator.AnimatorListener</code>,
                                <code>TypeEvaluator</code>, <code>TimeInterpolator</code>, <code>AnimatorInflater</code>,
                                <code>AnimatorListenerAdapter</code>, <code>AnimatorSet</code>,
                                <code>ArgbEvaluator</code>, <code>FloatEvaluator</code>, <code>FloatArrayEvaluator</code>,
                                <code>RectEvaluator</code>, <code>ObjectAnimator</code>, <code>TimeAnimator</code>,
                                <code>ValueAnimator</code>, <code>StateListAnimator</code> ...</p>
                            </li>
                            <li><p><a href="docs/reference/android/widget/package-summary.html">android.widget</a>
                                -- 包含通常派生自 View 类的所有 UI 控件。包括的类和接口：<code>Adapter</code>, <code>ListAdapter</code>,
                                <code>Checkable</code>, <code>LinearLayout</code>,
                                <code>FrameLayout</code>, <code>RelativeLayout</code>, <code>AbsoluteLayout</code>,
                                <code>TableLayout</code>, <code>TextView</code>, <code>Button</code>,
                                <code>ImageView</code>, <code>EditText</code>, <code>ListView</code>,
                                <code>Gallery</code>, <code>GridView</code>, <code>ScrollView</code>,
                                <code>Toast</code>, <code>VideoView</code> ...</p></li>
                            <li><p><a href="docs/reference/android/webkit/package-summary.html">android.webkit</a>
                                -- 包含表示 Web 浏览器的类。包括的类和接口：<code>WebView</code>,
                                <code>WebSettings</code>, <code>WebViewClient</code>, <code>WebChromeClient</code>,
                                <code>DownloadListener</code>, <code>CookieManager</code>, <code>URLUtil</code>,
                                <code>WebStorage</code>, <code>WebMessage</code> ...</p></li>
                            <li><p><a href="docs/reference/android/gesture/package-summary.html">android.gesture</a>
                                -- 包含处理用户定义的手势所需的所有类和接口。包括的类和接口：<code>Gesture</code>, <code>GestureLibrary</code>,
                                <code>GestureStore</code>, <code>GestureStroke</code>, <code>GesturePoint</code>,
                                <code>GestureUtils</code>, <code>GestureOverlayView</code>, <code>GestureOverlayView</code>,
                                <code>GestureOverlayView.OnGestureListener</code>, <code>GestureOverlayView.OnGesturePerformedListener</code>
                                ...</p></li>
                            <li><p><a href="docs/reference/android/transition/package-summary.html">android.transition</a>
                                -- 转场动画框架，API 19
                                引入。包括的类和接口：<code>Transition.TransitionListener</code>, <code>Transition</code>,
                                <code>ChangeBounds</code>, <code>ChangeClipBounds</code>, <code>ChangeImageTransform</code>,
                                <code>ChangeScroll</code>, <code>ChangeTransform</code>, <code>TransitionSet</code>,
                                <code>AutoTransition</code>, <code>Visibility</code>,
                                <code>Explode</code>, <code>Fade</code>, <code>Slide</code>, <code>TransitionValues</code>,
                                <code>TransitionInflater</code>, <code>TransitionManager</code>,
                                <code>Scene</code>, <code>PathMotion</code>, <code>ArcMotion</code>
                                ...</p></li>
                            <li><p><a href="docs/reference/android/util/package-summary.html">android.util</a>
                                -- 各种工具类。包括的类和接口：<code>Log</code>, <code>EventLog</code>, <code>TypedValue</code>,
                                <code>DisplayMetrics</code>, <code>XML</code>, <code>ArrayMap</code>,
                                <code>ArraySet</code>, <code>Size</code>, <code>SizeF</code>, <code>Base64</code>,
                                <code>Base64InputStream</code>, <code>Base64OutputStream</code>,
                                <code>JsonReader</code>, <code>JsonWriter</code>,
                                <code>LruCache</code>, <code>LayoutDirection</code>, <code>MutableByte</code>,
                                <code>MutableBoolean</code>, <code>MutableInt</code>, <code>MutableChar</code>,
                                <code>StateSet</code> ...</p></li>
                            <li><p><a href="docs/reference/android/text/package-summary.html">android.text</a>
                                -- 包含文本处理类。包括的类和接口：<code>TextPaint</code>, <code>TextUtils</code>,
                                <code>Html</code>, <code>Spanned</code>, <code>Spannable</code>,
                                <code>SpanWatcher</code>, <code>TextWatcher</code>, <code>SpannableStringBuilder</code>,
                                <code>SpannableString</code>, <code>SpannedString</code><code>Selection</code>,
                                <code>ClipboardManager</code>, <code>Layout</code>, <code>BoringLayout</code>,
                                <code>StaticLayout</code>, <code>DynamicLayout</code>, <code>format.DateFormat</code>,
                                <code>format.DateUtils</code> ...</p></li>
                            <li><p><a href="docs/reference/android/text/style/package-summary.html">android.text.style</a>
                                -- 为各种文本提供多种样式设置机制。包括的类和接口：<code>ImageSpan</code>,
                                <code>StyleSpan</code>, <code>QuoteSpan</code>,
                                <code>UnderlineSpan</code>, <code>URLSpan</code>,
                                <code>ScaleXSpan</code>, <code>QuoteSpan</code>, <code>IconMarginSpan</code>,
                                <code>DrawableMarginSpan</code> ...</p></li>
                            <li><p><a href="docs/reference/android/telephony/package-summary.html">android.telephony</a>
                                -- 电话，信息及蜂窝式网络相关类。包括的类和接口：<code>TelephonyManager</code>, <code>SmsManager</code>,
                                <code>SmsMessage</code>, <code>PhoneStateListener</code>, <code>PhoneNumberUtils</code>,
                                <code>CellInfo</code>, <code>CellInfoLte</code>, <code>NeighboringCellInfo</code>,
                                <code>CellLocation</code>,<code>cdma.CdmaCellLocation</code>,<code>gsm.GsmCellLocation</code>
                                ...</p></li>
                            <li><p><a href="docs/reference/android/provider/package-summary.html">android.provider</a>
                                -- 系统提供的 ContentProvider。包括的类和接口：<code>MediaStore</code>, <code>Telephony</code>,
                                <code>Settings</code>, <code>DocumentsProvider</code>, <code>DocumentsContract</code>,
                                <code>ContactsContract</code>, <code>CalendarContract</code> ...</p>
                            </li>
                            <li><p><a href="docs/reference/android/net/package-summary.html">android.net</a>
                                -- 网络相关，以及 <code>android.net.wifi</code> 下为 WIFI 相关代码。包括的类和接口：<code>ConnectivityManager</code>,
                                <code>Network</code>, <code>NetworkInfo</code>, <code>Uri</code>,
                                <code>VpnService</code>, <code>Proxy</code>, <code>ProxyInfo</code>,
                                <code>WifiInfo</code>, <code>WifiManager</code>,
                                <code>ScanResult</code>, <code>WifiConfiguration</code> ...</p>
                            </li>

                            <li><p><a href="docs/reference/android/hardware/package-summary.html">android.hardware</a>
                                -- 要是原来主要是 Camara 相关类，API 21 不再使用。包括的类和接口：<code>Sensor</code>,
                                <code>SensorManager</code>, <code>SensorEvent</code>, <code>TriggerEvent</code>,
                                <code>TriggerEventListener</code>, <code>Camara</code> ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/hardware/camera2/package-summary.html">android.hardware.camera2</a>
                                -- 相机的新实现，替代 Camara，API 21 才添加。包括的类和接口：<code>CameraManager</code>,
                                <code>CameraDevice</code>, <code>CameraCaptureSession</code>, <code>CameraCharacteristics</code>,
                                <code>CameraMetadata</code>, <code>CaptureResult</code>, <code>CaptureRequest</code>,
                                <code>TotalCaptureResult</code> ...</p></li>
                            <li><p><a href="docs/reference/android/bluetooth/package-summary.html">android.bluetooth</a>
                                -- 蓝牙功能相关类。包括的类和接口：<code>BluetoothAdapter</code>, <code>BluetoothDevice</code>,
                                <code>BluetoothClass</code>, <code>BluetoothSocket</code>, <code>BluetoothServerSocket</code>,
                                <code>BluetoothManager</code>, <code>BluetoothA2dp</code>, <code>BluetoothHealth</code>,
                                <code></code> ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/bluetooth/le/package-summary.html">android.bluetooth.le</a>
                                -- 低功耗蓝牙，API 21 添加。包括的类和接口：<code>BluetoothLeScanner</code>, <code>ScanCallback</code>,
                                <code>ScanFilter</code>, <code>ScanSettings</code>,
                                <code>ScanRecord</code>, <code>ScanResult</code>, <code>BluetoothLeAdvertiser</code>,
                                <code>AdvertiseData</code>, <code>AdvertiseCallback</code> ...</p>
                            </li>
                            <li><p><a href="docs/reference/android/database/package-summary.html">android.database</a>
                                -- 实现抽象数据库的理念。包括的类和接口：<code>Cursor</code>,
                                <code>AbstractCursor</code>, <code>CursorWrapper</code>, <code>MatrixCursor</code>,
                                <code>ContentObserver</code>, <code>DatabaseUtils</code>, <code>DataSetObserver</code>
                                ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/database/sqlite/package-summary.html">android.database.sqlite</a>
                                -- 实现 android.database 包中的概念，该包将SQLite用作物理数据库。包括的类和接口：<code>SQLiteTransactionListener</code>,
                                <code>SQLiteCursor</code>, <code>SQLiteDatabase</code>, <code>SQLiteOpenHelper</code>,
                                <code>SQLiteQuery</code>, <code>SQLiteQueryBuilder</code>, <code>SQLiteStatement</code>,
                                <code>SQLiteClosable</code> ...</p></li>
                            <li><p><a href="docs/reference/android/location/package-summary.html">android.location</a>
                                -- 地理位置相关类。包括的类和接口：<code>LocationListener</code>,
                                <code>Location</code>, <code>LocationManager</code>, <code>LocationProvider</code>,
                                <code>Address</code>, <code>Geocoder</code>, <code>GpsStatus</code>,
                                <code>GpsSatellite</code>, <code>GnssClock</code>,
                                <code>GnssStatus</code>, <code>GnssMeasurement</code>, <code>GnssMeasurementsEvent</code>,
                                <code>GnssNavigationMessage</code> ...</p></li>
                            <li><p><a href="docs/reference/android/media/package-summary.html">android.media</a>
                                -- 多媒体相关类。包括的类和接口：<code>MediaPlayer</code>,
                                <code>MediaRecorder</code>, <code>AudioManager</code>, <code>AudioRecord</code>,
                                <code>SoundPool</code>, <code>RemoteControlClient</code>, <code>RemoteController</code>,
                                <code>MediaRouter</code>, <code>MediaMuxer</code>, <code>MediaDataSource</code>,
                                <code>MediaCodec</code>, <code>JetPlayer</code>,
                                <code>AsyncPlayer</code>, <code>AudioFormat</code>,
                                <code>AudioTrack</code> ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/support/v4/app/package-summary.html">android.support.v4</a>
                                -- 低版本使用高版本 API 支持，从 24.2.0 开始拆分为子包，拆分成 <code>support-compat</code>、<code>support-core-utils</code>、<code>support-core-ui</code>、<code>support-media-compat</code>
                                和 <code>support-fragment</code> 5个包，拆分后信赖关系如下图; 最低支持 API Level 4，但
                                24.2.0 开始，V4 包支持的最低版本是 API Level 9。包括的类和接口：<code>Fragment</code>,
                                <code>FragmentManager</code>, <code>FragmentActivity</code>, <code>ActivityCompat</code>,
                                <code>ListFragment</code>, <code>CursorAdapter</code>, <code>NotificationCompat</code>,
                                <code>PagerAdapter</code>, <code>ViewPager</code>, <code>DrawerLayout</code>,
                                <code>Space</code> ...</p>
                                <p><img src="res/sdk-support-v4.png"
                                        class="img-responsive center-block"></p></li>
                            <li><p><a
                                    href="docs/reference/android/support/v7/app/package-summary.html">android.support.v7</a>
                                -- 低版本使用高版本 API 支持，最初设计就是拆分的，包括 <code>appcompat-v7(依赖
                                    v4)</code>、<code>cardview-v7</code>、<code>gridlayout-v7</code>、<code>mediarouter-v7</code>、<code>palette-v7</code>、<code>recyclerview-v7</code>、<code>preference-v7</code>,
                                只要导入使用的子包。最低支持 API Level 7，但 24.2.0 开始，V7 包支持的最低版本是 API Level
                                9。包括的类和接口：<code>ActionBar</code>, <code>MediaRouteButton</code>,
                                <code>NotificationCompat</code>, <code>Palette</code>, <code>DrawerArrowDrawable</code>,
                                <code>MediaRouter</code>, <code>MediaRouteProvider</code>, <code>Preference</code>,
                                <code>ListPreference</code>, <code>ActionMenuView</code>, <code>CardView</code>,
                                <code>GridLayout</code>, <code>RecyclerView</code>,
                                <code>Toolbar</code> ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/support/design/widget/package-summary.html">android.support.design</a>
                                -- 提供了 Material Desgin 设计风格的控件, 最低可支持 API Level 8。包括的类和接口：<code>AppBarLayout</code>,
                                <code>Snackbar</code>, <code>TabLayout</code>, <code>TabItem</code>,
                                <code>TextInputLayout</code>, <code>TextInputEditText</code>, <code>NavigationView</code>,
                                <code>FloatingActionButton</code>, <code>CoordinatorLayout</code>,
                                <code>BottomSheetDialog</code>, <code>CollapsingToolbarLayout</code>,
                                <code>BottomSheetDialogFragment</code> ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/support/annotation/package-summary.html">android.support.annotation</a>
                                -- 提供了注解支持。包括的类和接口：<code>AnimatorRes</code>, <code>AnimRes</code>,
                                <code>AttrRes</code>, <code>ColorRes</code>, <code>DimenRes</code>,
                                <code>DrawableRes</code>, <code>IdRes</code>, <code>LayoutRes</code>,
                                <code>RawRes</code>, <code>StringRes</code>, <code>StyleRes</code>,
                                <code>XmlRes</code>, <code>StyleableRes</code>, <code>AnyRes</code>,
                                <code>ArrayRes</code>, <code>BoolRes</code>, <code>ColorInt</code>,
                                <code>Dimension</code>, <code>IntRange</code>,
                                <code>FloatRange</code>, <code>UiThread</code>,
                                <code>AnyThread</code>, <code>Nullable</code>, <code>NonNull</code>,
                                <code>RequiresApi</code>, <code>RequiresPermission</code>, <code>Size</code>,
                                <code>Px</code> ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/support/percent/package-summary.html">android.support.percent</a>
                                -- 提供了百分比布局支持。包括的类和接口： <code>PercentFrameLayout.LayoutParams</code>,
                                <code>PercentFrameLayout</code>, <code>PercentRelativeLayout</code>,
                                <code>PercentLayoutHelper</code>, <code>PercentFrameLayout.LayoutParams</code>,
                                <code>PercentRelativeLayout.LayoutParams</code> ...</p></li>
                            <li><p><a
                                    href="docs/reference/android/support/multidex/package-summary.html">android.support.multidex</a>
                                -- 用于使用多 dex 技术编译APP支持,应用的方法数超过 65536 个时需要使用 multidex
                                配置。包括的类和接口：<code>MultiDex</code>, <code>MultiDexApplication</code>
                            </p></li>
                        </ul>
                    </div>

                    <div class="sub-item">
                        <p>Android 平台版本和 API 级别( API LEVEL -- NAME -- Build.VERSION_CODES ):</p>
                        <ul>
                            <li><p><b>27</b> -- <b>Android 8.1</b> -- <b>O_MR1</b></p>
                                <ul>
                                    <li><p>神经网络API（NNAPI），提供机器学习的硬件加速;</p></li>
                                    <li><p>通知：通知消息现在每秒仅能发出一次提示音;</p></li>
                                    <li><p>改善 2G 以下内存设备的表现;</p></li>
                                    <li><p>自动填充功能针对APP进行优化，提供验证器判断是否响应;</p></li>
                                    <li><p>文本编辑更新;</p></li>
                                    <li><p>壁纸色彩管理 API;</p></li>
                                    <li><p>共享内存　API：Android 8.1(API级别27)引入了一个新的　SharedMemory　类;</p>
                                    </li>
                                </ul>
                            </li>
                            <li><p><b>26</b> -- <b>Android 8.0</b> -- <b>O</b></p>
                                <ul>
                                    <li><p>通知渠道,
                                        应用自行定义的通知内容类别，借助渠道，开发者可以让用户对不同种类的通知进行精细控制，用户可以单独拦截或更改每个渠道的行为;</p>
                                    </li>
                                    <li><p>支持画中画模式, 是一种特殊的多窗口模式;</p></li>
                                    <li><p>可下载字体, 而无需将字体绑定到 APK 中或让 APK 下载字体;</p></li>
                                    <li><p>自适应图标, 系统可以基于设备选择的蒙版将这些图标显示为不同形状;</p></li>
                                    <li><p>自动填充框架, 简化了表单的填写工作;</p></li>
                                </ul>
                            </li>
                            <li><p><b>25</b> -- <b>Android 7.1.x</b> -- <b>N_MR1</b></p>
                                <ul>
                                    <li><p>提供了新的 shortcuts 功能,长按应用程序的桌面图标即可显示应用程序的快捷方式(打开应用提供的不同
                                        Activity, 最多可以静态或动态地创建 5 个快捷方式);</p></li>
                                    <li><p>圆形应用图标支持(短期内或为 Pixel 系列独占);</p></li>
                                </ul>
                            </li>
                            <li><p><b>24</b> -- <b>Android 7.0</b> -- <b>N</b></p>
                                <ul>
                                    <li><p>默认多窗口支持;</p></li>
                                    <li><p>建议使用 SurfaceView 代替 TextureView，以实现省电;</p></li>
                                    <li><p>将一项新的 3D 渲染 API Vulkan™ 集成到平台中;</p></li>
                                    <li><p>添加了框架接口和对 OpenGL ES 3.2 的平台支持;</p></li>
                                    <li><p>重新设计了通知，使其更易于使用并且速度更快;</p></li>
                                    <li><p>引入 JIT 编译器;</p></li>
                                    <li><p>低电耗模式又前进了一步，随时随地可以省电;</p></li>
                                </ul>
                            </li>
                            <li><p><b>23</b> -- <b>Android 6.0</b> -- <b>M</b></p>
                                <ul>
                                    <li><p>运行时请求权限, normal 权限在清单文件中申请就可以直接授权; dangerous
                                        权限即使在清单文件注册，也需要在运行是通过用户授权；</p></li>
                                    <li><p>添加了指纹身份验证,新 <a
                                            href="android/hardware/fingerprint/FingerprintManager.html">FingerprintManager</a>
                                        类的实例, 添加 <code>USE_FINGERPRINT</code> 权限;</p></li>
                                    <li><p>支持在 <a
                                            href="docs/reference/android/content/res/ColorStateList.html">ColorStateList</a>
                                        中使用主题属性;</p></li>
                                    <li><p>引入了一个新的而且非常需要的多任务处理功能 -- 多窗口支持;</p></li>
                                    <li><p>提供了用于访问相机闪光灯和相机图像再处理的新 API;</p></li>
                                    <li><p>推出了低电耗模式，即设备处于空闲状态时，通过推迟应用的 CPU 和网络活动以实现省电目的的系统模式;</p>
                                    </li>
                                    <li><p>平台允许应用在兼容硬件上请求将显示分辨率升级到 4K 渲染;</p></li>
                                    <li><p>增强了 Android 上的音频/视频处理功能;</p></li>
                                </ul>
                            </li>
                            <li><p><b>22</b> -- <b>Android 5.1</b> -- <b>LOLLIPOP_MR1</b></p>
                                <ul>
                                    <li><p>添加了对同时使用多个蜂窝运营商 SIM 卡的支持;</p></li>
                                    <li><p>已弃用 <code>org.apache.http</code> 类和 <code>android.net.http.AndroidHttpClient</code>
                                        类;</p></li>
                                </ul>
                            </li>
                            <li><p><b>21</b> -- <b>Android 5.0</b> -- <b>LOLLIPOP</b></p>
                                <ul>
                                    <li><p>ART 运行时取代 Dalvik 成为平台默认设置;</p></li>
                                    <li><p>添加了对 Android 的新 Material Design 样式的支持;</p></li>
                                    <li><p><code>Context.bindService()</code> 方法现在需要显式 Intent，如果提供隐式
                                        intent，将引发异常;</p></li>
                                    <li><p>引入了对 64 位系统的支持;</p></li>
                                    <li><p>低功耗蓝牙，添加了 <code>android.bluetooth.le</code> 包;</p></li>
                                    <li><p>添加了 Java 接口和对 OpenGLES 3.1 的原生支持;</p></li>
                                    <li><p>引入了新的 <code>android.hardware.camera2</code> API
                                        来简化精细照片采集和图像处理;</p></li>
                                    <li><p>利用新增的 PdfRenderer 类，将 PDF 文档页面渲染成位图图像后进行打印;</p></li>
                                </ul>
                            </li>
                            <li><p><b>20</b> -- <b>Android 4.4W</b> -- <b>KITKAT_WATCH</b></p>
                                <ul>
                                    <li><p>此版本只为可穿戴设备；</p></li>
                                </ul>
                            </li>
                            <li><p><b>19</b> -- <b>Android 4.4</b> -- <b>KITKAT</b></p>
                                <ul>
                                    <li><p>添加了新的全屏沉浸模式, 隐藏所有系统 UI，例如: 状态栏和导航栏;</p></li>
                                    <li><p>引入新的转场框架, 可以对视图层次进行一系列更改，然后让 <a
                                            href="docs/reference/android/transition/TransitionManager.html">TransitionManager</a>
                                        对这些更改自动运行延迟转场;</p></li>
                                    <li><p>使用新的窗口样式和主题请求透明系统 UI，包括状态栏和导航栏;</p></li>
                                    <li><p>添加存储访问框架；</p></li>
                                    <li><p>添加了对屏幕录制的支持，提供屏幕录制实用程序，让您能够在通过 USB 连接到 Android SDK
                                        环境的设备上启动和停止录制;</p></li>
                                </ul>
                            </li>
                            <li><p><b>18</b> -- <b>Android 4.3</b> -- <b>JELLY_BEAN_MR2</b></p>
                                <ul>
                                    <li><p>人脸识别解锁;</p></li>
                                    <li><p>一个新的媒体效果框架，适用于各种图像和视频的视觉效果;</p></li>
                                    <li><p>支持 Daydream;</p></li>
                                    <li><p>支持 Photo Sphere 全景相片;</p></li>
                                </ul>
                            </li>
                            <li><p><b>17</b> -- <b>Android 4.2</b> -- <b>JELLY_BEAN_MR1</b></p></li>
                            <li><p><b>16</b> -- <b>Android 4.1.x</b> -- <b>JELLY_BEAN</b></p></li>
                            <li><p><b>15</b> -- <b>Android 4.0.3+</b> --
                                <b>ICE_CREAM_SANDWICH_MR1</b></p></li>
                            <li><p><b>14</b> -- <b>Android 4.0.x</b> -- <b>ICE_CREAM_SANDWICH</b>
                            </p></li>
                            <li><p><b>13</b> -- <b>Android 3.2</b> -- <b>HONEYCOMB_MR2</b></p></li>
                            <li><p><b>12</b> -- <b>Android 3.1.x</b> -- <b>HONEYCOMB_MR1</b></p>
                            </li>
                            <li><p><b>11</b> -- <b>Android 3.0.x</b> -- <b>HONEYCOMB</b></p></li>
                            <li><p><b>10</b> -- <b>Android 2.3.3</b> -- <b>GINGERBREAD_MR1</b></p>
                            </li>
                            <li><p><b>9</b> -- <b>Android 2.3</b> -- <b>GINGERBREAD</b></p></li>
                            <li><p><b>8</b> -- <b>Android 2.2.x</b> -- <b>FROYO</b></p></li>
                            <li><p><b>7</b> -- <b>Android 2.1.x</b> -- <b>ECLAIR_MR1</b></p></li>
                            <li><p><b>6</b> -- <b>Android 2.0.1</b> -- <b>ECLAIR_0_1</b></p></li>
                            <li><p><b>5</b> -- <b>Android 2.0</b> -- <b>ECLAIR</b></p></li>
                            <li><p><b>4</b> -- <b>Android 1.6</b> -- <b>DONUT</b></p></li>
                            <li><p><b>3</b> -- <b>Android 1.5</b> -- <b>CUPCAKE</b></p></li>
                            <li><p><b>2</b> -- <b>Android 1.1</b> -- <b>BASE_1_1</b></p></li>
                            <li><p><b>1</b> -- <b>Android 1.0</b> -- <b>BASE</b></p></li>
                        </ul>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-Manifest"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Manifest</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <p><a href="docs/reference/android/Manifest.html" target="_blank">Manifest</a> 不允许构造，也没有别的方法，只有两个静态内部类：<a href="docs/reference/android/Manifest.permission.html" target="_blank">Manifest.permission</a> 和 <a href="docs/reference/android/Manifest.permission_group.html" target="_blank">Manifest.permission_group</a> 用来定义权限和权限组。</p>
                    </div>
                    <div class="sub-item">
                        <p><a href="docs/reference/android/Manifest.permission.html" target="_blank">Manifest.permission</a> -- Android 权限分为基本权限，危险权限(全部属于权限组)，特殊权限。如果权限未授予，在 Android 日志中会打印。</p>
                        <ul>
                            <li><p>基本权限 -- 只需要在 <code>Androidmanifest.xml</code> 中申明；</p>
                                <pre class="brush: java;">
/** 基本权限 */
INTERNET -- 访问网络，Wifi 直连也要这个权限
ACCESS_NETWORK_STATE -- 获取网络信息状态
CHANGE_NETWORK_STATE -- 改变网络状态
ACCESS_WIFI_STATE -- 获取当前 WiFi 接入的状态以及 WLAN 热点的信息
CHANGE_WIFI_STATE -- 改变 WiFi 状态，如开启/关闭，连接和开启热点等
CHANGE_WIFI_MULTICAST_STATE -- 接收组播报文信息
BLUETOOTH -- 允许程序连接配对过的蓝牙设备
BLUETOOTH_ADMIN -- 允许程序进行发现和配对新的蓝牙设备
NFC -- 允许程序执行 NFC 近距离通讯操作

RECEIVE_BOOT_COMPLETED -- 接收开启启动广播
REORDER_TASKS -- 重新排序系统 TASK 的任务

ACCESS_LOCATION_EXTRA_COMMANDS -- 允许程序访问额外的定位提供者指令

ACCESS_NOTIFICATION_POLICY -- 访问通知策略
BROADCAST_STICKY -- 发送粘性广播
DISABLE_KEYGUARD -- 禁用键盘锁
EXPAND_STATUS_BAR -- 允许程序扩展或收缩状态栏
REQUEST_INSTALL_PACKAGES -- 允许请求安装未知来源的应用
GET_PACKAGE_SIZE -- 获取应用大小
INSTALL_SHORTCUT -- 安装快捷方式
UNINSTALL_SHORTCUT -- 卸载快捷方式
KILL_BACKGROUND_PROCESSES -- 杀死后台程序
MODIFY_AUDIO_SETTINGS -- 修改声音设置

READ_SYNC_SETTINGS -- 读取同步设置
READ_SYNC_STATS -- 读取同步状态
REQUEST_IGNORE_BATTERY_OPTIMIZATIONS -- 允许加入休眠模式白名单

SET_ALARM -- 设置闹铃提醒
SET_TIME_ZONE -- 设置系统时区
SET_WALLPAPER -- 设置桌面壁纸
SET_WALLPAPER_HINTS -- 设置壁纸建议
TRANSMIT_IR -- 允许使用设备的红外发射器
USE_FINGERPRINT -- 允许应用程序使用指纹硬件
VIBRATE -- 振动
WAKE_LOCK -- 唤醒锁定，允许程序在手机屏幕关闭后后台进程仍然运行
WRITE_SYNC_SETTINGS -- 写入在线同步设置
</pre>
                            </li>
                            <li><p>危险权限 -- 所有危险的 Android 系统权限属于权限组。在 <code>Androidmanifest.xml</code> 中申明，如果 <code>targetSdkVersion >= 23</code>，需要运行时授权；</p></li>
                            <li><p>特殊权限 -- 这个要看情况，有的需要系统签名，有的不适用第三方。</p>
<pre class="brush: java;">
/** 下面权限主要分为: not-third-party, system, signature, privileged **/

/** signature, 允许应用程序读取或写入系统设置
 * 注意：如果应用程序的目标 API 级别为 23 或更高，则应用程序用户必须通过权限管理屏幕向应用程序明确授予此权限.
 *   该应用程序通过发送具有操作ACTION_MANAGE_WRITE_SETTINGS的意图来请求用户的批准。
 *   该应用程序可以通过调用Settings.System.canWrite（）来检查它是否具有此授权。
 */
WRITE_SETTINGS
/** signature|privileged, 允许应用修改和删除系统中现有的语音邮件 */
WRITE_VOICEMAIL
/** signature, AccessibilityService 必须要求，以确保只有系统可以绑定到它 */
BIND_ACCESSIBILITY_SERVICE
/** system|signature, 允许绑定到运营商应用程序中的服务的系统进程将具有此权限 */
BIND_CARRIER_SERVICES
/** signature, 必须由 ChooserTargetService 来确保只有系统可以绑定到它 */
BIND_CHOOSER_TARGET_SERVICE
/** signature, ConditionProviderService 必须要求，以确保只有系统可以绑定到它 */
BIND_CONDITION_PROVIDER_SERVICE
/** signature, 设备管理接收方必须要求，以确保只有系统可以与之交互 */
BIND_DEVICE_ADMIN
/** signature, DreamService 必须要求，以确保只有系统可以绑定到它 */
BIND_DREAM_SERVICE
/** signature|privileged, 必须由 InCallService 所要求，以确保只有系统可以绑定到它 */
BIND_INCALL_SERVICE
/** signature, InputMethodService 必须被要求，以确保只有系统可以绑定到它 */
BIND_INPUT_METHOD
/** signature, 必须由 MidiDeviceService 来确保只有系统可以绑定到它 */
BIND_MIDI_DEVICE_SERVICE
/** signature, -必须由 HostApduService 或 OffHostApduService 来确保只有系统可以绑定到它 */
BIND_NFC_SERVICE
/** signature, NotificationListenerService 必须要求，以确保只有系统可以绑定到它 */
BIND_NOTIFICATION_LISTENER_SERVICE
/** signature, 必须是 PrintService 所必需的，以确保只有系统可以绑定到它 */
BIND_PRINT_SERVICE
/** signature, 允许应用绑定到第三方快速设置图块。只应由系统请求，应由 TileService 声明所要求 */
BIND_QUICK_SETTINGS_TILE
/** signature, RemoteViewsService 必须要求，以确保只有系统可以绑定到它 */
BIND_REMOTEVIEWS
/** signature|privileged, CallScreeningService 必须要求，以确保只有系统可以绑定到它 */
BIND_SCREENING_SERVICE
/** signature|privileged, ConnectionService 必须要求，以确保只有系统可以绑定到它 */
BIND_TELECOM_CONNECTION_SERVICE
/** signature, 必须由 TextService（例如: SpellCheckerService）来确保只有系统可以绑定到它*/
BIND_TEXT_SERVICE
/** signature|privileged, TvInputService 必须要求它确保只有系统可以绑定到它 */
BIND_TV_INPUT
/** signature, VoiceInteractionService 必须要求，以确保只有系统可以绑定到它 */
BIND_VOICE_INTERACTION
/** signature, VpnService 必须要求，以确保只有系统可以绑定到它 */
BIND_VPN_SERVICE
/** signature, VrListenerService 必须要求，以确保只有系统可以绑定到它 */
BIND_VR_LISTENER_SERVICE
/** signature|privileged, 必须由 WallpaperService 所需，以确保只有系统可以绑定到它 */
BIND_WALLPAPER
/** signature|privileged, 允许应用程序清除设备上所有已安装应用程序的缓存 */
CLEAR_APP_CACHE
/** signature|privileged, 允许应用程式读取系统中的语音信箱 */
READ_VOICEMAIL
/** signature, 允许应用使用 TYPE_APPLICATION_OVERLAY 类型创建窗口，并显示在所有其他应用的顶部 */
SYSTEM_ALERT_WINDOW

/** not-third-party, 允许读写访问 "properties" 表在 checkin 数据库中，改值可以修改上传 */
ACCESS_CHECKIN_PROPERTIES
/** not-third-party, 获取账户验证信息 */
ACCOUNT_MANAGER
/** not-third-party, 允许程序更新手机电池统计信息 */
BATTERY_STATS
/** not-third-party, 允许程序告诉 AppWidget 服务需要访问小插件的数据 */
BIND_APPWIDGET
/** API 23 不推荐 */
BIND_CARRIER_MESSAGING_SERVICE
/** not-third-party, 允许应用程序在无需用户交互的情况下配对蓝牙设备，并允许或禁止电话簿访问或消息访问 */
BLUETOOTH_PRIVILEGED
/** not-third-party, 允许应用程序广播一个应用程序包已被删除的通知 */
BROADCAST_PACKAGE_REMOVED
/** not-third-party, 允许应用程式广播短讯收据通知 */
BROADCAST_SMS
/** not-third-party, 允许应用程式广播WAP PUSH收据通知 */
BROADCAST_WAP_PUSH
/** not-third-party, 允许应用程式拨打任何电话号码，而无需通过拨号程式使用者界面让使用者确认所拨的电话 */
CALL_PRIVILEGED
/** not-third-party, 允许应用程序捕获音频输出 */
CAPTURE_AUDIO_OUTPUT
/** not-third-party, 允许应用程序捕获安全的视频输出 */
CAPTURE_SECURE_VIDEO_OUTPUT
/** not-third-party, 允许应用程序捕捉视频输出 */
CAPTURE_VIDEO_OUTPUT
/** not-third-party, 允许应用程序更改是否启用应用程序组件（非自己的应用程序组件） */
CHANGE_COMPONENT_ENABLED_STATE
/** ?, 允许应用程序修改当前配置，例如语言环境 */
CHANGE_CONFIGURATION
/** not-third-party, 允许从收音机启用/禁用位置更新通知 */
CONTROL_LOCATION_UPDATES
/** not-third-party, 允许应用程序删除缓存文件 */
DELETE_CACHE_FILES
/** not-third-party, 允许应用程序删除软件包 */
DELETE_PACKAGES
/** not-third-party, 允许应用程序读取 RW 到诊断资源 */
DIAGNOSTIC
/** not-third-party, 允许应用程序从系统服务中检索状态转储信息 */
DUMP
/** not-third-party, 作为制造商测试应用程序运行，以root用户身份运行。 仅当设备在制造商测试模式下运行时才可用 */
FACTORY_TEST
/** ?, 允许访问帐户服务中的帐户列表 */
GET_ACCOUNTS_PRIVILEGED
/** ?, API 21 不再推荐 */
GET_TASKS
/** ?, 此权限可用于内容提供商以允许全局搜索系统访问其数据 */
GLOBAL_SEARCH
/** not-third-party, 允许应用程序将位置提供程序安装到位置管理器中 */
INSTALL_LOCATION_PROVIDER
/** not-third-party, 允许应用程序安装软件包 */
INSTALL_PACKAGES
/** not-third-party, 允许应用程序在硬件中使用位置功能，例如: geofencing api */
LOCATION_HARDWARE
/** not-third-party, 允许应用程序管理对文档的访问，此权限只能由平台文档管理应用程序请求 */
MANAGE_DOCUMENTS
/** not-third-party, */
MASTER_CLEAR
/** not-third-party, 允许应用程式知道正在播放的内容并控制其播放 */
MEDIA_CONTENT_CONTROL
/** not-third-party, 允许修改电话状态 - 开机，mmi 等。不包括拨打电话 */
MODIFY_PHONE_STATE
/** not-third-party, 允许将文件系统格式化为可移动存储 */
MOUNT_FORMAT_FILESYSTEMS
/** not-third-party, 允许安装和卸载可移动存储的文件系统 */
MOUNT_UNMOUNT_FILESYSTEMS
/** ?, 允许应用程序收集组件使用情况统计信息声明权限意味着使用API的意图，设备的用户可以通过设置应用程序授予权限 */
PACKAGE_USAGE_STATS
/** ?, API 9 不再推荐 */
PERSISTENT_ACTIVITY
/** not-third-party, 允许应用程序进行屏幕截图，更一般地访问帧缓冲区数据 */
READ_FRAME_BUFFER
/** ?, API 16 不再推荐 */
READ_INPUT_STATE
/** not-third-party, 许应用程序读取底层系统日志文件 */
READ_LOGS
/** not-third-party, 要求能够重新启动设备 */
REBOOT
/** ?, API 8 不再推荐 */
RESTART_PACKAGES
/** not-third-party, 允许应用程序（电话）向其他应用程序发送请求以处理传入呼叫期间的响应通过消息操作 */
SEND_RESPOND_VIA_MESSAGE
/** not-third-party, 允许应用程序控制放置在后台时是否立即完成活动 */
SET_ALWAYS_FINISH
/** not-third-party, 修改全局动画缩放因子 */
SET_ANIMATION_SCALE
/** not-third-party, 配置应用程序进行调试 */
SET_DEBUG_APP
/** ?,API 7 不再推荐 */
SET_PREFERRED_APPLICATIONS
/** not-third-party, 允许应用程序设置可运行的最大数量的（不需要的）应用程序进程 */
SET_PROCESS_LIMIT
/** not-third-party, 允许应用程序设置系统时间 */
SET_TIME
/** not-third-party, 允许应用程序请求将信号发送到所有持久性进程 */
SIGNAL_PERSISTENT_PROCESSES
/** not-third-party, 允许应用程序打开，关闭或禁用状态栏及其图标 */
STATUS_BAR
/** not-third-party, 允许应用更新设备统计信息 */
UPDATE_DEVICE_STATS
/** not-third-party, 允许应用程序编写 apn 设置 */
WRITE_APN_SETTINGS
/** not-third-party, 允许应用修改 Google 服务地图 */
WRITE_GSERVICES
/** not-third-party, 允许应用程序读取或写入安全系统设置 */
WRITE_SECURE_SETTINGS
</pre>
</li>
                        </ul>

                    </div>
                    <div class="sub-item">
                        <p><a href="docs/reference/android/Manifest.permission_group.html" target="_blank">Manifest.permission_group</a> -- 所有危险的 Android 系统权限属于权限组。</p>
                        <p class="alert alert-success"><b>注意：系统不允许多个包声明具有相同名称的权限，除非所有包都使用相同的证书签名。如果一个包声明了一个权限，系统不允许用户安装具有相同权限名称的其他包，除非这些包与第一个包的证书相同。为了避免命名冲突，我们建议使用反向域风格命名自定义权限。</b></p>
                        <pre class="brush: java;">
/** 6.0 及以上需要运行时授权，分为 9 个权限组 */
CALENDAR 权限组：
    READ_CALENDAR -- 允许程序读取用户的日程信息
    WRITE_CALENDAR -- 写入日程，但不可读取
CAMERA 权限组：
    CAMERA -- 摄像头
CONTACTS 权限组：
    READ_CONTACTS -- 允许应用访问联系人通讯录信息
    WRITE_CONTACTS -- 写入联系人，但不可读取
    GET_ACCOUNTS -- 访问账户列表
LOCATION 权限组：
    ACCESS_FINE_LOCATION --  通过 GPS 的方式获取用户位置信息
    ACCESS_COARSE_LOCATION -- 通过 WiFi 或移动基站的方式获取用户位置信息
MICROPHONE 权限组：
    RECORD_AUDIO -- 使用录音
PHONE 权限组：
    READ_PHONE_STATE -- 读取手机状态和身份
    CALL_PHONE -- 允许程序从非系统拨号器里输入电话号码
    READ_CALL_LOG -- 读取通话记录
    WRITE_CALL_LOG -- 写入通话记录
    ADD_VOICEMAIL -- 允许应用程序添加系统中的语音邮件
    USE_SIP -- 允许程序使用 SIP 视频服务
    PROCESS_OUTGOING_CALLS -- 允许程序监视，修改或放弃播出电话
SENSORS 权限组：
    BODY_SENSORS -- 人体传感器
SMS 权限组：
    SEND_SMS -- 发送彩信
    RECEIVE_MMS -- 接收彩信
    RECEIVE_SMS -- 接收短信
    READ_SMS -- 读取短信
    RECEIVE_WAP_PUSH -- 接收 WAP PUSH 信息
STORAGE 权限组：
    READ_EXTERNAL_STORAGE -- 读取外部存储，如 SD 卡
    WRITE_EXTERNAL_STORAGE -- 允许程序写入外部存储，如 SD 卡上写文件
                        </pre>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-R"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">R</h3>
                </div>
                <div class="panel-body">
                    <p><a href="docs/reference/android/R.html" target="_blank">R</a> 类用于引用系统的资源。有以下内部类：</p>
                    <ol>
                        <li><p><a href="docs/reference/android/R.anim.html" target="_blank">R.layout</a> -- 系统布局文件，一共了一些 layout 文件，可以直接使用</p>
                        <pre class="brush: java;">
activity_list_item -- LinearLayout(ImageView, TextView)
browser_link_context_header -- TextView
expandable_list_content -- ExpandableListView
list_content -- FrameLayout(FrameLayout(ListView))
preference_category -- TextView
select_dialog_item -- TextView
select_dialog_multichoice -- CheckedTextView
select_dialog_singlechoice -- CheckedTextView
simple_dropdown_item_1line -- TextView
simple_expandable_list_item_1 -- TextView
simple_expandable_list_item_2 -- TwoLineListItem(TextView, TextView)
simple_gallery_item -- TextView
simple_list_item_1 -- TextView
simple_list_item_2 -- TwoLineListItem(TextView, TextView)
simple_list_item_activated_1 -- TextView
simple_list_item_activated_2 -- TwoLineListItem(TextView, TextView)
simple_list_item_checked -- CheckedTextView
simple_list_item_multiple_choice -- CheckedTextView
simple_list_item_single_choice -- CheckedTextView
simple_selectable_list_item -- CheckedTextView
simple_spinner_dropdown_item -- CheckedTextView
simple_spinner_item -- TextView
test_list_item -- TextView
two_line_list_item -- LinearLayout(TextView, TextView)
                        </pre>
                        </li>
                        <li><p><a href="docs/reference/android/R.drawable.html" target="_blank">R.drawable</a> -- 系统图片，这个有很多，都是支持系统控件的，目录：<code>sdk/platforms/android-[VERSION]/data/res/drawable/</code></p></li>

                        <li><p><a href="docs/reference/android/R.mipmap.html" target="_blank">R.mipmap</a> -- 系统 ICON 目录，只有一张默认图片：<code>sdk/platforms/android-[VERSION]/data/res/mipmap/</code></p></li>

                        <li><p><a href="docs/reference/android/R.anim.html" target="_blank">R.anim</a> -- 补间动画，目录：<code>sdk/platforms/android-[VERSION]/data/res/anim/</code></p>
                            <pre class="brush: java;">
fade_in -- 渐入动画
fade_out -- 渐出动画
slide_in_left -- 左边渐入动画
slide_out_right -- 右边渐出动画
/** 下面的每个插入器都对应 android.view.animation 下的一个类 */
accelerate_interpolator -- 加速
decelerate_interpolator -- 减速
accelerate_decelerate_interpolator -- 先加速-后减速
anticipate_interpolator -- 开始的时候向后然后向前甩
anticipate_overshoot_interpolator -- 开始的时候向后然后向前甩一定值后返回最后的值
bounce_interpolator -- 动画结束的时候弹起
cycle_interpolator -- 动画循环播放特定的次数，速率改变沿着正弦曲线
linear_interpolator -- 以常量速率改变
overshoot_interpolator -- 向前甩一定值后再回到原来位置
                        </pre></li>
                        <li><p><a href="docs/reference/android/R.interpolator.html" target="_blank">R.interpolator</a> -- 时间插值类，定义动画变换的速度。目录：<code>sdk/platforms/android-[VERSION]/data/res/interpolator/</code></p>
                            <pre class="brush: java;">
/** 还是上面的插值器 */
accelerate_decelerate -- AccelerateDecelerateInterpolator
anticipate -- AnticipateInterpolator
anticipate_overshoot -- AnticipateOvershootInterpolator
bounce -- BounceInterpolator
cycle -- CycleInterpolator
linear -- LinearInterpolator
overshoot -- OvershootInterpolator
accelerate_quad -- AccelerateInterpolator
decelerate_quad -- DecelerateInterpolator

/** 加了参数的 AccelerateInterpolator 和 DecelerateInterpolator */
accelerate_cubic -- AccelerateInterpolator, factor="1.5"
accelerate_quint -- AccelerateInterpolator, factor="2.5"
decelerate_cubic -- DecelerateInterpolator, factor="1.5"
decelerate_quint -- DecelerateInterpolator, factor="2.5"
/** 下面三个都是 PathInterpolator, API 21 添加，贝塞尔曲线控制 */
fast_out_linear_in
fast_out_slow_in
linear_out_slow_in
                        </pre>
                        </li>
                        <li><p><a href="docs/reference/android/R.animator.html" target="_blank">R.animator</a> -- 属性动画，目录：<code>sdk/platforms/android-[VERSION]/data/res/animator/</code></p>
                            <pre class="brush: java;">
/** 对应 android.animation 包下的类 */
fade_in -- 渐入
fade_out -- 渐出
                        </pre></li>
                        <li><p><a href="docs/reference/android/R.transition.html" target="_blank">R.transition</a> -- 转场动画，目录：<code>sdk/platforms/android-[VERSION]/data/res/transition/</code></p>
                            <pre class="brush: java;">
/** 对应 android.transition 包下的类 */
explode -- Explode
fade -- Fade
move -- TransitionSet(ChangeBounds, ChangeTransform, ChangeClipBounds, ChangeImageTransform)
no_transition -- 空的 TransitionSet
slide_bottom -- Slide, slideEdge="bottom"
slide_left -- Slide, slideEdge="left"
slide_right -- Slide, slideEdge="right"
slide_top -- Slide, slideEdge="top"
                        </pre></li>
                        <li><p><a href="docs/reference/android/R.menu.html" target="_blank">R.menu</a> -- 目录，目录：<code>sdk/platforms/android-[VERSION]/data/res/menu/</code></p>
                        </li>
                        <li><p><a href="docs/reference/android/R.xml.html" target="_blank">R.xml</a> -- xml 文件，目录：<code>sdk/platforms/android-[VERSION]/data/res/xml/</code></p></li>
                        <li><p><a href="docs/reference/android/R.raw.html" target="_blank">R.raw</a> -- 二进制资源，目录：<code>sdk/platforms/android-[VERSION]/data/res/raw/</code></p>
                        </li>
                        <li class="group"><p><a href="docs/reference/android/R.color.html" target="_blank">R.color</a> -- 系统颜色，这个比较特殊，可以为文件：<code>sdk/platforms/android-[VERSION]/data/res/color/</code>，也可以为 values 下的值：<code>sdk/platforms/android-[VERSION]/data/res/values/colors.xml</code></p>
                        <pre class="brush: java;">
// 如果是 res/color/ 目录下的文件，应该为 ColorStateList
ColorStateList primary_text_dark = getResources().getColorStateList(
                            android.R.color.primary_text_dark, getTheme());

// 如果是 res/values/ 下，应该为颜色值
nt color = getResources().getColor(android.R.color.holo_blue_bright, getTheme());
                        </pre>
                        </li>
                        <li class="group"><p><a href="docs/reference/android/R.style.html" target="_blank">R.style</a> -- 样式和主题，<code>sdk/platforms/android-[VERSION]/data/res/values/styles.xml</code></p></li>
                        <li><p><a href="docs/reference/android/R.attr.html" target="_blank">R.attr</a> -- 属性，目录：<code>sdk/platforms/android-[VERSION]/data/res/values/attrs.xml</code></p>
                            </li>
                        <li><p><a href="docs/reference/android/R.styleable.html" target="_blank">R.styleable</a> -- 注意: <code>android.R.styleable</code> 不再使用，使用应用的 styleable，比如: <code>appcompat-v7</code>，它的 <code>res/values/values.xml</code> 中就有很多 styleable 可用。</p>
                            <pre class="brush: java;">
&lt;declare-styleable name="ActionBar">
    &lt;attr name="navigationMode">
         &lt;enum name="normal" value="0"/>
         &lt;enum name="listMode" value="1"/>
         &lt;enum name="tabMode" value="2"/>
    &lt;/attr>
    &lt;attr name="displayOptions">
        &lt;flag name="none" value="0"/>
        &lt;flag name="useLogo" value="0x1"/>
    &lt;/attr>
&lt;/declare-styleable>
                        </pre></li>
                        <li><p><a href="docs/reference/android/R.array.html" target="_blank">R.array</a> -- 数组，目录：<code>sdk/platforms/android-[VERSION]/data/res/values/arrays.xml</code></p>
                            </li>
                        <li><p><a href="docs/reference/android/R.bool.html" target="_blank">R.bool</a> -- boolean 值，，目录：<code>sdk/platforms/android-[VERSION]/data/res/values/bools.xml</code></p>
                            </li>
                        <li><p><a href="docs/reference/android/R.dimen.html" target="_blank">R.dimen</a> -- 尺寸，目录：<code>sdk/platforms/android-[VERSION]/data/res/values/dimens.xml</code></p>

                        </li>
                        <li><p><a href="docs/reference/android/R.fraction.html" target="_blank">R.fraction</a> -- 百分比值，这个系统没有定义值</p>

                        </li>
                        <li><p><a href="docs/reference/android/R.id.html" target="_blank">R.id</a> -- 预定义的 id，目录：<code>sdk/platforms/android-[VERSION]/data/res/values/ids.xml</code></p>

                        </li>
                        <li><p><a href="docs/reference/android/R.integer.html" target="_blank">R.integer</a> -- int 值，目录：<code>sdk/platforms/android-[VERSION]/data/res/values/integers.xml</code></p>

                        </li>


                        <li><p><a href="docs/reference/android/R.plurals.html" target="_blank">R.plurals</a> -- 复数形式，系统没有定义值</p>

                        </li>

                        <li><p><a href="docs/reference/android/R.string.html" target="_blank">R.string</a> -- 字符串，目录：<code>sdk/platforms/android-[VERSION]/data/res/values/strings.xml</code></p>

                        </li>

                    </ol>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-content-Context"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Context</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
<pre class="brush: java;">
java.lang.Object
    android.content.Context

public abstract class Context {}

Context
    ├── ...
    ├── ContextImpl             // 上下文功能的实现类
    └── ContextWrapper          // 是上下文功能的封装类, 调用 ContextImpl
            ├── ...
            ├── Application
            ├── Service
            └── ContextThemeWrapper     // 带主题的封装类
                    └── Activity
</pre>
                        <p><a href="docs/reference/android/content/Context.html">Context</a>
                            是一个抽象类，并提供了该抽象类的具体实现类 <code>android.app.ContextImpl</code>。描述的是一个应用程序环境的信息，通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作。
                        </p>
                        <p><a href="docs/reference/android/content/ContextWrapper.html">ContextWrapper</a>
                            只是对 Context 类的一种包装，该类的包含了一个真正的 Context 引用，即 ContextIml。并调用 <code>attachBaseContext(Context
                                base)</code> 方法将 ContextIml 的实例赋值到 ContextWrapper。因此，在此方法调用前，Context
                            为空。 </p>
                        <pre class="brush: java;">
public class ContextWrapper extends Context {
    Context mBase;  // 该属性指向一个 ContextIml 实例，一般在创建 Application、Service、Activity 时赋值

    public ContextWrapper(Context base) {
        mBase = base;
    }

    // 创建 Application、Service、Activity，会调用该方法给 mBase 属性赋值
    protected void attachBaseContext(Context base) {
        if (mBase != null) {
            throw new IllegalStateException("Base context already set");
        }
        mBase = base;
    }

    @Override
    public void startActivity(Intent intent) {
        mBase.startActivity(intent);  //调用mBase实例方法
    }
    ...
}
</pre>
                        <p><a href="docs/reference/android/view/ContextThemeWrapper.html">ContextThemeWrapper</a>
                            带主题的封装类, Activity 的父类。</p>
                        <pre class="brush: java;">
public ContextThemeWrapper() {}
public ContextThemeWrapper(Context base, int themeResId) {}
public ContextThemeWrapper(Context base, Resources.Theme theme) {}

public Resources.Theme getTheme() {}
public void setTheme(int resid) {}

protected void onApplyThemeResource(Resources.Theme theme, int resId, boolean first) {}
</pre>

                    </div>

                    <div class="sub-item">
                        <p>Context 方法:</p>
                        <ol type="I">
                            <li>Context 创建方法：
                                <ol>
                                    <li><p><code>abstract Context createPackageContext(String
                                        packageName, int flags)</code> -- 返回一个新的上下文对象,
                                        和给定的包名应用包含相同的资源和类装入器, 可以访问这个包的资源，<b>此方法可用于实现动态主题，将主题打包到 apk
                                            中供用户下载安装，然后在主应用中访问。</b>(flags 为 <code>CONTEXT_INCLUDE_CODE</code>
                                        或者 <code>CONTEXT_IGNORE_SECURITY</code>),
                                        前提为两个应用拥有相同的签名与用户ID(指定 android:shareUserId="**")</p></li>
                                    <li><p><code>abstract Context createDisplayContext(Display
                                        display)</code> -- 返回一个新的上下文对象，但对其资源进行调整以匹配给定显示的度量, 参见: <a
                                            href="#sdk-Display">Display</a></p></li>
                                    <li><p><code>abstract Context
                                        createDeviceProtectedStorageContext()</code> --
                                        返回一个新的上下文对象，但它的存储API由设备保护存储支持</p></li>
                                    <li><p><code>abstract Context
                                        createConfigurationContext(Configuration
                                        overrideConfiguration)</code> --
                                        返回一个新的上下文对象，但对其资源进行调整以匹配给定的配置，<b>比如可以更改语言</b>, 参见: <a
                                                href="#sdk-Configuration">Configuration</a></p></li>
                                </ol>
                                <pre class="brush: java;">
// Activity 的　attachBaseContext 方法
@Override
protected void attachBaseContext(Context newBase) {
    Configuration newConfig = newBase.getResources().getConfiguration();
    Locale locale = new Locale("en");
    newConfig.setLocale(locale);// 修改 Configuration 的 Locale 为英语
    Context newContext = newBase.createConfigurationContext(newConfig);
    super.attachBaseContext(newContext);

    Log.d(TAG, getString(R.string.app_name));// 读取 values-en 下的 strings.xml
}
</pre>
                            </li>
                            <li>Context 上下文信息：
                                <ol start="5">
                                    <li><p><code>abstract Context getApplicationContext()</code> --
                                        返回真正的 Context 实现类 <code>ContextImpl</code> 的实例</p></li>
                                    <li><p><code>abstract ApplicationInfo
                                        getApplicationInfo()</code> -- 获取应用程序的信息, 参见：<a
                                            href="#sdk-ApplicationInfo">ApplicationInfo</a></p></li>
                                    <li><p><code>abstract ClassLoader getClassLoader()</code> --
                                        获取类加载器</p></li>
                                    <li><p><code>abstract Looper getMainLooper()</code> -- 获取主线程的
                                        Looper</p></li>
                                    <li><p><code>abstract PackageManager getPackageManager()</code>
                                        -- 获取包管理器</p></li>
                                    <li><p><code>abstract String getPackageName()</code> -- 获取当前应用包名
                                    </p></li>
                                    <li><p><code>abstract String getPackageResourcePath()</code> --
                                        获取当前应用资源路径</p></li>
                                    <li><p><code>abstract String getPackageCodePath()</code> --
                                        获取当前应用代码路径</p></li>
                                    <li><p><code>boolean isRestricted()</code> -- 指示此上下文是否受限制， 参照
                                        <code>createPackageContext</code> 方法</p></li>
                                    <li><p><code>void registerComponentCallbacks(ComponentCallbacks
                                        callback)</code> -- 注册给应用程序的所有组件(Applicatoin, Activity,
                                        Service, Fragment ...)回调接口, 这个接口有两个方法：<code>onConfigurationChanged(Configuration
                                            newConfig)</code> 和 <code>onLowMemory()</code></p></li>
                                    <li><p><code>void
                                        unregisterComponentCallbacks(ComponentCallbacks
                                        callback)</code> -- 反注册回调接口</p></li>
                                    <li><p><code>abstract Object getSystemService(String
                                        name)</code> -- 获取系统服务</p></li>
                                    <li><p><code>final &lt;T&gt; T getSystemService(Class&lt;T>
                                        serviceClass)</code> -- 同上，API 23 添加</p></li>
                                    <li><p><code>abstract String getSystemServiceName(Class&lt;?>
                                        serviceClass)</code> -- 同上，API 23 添加</p></li>
                                </ol>
                                <pre class="brush: java;">
WindowManager wm = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
WindowManager wm = mContext.getSystemService(WindowManager.class);// API 23 添加更直观的方法
/** 当前可用的类有:
 * WindowManager(Context.WINDOW_SERVICE),
 * DownloadManager(Context.DOWNLOAD_SERVICE),
 * LayoutInflater(Context.LAYOUT_INFLATER_SERVICE),
 * NetworkStatsManager(Context.NETWORK_STATS_SERVICE)
 * WifiManager(Context.WIFI_SERVICE),
 * ConnectivityManager(Context.CONNECTIVITY_SERVICE),
 * ActivityManager(Context.ACTIVITY_SERVICE),
 * PowerManager(Context.POWER_SERVICE),
 * BatteryManager(Context.BATTERY_SERVICE),
 * AlarmManager(Context.ALARM_SERVICE),
 * NotificationManager(Context.NOTIFICATION_SERVICE),
 * KeyguardManager(Context.KEYGUARD_SERVICE),
 * InputMethodManager(Context.INPUT_METHOD_SERVICE),
 * LocationManager(Context.LOCATION_SERVICE),
 * SearchManager(Context.SEARCH_SERVICE),
 * AudioManager(Context.AUDIO_SERVICE),
 * Vibrator(Context.VIBRATOR_SERVICE),
 * MediaRouter(Context.MEDIA_ROUTER_SERVICE),
 * TelephonyManager(Context.TELEPHONY_SERVICE),
 * SubscriptionManager(Context.TELEPHONY_SUBSCRIPTION_SERVICE),
 * UiModeManager(Context.UI_MODE_SERVICE),
 * JobScheduler(Context.JOB_SCHEDULER_SERVICE),
 */
                                    </pre>
                            </li>
                            <li>Service, Activity, Broadcast, ContentProvider 相关方法：
                                <ol start="19">
                                    <li><p><code>abstract void startActivity(Intent intent)</code>
                                        -- 启动一个新的 Activity</p></li>
                                    <li><p><code>abstract void startActivity(Intent intent, Bundle
                                        options)</code> -- API 16 添加，同上，附加参数</p></li>
                                    <li><p><code>abstract void startActivities(Intent[]
                                        intents)</code> -- API 11 添加，启动多个 Activity</p></li>
                                    <li><p><code>abstract void startActivities(Intent[] intents,
                                        Bundle options)</code> -- API 16 添加，同上，附加参数</p></li>
                                    <li><p><code>abstract ComponentName startService(Intent
                                        service)</code> -- 启动 service</p></li>
                                    <li><p><code>abstract boolean stopService(Intent service)</code>
                                        -- 停止 service</p></li>
                                    <li><p><code>abstract boolean bindService(Intent service,
                                        ServiceConnection conn, int flags)</code> -- 绑定 service</p>
                                    </li>
                                    <li><p><code>abstract void unbindService(ServiceConnection
                                        conn)</code> -- 解绑 service</p></li>
                                    <li><p><code>abstract void sendBroadcast(Intent intent)</code>
                                        -- 发送广播</p></li>
                                    <li><p><code>abstract void sendBroadcast(Intent intent, String
                                        receiverPermission)</code> -- 发送指定权限广播</p></li>
                                    <li><p><code>abstract void sendBroadcastAsUser(Intent intent,
                                        UserHandle user)</code> -- 发送广播给指定用户</p></li>
                                    <li><p><code>abstract void sendBroadcastAsUser(Intent intent,
                                        UserHandle user, String receiverPermission)</code> --
                                        发送广播给指定有权限接收的用户</p></li>
                                    <li><p><code>abstract void sendOrderedBroadcast(Intent intent,
                                        String receiverPermission)</code> -- 发送有序广播</p></li>
                                    <li><p><code>abstract void sendOrderedBroadcast(Intent intent,
                                        String receiverPermission, BroadcastReceiver resultReceiver,
                                        Handler scheduler, int initialCode, String initialData,
                                        Bundle initialExtras)</code> -- 发送有序广播</p></li>
                                    <li><p><code>abstract void sendOrderedBroadcastAsUser(Intent
                                        intent, UserHandle user, String receiverPermission,
                                        BroadcastReceiver resultReceiver, Handler scheduler, int
                                        initialCode, String initialData, Bundle
                                        initialExtras)</code> -- 发送有序广播</p></li>
                                    <li><p><code>abstract void sendStickyBroadcast(Intent
                                        intent)</code> -- API 21 后不推荐使用</p></li>
                                    <li><p><code>abstract void removeStickyBroadcast(Intent
                                        intent)</code> -- API 21 后不推荐使用</p></li>
                                    <li><p><code>abstract void sendStickyBroadcastAsUser(Intent
                                        intent, UserHandle user)</code> -- API 21 后不推荐使用</p></li>
                                    <li><p><code>abstract void sendStickyOrderedBroadcast(Intent
                                        intent, BroadcastReceiver resultReceiver, Handler scheduler,
                                        int initialCode, String initialData, Bundle
                                        initialExtras)</code> -- API 21 后不推荐使用</p></li>
                                    <li><p><code>abstract void
                                        sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle
                                        user, BroadcastReceiver resultReceiver, Handler scheduler,
                                        int initialCode, String initialData, Bundle
                                        initialExtras)</code> -- API 21 后不推荐使用</p></li>
                                    <li><p><code>abstract void removeStickyBroadcastAsUser(Intent
                                        intent, UserHandle user)</code> -- API 21 后不推荐使用</p></li>
                                    <li><p><code>abstract Intent registerReceiver(BroadcastReceiver
                                        receiver, IntentFilter filter)</code> -- 注册广播接收者</p></li>
                                    <li><p><code>abstract Intent registerReceiver(BroadcastReceiver
                                        receiver, IntentFilter filter, String broadcastPermission,
                                        Handler scheduler)</code> -- 注册广播接收者</p></li>
                                    <li><p><code>abstract void unregisterReceiver(BroadcastReceiver
                                        receiver)</code> -- 取消广播接收者</p></li>
                                    <li><p><code>abstract ContentResolver
                                        getContentResolver()</code> -- 获取 ContentResolver</p></li>
                                    <li><p><code>abstract boolean startInstrumentation(ComponentName
                                        className, String profileFile, Bundle arguments)</code> --
                                        主要用于自动化测试</p></li>
                                    <li><p><code>abstract void startIntentSender(IntentSender
                                        intent, Intent fillInIntent, int flagsMask, int flagsValues,
                                        int extraFlags, Bundle options)</code> -- 类似 startActivity
                                    </p></li>
                                    <li><p><code>abstract void startIntentSender(IntentSender
                                        intent, Intent fillInIntent, int flagsMask, int flagsValues,
                                        int extraFlags)</code> -- 同上</p></li>
                                </ol>
                            </li>
                            <li>Context 权限相关方法(<code>check</code> 开头的方法只检查权限，<code>enforce</code>
                                开头的方法无权限抛出异常)：
                                <ol start="47">
                                    <li><p><code>abstract int checkCallingOrSelfPermission(String
                                        permission)</code> -- 确定是否已获得特定权限, 结果为：<code>PackageManager.PERMISSION_GRANTED</code>
                                        和 <code>PackageManager.PERMISSION_DENIED</code></p></li>
                                    <li><p><code>abstract int checkSelfPermission(String
                                        permission)</code> -- API 23 添加，确定是否已获得特定权限</p></li>
                                    <li><p><code>abstract int checkCallingPermission(String
                                        permission)</code> -- 确定正在处理的 IPC 的调用过程是否已授予特定权限,
                                        如果当前不处理IPC，这个函数将总是失败</p></li>
                                    <li><p><code>abstract int checkCallingUriPermission(Uri uri, int
                                        modeFlags)</code> -- 用来检测自己或者调用进程中是否授予了指定权限</p></li>
                                    <li><p><code>abstract int checkCallingOrSelfUriPermission(Uri
                                        uri, int modeFlags)</code> -- 用来检测自己或者调用进程中是否授予了一个 uri 通过
                                        modeFlags 指定的权限</p></li>
                                    <li><p><code>abstract int checkPermission(String permission, int
                                        pid, int uid)</code> -- 用来检测指定 uid 和 pid 的进程中是否授予了指定的权限</p>
                                    </li>
                                    <li><p><code>abstract int checkUriPermission(Uri uri, int pid,
                                        int uid, int modeFlags)</code> -- 用来检测指定 uid 和 pid
                                        的进程中是否授予了一个 uri 通过 modeFlags 指定的权限</p></li>
                                    <li><p><code>abstract int checkUriPermission(Uri uri, String
                                        readPermission, String writePermission, int pid, int uid,
                                        int modeFlags)</code> -- 相当于同时调用 <code>checkPermission(String,
                                        int, int)</code> 和 <code>checkUriPermission(Uri, int, int,
                                        int)</code></p></li>
                                    <li><p><code>abstract void revokeUriPermission(Uri uri, int
                                        modeFlags)</code> -- 移除一个 Uri 权限</p></li>
                                    <li><p><code>abstract void grantUriPermission(String toPackage,
                                        Uri uri, int modeFlags)</code> -- 授予一个 Uri 权限</p></li>
                                    <li><p><code>abstract void enforceCallingOrSelfUriPermission(Uri
                                        uri, int modeFlags, String message)</code> -- 对应上面的 check 方法
                                    </p></li>
                                    <li><p><code>abstract void enforceCallingPermission(String
                                        permission, String message)</code> -- 对应上面的 check 方法</p>
                                    </li>
                                    <li><p><code>abstract void enforceCallingUriPermission(Uri uri,
                                        int modeFlags, String message)</code> -- 对应上面的 check 方法</p>
                                    </li>
                                    <li><p><code>abstract void enforcePermission(String permission,
                                        int pid, int uid, String message)</code> -- 对应上面的 check 方法
                                    </p></li>
                                    <li><p><code>abstract void enforceUriPermission(Uri uri, String
                                        readPermission, String writePermission, int pid, int uid,
                                        int modeFlags, String message)</code> -- 对应上面的 check 方法</p>
                                    </li>
                                    <li><p><code>abstract void enforceUriPermission(Uri uri, int
                                        pid, int uid, int modeFlags, String message)</code> -- 对应上面的
                                        check 方法</p></li>
                                </ol>
                                <pre class="brush: java;">
/** API 23 及以后 danger 的权限要动态申请 */
int recordAudioPermissionResult = checkCallingOrSelfPermission(Manifest.permission.RECORD_AUDIO);
if (PackageManager.PERMISSION_DENIED == recordAudioPermissionResult) {
    ActivityCompat.requestPermissions(MainActivity.this,
            new String[]{Manifest.permission.RECORD_AUDIO},
            MY_PERMISSIONS_REQUEST_RECORD_AUDIO);
}

private static final int MY_PERMISSIONS_REQUEST_RECORD_AUDIO = 0x01;

/** Activity 的 onRequestPermissionsResult 方法 */
@Override
public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);

    switch (requestCode) {
        case MY_PERMISSIONS_REQUEST_RECORD_AUDIO:
            for (int permissionResult : grantResults) {
                Log.d(TAG, "" + permissionResult);
            }
            break;
    }
}
</pre>
                            </li>
                            <li>Context Database 和 SharedPreferences 相关方法：
                                <ol start="63">
                                    <li><p><code>abstract String[] databaseList()</code> --
                                        返回私有数据库数组</p></li>
                                    <li><p><code>abstract File getDatabasePath(String name)</code>
                                        -- 获致指定的数据库路径</p></li>
                                    <li><p><code>abstract SQLiteDatabase openOrCreateDatabase(String
                                        name, int mode, SQLiteDatabase.CursorFactory factory)</code>
                                        -- 打开或创建数据库</p></li>
                                    <li><p><code>abstract SQLiteDatabase openOrCreateDatabase(String
                                        name, int mode, SQLiteDatabase.CursorFactory factory,
                                        DatabaseErrorHandler errorHandler)</code> -- 打开或创建数据库</p>
                                    </li>
                                    <li><p><code>abstract boolean moveDatabaseFrom(Context
                                        sourceContext, String name)</code> -- API 24
                                        添加，从指定的上下文移动数据库，通常用于在升级之后在存储位置之间迁移数据</p></li>
                                    <li><p><code>abstract boolean deleteDatabase(String name)</code>
                                        -- 删除指定的数组库</p></li>
                                    <li><p><code>abstract SharedPreferences
                                        getSharedPreferences(String name, int mode</code> --
                                        指定模式打开配置文件</p></li>
                                    <li><p><code>abstract boolean moveSharedPreferencesFrom(Context
                                        sourceContext, String name)</code> -- API 24
                                        添加，从指定的上下文移动配置文件，通常用于在升级之后在存储位置之间迁移数据</p></li>
                                    <li><p><code>abstract boolean deleteSharedPreferences(String
                                        name)</code> -- API 24 添加，删除指定配置文件</p></li>
                                </ol>
                            </li>
                            <li>Context 主题和壁纸相关方法：
                                <ol start="72">
                                    <li><p><code>abstract Resources.Theme getTheme()</code> --
                                        获取当前的主题</p></li>
                                    <li><p><code>abstract void setTheme(int resid)</code> -- 设置主题
                                    </p></li>
                                    <li><p><code>abstract void setWallpaper(Bitmap bitmap)</code> --
                                        API 5 后不推荐使用, 使用 <a
                                                href="docs/reference/android/app/WallpaperManager.html">WallpaperManager</a>
                                        管理</p></li>
                                    <li><p><code>abstract void setWallpaper(InputStream data)</code>
                                        -- API 5 后不推荐使用, 使用 <a
                                                href="docs/reference/android/app/WallpaperManager.html">WallpaperManager</a>
                                        管理</p></li>
                                    <li><p><code>abstract Drawable getWallpaper()</code> -- API 5
                                        后不推荐使用, 使用 <a
                                                href="docs/reference/android/app/WallpaperManager.html">WallpaperManager</a>
                                        管理</p></li>
                                    <li><p><code>abstract Drawable peekWallpaper()</code> -- API 5
                                        后不推荐使用, 使用 <a
                                                href="docs/reference/android/app/WallpaperManager.html">WallpaperManager</a>
                                        管理</p></li>
                                    <li><p><code>abstract void clearWallpaper()</code> -- API 5
                                        后不推荐使用, 使用 <a
                                                href="docs/reference/android/app/WallpaperManager.html">WallpaperManager</a>
                                        管理</p></li>
                                    <li><p><code>abstract int
                                        getWallpaperDesiredMinimumWidth()</code> -- API 5 后不推荐使用, 使用
                                        <a href="docs/reference/android/app/WallpaperManager.html">WallpaperManager</a>
                                        管理</p></li>
                                    <li><p><code>abstract int
                                        getWallpaperDesiredMinimumHeight()</code> -- API 5 后不推荐使用,
                                        使用
                                        <a href="docs/reference/android/app/WallpaperManager.html">WallpaperManager</a>
                                        管理</p></li>
                                </ol>
                            </li>
                            <li>Context 文件与目录相关方法, 这里的文件目录都是和应用包名相关的，会根据应用卸载而删除：
                                <ol start="81">
                                    <li><p><code>abstract File getDir(String name, int mode)</code>
                                        -- 返回 <code>/data/data/youPackageName/</code> 下的指定名称的文件夹
                                        File 对象，如果该文件夹不存在则用指定名称创建一个新的文件夹</p></li>
                                    <li><p><code>abstract File getFilesDir()</code> -- 返回 <code>/data/data/youPackageName/files</code>
                                        的 File 对象</p></li>
                                    <li><p><code>abstract File getFileStreamPath(String name)</code>
                                        -- 返回 <code>/data/data/youPackageName/files/name</code> 的
                                        File 对象</p></li>
                                    <li><p><code>abstract FileInputStream openFileInput(String
                                        name)</code> -- 读 <code>files</code> 下的文件</p></li>
                                    <li><p><code>abstract FileOutputStream openFileOutput(String
                                        name, int mode)</code> -- 写 <code>files</code> 下的文件</p></li>
                                    <li><p><code>abstract String[] fileList()</code> -- 返回 <code>files</code>
                                        下的所有文件名</p></li>
                                    <li><p><code>abstract boolean deleteFile(String name)</code> --
                                        删除 <code>files</code> 下的指定文件</p></li>
                                    <li><p><code>abstract File getCacheDir()</code> -- 返回 <code>/data/data/youPackageName/cache</code>
                                        的 File 对象</p></li>
                                    <li><p><code>abstract File getCodeCacheDir()</code> -- API 21
                                        添加, 返回为存储缓存代码而设计的文件系统中特定于应用程序的缓存目录的绝对路径,
                                        用于存储应用程序在运行时生成的编译或优化代码的最佳位置</p></li>
                                    <li><p><code>abstract File getDataDir()</code> -- API 24 添加,
                                        应用程序的私有文件存储的绝对路径, 应用程序不应直接使用这个路径</p></li>
                                    <li><p><code>abstract File getNoBackupFilesDir()</code> -- API
                                        21 添加, 返回的文件系统类似 <code>getfilesdir()</code>
                                        目录的绝对路径。不同的是，在这个目录下的文件将被排除在自动备份到远程存储中</p></li>
                                    <li><p><code>abstract boolean isDeviceProtectedStorage()</code>
                                        -- API 24 添加, 指示此上下文的存储API是否受设备保护存储的支持</p></li>
                                    <li><p><code>abstract File getExternalCacheDir()</code> -- API 8
                                        添加, 应用卸载删除，外置 cache 目录<code>/storage/emulated/0/Android/data/yourPackage/cache</code>
                                    </p></li>
                                    <li><p><code>abstract File[] getExternalCacheDirs()</code> --
                                        API 19 添加, 上面的目录外加一个 null 的 file</p></li>
                                    <li><p><code>abstract File getExternalFilesDir(String
                                        type)</code> -- API 8 添加, 应用卸载删除，外置文件目录<code>/storage/emulated/0/Android/data/yourPackage/files</code>
                                    </p>
                                        <pre class="brush: java;">
/** type 其实为子目录
 * 推荐的 type 参数使用 Environment 的如下变量：
 * DIRECTORY_MUSIC, DIRECTORY_PODCASTS, DIRECTORY_RINGTONES, DIRECTORY_ALARMS,
 * DIRECTORY_NOTIFICATIONS, DIRECTORY_PICTURES, DIRECTORY_MOVIES
 */
Log.d(TAG, getExternalFilesDir(null));
Log.d(TAG, getExternalFilesDir("xxxxxx"));
Log.d(TAG, getExternalFilesDir(Environment.DIRECTORY_MUSIC));
Log.d(TAG, getExternalFilesDir(Environment.DIRECTORY_PICTURES));
/** 上面的输出为：
 * /storage/emulated/0/Android/data/com.lesson1234.myapplication/files
 * /storage/emulated/0/Android/data/com.lesson1234.myapplication/files/xxxxxx
 * /storage/emulated/0/Android/data/com.lesson1234.myapplication/files/Music
 * /storage/emulated/0/Android/data/com.lesson1234.myapplication/files/Pictures
 */
</pre>
                                    </li>
                                    <li><p><code>abstract File[] getExternalFilesDirs(String
                                        type)</code> -- API 19 添加, 上面的目录外加一个 null 的 file</p></li>
                                    <li><p><code>abstract File getObbDir()</code> -- API 11 添加,
                                        应用卸载删除，外置应用存储目录 <code>/storage/emulated/0/Android/obb/yourPackage</code>
                                    </p></li>
                                    <li><p><code>abstract File[] getObbDirs()</code> -- API 19 添加,
                                        上面的目录外加一个 null 的 file</p></li>
                                    <li><p><code>abstract File[] getExternalMediaDirs(String
                                        type)</code> -- API 21 添加, 外部媒体目录</p></li>

                                </ol>
                            </li>
                            <li>Context 资源相关方法：
                                <ol start="100">
                                    <li><p><code>abstract Resources getResources()</code> --
                                        返回应用程序包的 Resources 实例, 参见： <a
                                                href="#android-content-Resources">Recources</a></p>
                                    </li>
                                    <li><p><code>abstract AssetManager getAssets()</code> --
                                        返回应用程序包的 AssetManager 实例, 参见： <a href="#sdk-AssetManager">AssetManager</a>
                                    </p></li>
                                    <li><p><code>final Drawable getDrawable(int id)</code> -- 调用
                                        Resourcs 的 <code>getDrawable(id, theme)</code> 方法</p></li>
                                    <li><p><code>final int getColor(int id)</code> -- 调用 Resourcs 的
                                        <code>getColor(id, theme)</code> 方法</p></li>
                                    <li><p><code>final ColorStateList getColorStateList(int
                                        id)</code> -- 调用 Resourcs 的 <code>getColorStateList(id,
                                        theme)</code> 方法</p></li>
                                    <li><p><code>final String getString(int resId)</code> -- 调用
                                        Resourcs 的 <code>getString(id)</code> 方法</p></li>
                                    <li><p><code>final String getString(int resId, Object...
                                        formatArgs)</code> -- 调用 Resourcs 的 <code>getString(resId,
                                        formatArgs)</code> 方法</p></li>
                                    <li><p><code>final CharSequence getText(int resId)</code> -- 调用
                                        Resourcs 的 <code>getText(id)</code> 方法</p></li>
                                    <li><p><code>final TypedArray obtainStyledAttributes(int[]
                                        attrs)</code> -- 调用 Resourcs.Theme 的 <code>obtainStyledAttributes(attrs)</code>
                                        方法</p></li>
                                    <li><p><code>final TypedArray obtainStyledAttributes(int resid,
                                        int[] attrs)</code> -- 调用 Resourcs.Theme 的 <code>obtainStyledAttributes(resid,
                                        attrs)</code> 方法</p></li>
                                    <li><p><code>final TypedArray
                                        obtainStyledAttributes(AttributeSet set, int[] attrs)</code>
                                        -- 调用 Resourcs.Theme 的 <code>obtainStyledAttributes(set,
                                            attrs)</code> 方法</p></li>
                                    <li><p><code>final TypedArray
                                        obtainStyledAttributes(AttributeSet set, int[] attrs, int
                                        defStyleAttr, int defStyleRes)</code> -- 调用 Resourcs.Theme 的
                                        <code>obtainStyledAttributes(set, attrs, defStyleAttr,
                                            defStyleRes)</code> 方法</p></li>
                                </ol>
                            </li>
                        </ol>
                    </div>

                    <div class="sub-item">
                        <p>Context 相关类：</p>
                        <ol>
                            <li><a id="sdk-Display" class="offset"></a>
                                <p><a href="docs/reference/android/view/Display.html">Display</a> --
                                    提供有关逻辑显示的大小和密度的信息</p>
                                <pre class="brush: java;">
Display mDisplay = mActivity.getWindowManager().getDefaultDisplay();

DisplayMetrics mMetrics = new DisplayMetrics();
mDisplay.getMetrics(mMetrics);
Log.d(TAG, mMetrics.toString());
int appHeight = mMetrics.heightPixels;

mDisplay.getRealMetrics(mMetrics);      // API 17 添加的方法, API 17 和可用如下方法计算虚拟按键高度计算
Log.d(TAG, mMetrics.toString());
int screenHeight = mMetrics.heightPixels;

int navigationBarHeight = screenHeight - appHeight;     // 虚拟按键高度计算

/** 状态栏的高度可以从系统资源获取 */
public static int getStatusBarHeight(Context context) {
    int resourceId = context.getResources().getIdentifier("status_bar_height", "dimen", "android");
    if (resourceId > 0) {
        return context.getResources().getDimensionPixelSize(resourceId);
    }
    return 0;
}
</pre>
                            </li>
                            <li><a id="sdk-Configuration" class="offset"></a>
                                <p><a href="docs/reference/android/content/res/Configuration.html">Configuration</a>
                                    -- 该类描述所有可能影响应用程序检索资源的设备配置信息,
                                    包括用户指定的配置选项（区域列表和缩放）以及设备配置（如输入模式、屏幕大小和屏幕方向）。</p>
                                <pre class="brush: java;">
/** 动态更改 Activity 的横竖屏 */
mActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
mActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);

/** Activity 的　onConfigurationChanged　方法 */
@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);

    String screen = newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE ? "横屏" : "竖屏";
    Log.d(TAG, screen);
}

/** Configuration 的属性 */
Configuration cfg = mContext.getResources().getConfiguration();
StringBuffer status = new StringBuffer();
status.append("densityDpi:" + cfg.densityDpi + "\n");
status.append("fontScale:" + cfg.fontScale + "\n");
status.append("hardKeyboardHidden:" + cfg.hardKeyboardHidden + "\n");
status.append("keyboard:" + cfg.keyboard + "\n");
status.append("keyboardHidden:" + cfg.keyboardHidden + "\n");
status.append("locale:" + cfg.locale + "\n");
status.append("mcc:" + cfg.mcc + "\n");
status.append("mnc:" + cfg.mnc + "\n");
status.append("navigation:" + cfg.navigation + "\n");
status.append("navigationHidden:" + cfg.navigationHidden + "\n");
status.append("orientation:" + cfg.orientation + "\n");
status.append("screenHeightDp:" + cfg.screenHeightDp + "\n");
status.append("screenWidthDp:" + cfg.screenWidthDp + "\n");
status.append("screenLayout:" + cfg.screenLayout + "\n");
status.append("smallestScreenWidthDp:" + cfg.densityDpi + "\n");
status.append("touchscreen:" + cfg.densityDpi + "\n");
status.append("uiMode:" + cfg.densityDpi + "\n");
Log.d(TAG, status.toString());
</pre>
                            </li>
                            <li><a id="sdk-ApplicationInfo" class="offset"></a>
                                <p><a href="docs/reference/android/content/pm/ApplicationInfo.html">ApplicationInfo</a>
                                    -- 可以检索特定应用程序的信息</p>
                                <pre class="brush: java;">
ApplicationInfo info = mContext.getApplicationInfo();
StringBuffer buffer = new StringBuffer();
buffer.append("packageName:" + info.packageName + "\n")
        .append("uid:" + info.uid + "\n")
        .append("theme:" + info.theme + "\n")
        .append("targetSdkVersion:" + info.targetSdkVersion + "\n")
        .append("sourceDir:" + info.sourceDir + "\n")
        .append("publicSourceDir:" + info.publicSourceDir + "\n")
        .append("nativeLibraryDir:" + info.nativeLibraryDir + "\n")
        .append("dataDir:" + info.dataDir + "\n")
        .append("processName:" + info.processName + "\n")
        .append("permission:" + info.permission + "\n")
        .append("uiOptions:" + info.uiOptions + "\n")
        .append("className:" + info.className);
Log.d(TAG, buffer.toString());
</pre>
                            </li>
                            <li><a id="sdk-AssetManager" class="offset"></a>
                                <p><a href="docs/reference/android/content/res/AssetManager.html">AssetManager</a>
                                    -- 提供对应用程序原始资源文件的访问，<code>assets</code> 目录下的文件访问</p>
                                <pre class="brush: java;">
/** 1.列出 assets 相对目录下的文件名 */
for(String item : am.list("fonts")){
    Log.d(TAG, item);// assets/fonts/
}

/** 2.打开文件
 * open(String fileName, int accessMode) -- 读取文件
 *      ACCESS_STREAMING -- 顺序阅读，偶尔向前寻找
 *      ACCESS_BUFFER -- 试图将内容加载到内存中，以便快速读取
 *      ACCESS_RANDOM -- 阅读大块，向前和向后寻找
 *      ACCESS_UNKNOWN -- 没有关于如何访问数据的特定信息
 * open(String fileName) -- 调用 open(fileName, ACCESS_STREAMING)
 */
InputStream is = am.open("read_asset.txt");
BufferedReader br = new BufferedReader(new InputStreamReader(is));
String tmp = null;
StringBuffer sb = new StringBuffer();
while((tmp = br.readLine()) != null) {
    sb.append(tmp + "\n");
}
am.close();
Log.d(TAG, sb.toString());

/** 3. xml 和 文件描述符
 * openXmlResourceParser(xmlFileName) -- 读取 xml 文件
 * openFd(String fileName) -- AssetFileDescriptor 方式打开文件
 *      AssetFileDescriptor 有一个 getFileDescriptor() 方法，它的返回为
 *      FileDescriptor, 是文件描述符，可通过它对文件期待访问
 * openNonAssetfd(String filaName) -- 可以打开 res/ 下的文件，这个 api 系统应用才能使用

 */
</pre>
                            </li>
                        </ol>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-content-Resources"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Resources</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
<pre class="brush: java;">
java.lang.Object
	android.content.res.Resources

public class Resources {
    public Resources(AssetManager assets, DisplayMetrics metrics, Configuration config) () {}

    /** 内部类 */
    class Resources.NotFoundException {}
    class Resources.Theme {}
}
</pre>
                        <p>Android 应用程序资源可以分为两大类，分别是 assets 和 res。</p>
                        <ul>
                            <li><p>assets 类资源放在工程根目录的 assets
                                子目录下，它里面保存的是一些原始的文件，可以以任何方式来进行组织。这些文件最终会被原装不动地打包在 apk 文件中。</p></li>
                            <li><p>
                                res类资源放在工程根目录的res子目录下，它里面保存的文件大多数都会被编译，并且都会被赋予资源ID。这样我们就可以在程序中通过ID来访问res类的资源。</p>
                            </li>
                        </ul>
                        <p>res 类资源按照不同的用途可以进一步划分为以下 9 + 1 种子类型：</p>
                        <ul>
                            <li><p><code>animator</code> -- 以 XML 文件保存在 <code>res/animator</code>
                                目录下，用来描述属性动画。参见：<a href="animation.html"
                                                   target="_blank">Animation</a></p>
                                <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;!-- 属性动画 xml 支持 4 个标签(标签可单独使用): animator, objectAnimator, set, selector
&lt;selector xmlns:android="http://schemas.android.com/apk/res/android">
    &lt;item android:state_pressed="true" android:animation="@anim/fade"/>
    &lt;item android:animation="@anim/fade"/>
&lt;/selector>
-->
&lt;set           <!-- 对应 android.animation.AnimatorSet  -->
    android:ordering="sequentially|together"   <!-- 顺序启动或同时启动, set 支持嵌套 -->
    xmlns:android="http://schemas.android.com/apk/res/android">
    &lt;animator  <!-- 对应 android.animation.ValueAnimator -->
        android:duration="3000"         <!-- 总时长 -->
        android:valueFrom="0"           <!-- 开始值 -->
        android:valueTo="99"            <!-- 结束值 -->
        android:valueType="intType|floatType|colorType|pathType"    <!-- 值类型 -->
        android:repeatCount="1"         <!-- 重复次数 -->
        android:repeatMode="restart|reverse"    <!-- 重复模式-->
        android:startOffset="1000"      <!-- 等待多长时间启动 -->
        android:interpolator="@android:interpolator/accelerate_decelerate" >    <!-- 插值器 -->

        &lt;propertyValuesHolder
                android:propertyName="name"
                android:valueType="intType"
                android:valueTo="0"
                android:valueFrom="99" >

                &lt;keyframe android:value="100" android:valueType="intType" />
                &lt;keyframe android:value="100" android:valueType="intType" />
        &lt;/propertyValuesHolder>
    &lt;/animator>


    &lt;objectAnimator    <!-- 对应 android.animation.ObjectAnimator -->
        android:duration="3000"         <!-- 总时长 -->
        android:valueFrom="0"           <!-- 开始值 -->
        android:valueTo="99"            <!-- 结束值 -->
        android:valueType="intType|floatType|colorType|pathType"    <!-- 值类型 -->
        android:repeatCount="1"         <!-- 重复次数 -->
        android:repeatMode="restart|reverse"    <!-- 重复模式-->
        android:startOffset="1000"      <!-- 等待多长时间启动 -->
        android:interpolator="@android:interpolator/accelerate_decelerate"    <!-- 插值器 -->
        android:pathData=""             <!--  -->
        android:propertyName=""         <!-- 应用的属性 -->
        android:propertyXName=""        <!--  -->
        android:propertyYName="" >     <!--  -->

            &lt;propertyValuesHolder
                android:propertyName="name"
                android:valueType="intType"
                android:valueTo="0"
                android:valueFrom="99" >

                &lt;keyframe android:value="100" android:valueType="intType" />

        &lt;/propertyValuesHolder>
    &lt;/animator>
&lt;/set>
                                </pre>
                            </li>
                            <li><p><code>anim</code> -- 以 XML 文件保存在 <code>res/anim</code>
                                目录下，用来描述补间动画。参见：<a href="animation.html"
                                                   target="_blank">Animation</a></p>
                                <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;!-- 补间动画 xml 支持的标签(标签可单独使用): alpha, translate, scale, rotate, set, ...
    Animation 支持的属性为公有属性
    不同的 sdk 版本还运行一些不同的标签，如：layoutAnimation, gridLayoutAnimation,
    linearInterpolator, cycleInterpolator, pathInterpolator, overshootInterpolator,
    decelerateInterpolator, anticipateInterpolator, anticipateOvershootInterpolator,
    accelerateInterpolator, accelerateDecelerateInterpolator ...
 -->
&lt;set
    android:startOffset="100"
    android:repeatMode="reverse|restart"
    android:fillBefore="true|false"
    android:fillAfter="true|false"
    android:shareInterpolator="true|false"
    xmlns:android="http://schemas.android.com/apk/res/android">

    &lt;!-- android.view.animation.AlphaAnimation -->
    &lt;alpha
        android:interpolator="@android:anim/accelerate_interpolator"
        android:fromAlpha="0.0"
        android:toAlpha="1.0"
        android:duration="100"/>

    &lt;!-- android.view.animation.ScaleAnimation -->
    &lt;scale
        android:fromXScale="1.0"
        android:toXScale="2.0"
        android:fromYScale="1.0"
        android:toYScale="2.0"
        android:pivotX="10"
        android:duration="100"
        android:pivotY="10"/>

    &lt;!-- android.view.animation.TranslateAnimation -->
    &lt;translate
        android:fromXDelta="0"
        android:toXDelta="100"
        android:fromYDelta="0"
        android:duration="100"
        android:toYDelta="200"/>

    &lt;!-- android.view.animation.RotateAnimation -->
    &lt;rotate
        android:fromDegrees="0"
        android:toDegrees="60"
        android:pivotX="10"
        android:duration="100"
        android:pivotY="10"/>
&lt;/set>
</pre>
                            </li>
                            <li><p><code>color</code> -- 以 XML 文件保存在 <code>res/color</code>
                                目录下，用描述对象颜色状态。</p>
                                <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;selector>
    &lt;item android:color="#FF0000" android:state_pressed="true" />
    &lt;item android:color="#000000"/>
&lt;/selector>
</pre>
                            </li>
                            <li><p><code>drawable</code> -- 以 XML 或者 Bitmap 文件保存在
                                <code>res/drawable</code> 目录下，用来描述可绘制对象。参见：<a href="drawable.html"
                                                                              target="_blank">Drawable</a>
                            </p>
                                <pre class="brush: xml;">
&lt;selector />         <!-- android.graphics.drawable.StateListDrawable -->
&lt;drawable />         <!-- android.graphics.drawable.Drawable -->
&lt;shape />            <!-- android.graphics.drawable.ShapeDrawable -->
&lt;bitmap />           <!-- android.graphics.drawable.BitmapDrawable -->
&lt;scale />            <!-- android.graphics.drawable.ScaleDrawable -->
&lt;rotate />           <!-- android.graphics.drawable.RotateDrawable -->
&lt;transition />       <!-- android.graphics.drawable.TransitionDrawable -->
&lt;color />            <!-- android.graphics.drawable.ColorDrawable -->
&lt;clip />             <!-- android.graphics.drawable.ClipDrawable -->
&lt;inset />            <!-- android.graphics.drawable.InsetDrawable -->
&lt;animation-list />   <!-- android.graphics.drawable.AnimationDrawable -->
&lt;animated-selector /><!-- AnimatedStateListDrawable -->
&lt;animated-rotate />  <!--  -->
&lt;animated-vector />  <!-- android.graphics.drawable.AnimatedVectorDrawable -->
&lt;layer-list />       <!-- android.graphics.drawable.LayerDrawable -->
&lt;level-list />       <!-- android.graphics.drawable.LevelListDrawable -->
&lt;nine-patch />       <!-- android.graphics.drawable.NinePatchDrawable -->
&lt;ripple />           <!-- android.graphics.drawable.RippleDrawable -->
&lt;vector />           <!-- android.graphics.drawable.VectorDrawable -->
                                </pre>
                            </li>
                            <li><p><code>mipmap</code> -- 以 Bitmap 文件保存在 <code>res/mipmap</code>
                                目录下, 只用来放置不同密度启动器图标</p></li>
                            <li><p><code>layout</code> -- 以 XML 文件保存在 <code>res/layout</code>
                                目录下，用来描述应用程序界面布局。</p></li>
                            <li><p><code>menu</code> -- 以 XML 文件保存在 <code>res/menu</code>
                                目录下，用来描述应用程序菜单。</p></li>
                            <li><p><code>raw</code> -- 以任意格式的文件保存在 <code>res/raw</code> 目录下，它们和
                                assets 类资源一样，都是原装不动地打包在 apk 文件中的，不过它们会被赋予资源 ID，这样我们就可以在程序中通过ID来访问它们。
                            </p></li>
                            <li><p><code>values</code> -- 以 XML 文件保存在 <code>res/values</code>
                                目录下，用来描述一些简单值，例如，数组、颜色、尺寸、字符串和样式值等，一般来说，这六种不同的值可以分别保存在名称为
                                arrays.xml、colors.xml、dimens.xml、strings.xml 和 styles.xml 文件中。参见：<a
                                        href="#sdk-values">获取 values 资源</a></p></li>
                            <li><p><code>xml</code> -- 以 XML 文件保存在 <code>res/xml</code>
                                目录下，一般就是用来描述应用程序的配置信息。</p></li>
                        </ul>
                        <p>Android
                            支持若干配置限定符，您可以通过使用短划线分隔每个限定符，向一个目录名称添加多个限定符。下表按优先顺序列出了有效的配置限定符；如果对资源目录使用多个限定符，则必须按照表中列出的顺序将它们添加到目录名称。 </p>
                        <table class="table table-responsive table-bordered">
                            <tr>
                                <td><b>配置</b></td>
                                <td><b>说明</b></td>
                                <td><b>示例</b></td>
                            </tr>
                            <tr>
                                <td>MCC 和 MNC</td>
                                <td>移动国家代码(MCC)<br>移动网络代码(MNC)</td>
                                <td><code>mcc310</code> --
                                    美国的任一运营商<br><br><code>mcc310-mnc004</code> -- 美国的 Verizon 公司<br><br><code>mcc208-mnc00</code>
                                    -- 法国的 Orange 公司
                                </td>
                            </tr>
                            <tr>
                                <td>语言和区域</td>
                                <td>语言通过由两个字母组成的语言代码定,<br>可以选择后跟两个字母组成的区域码(前带小写字母"r")。</td>
                                <td><code>en</code>, <code>en-rUS</code>,
                                    <code>en-rGB</code><br><br><code>zh</code>, <code>zh_rCN</code>,
                                    <code>zh_rTW</code></td>
                            </tr>
                            <tr>
                                <td>布局方向</td>
                                <td>应用的布局方向, 从左到可或从右到左<br><span class="text-warning">此项为 API 级别 17 中新增配置</span>
                                </td>
                                <td><code>ldrtl</code> -- 从右到左<br><br><code>ldltr</code> -- 从左到右
                                </td>
                            </tr>
                            <tr>
                                <td>smallestWidth</td>
                                <td>是屏幕可用高度和宽度的最小尺寸;<br>设备的 smallestWidth 不会随屏幕方向的变化而改变;<br>应用为多个资源目录提供不同的
                                    smallestWidth 限定符值时，<br>系统会使用最接近但未超出设备的值。 <br><span
                                            class="text-warning">此项为 API 级别 13 中新增配置</span></td>
                                <td><code>sw320dp</code><br><br><code>sw480dp</code></td>
                            </tr>
                            <tr>
                                <td>可用宽度</td>
                                <td>指定资源应该使用的最小可用屏幕宽度;<br>在横向和纵向之间切换时，此配置值也会随之发生变化;<br><span
                                        class="text-warning">此项为 API 级别 13 中新增配置</span></td>
                                <td><code>w360dp</code><br><br><code>w480dp</code></td>
                            </tr>
                            <tr>
                                <td>可用高度</td>
                                <td>指定资源应该使用的最小可用屏幕高度;<br>在横向和纵向之间切换时，此配置值也会随之发生变化;<br><span
                                        class="text-warning">此项为 API 级别 13 中新增配置</span></td>
                                <td><code>w720dp</code><br><br><code>w1024dp</code></td>
                            </tr>
                            <tr>
                                <td>屏幕尺寸</td>
                                <td>small：尺寸类似于低密度 QVGA 屏幕的屏幕,<br>小屏幕的最小布局尺寸约为 320x426 dp
                                    单位;<br><br>normal：尺寸类似于中等密度 HVGA 屏幕的屏幕,<br>标准屏幕的最小布局尺寸约为 320x470
                                    dp 单位;<br><br>large：尺寸类似于中等密度 VGA 屏幕的屏幕, <br>大屏幕的最小布局尺寸约为
                                    480x640 dp 单位;<br><br>xlarge：明显大于传统中等密度 HVGA 屏幕的屏幕，<br>超大屏幕的最小布局尺寸约为
                                    720x960 dp 单位。<br><br><span class="text-warning">此项为 API 级别 4 中新增配置</span>
                                </td>
                                <td>
                                    <code>small</code><br><br><code>normal</code><br><br><code>large</code><br><br><code>xlarge</code>
                                </td>
                            </tr>
                            <tr>
                                <td>屏幕纵横比</td>
                                <td>long：宽屏，如 WQVGA、WVGA、FWVGA<br><br>notlong：非宽屏，如 QVGA、HVGA 和
                                    VGA<br><br>完全基于屏幕的纵横比，而与屏幕方向无关<br><br><span
                                            class="text-warning">此项为 API 级别 4 中新增配置</span></td>
                                <td><code>long</code><br><br><code>notlong</code></td>
                            </tr>
                            <tr>
                                <td>圆形屏幕</td>
                                <td>
                                    round：圆形屏幕，例如圆形可穿戴式设备<br><br>
                                    notround：方形屏幕，例如手机或平板电脑<br><br>
                                    <span class="text-warning">此项为 API 级别 23 中新增配置。</span></td>
                                <td><code>round</code><br><br><code>notround</code></td>
                            </tr>
                            <tr>
                                <td>屏幕方向</td>
                                <td>port：设备处于纵向（垂直）<br><br>
                                    land：设备处于横向（水平）
                                </td>
                                <td><code>port</code><br><br><code>land</code></td>
                            </tr>
                            <tr>
                                <td>UI 模式</td>
                                <td>

                                    car：设备正在车载手机座上显示<br><br>
                                    desk：设备正在桌面手机座上显示<br><br>
                                    television：设备正在电视上显示<br><br>
                                    appliance：设备用作不带显示屏的装置<br><br>
                                    watch：设备配有显示屏，戴在手腕上<br><br>

                                    <span class="text-warning">此项为 API 级别 8 中新增配置，API 13 中新增电视配置，API 20 中新增手表配置</span>
                                </td>
                                <td><code>car</code><br><br>
                                    <code>desk</code><br><br>
                                    <code>television</code><br><br>
                                    <code>appliance</code><br><br> <code>watch</code><br><br></td>
                            </tr>
                            <tr>
                                <td>夜间模式</td>
                                <td>

                                    night：夜间<br><br>
                                    notnight：白天<br><br>

                                    <span class="text-warning">此项为 API 级别 8 中新增配置。</span>
                                </td>
                                <td>
                                    <code>night</code><br><br>
                                    <code>notnight</code><br><br>
                                </td>
                            </tr>
                            <tr>
                                <td>屏幕像素密度</td>
                                <td>

                                    ldpi：低密度屏幕；约为 120dpi。<br><br>
                                    mdpi：中等密度（传统 HVGA）屏幕；约为 160dpi。<br><br>
                                    hdpi：高密度屏幕；约为 240dpi。<br><br>
                                    xhdpi：超高密度屏幕；约为 320dpi。此项为 API 级别 8 中新增配置<br><br>
                                    xxhdpi：超超高密度屏幕；约为 480dpi。此项为 API 级别 16 中新增配置<br><br>
                                    xxxhdpi：超超超高密度屏幕使用；约为 640dpi。 此项为 API 级别 18 中新增配置<br><br>
                                    nodpi：它可用于您不希望缩放以匹配设备密度的位图资源。<br><br>
                                    tvdpi：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。主要用于电视，此项为 API 级别 13
                                    中新增配置<br><br>
                                    anydpi：此限定符适合所有屏幕密度，其优先级高于其他限定符。这对于矢量可绘制对象很有用。 此项为 API 级别 21
                                    中新增配置
                                </td>
                                <td>
                                    <code>ldpi</code><br><br>
                                    <code>mdpi</code><br><br>
                                    <code>hdpi</code><br><br>
                                    <code>xhdpi</code><br><br>
                                    <code>xxhdpi</code><br><br>
                                    <code>xxxhdpi</code><br><br>
                                    <code>nodpi</code><br><br>
                                    <code>tvdpi</code><br><br>
                                    <code>anydpi</code>
                                </td>
                            </tr>
                            <tr>
                                <td>触摸屏类型</td>
                                <td>

                                    notouch：设备没有触摸屏。<br><br>
                                    finger：设备有一个专供用户通过手指直接与其交互的触摸屏。

                                </td>
                                <td>
                                    <code>notouch</code><br><br>
                                    <code>finger</code></td>
                            </tr>
                            <tr>
                                <td>键盘可用性</td>
                                <td>
                                    keysexposed：设备具有可用的键盘。如果设备启用了软键盘（不无可能），那么即使硬键盘没有展示给用户，哪怕设备没有硬键盘，也可以使用此限定符。
                                    如果没有提供或已经禁用软键盘，则只有在显示硬键盘时才会使用此限定符。<br><br>
                                    keyshidden：设备具有可用的硬键盘，但它处于隐藏状态，且设备没有启用软键盘。<br><br>
                                    keyssoft：设备已经启用软键盘（无论是否可见）。
                                </td>
                                <td>
                                    <code>keysexposed</code><br><br>
                                    <code>keyshidden</code><br><br>
                                    <code>keyssoft</code>
                                </td>
                            </tr>
                            <tr>
                                <td>主要文本输入法</td>
                                <td>
                                    nokeys：设备没有用于文本输入的硬按键。<br><br>
                                    qwerty：设备具有标准硬键盘（无论是否对用户可见）。<br><br>
                                    12key：设备具有 12 键硬键盘（无论是否对用户可见）。
                                </td>
                                <td>
                                    <code>nokeys</code><br><br>
                                    <code>qwerty</code><br><br>
                                    <code>12key</code>
                                </td>
                            </tr>
                            <tr>
                                <td>导航键可用性</td>
                                <td>

                                    navexposed：导航键可供用户使用。<br><br>
                                    navhidden：导航键不可用（例如，位于密封盖子后面）。

                                </td>
                                <td>
                                    <code>navexposed</code><br><br>
                                    <code>navhidden</code>
                                </td>
                            </tr>
                            <tr>
                                <td>主要非触摸导航方法</td>
                                <td>

                                    nonav：除了使用触摸屏以外，设备没有其他导航设施。<br><br>
                                    dpad：设备具有用于导航的方向键。<br><br>
                                    trackball：设备具有用于导航的轨迹球。<br><br>
                                    wheel：设备具有用于导航的方向盘（不常见）。<br><br>

                                </td>
                                <td>
                                    <code>nonav</code><br><br>
                                    <code>dpad</code><br><br>
                                    <code>trackball</code><br><br>
                                    <code>wheel</code>
                                </td>
                            </tr>
                            <tr>
                                <td>API 级别</td>
                                <td>
                                    设备支持的 API 级别
                                </td>
                                <td>
                                    <code>v14</code><br><br>
                                    <code>v21</code>
                                </td>
                            </tr>
                        </table>
                    </div>

                    <div class="sub-item">
                        <p><a href="docs/reference/android/content/res/Resources.html">Resources</a>
                            方法列表：</p>
                        <ol type="I">
                            <li><a id="sdk-values" class="offset"></a>获取 values 资源，所有 values
                                下的资源获取和文件名无关，只和类型有关:
                                <ol>
                                    <li><p><code>boolean getBoolean(int id)</code> -- 获取 boolean 值
                                    </p></li>
                                    <li><p><code>int getInteger(int id)</code> -- 获取 int 值</p></li>
                                    <li><p><code>int[] getIntArray(int id)</code> -- 获取 int 数组值</p>
                                    </li>
                                    <li><p><code>CharSequence getText(int id)</code> -- 获取
                                        CharSequence 值</p></li>
                                    <li><p><code>CharSequence[] getTextArray(int id)</code> -- 获取
                                        CharSequence 数组值</p></li>
                                    <li><p><code>CharSequence getText(int id, CharSequence
                                        def)</code> -- 如果为 null 返回　def 值</p></li>
                                    <li><p><code>String getString(int id)</code> -- 获取 String 值,等同于
                                        <code>getText(id).toString()</code></p></li>
                                    <li><p><code>String[] getStringArray(int id)</code> -- 获取 String
                                        数组值</p></li>
                                    <li><p><code>String getString(int id, Object...
                                        formatArgs)</code> -- 获取格式化 String 值, 如 xml 文件：<code>&lt;string
                                        name="sstring_format">My %1$s is %2$d.&lt;/string></code>,
                                        要一个 String 和 一个 int 参数, java 代码要这样写：<code>res.getString(R.string.sstring_format,
                                            "Age", 24);</code></p></li>
                                    <li><p><code>String getQuantityString(int id, int
                                        quantity)</code> -- 用于复数形式，xml 对应标签为 <code>plurals</code>
                                    </p></li>
                                    <li><p><code>String getQuantityString(int id, int quantity,
                                        Object... formatArgs)</code> -- 用于复数形式，xml 对应标签为 <code>plurals</code>
                                    </p></li>
                                    <li><p><code>CharSequence getQuantityText(int id, int
                                        quantity)</code> -- 用于复数形式，xml 对应标签为 <code>plurals</code>
                                    </p></li>
                                    <li><p><code>float getDimension(int id)</code> --
                                        获取尺寸，可以使用单位，自动转换为 px 值</p></li>
                                    <li><p><code>int getDimensionPixelSize(int id)</code> --
                                        getDimension 4 舍 5 入 的 int 值</p></li>
                                    <li><p><code>int getDimensionPixelOffset(int id)</code> --
                                        getDimension 的 int 部分值</p></li>
                                    <li><p><code>int getColor(int id)</code> -- 获取颜色值，AIP 23
                                        推荐使用下面的方法</p></li>
                                    <li><p><code>int getColor(int id, Resources.Theme theme)</code>
                                        -- 获取颜色值，AIP 23 添加</p></li>
                                    <li><p><code>TypedArray obtainTypedArray(int id)</code> --
                                        TypedArray 可以根据索引获取各种类型的值, 参见: <a
                                                href="#android-content-res-TypedArray">TypedArray</a>
                                    </p></li>
                                    <li><p><code>void getValue(int id, TypedValue outValue, boolean
                                        resolveRefs)</code> -- 获取指定 id 的值，并作为有类型的值存入 outValue
                                        中，<code>resolveRefs</code> 用于指定这个 id 是否为引用资源。参见：<a
                                                href="#android-util-TypedValue">TypedValue</a></p>
                                    </li>
                                    <li><p><code>void getValue(String name, TypedValue outValue,
                                        boolean resolveRefs)</code> -- 获取指定 name 的值，并作为有类型的值存入
                                        outValue 中，<code>resolveRefs</code> 用于指定这个 name
                                        是否为引用资源。参见：<a href="#android-util-TypedValue">TypedValue</a>
                                    </p></li>
                                    <li><p><code>void getValueForDensity(int id, int density,
                                        TypedValue outValue, boolean resolveRefs)</code> -- API 25
                                        添加, 获取指定 id 的在指定 density 下的值，并作为有类型的值存入 outValue 中，<code>resolveRefs</code>
                                        用于指定这个 id 是否为引用资源。参见：<a href="#android-util-TypedValue">TypedValue</a>
                                    </p></li>
                                    <li><p><code>float getFraction(int id, int base, int
                                        pbase)</code> -- 获取百分比值</p>
                                        <pre class="brush: java;">
/** 百分比值
 * &lt;item name="offset" type="fraction">50%</item>
                                            * &lt;item name="offset_p" type="fraction">50%p</item>
                                            */
float result = res.getFraction(R.fraction.offset, 2, 1);// 1.0, 和 pbase 无关
float result_p = res.getFraction(R.fraction.offset_p, 1, 3);// 1.5, 和 base 无关
</pre>
                                    </li>
                                </ol>
                                <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;resources>
    &lt;bool name="Sbool">false&lt;/bool>

    &lt;integer name="Sint">20&lt;/nteger>
    &lt;integer-array name="Sint_array">
        &lt;item>0&lt;/item>
        &lt;item>1&lt;/item>
    &lt;/integer-array>

    &lt;string name="Sstring">sstring&lt;/string>
    &lt;string name="Sstring_format">My %1$s is %2$d.&lt;/string>
    &lt;string-array name="Sstring_array">
        &lt;item>s01&lt;/item>
        &lt;item>s02&lt;/item>
    &lt;/string-array>
    &lt;plurals name="numberOfSongsAvailable">
        &lt;item quantity="one">Only one song found.&lt;/item>
        &lt;item quantity="other">Many songs found.&lt;/item>
    &lt;/plurals>
    &lt;!-- plurals 使用, 英语对 1 和　其它数量 处理不一样， 比如 1 book, 如果是其它数量就为 books
    Resources res = getResources();
    Configuration config = res.getConfiguration();
    config.setLocale(new Locale("en"));// 将语言修改为英语
    res.updateConfiguration(config, null);

    /** 这个参数为 1, 返回 Only one song found.
    * 不为 1 时， 返回 Many songs found.
    */
    String song = res.getQuantityString(R.plurals.numberOfSongsAvailable, 1);
    -->

    &lt;dimen name="Sdimen">3.3dp&lt;/dimen>
    &lt;dimen name="Sdimen_px">2.6px&lt;/dimen>

    &lt;color name="Scolor">#FF0000&lt;/color>

    &lt;item type="id" name="image"/><!-- <ImageView android:id="@id/image" ... -->

    &lt;item name="offset" type="fraction">50%&lt;/item>
    &lt;item name="offset_p" type="fraction">50%p&lt;/item>

    &lt;array name="Sarray">
        &lt;item>@drawable/img_200_300_font&lt;/item>
        &lt;item>28&lt;/item>
        &lt;item>0xFF0000&lt;/item>
    &lt;/array>
    &lt;!-- array 使用
        Resources res = getResources();
        TypedArray array = res.obtainTypedArray(R.array.Sarray);
        Drawable mDrawable = array.getDrawable(0);

        int age = array.getInt(1, -1);

        array.recycle();// 资源回收
        image.setImageDrawable(mDrawable);

        Log.d(TAG, "==" + age);
    -->
&lt;/resources>
</pre>
                            </li>
                            <li>获取其它资源:
                                <ol start="23">
                                    <li><p><code>ColorStateList getColorStateList(int id)</code> --
                                        获取不同状态的颜色列表，API 23 推荐使用下面的方法, 参见：　<a
                                                href="#android-content-res-ColorStateList">ColorStateList</a>
                                    </p></li>
                                    <li><p><code>ColorStateList getColorStateList(int id,
                                        Resources.Theme theme)</code> -- 获取不同状态的颜色列表，API 23 添加</p>
                                        <pre class="brush: xml;">
&lt;!-- 位置：　res/color/text_color.xml
    　  TextView.setTextColor(ColorStateList color) 接收一个 ColorStateList 作为参数
    也可在 xml 文件中配置
        android:textColor="@color/text_color"
 -->
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;selector>
    &lt;item android:color="#FF0000" android:state_pressed="true" />
    &lt;item android:color="#000000"/>
&lt;/selector>
</pre>
                                    </li>
                                    <li><p><code>InputStream openRawResource(int id)</code> --
                                        读取资源为数据流，drawable, raw 下的资源</p></li>
                                    <li><p><code>AssetFileDescriptor openRawResourceFd(int
                                        id)</code> -- 读取资源为文件描述符</p></li>
                                    <li><p><code>InputStream openRawResource(int id, TypedValue
                                        value)</code> -- 读取资源为数据流</p></li>
                                    <li><p><code>Drawable getDrawable(int id)</code> -- 读取一个图片资源，API
                                        22 使用下面的 API</p></li>
                                    <li><p><code>Drawable getDrawable(int id, Resources.Theme
                                        theme)</code> -- 读取一个图片资源，API 21 添加</p></li>
                                    <li><p><code>Drawable getDrawableForDensity(int id, int
                                        density)</code> -- 读取给定的屏幕密度 DPI 特定资源API 15 添加, API 22 使用下面的
                                        API</p></li>
                                    <li><p><code>Drawable getDrawableForDensity(int id, int density,
                                        Resources.Theme theme)</code> -- 实测结果为读取的资源还是来源于屏幕 DPI,
                                        但是为指定的 density 缩放的结果，API 21 添加</p>
                                        <pre class="brush: java;">
/** 此方法有点难理解，出现以下不同的情况
 * 屏幕为 xhdpi, dpi = 320
 * 图片大小为 200 * 300
 * 图片位置为下列每个文件目录下都放置一张，但每个图片都写明了来源:
 * drawable-xhpi, drawable-xxhpi, drawable-hpi, drawable-mhdpi, drawable-lpi, drawable
 */
Bitmap bitmap_xhppi = BitmapFactory.decodeResource(res, R.drawable.img_200_300_font);
canvas.drawBitmap(bitmap_xhppi, 0, 0, null);// 来源于 drawable-xhdpi 目录，图片为 400 * 600

Drawable dw = res.getDrawableForDensity(R.drawable.img_200_300_font,DisplayMetrics.DENSITY_LOW);
Bitmap bitmap = drawableToBitmap(dw);
canvas.drawBitmap(bitmap, 200, 0, null);// 来源于 drawable 目录，图片为 400 * 600

dw = res.getDrawableForDensity(R.drawable.img_200_300_font, DisplayMetrics.DENSITY_MEDIUM);
Bitmap bitmap2 = drawableToBitmap(dw);
canvas.drawBitmap(bitmap2, 0, 300, null);// 来源于 drawable 目录，图片为 400 * 600

dw = res.getDrawableForDensity(R.drawable.img_200_300_font, DisplayMetrics.DENSITY_HIGH);
Bitmap bitmap4 = drawableToBitmap(dw);
// 来源于 drawable-xhdpi 目录，图片为 200*240/320 * 300*240/320
canvas.drawBitmap(bitmap4, 200, 0, null);

dw = res.getDrawableForDensity(R.drawable.img_200_300_font, DisplayMetrics.DENSITY_XXHIGH);
Bitmap bitmap3 = drawableToBitmap(dw);
// 来源于 drawable-xhdpi 目录，图片为 200 * 300
canvas.drawBitmap(bitmap4, 200, 0, null);
</pre>
                                    </li>
                                    <li><p><code>XmlResourceParser getXml(int id)</code> -- 用于解析
                                        <code>res/xml</code> 下的 xml 文件</p></li>
                                    <li><p><code>XmlResourceParser getAnimation(int id)</code> --
                                        用于解析 <code>res/anim</code> 下的 xml 文件</p></li>
                                    <li><p><code>XmlResourceParser getLayout(int id)</code> -- 解析
                                        <code>res/layout</code> 下的 xml</p></li>
                                    <li><p><code>Movie getMovie(int id)</code> -- 读取
                                        <code>res/raw</code> 下的视频资源</p></li>
                                    <li><p><code>String getResourcePackageName(int resid)</code> --
                                        资源所属包名：<code>com.lesson1234.myapplication</code></p></li>
                                    <li><p><code>String getResourceTypeName(int resid)</code> --
                                        资源类型：<code>dimen</code></p></li>
                                    <li><p><code>String getResourceEntryName(int resid)</code> --
                                        资源名：<code>dimen_20_dp</code></p></li>
                                    <li><p><code>String getResourceName(int resid)</code> --
                                        合并：<code>com.lesson1234.myapplication:dimen/dimen_20_dp</code>
                                    </p></li>
                                    <li><p><code>int getIdentifier(String name, String defType,
                                        String defPackage)</code> -- 包名, 类型, 资源名查找 ID</p></li>
                                    <li><p><code>TypedArray obtainAttributes(AttributeSet set, int[]
                                        attrs)</code> -- 从指定的 set 中获取 attrs 指定 id 的值，存入 TypedArray
                                    </p></li>
                                </ol>

                            </li>
                            <li>获取其它方法:
                                <ol start="42">
                                    <li><p><code>void parseBundleExtra(String tagName, AttributeSet
                                        attrs, Bundle outBundle)</code> -- 将 attrs 中数据存入 outBundle
                                    </p></li>
                                    <li><p><code>void parseBundleExtras(XmlResourceParser parser,
                                        Bundle outBundle)</code> -- 将 parser　中数据存入 outBundle</p>
                                    </li>
                                    <li><p><code>final AssetManager getAssets()</code> -- 获取
                                        AssetManager</p></li>
                                    <li><p><code>DisplayMetrics getDisplayMetrics()</code> -- 获取
                                        DisplayMetrics</p></li>
                                    <li><p><code>Configuration getConfiguration()</code> -- 获取
                                        Configuration</p></li>
                                    <li><p><code>void updateConfiguration(Configuration config,
                                        DisplayMetrics metrics)</code> -- 更新配置, 参见：<a
                                            href="#sdk-Configuration">Configuration</a></p></li>
                                    <li><p><code>final Resources.Theme newTheme()</code> -- 创建一个新的主题
                                    </p></li>
                                    <li><p><code>static Resources getSystem()</code> -- 获取本身</p>
                                    </li>
                                    <li><p><code>final void finishPreloading()</code> -- 在预加载资源时由
                                        zygote 调用，以恢复正常的资源操作。</p></li>
                                    <li><p><code>final void flushLayoutCache()</code> --
                                        调用此命令从资源对象中删除所有缓存的加载布局资源, 只用于与性能测试工具一起使用。</p></li>
                                </ol>
                            </li>
                        </ol>

                    </div>

                    <div class="sub-item">
                        <p>Resources 相关类：</p>
                        <ul>
                            <li><p><a id="android-content-res-TypedArray" class="offset"></a><a
                                    href="docs/reference/android/content/res/TypedArray.html">TypedArray</a>
                                -- 包含了各种类型的值，可以使用索引进行检索, 并自动转化为相应的类型。</p>
                                <pre class="brush: java;">
/** &lt;array name="Sarray">
 *      &lt;item>@drawable/img_200_300_font&lt;/item>
 *      &lt;item>28&lt;/item>
 *      &lt;item>0xFF0000&lt;/item>
 *  &lt;/array>
 */
Resources res = getResources();
TypedArray array = res.obtainTypedArray(R.array.Sarray);// 来源于values 下 array 标签定义的数据
Drawable mDrawable = array.getDrawable(0);// 第 0 个数据为 drawable
int age = array.getInt(1, -1);// 第 1 个数据为 int
...
array.recycle();
</pre>
                            </li>
                            <li><p><a id="android-content-res-Resource-Theme" class="offset"></a><a
                                    href="docs/reference/android/content/res/Resources.Theme.html">Resources.Theme</a>
                                -- 保存特定主题的当前属性值,
                                换句话说，一个主题是一组资源属性的值。如果没有为一个特定的样式定义属性，作为最后的手段，将尝试在主题查找属性值。比如定义一个
                                TextView, 没有设置字体颜色，将从主题获取。</p>
                            </li>
                            <li><p><a id="android-content-res-ColorStateList" class="offset"></a><a
                                    href="docs/reference/android/content/res/ColorStateList.html">ColorStateList</a>
                                -- 用于保存不周状态的颜色列表，一般从 xml 创建，位置为 <code>res/color/</code>。<code>StateListDrawable</code>
                                类为对应的 Drawable。</p>
                                <p class="alert alert-success">请记住，<b>状态列表中与对象当前状态匹配的第一个项目将被应用。</b>因此，如果列表中的第一个项目不包含下面的状态属性，那么它将每次都被应用，这就是为什么您的默认值应该始终保持不变。比如：将
                                    <code>state_focused</code> 放置于 <code>state_pressed</code> 前，那么
                                    <code>state_pressed</code> 将不会执行，因为它也是
                                    <code>state_focused</code> 状态。</p>
                                <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;selector>
    &lt;item
        android:color="hex_color"
        android:state_pressed=["true" | "false"]
        android:state_focused=["true" | "false"]
        android:state_selected=["true" | "false"]
        android:state_checkable=["true" | "false"]
        android:state_checked=["true" | "false"]
        android:state_enabled=["true" | "false"]
        android:state_window_focused=["true" | "false"] />
&lt;/selector>

&lt;!-- Java 代码构建　ColorStateList
    int[][] states = {{android.R.attr.state_pressed}, {android.R.attr.state_enabled}, {}};
    int[] colors = {Color.RED, Color.BLACK, Color.GRAY};
    ColorStateList csl = new ColorStateList(states, colors);
-->
</pre>
                            </li>
                            <li><p><a id="android-util-TypedValue" class="offset"></a><a
                                    href="docs/reference/android/util/TypedValue.html">TypedValue</a>
                                -- 动态类型数据值的容器, 主要用于保存资源值的资源。可直接译为有类型数据，如：20px, 20dp, 不仅有数值，还有单位。</p>
                                <pre class="brush: java;">
/**
 * applyDimension(int unit, float value, DisplayMetrics metrics)  -- 将指定类型转换为浮点像素数据
 * coerceToString(int type, int data) -- 将 int(mTypedValue.data) 表示的复合数据转换为原始形式
 * complexToDimension(int data, DisplayMetrics metrics) -- 将 value.data 表示的复合数据转换为浮点像素数据
 * complexToDimensionPixelSize(int data, DisplayMetrics dm) -- complexToDimension 4 舍 5 入 的 int 值
 * complexToDimensionPixelOffset(int data, DisplayMetrics metrics) -- complexToDimension 的 int 部分值
 */

Resources res = getResources();
/** applyDimension(int unit, float value, DisplayMetrics metrics) -- 查看源码，此函数支持的转换有：
 * COMPLEX_UNIT_PX:    return value;
 * COMPLEX_UNIT_DIP:   value * metrics.density;
 * COMPLEX_UNIT_SP:    value * metrics.scaledDensity;
 * COMPLEX_UNIT_PT:    value * metrics.xdpi * (1.0f/72);
 * COMPLEX_UNIT_IN:    value * metrics.xdpi;
 * COMPLEX_UNIT_MM:    value * metrics.xdpi * (1.0f/25.4f);
 */
DisplayMetrics dm = res.getDisplayMetrics();
float px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, dm);// dp -> px

/** coerceToString(int type, int data) -- 将 int 表示的复合数据按 type 转换为原始形式 */
TypedValue value = new TypedValue();
res.getValue(android.R.dimen.app_icon_size, value, true);
Log.d(TAG, TypedValue.coerceToString(TypedValue.TYPE_DIMENSION, value.data));// 48.0dip
res.getValue(android.R.color.black, value, true);
Log.d(TAG, TypedValue.coerceToString(TypedValue.TYPE_INT_COLOR_ARGB8, value.data));// #ff000000

/** TypedValue 不仅保存了尺寸的数值，还使用一个字节(低字节)保存了尺寸的数值单位 */
res.getValue(R.dimen.dimen_20_px, value, true);
Log.d(TAG, "20px -> " + Integer.toBinaryString(value.data));
/** 20px -> 10100 00000000 */

res.getValue(R.dimen.dimen_20_dp, value, true);
Log.d(TAG, "20dp -> " + Integer.toBinaryString(value.data));
/** 20dp -> 10100 00000001 */

res.getValue(R.dimen.dimen_20_sp, value, true);
Log.d(TAG, "20sp -> " + Integer.toBinaryString(value.data));
/** 20sp -> 10100 00000010 */


</pre>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-content-pm-PackageManager"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">PackageManager</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
<pre class="brush: java;">
java.lang.Object
    android.content.pm.PackageManager

public abstract class PackageManager {}
</pre>
                        <p><a href="docs/reference/android/content/pm/PackageManager.html">PackageManager</a>
                            用于检索与当前安装在设备上的应用程序包相关的各种信息的类。</p>
                        <p>PackageManager 是一个抽象类，其方法实现多为子类 <code>android.app.ApplicationPackageManager</code>
                            类，这是一个标注为 <code>@hide</code> 的类。</p>
                    </div>

                    <div class="sub-item">
                        <p>PackageManager 方法列表：</p>
                        <ol type="I">
                            <li>PackageManager 常用方法：
                                <ol>
                                    <li>
                                        <p><code>List
                                            <ApplicationInfo> getInstalledApplications(int flags)
                                        </code> -- 返回安装在设备上的所有应用程序包的列表
                                        </p>
                                        <pre class="brush: java;">
GET_UNINSTALLED_PACKAGES
GET_META_DATA --
GET_SHARED_LIBRARY_FILES --

MATCH_SYSTEM_ONLY -- API 24 添加，只包括从标有 FLAG_SYSTEM 应用组件
MATCH_UNINSTALLED_PACKAGES -- API 24 添加，应用卸载，选择保留数据的应用
</pre>
                                    </li>
                                    <li>
                                        <p><code>List
                                            <PackageInfo> getInstalledPackages(int flags)
                                        </code> -- 返回安装在设备上的所有包的列表
                                        </p>
                                        <pre class="brush: java;">
GET_ACTIVITIES
GET_CONFIGURATIONS
GET_GIDS
GET_INSTRUMENTATION
GET_INTENT_FILTERS
GET_META_DATA
GET_PERMISSIONS
GET_PROVIDERS
GET_RECEIVERS
GET_SERVICES
GET_SHARED_LIBRARY_FILES
GET_SIGNATURES
GET_URI_PERMISSION_PATTERNS
MATCH_DISABLED_COMPONENTS
MATCH_DISABLED_UNTIL_USED_COMPONENTS
MATCH_UNINSTALLED_PACKAGES
</pre>
                                    </li>
                                    <li><p><code></code> -- </p></li>
                                    <li><p><code></code> -- </p></li>
                                    <li><p><code></code> -- </p></li>
                                    <li><p><code></code> -- </p></li>
                                    <li><p><code></code> -- </p></li>
                                    <li><p><code></code> -- </p></li>
                                    <li><p><code></code> -- </p></li>
                                    <li><p><code></code> -- </p></li>
                                </ol>
                            </li>

                            <li>PackageManager 其它方法：
                                <ol start="n">
                                    <li><p><code></code> -- </p></li>
                                    <li><p><code></code> -- </p></li>
                                </ol>
                            </li>
                        </ol>

                    </div>

                    <div class="sub-item">
                        <p>PackageManager 相关类：</p>
                        <ul>
                            <li><p><a id="sdk-PackageInfo" class="offset"></a><a
                                    href="docs/reference/android/content/pm/PackageInfo.html">PackageInfo</a>
                                -- </p>
                                <pre class="brush: java;">

</pre>
                            </li>
                            <li><p><a id="sdk-PackageItemInfo" class="offset"></a><a
                                    href="docs/reference/android/content/pm/PackageItemInfo.html">PackageItemInfo</a>
                                -- </p>
                                <ul>
                                    <li><p><a href="">ApplicationInfo</a> -- </p></li>
                                    <li><p><a href="">ComponentInfo</a> -- </p>
                                        <ul>
                                            <li><p><a href="">ActivityInfo</a> -- </p></li>
                                            <li><p><a href="">ProviderInfo</a> -- </p></li>
                                            <li><p><a href="">ServiceInfo</a> -- </p></li>
                                        </ul>
                                    </li>
                                    <li><p><a href="">PermissionInfo</a> -- </p></li>
                                    <li><p><a href="">PermissionGroupInfo</a> -- </p></li>
                                    <li><p><a href="">InstrumentationInfo</a> -- </p></li>
                                </ul>
                                <pre class="brush: java;">

</pre>
                            </li>
                            <li><p><a id="sdk-" class="offset"></a><a href=""></a> -- </p>
                                <pre class="brush: java;">

</pre>
                            </li>
                        </ul>

                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-content-Intent"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Intent</h3>
                </div>
                <div class="panel-body">
<pre class="brush: java;">
java.lang.Object
	android.content.Intent

public class Intent implements Parcelable, Cloneable {
	public Intent() {}
	public Intent(Intent o) {}
	public Intent(String action) {}
	public Intent(String action, Uri uri) {}
	public Intent(Context packageContext, Class&lt;?> cls) {}
	public Intent(String action, Uri uri, Context packageContext, Class&lt;?> cls) {}

    class Intent.FilterComparison {}
    class Intent.ShortcutIconResource {}
}

</pre>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-app-Application"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Application</h3>
                </div>
                <div class="panel-body">
<pre class="brush: java;">
java.lang.Object
    android.content.Context
  	    android.content.ContextWrapper
            android.app.Application

public class Application extends ContextWrapper implements ComponentCallbacks2 {
    interface ActivityLifecycleCallbacks {
        void onActivityCreated(Activity activity, Bundle savedInstanceState);
        void onActivityStarted(Activity activity);
        void onActivityResumed(Activity activity);
        void onActivityPaused(Activity activity);
        void onActivityStopped(Activity activity);
        void onActivitySaveInstanceState(Activity activity, Bundle outState);
        void onActivityDestroyed(Activity activity);
    }

    interface OnProvideAssistDataListener {
        public void onProvideAssistData(Activity activity, Bundle data);
    }
}
</pre>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-app-Activity"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Activity</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
<pre class="brush: java;">
java.lang.Object
    android.content.Context
        android.content.ContextWrapper
            android.view.ContextThemeWrapper
                android.app.Activity

public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2,
                Window.Callback, KeyEvent.Callback,
                View.OnCreateContextMenuListener, ComponentCallbacks2 {}
</pre>
                        <p><a href="docs/reference/android/app/Activity.html">Activity</a> 继承的方法参见:
                            <a href="#android-content-Context">Context</a> 类, Context 为抽象类，使用的是其包装类
                            <code>ContextWrapper</code>, 真正的实现在 <code>ContextImpl</code> 类中，这两个类都是
                            Context 的子类。</p>
                        <p><a href="index.html#android-activity">Activity 生命周期及使用</a> 参见此处, 本文只研究其
                            API。</p>
                    </div>

                    <div class="sub-item">
                        <ol type="I">
                            <li><p>实现的接口:</p>
                                <p>
                                    <a href="docs/reference/android/view/LayoutInflater.Factory2.html">LayoutInflater.Factory2</a>
                                    -- <code>setContentView</code> 调用后回调下面的两个方法，解析布局文件的每个 xml
                                    标签的时候都会调用一次下面的方法，可以获取 xml 的所有的属性。</p>
                                <ol>
                                    <li><p><code>View onCreateView(String name, Context context,
                                        AttributeSet attrs)</code> -- 解析使用的布局文件的时候调用，来自父类 <a
                                            href="docs/reference/android/view/LayoutInflater.Factory.html">LayoutInflater.Factory</a>
                                    </p></li>
                                    <li><p><code>View onCreateView(View parent, String name, Context
                                        context, AttributeSet attrs)</code> -- 同上，API 11 添加</p></li>
                                </ol>
                                <pre class="brush: java;">
/** 在解析的布局 xml 前还有 Window 的标签: LinearLayout -> ViewStub -> FrameLayout
 * 后面才是自己的布局文件： RelativeLayout -> ...
 * name -- 解析布局文件的标签(RelativeLayout, ImageView ...)，每次解析一个 tag 都调用一次此方法
 * attrs -- 对应标签的属性集
 */
public View onCreateView(String name, Context context, AttributeSet attrs) {
    for (int i = 0; i < attrs.getAttributeCount(); i++) {
        Log.d(TAG, name + ":" + attrs.getAttributeName(i) + "=" + attrs.getAttributeValue(i));
    }
    return super.onCreateView(name, context, attrs);
}
</pre>
                                <p><a href="docs/reference/android/view/KeyEvent.Callback.html">KeyEvent.Callback</a>
                                    -- 按键事件处理，View 和 Activity 都实现了这个接口。</p>
                                <ol start="3">
                                    <li><p><code>boolean onKeyDown(int keyCode, KeyEvent
                                        event)</code> -- 键按下时调用</p></li>
                                    <li><p><code>boolean onKeyLongPress(int keyCode, KeyEvent
                                        event)</code> -- 长按时调用</p></li>
                                    <li><p><code>boolean onKeyMultiple(int keyCode, int count,
                                        KeyEvent event)</code> -- 当接连发生同一个键的多个 按下/弹起 动作时调用</p></li>
                                    <li><p><code>boolean onKeyUp(int keyCode, KeyEvent event)</code>
                                        -- 键弹起时调用</p></li>
                                </ol>
                                <p>
                                    <a href="docs/reference/android/content/ComponentCallbacks2.html">ComponentCallbacks2</a>
                                    -- API 14 添加，前两个方法来自父类 <code>ComponentCallbacks</code>, Service,
                                    Activity, Application, ContentProvider 都实现了此接口。</p>
                                <ol start="7">
                                    <li><p><code>void onConfigurationChanged(Configuration
                                        newConfig)</code> -- 正在运行时设备配置发生变化时系统调用该方法，如横竖屏切换</p></li>
                                    <li><p><code>void onLowMemory()</code> --
                                        当整个系统内存不足时，回调此方法，进程应该主动处理以降低内存使用</p></li>
                                    <li><p><code>void onTrimMemory(int level)</code> --
                                        系统确定有进程不使用的内存时，调用此方法。API 14 添加</p></li>
                                </ol>
                                <p>
                                    <a href="docs/reference/android/view/View.OnCreateContextMenuListener.html">View.OnCreateContextMenuListener</a>
                                    -- 要绑定到 View, 默认长按 view 时显示，每次调用重新创建</p>
                                <ol start="10">
                                    <li><p><code>void onCreateContextMenu(ContextMenu menu, View v,
                                        ContextMenu.ContextMenuInfo menuInfo)</code> --
                                        在构建此视图的上下文菜单时调用</p>
                                        <pre class="brush: java;">
/** ContextMenu 和 OptionsMenu
 * ContextMenu -- 要绑定到 View, 默认长按 view 时显示，每次调用重新创建:
 *   绑定到 view -- registerForContextMenu(view);
 *   主动调用为 -- view.showContextMenu();
 * OptionsMenu -- 不用绑定，默认按菜单按键时显示，只第一次调用时创建:
 *   主动调用为 -- openOptionsMenu();
 */
@Override
public void onCreateContextMenu(ContextMenu menu,View v,ContextMenu.ContextMenuInfo menuInfo) {
    Log.d(TAG, "== onCreateContextMenu ==");
    getMenuInflater().inflate(R.menu.menu, menu);
    super.onCreateContextMenu(menu, v, menuInfo);
}

@Override
public boolean onContextItemSelected(MenuItem item) {
    Log.d(TAG, "== onContextItemSelected ==");
    return super.onContextItemSelected(item);
}

@Override
public boolean onCreateOptionsMenu(Menu menu) {
    Log.d(TAG, "== onCreateOptionsMenu ==");
    getMenuInflater().inflate(R.menu.menu, menu);
    return super.onCreateOptionsMenu(menu);
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {
    Log.d(TAG, "== onOptionsItemSelected ==");
    return super.onOptionsItemSelected(item);
}
</pre>
                                    </li>
                                </ol>
                                <p><a href="docs/reference/android/view/Window.Callback.html">Window.Callback</a>
                                    -- 主要是各种 Activity 和各种 Dialog 实现了此接口, 由 Window 进行回调。</p>
                                <ol start="11">
                                    <li><p><code>void onAttachedToWindow()</code> -- 当与 Activity
                                        关联的主窗口被附加到窗口管理器时调用, 在 <code>onResume</code> 以后。View
                                        也有此方法，且每个 view 只会被调用一次，父 view 的调用在前，不论 view 的 visibility
                                        状态都会被调用，适合做些 view 特定的初始化操作。</p></li>
                                    <li><p><code>void onDetachedFromWindow()</code> -- 与 Activity
                                        关联的主窗口已从窗口管理器分离时调用, 在 <code>onDestory</code> 以后</p></li>
                                    <li><p><code>void onContentChanged()</code> -- Window
                                        的内容改变时调用，比如：在 <code>setContentView</code> 以后</p></li>
                                    <li><p><code>void onActionModeStarted(ActionMode mode)</code> --
                                        当 ActionMode 完成时调用, 参见: <a href="#android-view-ActionMode">ActionMode</a>
                                    </p></li>
                                    <li><p><code>void onActionModeFinished(ActionMode mode)</code>
                                        -- 当 ActionMode 启动时调用, 参见: <a
                                                href="#android-view-ActionMode">ActionMode</a></p>
                                    </li>
                                    <li><p><code>View onCreatePanelView(int featureId)</code> --
                                        按菜单按钮时调用，可创见自定义的 View</p></li>
                                    <li><p><code>boolean onCreatePanelMenu(int featureId, Menu
                                        menu)</code> -- 按菜单按钮时调用，</p></li>
                                    <li><p><code>boolean onPreparePanel(int featureId, View view,
                                        Menu menu)</code> -- 按菜单按钮时调用，</p></li>
                                    <li><p><code>boolean onMenuOpened(int featureId, Menu
                                        menu)</code> -- 菜单打开时回调</p></li>
                                    <li><p><code>boolean onMenuItemSelected(int featureId, MenuItem
                                        item)</code> -- 菜单被选择时回调</p></li>
                                    <li><p><code>void onPanelClosed(int featureId, Menu menu)</code>
                                        -- 菜单关闭时回调</p>
                                        <pre class="brush: java;">
/** 在 featureId == Window.FEATURE_OPTIONS_PANEL 情况下:
 * 1. 如果 onCreatePanelView 返回　null, 则调用如下：
 * onCreatePanelView -> onCreatePanelMenu -> onCreateOptionsMenu(如果重写了此方法)
 * -> onPreparePanel -> onMenuOpened-> onMenuItemSelected-> onOptionsItemSelected(如果重写了此方法)
 * -> onPanelClosed -> onOptionsMenuClosed(如果重写了此方法)
 * 2. 如果 onCreatePanelView 返回自定义的 view, 则调用如下：
 * onCreatePanelView -> onMenuOpened -> onPanelClosed -> onOptionsMenuClosed
 */
public View onCreatePanelView(int featureId) {
    View v = getLayoutInflater().inflate(R.layout.layout_panel_menu, null);
    ...
    return v;
}

/** onCreatePanelView 返回 null 时，可以在此添加菜单，同 optionsMenu */
public boolean onCreatePanelMenu(int featureId, Menu menu) {
    menu.add("测试1");
    menu.add("测试2");

    return super.onCreatePanelMenu(featureId, menu);
}
</pre>
                                    </li>
                                    <li><p><code>void onProvideKeyboardShortcuts(List&lt;KeyboardShortcutGroup>
                                        data, Menu menu, int deviceId)</code> -- 当为当前窗口请求键盘快捷键时调用,
                                        API 24 添加</p></li>
                                    <li><p><code>boolean onSearchRequested()</code> --
                                        当用户发出启动搜索的信号时调用</p></li>
                                    <li><p><code>boolean onSearchRequested(SearchEvent
                                        searchEvent)</code> -- 当用户发出启动搜索的信号时调用, API 23 添加</p></li>
                                    <li><p><code>void
                                        onWindowAttributesChanged(WindowManager.LayoutParams
                                        attrs) </code> -- 当前窗口属性改变时调用</p></li>
                                    <li><p><code>void onWindowFocusChanged(boolean hasFocus)</code>
                                        -- 窗口焦点变化时调用</p></li>
                                    <li><p><code>ActionMode
                                        onWindowStartingActionMode(ActionMode.Callback
                                        callback)</code> -- 在启动此窗口的 ActionMode 时调用, 参见: <a
                                            href="#android-view-ActionMode">ActionMode</a></p></li>
                                    <li><p><code>ActionMode
                                        onWindowStartingActionMode(ActionMode.Callback callback, int
                                        type)</code> -- 在启动此窗口的 ActionMode 时调用, 参见: <a
                                            href="#android-view-ActionMode">ActionMode</a>，API 23 添加
                                    </p></li>
                                    <li><p><code>boolean dispatchKeyEvent(KeyEvent event)</code> --
                                        处理按键事件，按下一个键会一般调用再次，一次为 KeyDown, 一次为 KeyUp，如果长按，可能还会调用一次
                                        LongPress件; 如果不调用 <code>super.dispatchKeyEvent(event)</code>,
                                        那么 <code>onKeyDown, onKeyUp ...</code> 事件不会调用。</p></li>
                                    <li><p><code>boolean dispatchKeyShortcutEvent(KeyEvent
                                        event)</code> -- 处理键盘快捷键事件</p></li>
                                    <li><p><code>boolean
                                        dispatchPopulateAccessibilityEvent(AccessibilityEvent
                                        event)</code> -- 处理 PopulateAccessibility
                                        事件（辅助事件，如焦点变化，按钮被点击等）</p></li>
                                    <li><p><code>boolean dispatchTouchEvent(MotionEvent
                                        event)</code> -- 处理 Touch 事件</p></li>
                                    <li><p><code>boolean dispatchGenericMotionEvent(MotionEvent
                                        event)</code> -- 处理 GenericMotion 事件</p></li>
                                    <li><p><code>boolean dispatchTrackballEvent(MotionEvent
                                        event) </code> -- 处理 Trackball 事件</p></li>
                                </ol>

                            </li>
                            <li>来自于 ContextThemeWrapper 的方法(来自 Context 和 ContextWrapper 的方参见：<a
                                    href="#android-content-Context">Context</a>)：
                                <ol start="35">
                                    <li><p><code>void attachBaseContext(Context newBase)</code> -- 将
                                        ContextImpl 的实例赋值到 ContextWrapper</p>
                                        <pre class="brush: java;">
@Override
protected void attachBaseContext(Context newBase) {
    Configuration newConfig = newBase.getResources().getConfiguration();
    Locale locale = new Locale("en");
    newConfig.setLocale(locale);// 修改 Configuration 的 Locale 为英语
    Context newContext = newBase.createConfigurationContext(newConfig);
    super.attachBaseContext(newContext);// 如果不调用它，ContextWrapper 的 ContextImpl 实例为空

    Log.d(TAG, getString(R.string.app_name));// 读取 values-en 下的 strings.xml
}
</pre>
                                    </li>
                                    <li><p><code>void onApplyThemeResource(Resources.Theme theme,
                                        int resId, boolean first)</code> -- 此方法在
                                        <code>onCreate</code> 前执行，用于设置主题，application 标签指定了应用的主题；调用
                                        setTheme 方法，此方法会再次执行。</p></li>
                                    <li><p><code>void applyOverrideConfiguration(Configuration
                                        overrideConfiguration)</code> -- 只能调用一次，要在 getResources 和
                                        getAssets 前</p></li>
                                </ol>
                            </li>
                            <li>简单生命周期回调方法:
                                <ol start="38">
                                    <li><p><code>void onCreate(Bundle savedInstanceState)</code> --
                                        一次被创建时调用，参见： <a href="index.html#android-activity">Activity
                                            生命周期</a></p></li>
                                    <li><p><code>void onRestart()</code> -- 被停止后、又再次被启动之前调用，参见： <a
                                            href="index.html#android-activity">Activity 生命周期</a></p>
                                    </li>
                                    <li><p><code>void onStart()</code> -- 要显示给用户之前调用，参见： <a
                                            href="index.html#android-activity">Activity 生命周期</a></p>
                                    </li>
                                    <li><p><code>void onResume()</code> -- 开始与用户交互之前调用，参见： <a
                                            href="index.html#android-activity">Activity 生命周期</a></p>
                                    </li>
                                    <li><p><code>void onPause()</code> -- 系统准备启动另一个正在恢复的 Activity
                                        时调用，参见： <a href="index.html#android-activity">Activity
                                            生命周期</a></p></li>
                                    <li><p><code>void onStop()</code> -- 当不再对用户可见时调用，参见：
                                        <a href="index.html#android-activity">Activity 生命周期</a></p>
                                    </li>
                                    <li><p><code>void onDestory()</code> -- 在被销毁前调用，参见：
                                        <a href="index.html#android-activity">Activity 生命周期</a></p>
                                    </li>
                                </ol>
                            </li>
                            <li>其它回调方法和关联方法:
                                <ol start="45">
                                    <li><p><code>void onCreate(Bundle savedInstanceState,
                                        PersistableBundle persistentState)</code> -- API 21 添加，同
                                        <code>onCreate(Bundle savedInstanceState);</code></p></li>
                                    <li><p><code>void onPostCreate(Bundle savedInstanceState)</code>
                                        -- 应用程序一般不会实现此方法,它是用于系统类在应用程序代码运行之后进行最终初始化的</p></li>
                                    <li><p><code>void onPostCreate(@Nullable Bundle
                                        savedInstanceState, @Nullable PersistableBundle
                                        persistentState)</code> -- 同上，API 21 添加</p></li>
                                    <li><p><code>void onPostResume()</code> --
                                        应用程序一般不会实现此方法,它是用于系统类在应用程序代码运行之后进行最终初始化的</p></li>
                                    <li><p><code>void onBackPressed()</code> -- 返回键按下，在 Activity 的
                                        onKeyDown 调用</p></li>
                                    <li class="group"><p><code>void onActivityResult(int requestCode, int
                                        resultCode, Intent data)</code> -- 此方法 <code>startActivityForResult</code>
                                        返回时调用，用于接收子 Activity 操作后的数据</p></li>
                                    <li><p><code>void startActivityForResult(Intent intent, int
                                        requestCode)</code> -- 启动一个请求参数的 Activity</p></li>
                                    <li><p><code>void startActivityForResult(Intent intent, int
                                        requestCode, Bundle options)</code> -- 启动一个请求参数的 Activity,
                                        并使用 Bundle 数据为参数</p></li>
                                    <li><p><code>final void setResult(int resultCode)</code> --
                                        设置返回码，<code>onActivityResult</code> 接收</p></li>
                                    <li><p><code>final void setResult(int resultCode, Intent
                                        data)</code> -- 设置返回码和数据，<code>onActivityResult</code> 接收
                                    </p></li>
                                    <li class="group"><p><code>void onNewIntent(Intent intent)</code> -- 当
                                        Activity 的 <code>launchMode</code> 为 <code>singleTask |
                                            singleInstance | singleTop</code>, 不要再启动一个新的 Activity
                                        时调用</p></li>
                                    <li><p><code>void onAttachFragment(Fragment fragment)</code> --
                                        Fragment 被附加到 Activity 时调用(每个 Fragment 被附加都调用一次)</p></li>
                                    <li><p><code>FragmentManager getFragmentManager()</code> -- 获取
                                        Fragment 管理器</p></li>
                                    <li class="group"><p><code>void onSaveInstanceState(Bundle outState)</code> --
                                        保存用户数据，在 <code>onPause</code> 和 <code>onStop</code> 间调用</p>
                                    </li>
                                    <li><p><code>void onSaveInstanceState(Bundle outState,
                                        PersistableBundle outPersistentState)</code> -- 同上，API 21 添加
                                    </p></li>
                                    <li><p><code>void onRestoreInstanceState(Bundle
                                        savedInstanceState)</code> -- 恢复用户数据，只有 Activity 被系统回收，重新创建
                                        Activity 的情况下才会被调用，在 <code>onStart</code> 和
                                        <code>onResume</code> 间调用。在 <code>onCreate</code> 中也有 <code>savedInstanceState</code>
                                        的数据，但它有可能为空；此方法中不会为空。</p></li>
                                    <li><p><code>void onRestoreInstanceState(Bundle
                                        savedInstanceState, PersistableBundle
                                        persistentState)</code> -- 同上，API 21 添加</p></li>
                                    <li><p><code>void onStateNotSaved()</code> -- 在 <code>onResume()</code> 前，告知 Activity 状态将不保存</p></li>
                                    <li class="group"><p><code>void onTitleChanged(CharSequence title, int
                                        color)</code> -- 第一次调用在获取到 title 时调用(onStart 后)，<code>setTitle</code>
                                        和 <code>setTitleColor</code> 方法会回调此方法</p></li>
                                    <li><p><code>final CharSequence getTitle()</code> -- 获取　title
                                    </p></li>
                                    <li><p><code>final int getTitleColor()</code> -- 获取　title color
                                    </p></li>
                                    <li><p><code>void setTitle(CharSequence title)</code> -- 设置
                                        title</p></li>
                                    <li><p><code>void setTitle(int titleId)</code> -- 设置 title</p>
                                    </li>
                                    <li><p><code>void setTitleColor(int textColor)</code> -- API 21
                                        后不推荐使用</p></li>
                                    <li><p><code>void onChildTitleChanged(Activity childActivity,
                                        CharSequence title)</code> -- 子 Activity 标题改变调用</p></li>
                                    <li><p><code>void onUserInteraction()</code> -- 任何一个 KeyEvent,
                                        MotionEvent 事件都会触发一次此方法</p></li>
                                    <li class="group"><p><code>void onUserLeaveHint()</code> -- 用户手动离开当前
                                        Activity，会调用该方法；来电，灭屏等不会调用此方法</p></li>
                                    <li class="group"><p><code>boolean onCreateOptionsMenu(Menu menu)</code> --
                                        菜单按钮按下时调用，只在第一次创建的时候调用</p></li>
                                    <li><p><code>boolean onPrepareOptionsMenu(Menu menu)</code> --
                                        显示 OptionsMenu 时调用</p></li>
                                    <li><p><code>boolean onOptionsItemSelected(MenuItem item)</code>
                                        -- 条目被选中调用</p></li>
                                    <li><p><code>void onOptionsMenuClosed(Menu menu)</code> -- 关闭
                                        OptionsMenu 时调用</p></li>
                                    <li><p><code>void openOptionsMenu()</code> -- 打开
                                        OptionsMenu(此方法在 AppCompatActivity 中无效)</p></li>
                                    <li><p><code>void closeOptionsMenu()</code> -- 关闭 OptionsMenu
                                    </p></li>
                                    <li><p><code>void invalidateOptionsMenu()</code> --
                                        声明选项菜单已更改，因此应该重新创建</p></li>
                                    <li><p><code>void registerForContextMenu(View view)</code> --
                                        为一个 View 注册一个 ContextMenu, 然后在
                                        <code>onCreateContextMenu</code> 创建视图</p></li>
                                    <li><p><code>void unregisterForContextMenu(View view)</code> --
                                        反注册 ContextMenu</p></li>
                                    <li><p><code>void openContextMenu(View view)</code> -- 打开
                                        ContextMenu</p></li>
                                    <li><p><code>boolean onContextItemSelected(MenuItem item)</code>
                                        -- 条目被选中调用</p></li>
                                    <li><p><code>void closeContextMenu()</code> -- 关闭 ContextMenu
                                    </p></li>
                                    <li><p><code>void onContextMenuClosed(Menu menu)</code> -- 关闭
                                        ContextMenu 时调用</p></li>
                                    <li class="group"><p><code>CharSequence onCreateDescription()</code> -- 创建
                                        Activity 的描述信息, 在 <code>onPause</code> 后执行</p></li>
                                    <li class="group"><p><code>void onEnterAnimationComplete()</code> --
                                        进入动画完成回调，API 21 添加</p></li>
                                    <li><p><code>void startPostponedEnterTransition()</code> -- ，API
                                        21 添加</p></li>
                                    <li><p><code>void postponeEnterTransition()</code> -- ，API 21 添加
                                    </p></li>
                                    <li><p><code>void overridePendingTransition(int enterAnim, int
                                        exitAnim)</code> -- Activity 的跳转动画，此方法必须在 startActivity
                                        后马上执行</p></li>
                                    <li><p><code>void
                                        setEnterSharedElementCallback(SharedElementCallback
                                        callback)</code> -- 设置进入时共享元素回调，API 21 添加</p>
                                    <pre class="brush: java;">
共享元素 -- 页面内容过渡动画和页面共享动画
从 activityA 的一个图片，变大进入到了 activityB 里面。好像是把 A 的图片传递给了 B 去显示。
其实几乎所以的变换都是在 B 里面完成的，A 并没有干什么卵事情。
简单的说就是把 A 里面的图片的位置，大小等信息传递给 B，然后 B 通过这些信息在自己的界面里面绘制出一模一样的，
然后在通过比较最终的大小和位置等信息，创建出一个 Animator，再然后就是动画的执行。
这就看起来像是 A 里面的元素共享到了 B 里面。
                                    </pre>
                                    </li>
                                    <li><p><code>void
                                        setExitSharedElementCallback(SharedElementCallback
                                        callback)</code> -- 设置退出时共享元素回调，API 21 添加</p></li>
                                    <li class="group"><p><code>boolean onKeyShortcut(int keyCode, KeyEvent
                                        event)</code> -- 组合键按下</p></li>
                                    <li class="group"><p><code>void onLocalVoiceInteractionStarted()</code> -- 下面的 start 完成回调，参见: <a target="_blank" href="docs/reference/android/service/voice/VoiceInteractionSession.html">VoiceInteractionSession</a>
                                    </p></li>
                                    <li><p><code>void startLocalVoiceInteraction(Bundle
                                        privateOptions)</code> -- 启动本地语音交互会话</p></li>
                                    <li><p><code>void onLocalVoiceInteractionStopped()</code> -- 下面的 stop 完成回调
                                    </p></li>
                                    <li><p><code>void stopLocalVoiceInteraction()</code> -- 停止本地语音交互会话</p>
                                    </li>
                                    <li class="group"><p><code>void onMultiWindowModeChanged(boolean
                                        isInMultiWindowMode)</code> -- 进入或退出多窗口模式，API 24</p></li>

                                    <li><p><code>void onPictureInPictureModeChanged(boolean
                                        isInPictureInPictureMode)</code> -- 应用进入或退出画中画模式回调(必须在 Activity 注册时标注:<code>android:resizeableActivity="true"</code>)，API 24</p></li>
                                    <li><p><code>void enterPictureInPictureMode()</code> -- 进入画中画模式，API 24</p></li>
                                    <li><p><code>boolean isInPictureInPictureMode()</code> -- 是否为，API 24</p>
                                    </li>
                                    <li class="group"><p><code>void onProvideAssistContent(AssistContent
                                        outContent)</code> -- </p></li>
                                    <li><p><code>void onProvideAssistData(Bundle data)</code> --
                                    </p></li>
                                    <li><p><code>void onActivityReenter(int resultCode, Intent
                                        data)</code> -- </p></li>
                                    <li><p><code>Uri onProvideReferrer()</code> -- </p></li>
                                    <li><p><code>void onRequestPermissionsResult(int requestCode,
                                        String[] permissions, int[] grantResults)</code> -- </p>
                                    </li>
                                    <li><p><code>Object onRetainNonConfigurationInstance()</code> --
                                    </p></li>
                                    <li><p><code>void onVisibleBehindCanceled()</code> -- </p></li>
                                </ol>
                            </li>
                            <li>Activity 其它常用方法:
                                <ol start="104">

                                    <li><p><code>PendingIntent createPendingResult(int requestCode,
                                        Intent data, int flags)</code> -- </p></li>
                                    <li><p><code>View findViewById(int id)</code> -- </p></li>
                                    <li><p><code>void finish()</code> -- </p></li>
                                    <li><p><code>void finishAffinity()</code> -- </p></li>
                                    <li><p><code>void finishAfterTransition()</code> -- </p></li>
                                    <li><p><code>void finishAndRemoveTask()</code> -- </p></li>
                                    <li><p><code>void finishFromChild(Activity child)</code> -- </p>
                                    </li>
                                    <li><p><code>void finishActivity(int requestCode)</code> -- </p>
                                    </li>
                                    <li><p><code>void finishActivityFromChild(Activity child, int
                                        requestCode)</code> -- </p></li>

                                    <li><p><code>ActionBar getActionBar()</code> -- </p></li>
                                    <li><p><code>void setActionBar(Toolbar toolbar)</code> -- </p>
                                    </li>
                                    <li><p><code>final Application getApplication()</code> -- </p>
                                    </li>
                                    <li><p><code>ComponentName getCallingActivity()</code> -- </p>
                                    </li>
                                    <li><p><code>String getCallingPackage()</code> -- </p></li>
                                    <li><p><code>int getChangingConfigurations()</code> -- </p></li>
                                    <li><p><code>Object getLastNonConfigurationInstance()</code> --
                                    </p></li>
                                    <li><p><code>ComponentName getComponentName()</code> -- </p>
                                    </li>
                                    <li><p><code>Scene getContentScene()</code> -- </p></li>
                                    <li><p><code>TransitionManager
                                        getContentTransitionManager()</code> -- </p></li>
                                    <li><p><code>void setContentTransitionManager(TransitionManager
                                        tm)</code> -- </p></li>
                                    <li><p><code>View getCurrentFocus()</code> -- </p></li>

                                    <li><p><code>LayoutInflater getLayoutInflater()</code> -- </p>
                                    </li>
                                    <li><p><code>MenuInflater getMenuInflater()</code> -- </p></li>
                                    <li><p><code>LoaderManager getLoaderManager()</code> -- </p>
                                    </li>
                                    <li><p><code>String getLocalClassName()</code> -- </p></li>
                                    <li><p><code>final MediaController getMediaController()</code>
                                        -- </p></li>
                                    <li><p><code>final Activity getParent()</code> -- </p></li>
                                    <li><p><code>Intent getParentActivityIntent()</code> -- </p>
                                    </li>
                                    <li><p><code>SharedPreferences getPreferences(int mode)</code>
                                        -- </p></li>
                                    <li><p><code>Uri getReferrer()</code> -- </p></li>
                                    <li><p><code>int getRequestedOrientation()</code> -- </p></li>
                                    <li><p><code>final SearchEvent getSearchEvent()</code> -- </p>
                                    </li>
                                    <li><p><code>Object getSystemService(String name)</code> -- </p>
                                    </li>
                                    <li><p><code>int getTaskId()</code> -- </p></li>
                                    <li><p><code>VoiceInteractor getVoiceInteractor()</code> -- </p>
                                    </li>
                                    <li><p><code>final int getVolumeControlStream()</code> -- </p>
                                    </li>
                                    <li><p><code>final void setVolumeControlStream(int
                                        streamType)</code> -- </p></li>
                                    <li><p><code>Window getWindow()</code> -- </p></li>
                                    <li><p><code>WindowManager getWindowManager()</code> -- </p>
                                    </li>
                                    <li><p><code>void addContentView(View view,
                                        ViewGroup.LayoutParams params)</code> -- </p></li>
                                    <li><p><code>void setContentView(View view,
                                        ViewGroup.LayoutParams params)</code> -- </p></li>
                                    <li><p><code>void setContentView(View view)</code> -- </p></li>
                                    <li><p><code>void setContentView(int layoutResID)</code> -- </p>
                                    </li>
                                    <li><p><code>final void setDefaultKeyMode(int mode)</code> --
                                    </p></li>

                                    <li><p><code>final void setFeatureDrawable(int featureId,
                                        Drawable drawable)</code> -- </p></li>
                                    <li><p><code>final void setFeatureDrawableAlpha(int featureId,
                                        int alpha)</code> -- </p></li>
                                    <li><p><code>final void setFeatureDrawableResource(int
                                        featureId, int resId)</code> -- </p></li>
                                    <li><p><code>final void setFeatureDrawableUri(int featureId, Uri
                                        uri)</code> -- </p></li>
                                    <li><p><code>void setFinishOnTouchOutside(boolean finish)</code>
                                        -- </p></li>
                                    <li><p><code>void setImmersive(boolean i)</code> -- </p></li>
                                    <li><p><code>void setIntent(Intent newIntent)</code> -- </p>
                                    </li>
                                    <li><p><code>final void setMediaController(MediaController
                                        controller)</code> -- </p></li>
                                    <li><p><code>final void setProgress(int progress)</code> -- </p>
                                    </li>
                                    <li><p><code>final void setProgressBarIndeterminate(boolean
                                        indeterminate)</code> -- </p></li>
                                    <li><p><code>final void
                                        setProgressBarIndeterminateVisibility(boolean
                                        visible)</code> -- </p></li>
                                    <li><p><code>final void setProgressBarVisibility(boolean
                                        visible)</code> -- </p></li>
                                    <li><p><code>void setRequestedOrientation(int
                                        requestedOrientation)</code> -- </p></li>
                                    <li><p><code>final void setSecondaryProgress(int
                                        secondaryProgress)</code> -- </p></li>
                                    <li><p><code>void
                                        setTaskDescription(ActivityManager.TaskDescription
                                        taskDescription)</code> -- </p></li>
                                    <li><p><code>void setTheme(int resid)</code> -- </p></li>
                                    <li><p><code>void setVisible(boolean visible)</code> -- </p>
                                    </li>
                                    <li><p><code>void setVrModeEnabled(boolean enabled,
                                        ComponentName requestedComponent)</code> -- </p></li>


                                    <li><p><code>boolean hasWindowFocus()</code> -- </p></li>

                                    <li><p><code>boolean isChangingConfigurations()</code> -- </p>
                                    </li>
                                    <li><p><code>final boolean isChild()</code> -- </p></li>
                                    <li><p><code>boolean isDestroyed()</code> -- </p></li>
                                    <li><p><code>boolean isFinishing()</code> -- </p></li>
                                    <li><p><code>boolean isImmersive()</code> -- </p></li>
                                    <li><p><code>boolean isInMultiWindowMode()</code> -- </p></li>

                                    <li><p><code>boolean isLocalVoiceInteractionSupported()</code>
                                        -- </p></li>
                                    <li><p><code>boolean isTaskRoot()</code> -- </p></li>
                                    <li><p><code>boolean isVoiceInteraction()</code> -- </p></li>
                                    <li><p><code>boolean isVoiceInteractionRoot()</code> -- </p>
                                    </li>
                                    <li><p><code>final Cursor managedQuery(Uri uri, String[]
                                        projection, String selection, String[] selectionArgs, String
                                        sortOrder)</code> -- </p></li>
                                    <li><p><code>boolean moveTaskToBack(boolean nonRoot)</code> --
                                    </p></li>


                                    <li><p><code>boolean releaseInstance()</code> -- </p></li>
                                    <li><p><code>final boolean requestWindowFeature(int
                                        featureId)</code> -- </p></li>
                                    <li><p><code>final void runOnUiThread(Runnable action)</code> --
                                    </p></li>
                                    <li><p><code>boolean requestVisibleBehind(boolean
                                        visible)</code> -- </p></li>
                                    <li><p><code>final void requestShowKeyboardShortcuts()</code> --
                                    </p></li>
                                    <li><p><code>final void requestPermissions(String[] permissions,
                                        int requestCode)</code> -- </p></li>
                                    <li><p><code>DragAndDropPermissions
                                        requestDragAndDropPermissions(DragEvent event)</code> --
                                    </p></li>
                                    <li><p><code>void reportFullyDrawn()</code> -- </p></li>
                                    <li><p><code>void recreate()</code> -- </p></li>
                                    <li><p><code>boolean shouldShowRequestPermissionRationale(String
                                        permission)</code> -- </p></li>
                                    <li><p><code>boolean shouldUpRecreateTask(Intent
                                        targetIntent)</code> -- </p></li>
                                    <li><p><code>boolean showAssist(Bundle args)</code> -- </p></li>
                                    <li><p><code>final boolean showDialog(int id, Bundle
                                        args)</code> -- </p></li>
                                    <li><p><code>void showLockTaskEscapeMessage()</code> -- </p>
                                    </li>
                                    <li><p><code>void startActivityFromChild(Activity child, Intent
                                        intent, int requestCode)</code> -- </p></li>
                                    <li><p><code>void startActivityFromChild(Activity child, Intent
                                        intent, int requestCode, Bundle options)</code> -- </p></li>
                                    <li><p><code>void startActivityFromFragment(Fragment fragment,
                                        Intent intent, int requestCode, Bundle options)</code> --
                                    </p></li>
                                    <li><p><code>void startActivityFromFragment(Fragment fragment,
                                        Intent intent, int requestCode)</code> -- </p></li>
                                    <li><p><code>boolean startActivityIfNeeded(Intent intent, int
                                        requestCode, Bundle options)</code> -- </p></li>
                                    <li><p><code>boolean startActivityIfNeeded(Intent intent, int
                                        requestCode)</code> -- </p></li>
                                    <li><p><code>void startIntentSenderForResult(IntentSender
                                        intent, int requestCode, Intent fillInIntent, int flagsMask,
                                        int flagsValues, int extraFlags)</code> -- </p></li>
                                    <li><p><code>void startIntentSenderForResult(IntentSender
                                        intent, int requestCode, Intent fillInIntent, int flagsMask,
                                        int flagsValues, int extraFlags, Bundle options)</code> --
                                    </p></li>
                                    <li><p><code>void startIntentSenderFromChild(Activity child,
                                        IntentSender intent, int requestCode, Intent fillInIntent,
                                        int flagsMask, int flagsValues, int extraFlags, Bundle
                                        options)</code> -- </p></li>
                                    <li><p><code>void startIntentSenderFromChild(Activity child,
                                        IntentSender intent, int requestCode, Intent fillInIntent,
                                        int flagsMask, int flagsValues, int extraFlags)</code> --
                                    </p></li>

                                    <li><p><code>void startLockTask()</code> -- </p></li>
                                    <li><p><code>void startManagingCursor(Cursor c)</code> -- </p>
                                    </li>
                                    <li><p><code>boolean startNextMatchingActivity(Intent intent,
                                        Bundle options)</code> -- </p></li>
                                    <li><p><code>boolean startNextMatchingActivity(Intent
                                        intent)</code> -- </p></li>

                                    <li><p><code>void startSearch(String initialQuery, boolean
                                        selectInitialQuery, Bundle appSearchData, boolean
                                        globalSearch)</code> -- </p></li>

                                    <li><p><code>void stopLockTask()</code> -- </p></li>
                                    <li><p><code>void stopManagingCursor(Cursor c)</code> -- </p>
                                    </li>
                                    <li><p><code>void takeKeyEvents(boolean get)</code> -- </p></li>
                                    <li><p><code>void triggerSearch(String query, Bundle
                                        appSearchData)</code> -- </p></li>

                                    <li><p><code>final void dismissKeyboardShortcutsHelper()</code>
                                        -- </p></li>
                                    <li><p><code>void dump(String prefix, FileDescriptor fd,
                                        PrintWriter writer, String[] args)</code> -- </p></li>
                                </ol>
                            </li>
                            <li>Activity 其它方法:
                                <ol start="218">
                                    <li><p><code>final void showDialog(int id)</code> -- API 13
                                        后不推荐使用</p></li>
                                    <li><p><code>Dialog onCreateDialog(int id)</code> -- API 8
                                        后不推荐使用</p></li>
                                    <li><p><code>Dialog onCreateDialog(int id, Bundle args)</code>
                                        -- API 13 后不推荐使用</p></li>
                                    <li><p><code>void onPrepareDialog(int id, Dialog dialog)</code>
                                        -- API 8 后不推荐使用</p></li>
                                    <li><p><code>void onPrepareDialog(int id, Dialog dialog, Bundle
                                        args)</code> -- API 13 后不推荐使用</p></li>
                                    <li><p><code>final void dismissDialog(int id)</code> -- API 13
                                        后不推荐使用</p></li>
                                    <li><p><code>final void removeDialog(int id)</code> -- API 13
                                        后不推荐使用</p></li>
                                    <li><p><code>void onCreateNavigateUpTaskStack(TaskStackBuilder
                                        builder)</code> -- API 16 添加</p></li>
                                    <li><p><code>void onPrepareNavigateUpTaskStack(TaskStackBuilder
                                        builder)</code> -- API 16 添加</p></li>
                                    <li><p><code>boolean navigateUpTo(Intent upIntent)</code> -- API
                                        16 添加</p></li>
                                    <li><p><code>boolean navigateUpToFromChild(Activity child,
                                        Intent upIntent)</code> -- API 16 添加</p></li>
                                    <li><p><code>boolean onNavigateUp()</code> -- API 16 添加</p></li>
                                    <li><p><code>boolean onNavigateUpFromChild(Activity
                                        child)</code> -- API 16 添加</p></li>
                                    <li><p><code>boolean onCreateThumbnail(Bitmap outBitmap, Canvas
                                        canvas)</code> -- 生成一个略缩图(此方法好像不工作)</p></li>

                                </ol>
                            </li>

                        </ol>
                    </div>

                    <div class="sub-item">
                        <p>Activity 相关类：</p>
                        <ul>
                            <li><p><a href=""></a> -- </p></li>
                            <li><p><a href=""></a> -- </p></li>
                            <li><p><a href=""></a> -- </p></li>
                            <li><p><a href=""></a> -- </p></li>
                        </ul>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="..."></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">...</h3>
                </div>
                <div class="panel-body">

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-view-View"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">View</h3>
                </div>
                <div class="panel-body">

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-view-Fragment"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Fragment</h3>
                </div>
                <div class="panel-body">

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-view-SufaceView"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">SufaceView</h3>
                </div>
                <div class="panel-body">

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-view-Window"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Window</h3>
                </div>
                <div class="panel-body">
                    <p><a href="docs/reference/android/view/Window.html">Window</a> --
                        是一个抽象类，Activity 使用的是其子类的实例: <code>com.android.internal.policy.impl.PhoneWindow</code>
                    </p>

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-view-KeyEvent"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">KeyEvent</h3>
                </div>
                <div class="panel-body">
                    <p><a href="docs/reference/android/view/KeyEvent.html">KeyEvent</a>
                        -- 按键事件，</p>

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-view-MotionEvent"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">MotionEvent</h3>
                </div>
                <div class="panel-body">
                    <p><a href="docs/reference/android/view/MotionEvent.html">MotionEvent</a>
                        -- 触摸事件，</p>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-view-DragEvent"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">DragEvent</h3>
                </div>
                <div class="panel-body">

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-view-GestureDetector"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">GestureDetector</h3>
                </div>
                <div class="panel-body">

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a id="android-view-ActionMode" class="offset"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">ActionMode</h3>
                </div>
                <div class="panel-body">
                    <p><a
                            href="docs/reference/android/view/ActionMode.html">ActionMode</a>
                        -- 是 3.0 之后不同于 ContextMenu 的另一种上下文操作的实现，经常在文本编辑或列表选择的操作中使用</p>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-view-LayoutInflater"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">LayoutInflater</h3>
                </div>
                <div class="panel-body">

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-view-Menu"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Menu</h3>
                </div>
                <div class="panel-body">

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-view-MenuInflater"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">MenuInflater</h3>
                </div>
                <div class="panel-body">

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-os-AsyncTask"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">AsyncTask</h3>
                </div>
                <div class="panel-body">
                    <pre class="brush: java;">
java.lang.Object
    android.os.AsyncTask&lt;Params, Progress, Result>

/** Params：doInBackground 方法的参数类型；
 *  Progress：AsyncTask 所执行的后台任务的进度类型；
 *  Result：后台任务的返回结果类型。
 */
public abstract class AsyncTask&lt;Params, Progress, Result> {
    enum AsyncTask.Status {
        PENDING,    // 准备
        RUNNING,    // 运行
        FINISHED,   // 完成
    }
}
                    </pre>
                    <p><a href="docs/reference/android/os/AsyncTask.html"
                          target="_blank">AsyncTask</a> 是对 Handler
                        与线程池的封装。使用它的方便之处在于能够更新用户界面，当然这里更新用户界面的操作还是在主线程中完成的，但是由于 AsyncTask 内部包含一个
                        Handler，所以可以发送消息给主线程让它更新 UI。</p>
                    <p>另外，<a href="docs/reference/android/os/AsyncTask.html" target="_blank">AsyncTask</a>
                        内还包含了一个线程池，使用线程池的主要原因是避免不必要的创建及销毁线程的开销。</p>
                    <p><a href="docs/reference/android/os/AsyncTask.html"
                          target="_blank">AsyncTask</a> 是一个抽象类，我们在使用时需要定义一个它的派生类并重写相关方法。</p>
                    <p><b>AsyncTask 的局限性:</b></p>
                    <p class="alert alert-success"><b>1.一个 AsyncTask 对象只能调用一次 execute 方法;<br/>2.在
                        Android 4.1 版本之前，AsyncTask 类必须在主线程中加载，在 Android 4.1 以及以上版本则不存在这一限制;</b></p>
                    <p><a href="docs/reference/android/os/AsyncTask.html"
                          target="_blank">AsyncTask</a> 的主要方法：</p>
                    <ol>
                        <li><p><code>public final AsyncTask&lt;Params, Progress, Result>
                            execute(Params... params)</code> -- 触发执行异步任务</p></li>
                        <li><p><code>protected void onPreExecute()</code> -- 可以执行初始化操作</p></li>
                        <li><p><code>protected Result doInBackground(Params... params) {</code> --
                            工作线程</p></li>
                        <li><p><code>protected void publishProgress(Progress... values)</code> -- 在
                            doInBackground 中调用，会执行 onProgressUpdate 方法</p></li>
                        <li><p><code>protected void onProgressUpdate(Progress... values)</code> --
                            进度回调</p></li>
                        <li><p><code>protected void onPostExecute(Result result)</code> -- 执行完成回调
                        </p></li>
                        <li><p><code>protected void onCancelled()</code> -- 取消回调</p></li>
                        <li><p><code>public void cancel(boolean mayInterruptIfRunning)</code> -- 取消
                        </p></li>
                        <li><p><code>public final boolean isCancelled()</code> -- 是否取消</p></li>
                        <li><p><code>public final AsyncTask.Status getStatus()</code> -- 获取状态</p>
                        </li>
                    </ol>
                </div>
            </div>
            <!-- item over -->

            <a class="offset" id="android-os-Handler"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Handler 机制</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <p><b>Handler</b></p>
                        <pre class="brush: java;">

                        </pre>
                    </div>

                    <div class="sub-item">
                        <p><b>Looper</b></p>
                        <pre class="brush: java;">

                        </pre>
                    </div>

                    <div class="sub-item">
                        <p><b>MessageQueue</b></p>
                        <pre class="brush: java;">

                        </pre>
                    </div>

                    <div class="sub-item">
                        <p><b>ThreadLocal</b></p>
                        <pre class="brush: java;">

                        </pre>
                    </div>

                    <div class="sub-item">
                        <p><b>Message</b></p>
                        <pre class="brush: java;">

                        </pre>
                    </div>

                    <div class="sub-item">
                        <p><b>HandlerThread</b></p>
                        <pre class="brush: java;">
java.lang.Object
    java.lang.Thread
  	    android.os.HandlerThread

public class HandlerThread extends Thread {
    public MyHandlerThread(String name) {}
    public HandlerThread(String name, int priority) {}
}
                    </pre>
                        <p><a href="docs/reference/android/os/HandlerThread.html" target="_blank">HandlerThread</a>
                            是 <code>Thread</code> 的子类，将 Looper, Handler, Thread 封装在一起。</p>
                    </div>


                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-net-wifi-WifiManager"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">WifiManager</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <pre class="brush: java;">
java.lang.Object
    android.net.wifi.WifiManager

public class WifiManager {
    /** 手机屏幕关闭之后，并且其他的应用程序没有在使用 wifi 的时候，系统在一段时间之后，会关闭 wifi，
     * 使得 wifi 处于睡眠状态。有利于电源能量的节省和延长电池寿命等。
     * 通过 WifiLock 来锁定 wifi 网络，使其一直保持连接，直到这个锁定被释放。主要有两个方法：
     * acquire() -- 锁定 Wifi
     * release() -- 释放 Wifi
     */
    public class WifiLock {}

    /** 组播锁，默认情况下，应用是不接收组播报文信息的，要打开组播锁，主要还是同上面的两个方法，还需要权限：
     * android.permission.CHANGE_WIFI_MULTICAST_STATE
     */
    public class MulticastLock {}

    /** 启动 WPS 连接时的回调接口 */
    public static abstract class WpsCallback {
        abstract void onFailed(int reason);
        abstract void onStarted(String pin);
        abstract void onSucceeded();
    }
}
                        </pre>
                        <p>
                            <a href="docs/reference/android/net/wifi/WifiManager.html">WifiManager</a>
                            是 Android 暴露给开发者使用的一个系统服务管理类, 其中包含对 WiFi 的响应的操作函数; 其隐藏掉的系统服务类为
                            IWifiService, 为 Android 私有的, 其具体实现, 未暴露给用户; 只需要使用 WifiManager 进行函数操作完成
                            UI, 监听对应的广播消息, 就可完成功能了. 换言之, WifiManager 会调用 Service 和 Framework 层,
                            驱动层进行函数调用, 然后驱动层会回调至上层, 以广播的形式实现通知。</p>
                        <pre class="brush: java;">
<!-- Wifi 相关的几个权限 -->
&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
&lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />

&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
&lt;uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" />
&lt;uses-permission android:name="android.permission.INTERNET" />
                            <!-- 组播锁权限 -->
&lt;uses-permission android:name="android.permission.CHANGE_WIFI_MULTICAST_STATE" />

&lt;uses-permission android:name="android.permission.WRITE_SETTINGS" />


private WifiManager wifiManager;

private void setupView() {
    // 1.打开 / 关闭 Wifi
    wifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
    wifiManager.setWifiEnabled(true);

    // 2.Wifi 状态
    int wifiState = wifiManager.getWifiState();
    switch (wifiState) {
        case WifiManager.WIFI_STATE_DISABLED: // 已经完全关闭的状态

            break;
        case WifiManager.WIFI_STATE_DISABLING: // 正要关闭的状态

            break;
        case WifiManager.WIFI_STATE_ENABLED: // 已经完全开启的状态

            break;
        case WifiManager.WIFI_STATE_ENABLING: // 正要开启的状态

            break;
        case WifiManager.WIFI_STATE_UNKNOWN: // 未知的状态

            break;
    }

    // 3.获取扫描到的 WiFi 热点的结果
    wifiManager.startScan();
    List&lt;ScanResult> scanResults = wifiManager.getScanResults();

    /** 4.取配置好的 WiFi 信息
        * Android 的 WiFi 连接, 大概可以分为如下两种情况:
        * a.无密码的, 可直接连接, 连接过程中, 此热点一直有, 不管最后是否需要其他方式进行验证操作, 但凡连接成功, 
        *   即刻进行了对此热点的配置进行保存;
        * b.有密码的, 暂且不论何种加密手段, 只要用户输入密码, 点击连接, 如果连接途中, 此热点一直有, 
        *   不论连接成功还是失败, 都即刻对此热点的配置进行了保存操作;
        * c.连接多个WiFi成功之后, 然后关闭WiFi, 下次开启WiFi的时候, 它会主动帮你连接这其中配置好的其中一个WiFi;
        */
    List&lt;WifiConfiguration> wifiConfigurations = wifiManager.getConfiguredNetworks();
    if (wifiConfigurations == null || wifiConfigurations.isEmpty()) {
        return;
    }
    for (WifiConfiguration configuration : wifiConfigurations) {
        Log.v("Wifi", "configuration = " + configuration.toString());
    }

    // 5.连接 WiFi
    WifiConfiguration mConfig = createWifiConfig("ILESSON", "ilesson@2017", WIFICIPHER_WPA);
    mWifiManager.addNetwork(mConfig);
}

private static final int WIFICIPHER_NOPASS = 0;
private static final int WIFICIPHER_WEP = 1;
private static final int WIFICIPHER_WPA = 2;

private WifiConfiguration createWifiConfig(String ssid, String password, int type) {
    // 初始化 WifiConfiguration
    WifiConfiguration config = new WifiConfiguration();
    config.allowedAuthAlgorithms.clear();
    config.allowedGroupCiphers.clear();
    config.allowedKeyManagement.clear();
    config.allowedPairwiseCiphers.clear();
    config.allowedProtocols.clear();

    // 指定对应的 SSID
    config.SSID = "\"" + ssid + "\"";

    // 如果之前有类似的配置
    WifiConfiguration tempConfig = isExist(ssid);
    if (tempConfig != null) {
        // 则清除旧有配置
        wifiManager.removeNetwork(tempConfig.networkId);
    }

    // 不需要密码的场景
    if (type == WIFICIPHER_NOPASS) {
        config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
        // 以 WEP 加密的场景
    } else if (type == WIFICIPHER_WEP) {
        config.hiddenSSID = true;
        config.wepKeys[0] = "\"" + password + "\"";
        config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);
        config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.SHARED);
        config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
        config.wepTxKeyIndex = 0;
        //以 WPA 加密的场景，自己测试时，发现热点以 WPA2 建立时，同样可以用这种配置连接
    } else if (type == WIFICIPHER_WPA) {
        config.preSharedKey = "\"" + password + "\"";
        config.hiddenSSID = true;
        config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);
        config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);
        config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);
        config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);
        config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);
        config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);
        config.status = WifiConfiguration.Status.ENABLED;
    }

    return config;
}

private WifiConfiguration isExist(String ssid) {
    List&lt;WifiConfiguration> configs = wifiManager.getConfiguredNetworks();

    for (WifiConfiguration config : configs) {
        if (config.SSID.equals("\"" + ssid + "\"")) {
            return config;
        }
    }
    return null;
}

/** 获取热点的加密类型 */
private int getType(ScanResult scanResult) {
    int type = WIFICIPHER_NOPASS;
    if (scanResult.capabilities.contains("WPA"))
        type = WIFICIPHER_WPA;
    else if (scanResult.capabilities.contains("WEP"))
        type = WIFICIPHER_WEP;
    else
        type = WIFICIPHER_NOPASS;
    return type;
}

public static final String WIFI_HOTSPOT_SSID = "Robot";

/** 创建 Wifi 热点
 * 在开启热点的时候，我们需要确保 WiFi 是关闭状态，因为大部分手机都是不支持热点和 WiFi是同时开启的。
 *    接着就需要创建 WifiConfiguration 这个类，由于配置我们所要创建的热点的属性。这里我们所需注意的主要是
 *    SSID、preSharedKey 和 KeyMgmt。 分别对应热点的名称、密码和加密方式。
 */
private void createWifiHotspot() {
    if (wifiManager.isWifiEnabled()) {
        // 如果 wifi 处于打开状态，则关闭 wifi
        wifiManager.setWifiEnabled(false);
    }
    WifiConfiguration config = new WifiConfiguration();
    config.SSID = WIFI_HOTSPOT_SSID;
    config.preSharedKey = "123456789";
    config.hiddenSSID = true;
    config.allowedAuthAlgorithms
            .set(WifiConfiguration.AuthAlgorithm.OPEN);//开放系统认证
    config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);
    config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);
    config.allowedPairwiseCiphers
            .set(WifiConfiguration.PairwiseCipher.TKIP);
    config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);
    config.allowedPairwiseCiphers
            .set(WifiConfiguration.PairwiseCipher.CCMP);
    config.status = WifiConfiguration.Status.ENABLED;
    // 通过反射调用设置热点
    try {
        Method method = wifiManager.getClass().getMethod(
                "setWifiApEnabled", WifiConfiguration.class, Boolean.TYPE);
        boolean enable = (Boolean) method.invoke(wifiManager, config, true);
        if (enable) {
            Log.i("Wifi", "热点已开启 SSID:" + WIFI_HOTSPOT_SSID + " password:123456789");
        } else {
            Log.i("Wifi", "创建热点失败");
        }
    } catch (Exception e) {
        e.printStackTrace();
        Log.i("Wifi", "创建热点失败");
    }
}

/** 关闭 WiFi热点 */
public void closeWifiHotspot() {
    try {
        Method method = wifiManager.getClass().getMethod("getWifiApConfiguration");
        method.setAccessible(true);
        WifiConfiguration config = (WifiConfiguration) method.invoke(wifiManager);
        Method method2 = wifiManager.getClass().getMethod(
            "setWifiApEnabled", WifiConfiguration.class, boolean.class);
        method2.invoke(wifiManager, config, false);
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (IllegalArgumentException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    }
}
                        </pre>
                    </div>

                    <div class="sub-item">
                        <p><b>WifiManager</b> 方法</p>
                        <ol>
                            <li><p><code>boolean isWifiEnabled()</code> -- Wifi 是否打开</p></li>
                            <li><p><code>boolean setWifiEnabled(boolean enabled) </code> -- 开启或关闭
                                Wifi, 需要 <code>WRITE_SETTINGS</code> 权限</p></li>
                            <li><p><code>int getWifiState()</code> -- 获取 Wifi 状态: 打开，正在打开，关闭，正在关闭，未知
                            </p></li>
                            <li><p><code><a href="#WifiInfo">WifiInfo</a> getConnectionInfo()</code>
                                -- 获取已经连接的 Wifo 信息</p></li>
                            <li><p><code>boolean isScanAlwaysAvailable()</code> -- 检查扫描是否始终可用</p>
                            </li>
                            <li><p><code>boolean startScan()</code> --
                                开始扫描热点，立即返回，结果的可用性稍后通过扫描完成后发送的异步事件而知道。</p></li>
                            <li><p><code>List&lt;<a href="#ScanResult">ScanResult</a>>
                                getScanResults()</code> -- 获取扫描到的热点列表信息</p></li>

                            <li><p><code>List&lt;<a href="#android-net-wifi-WifiConfiguration">WifiConfiguration</a>>
                                getConfiguredNetworks()</code> -- 获取已经配置的 WifiConfiguration 信息列表</p>
                            </li>
                            <li><p><code>int addNetwork(<a
                                    href="#android-net-wifi-WifiConfiguration">WifiConfiguration</a>
                                config)</code> -- 通过 config 配置一个网络（配置，不是连接）</p></li>
                            <li><p><code>int updateNetwork(<a
                                    href="#android-net-wifi-WifiConfiguration">WifiConfiguration</a>
                                config)</code> -- 通过 config 更新 一个网络</p></li>
                            <li><p><code>boolean enableNetwork(int netId, boolean
                                disableOthers)</code> -- 根据 netId 启动一个网络</p></li>
                            <li><p><code>boolean removeNetwork(int netId)</code> -- 根据 netId 删除一个网络
                            </p></li>

                            <li><p><code>boolean saveConfiguration()</code> -- 保存配置</p></li>
                            <li><p><code>boolean reconnect()</code> -- 重新连接</p></li>
                            <li><p><code>boolean disconnect()</code> -- 断开连接</p></li>
                            <li><p><code>boolean reassociate()</code> -- 重新连接 WIFI 网络，即使该网络是已经被连接上的
                            </p></li>
                            <li><p><code><a href="#DhcpInfo">DhcpInfo</a> getDhcpInfo()</code> --
                                DhcpInfo 保存了当前连接的网络信息，包括 IP, 网关，掩码，DNS 等...不限于 Wifi。</p></li>
                            <li><p><code>void startWps(<a href="#WpsInfo">WpsInfo</a> config,
                                WifiManager.WpsCallback listener)</code> -- 启动 Wps 连接</p></li>
                            <li><p><code>void cancelWps(WifiManager.WpsCallback listener)</code> --
                                取消 Wps 连接</p></li>
                            <li><p><code>static int calculateSignalLevel(int rssi, int
                                numLevels)</code> -- 根据 rssi 返回信号强度等级</p>
                                <pre class="brush: java;">
/** 返回的等级为 0 ~ (numLevels - 1),
 * rssi 可以从 mScanResult.level 和 mWifiInfo.getRssi() 获取，其方法实现为：
 */
if (rssi <= MIN_RSSI) { // MIN_RSSI = -100
    return 0;
} else if (rssi >= MAX_RSSI) {  // MAX_RSSI = -55
    return numLevels - 1;
} else {
    float inputRange = (MAX_RSSI - MIN_RSSI);
    float outputRange = (numLevels - 1);
    return (int)((float)(rssi - MIN_RSSI) * outputRange / inputRange);
}
</pre>
                            </li>
                            <li><p><code>static int compareSignalLevel(int rssiA, int rssiB)</code>
                                -- 对比网络A和网络B的信号强度</p></li>

                            <li><p><code>WifiManager.WifiLock createWifiLock(int lockType, String
                                tag)</code> -- 创建 WIFI 锁，锁定当前的 WIFI 连接</p>
                                <pre class="brush:java;">
/** 有 3 种 lockType:
 * WIFI_MODE_FULL -- Wi-Fi 将保持活跃，并将正常工作
 * WIFI_MODE_SCAN_ONLY -- 工作在高性能与最低的丢包率和低分组延迟，当没有从硬件的支持时同上
 * WIFI_MODE_FULL_HIGH_PERF -- 唯一支持的操作是启动扫描，以及随后对扫描结果的报告
 */
                            </pre>
                            </li>
                            <li><p><code>WifiManager.WifiLock createWifiLock(String tag) </code> --
                                使用 <code>WIFI_MODE_FULL</code> 模式创建
                            </p></li>
                            <li><p><code>WifiManager.MulticastLock createMulticastLock(String
                                tag)</code> -- 创建组播锁，可以允许接受组播报文</p></li>
                            <li><p><code>boolean is5GHzBandSupported()</code> -- 是否支持 5 GHz 频段</p>
                            </li>
                            <li><p><code>boolean isDeviceToApRttSupported()</code> -- 是否支持
                                Device-to-AP RTT</p></li>
                            <li><p><code>boolean isEnhancedPowerReportingSupported()</code> --
                                是否支持高级电源/性能计数器</p>
                            </li>
                            <li><p><code>boolean isP2pSupported()</code> -- 是否支持 P2P 连接</p></li>
                            <li><p><code>boolean isPreferredNetworkOffloadSupported()</code> --
                                是否支持卸载连接扫描</p>
                            </li>
                            <li><p><code>boolean isTdlsSupported()</code> -- 是否支持 TDLS</p></li>
                            <li><p><code>boolean pingSupplicant()</code> -- 是否相应 ping</p></li>

                            <li><p><code>void setTdlsEnabled(InetAddress remoteIPAddress, boolean
                                enable)</code> -- IP 地址打开/关闭 TDLS</p></li>
                            <li><p><code>void setTdlsEnabledWithMacAddress(String remoteMacAddress,
                                boolean enable)</code> -- Mac 地址打开/关闭 TDLS</p></li>
                        </ol>
                    </div>

                    <div class="sub-item">
                        <p><b>WifiManager</b> 相关类</p>
                        <ul>
                            <li><a id="ScanResult" class="offset"></a>
                                <p><a href="docs/reference/android/net/wifi/ScanResult.html"
                                      target="_blank">ScanResult</a> -- 扫描到的 WiFi 热点的结果</p>
                                <pre class="brush: java;">
/** 扫描得到所有的热点列表 */
List&lt;ScanResult> scanResults = mWifiManager.getScanResults();
if(null == scanResults || scanResults.isEmpty()) {
    // 如果没有数据，那么应该扫描，此扫描完成会由一个广播 WifiManager.SCAN_RESULTS_AVAILABLE_ACTION
    mWifiManager.startScan();// 扫描应该放在系统的 wifi 状态改变时候，看下面代码


    IntentFilter filter = new IntentFilter();
    filter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
    filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION); // wifi 状态改变, 加这个貌似会快

    registerReceiver(new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            // wifi 已成功扫描到可用 wifi。
            if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {
                Log.d(TAG, "接收到" +DateUtils.getCurrentDateString());
                mScanResults = mWifiManager.getScanResults();
                Log.d(TAG, "mScanResults.size()===" + mScanResults.size());

            } else if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) { // 系统 wifi 的状态
                int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, 0);
                switch (wifiState) {
                    case WifiManager.WIFI_STATE_ENABLED:
                        Log.d(TAG, "WiFi已启用" + DateUtils.getCurrentTime());
                        mWifiManager.startScan();
                        break;
                    case WifiManager.WIFI_STATE_DISABLED:
                        Log.d(TAG, "Wifi已关闭" + DateUtils.getCurrentTime());
                        break;
                }
            }
        }
    },  filter);
}

/** 根据信号强弱排序 */
Collections.sort(scanResults, new Comparator&lt;ScanResult>() {
    @Override
    public int compare(ScanResult lhs, ScanResult rhs) {
        return rhs.level - lhs.level;
    }
});

/** ScanResult 的字段:
 * SSID -- Wifi 的名字
 * BSSID -- 接入点的 Mac 地址
 * level -- 信号强度 -0 ~ -100, 一般认为使用 WifiManger.calculateSignalLevel(level, NumberLevel) 计算等级
 * capabilities -- 支持的加密方式
 * frequency -- 当前 WIFI 设备附近热点的频率
 * ...
 */

</pre>
                            </li>
                            <li><a id="WifiInfo" class="offset"></a>
                                <p><a href="docs/reference/android/net/wifi/WifiInfo.html"
                                      target="_blank">WifiInfo</a> -- 描述处于活动状态或正在设置过程中的任何 WiFi 连接的状态
                                </p>
                                <pre class="brush: java;">
WifiInfo info = mWifiManager.getConnectionInfo();
/** WifiInfo 主要有以下方法：
 * getSSID() -- 网络名称
 * getBSSID() -- 网络 Mac 地址
 * getRssi() -- 型号强度
 * getHiddenSSID() -- 是否是隐藏网络
 * getMacAddress()  -- MacAddress
 * getNetworkId() -- 网络 id
 * getSupplicantState() -- 返回枚举类型，当前连接的状态
 * getLinkSpeed() -- 连接速度
 */
</pre>
                            </li>
                            <li><a id="DhcpInfo" class="offset"></a>
                                <p><a href="docs/reference/android/net/DhcpInfo.html"
                                      target="_blank">DhcpInfo</a> -- 保存了当前连接的网络信息，包括 IP, 网关，掩码，DNS
                                    等...不限于 Wifi。</p>
                                <pre class="brush: java;">
public int 	dns1;
public int 	dns2;
public int 	gateway;
public int 	ipAddress
public int 	leaseDuration;
public int 	netmask;
public int 	serverAddress;
</pre>
                            </li>
                            <li><a id="WpsInfo" class="offset"></a>
                                <p><a href="docs/reference/android/net/wifi/WpsInfo.html"
                                      target="_blank">WpInfo</a> -- 当热点端启动 WPS 连接时，连接端只需要点击 WPS
                                    按钮即可连接(连接端的 Wifi 连接，高级可看到 WPS 连接); 当热点端选择从对等设备获取 pin 码时，连接机的 WPS
                                    PIN 输入，会弹出一个 PIN 码，这个时候在个人热点端输入相应数字即可连接。</p>
                                <pre class="brush: java;">
WpsInfo config = new WpsInfo();
if (mWpsMode == PUSH_BUTTON) {
    config.setup = WpsInfo.PBC;
    config.BSSID = "any";
} else if (mWpsMode == PIN_FROM_CLIENT) {
    // PIN 码参数
    config.setup = WpsInfo.DISPLAY;
    config.pin = "1234";
}
mWifiManager.startApWps(config, new WifiManager.WpsCallback() {...});
</pre>
                            </li>
                        </ul>
                    </div>

                    <div class="sub-item">
                        <p>Wifi 状态监听：</p>
                        <ul>
                            <li><p>Wifi 状态变化：</p>
                                <pre class="brush: java;">
BroadcastReceiver wifiReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if(WifiManager.WIFI_STATE_CHANGED_ACTION.equals(action)) {
            int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, -1);
            AppUtil.logDebug("== state: " + wifiState);
            switch (wifiState) {
                case WifiManager.WIFI_STATE_DISABLING: // 正要关闭的状态
                    break;
                case WifiManager.WIFI_STATE_DISABLED: // 已经完全关闭的状态
                    break;
                case WifiManager.WIFI_STATE_ENABLING: // 正要开启的状态
                    break;
                case WifiManager.WIFI_STATE_ENABLED: // 已经完全开启的状态
                    break;
                case WifiManager.WIFI_STATE_UNKNOWN: // 未知的状态
                    break;
            }
        }
    }
};

IntentFilter wifiFilter = new IntentFilter();
wifiFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
// wifiFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION); // 触发 NetworkInfo.State 枚举类型
registerReceiver(wifiReceiver, wifiFilter);
                        </pre>
                            </li>
                            <li><p>Wifi 热点扫描结果：(一般来说，Wifi 启动后自动扫描热点，并每隔一段时间自动再次扫描，不用调用 WifiManager 的
                                <code>startScan()</code> 方法。)</p>
                                <pre class="brush: java;">
BroadcastReceiver wifiReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if(WifiManager.WIFI_STATE_CHANGED_ACTION.equals(action)) {
            int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, -1);
            AppUtil.logDebug("== state: " + wifiState);
            switch (wifiState) {
                case WifiManager.WIFI_STATE_DISABLING: // 正要关闭的状态
                    break;
                case WifiManager.WIFI_STATE_DISABLED: // 已经完全关闭的状态
                    break;
                case WifiManager.WIFI_STATE_ENABLING: // 正要开启的状态
                    break;
                case WifiManager.WIFI_STATE_ENABLED: // 已经完全开启的状态
                    break;
                case WifiManager.WIFI_STATE_UNKNOWN: // 未知的状态
                    break;
            }
        }

        if (WifiManager.SCAN_RESULTS_AVAILABLE_ACTION.equals(action)) {
            List&lt;ScanResult> list = mWifiManager.getScanResults();
            for (ScanResult scanResult : list) {
                AppUtil.logDebug(scanResult.SSID + "==\n");
            }
        }
    }
};
IntentFilter wifiFilter = new IntentFilter();
wifiFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
wifiFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
registerReceiver(wifiReceiver, wifiFilter);
                        </pre>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-net-wifi-WifiConfiguration"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">WifiConfiguration</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
<pre class="brush: java;">
java.lang.Object
    android.net.wifi.WifiConfiguration

public class WifiConfiguration implements Parcelable {
    // 公认的 IEEE 802.11 认证算法
    public static class WifiConfiguration.AuthAlgorithm {}
    // 公认的组加密
    public static class WifiConfiguration.GroupCipher {}
    // 公认的密钥管理方案
    public static class WifiConfiguration.KeyMgmt {}
    // 公认的 WPA 识别的对偶密码
    public static class WifiConfiguration.PairwiseCipher {}
    // 公认的安全协议
    public static class WifiConfiguration.Protocol {}
    // 网络配置的可能状态
    public static class WifiConfiguration.Status {}
}

</pre>
                        <p><a href="docs/reference/android/net/wifi/WifiConfiguration.html"
                              target="_blank">WifiConfiguration</a> 表示配置的 Wi-Fi
                            网络的类，包括安全配置。可用于产看已经配置的 Wifi 和 配置新的网络。</p>
                        <p>不论是配置 Wifi 还是创建移动热点，都要用到此类，主要是一些字段和内部类。</p>
                        <ul>
                            <li><p>配置 Wifi:</p>
                                <pre class="brush:java;">
/** 连接到一个指定的 Wifi */
WifiConfiguration mConfig = createWifiConfig("ILESSON", "ilesson@2017", WIFICIPHER_WPA);
int netId = mWifiManager.addNetwork(mConfig);
mWifiManager.enableNetwork(netId, true);

private static final int WIFICIPHER_NOPASS = 0; // 无密码
private static final int WIFICIPHER_WEP = 1; // WEP 加密
private static final int WIFICIPHER_WPA = 2; // WPA 加密

private WifiConfiguration createWifiConfig(String ssid, String password, int type) {
    // 初始化 WifiConfiguration
    WifiConfiguration config = new WifiConfiguration();
    config.allowedAuthAlgorithms.clear();
    config.allowedGroupCiphers.clear();
    config.allowedKeyManagement.clear();
    config.allowedPairwiseCiphers.clear();
    config.allowedProtocols.clear();

    // 指定对应的 SSID
    config.SSID = "\"" + ssid + "\"";

    // 如果之前有类似的配置，则清除旧有配置
    WifiConfiguration tempConfig = isExist(ssid);
    if (tempConfig != null) {
        wifiManager.removeNetwork(tempConfig.networkId);
    }

    // 不需要密码的场景
    if (type == WIFICIPHER_NOPASS) {
        config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
    } else if (type == WIFICIPHER_WEP) { // 以 WEP 加密的场景
        config.hiddenSSID = true;
        config.wepKeys[0] = "\"" + password + "\"";
        config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);
        config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.SHARED);
        config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
        config.wepTxKeyIndex = 0;

    } else if (type == WIFICIPHER_WPA) { // 以 WPA / WPA2 加密的场景
        config.preSharedKey = "\"" + password + "\"";
        config.hiddenSSID = true;
        config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);
        config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);
        config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);
        config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);
        config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);
        config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);
        config.status = WifiConfiguration.Status.ENABLED;
    }

    return config;
}

private WifiConfiguration isExist(String ssid) {
    List&lt;WifiConfiguration> configs = wifiManager.getConfiguredNetworks();

    for (WifiConfiguration config : configs) {
        if (config.SSID.equals("\"" + ssid + "\"")) {
            return config;
        }
    }
    return null;
}

/** 获取热点的加密类型 */
private int getType(ScanResult scanResult) {
    int type = WIFICIPHER_NOPASS;
    if (scanResult.capabilities.contains("WPA"))
        type = WIFICIPHER_WPA;
    else if (scanResult.capabilities.contains("WEP"))
        type = WIFICIPHER_WEP;
    else
        type = WIFICIPHER_NOPASS;
    return type;
}
</pre>
                            </li>
                            <li><p>创建移动热点:(4.4 测试成功；7.0 热点创建成功，但是不能获得 IP)</p>
                                <pre class="brush:java;">
/** WifiManager 的 setWifiApEnabled 要使用反射才能调用 */
public void startAp(WifiManager wifiManager, WifiConfiguration config, boolean startOrStop) {
    try {
        Method method = wifiManager.getClass().getMethod("setWifiApEnabled",
                WifiConfiguration.class, boolean.class);
        ret = (Boolean) method.invoke(wifiManager, config, startOrStop);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

private static final int WIFICIPHER_NOPASS = 0; // 无密码
private static final int WIFICIPHER_WEP = 1; // WEP 加密
private static final int WIFICIPHER_WPA = 2; // WPA 加密

/** 创建 Ap 的 WifiConfiguration */
public static WifiConfiguration createApConfig(String ssid, String password, int paramInt) {
    WifiConfiguration config = new WifiConfiguration();
    config.allowedAuthAlgorithms.clear();
    config.allowedGroupCiphers.clear();
    config.allowedKeyManagement.clear();
    config.allowedPairwiseCiphers.clear();
    config.allowedProtocols.clear();

    config.SSID = ssid;

    if (paramInt == WIFICIPHER_NOPASS) {
        config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
        return config;
    }
    if (paramInt == WIFICIPHER_WEP) {
        config.hiddenSSID = true;
        config.wepKeys[0] = password;
        config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.SHARED);
        config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);
        config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);
        config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP40);
        config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP104);
        config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
        config.wepTxKeyIndex = 0;
        return config;
    }
    if (paramInt == WIFICIPHER_WPA) {
        config.preSharedKey = password;
        config.hiddenSSID = true;
        config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);
        config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);
        config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);
        config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);
        // config.allowedProtocols.set(WifiConfiguration.Protocol.WPA);
        config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);
        config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);
        config.status = WifiConfiguration.Status.ENABLED;
        return config;
    }
    return null; // 返回 null，创建热点失败
}
                                </pre>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-net-wifi-p2p-WifiP2pManager"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">WifiP2pManager</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                    <pre class="brush: java;">
java.lang.Object
    android.net.wifi.p2p.WifiP2pManager

public class WifiP2pManager {
    // P2P 使用的通道，多数 P2P 操作都需要一个通道作为参数
    public static class WifiP2pManager.Channel {}
    // P2P 连接回调接口，这个很多方法都要用到，主要返回操作是否成功
    public static interface WifiP2pManager.ActionListener {
        public void onSuccess();
        // reason: BUSY(繁忙), ERROR(错误), P2P_UNSUPPORTED(不支持), NO_SERVICE_REQUESTS(无服务)
        public void onFailure(int reason);
    }
    // P2P 通道丢失的监听接口，initialize 方法使用
    public static interface WifiP2pManager.ChannelListener {
        public void onChannelDisconnected();
    }
    // Upnp 服务可达时响应接口， setUpnpServiceResponseListener 方法使用
    public static interface WifiP2pManager.UpnpServiceResponseListener {
        public void onUpnpServiceAvailable(List&lt;String> uniqueServiceNames, WifiP2pDevice srcDevice);
    }
    // DnsSd 服务可达时响应接口，setDnsSdResponseListeners 方法使用
    public static interface WifiP2pManager.DnsSdServiceResponseListener {
        public void onDnsSdServiceAvailable(String instanceName,
                        String registrationType, WifiP2pDevice srcDevice);
    }
    // DnsSd 回调传输数据的接口，setDnsSdResponseListeners 方法使用
    public static interface WifiP2pManager.DnsSdTxtRecordListener {
        public void onDnsSdTxtRecordAvailable(String fullDomainName,
                Map&lt;String, String> txtRecordMap, WifiP2pDevice srcDevice);
    }
    // 这个为不使用 upnp 和 dnssd 协议响应回调，主要是第三方
    public static interface WifiP2pManager.ServiceResponseListener {
        public void onServiceAvailable(int protocolType, byte[] responseData, WifiP2pDevice srcDevice);
    }

    // P2P 当连接信息可用时进行回调的接口，requestConnectionInfo 方法使用
    public static interface WifiP2pManager.ConnectionInfoListener {
        public void onConnectionInfoAvailable(WifiP2pInfo info);
    }
    // 组信息(相当于AP)回调，requestGroupInfo 方法使用
    public static interface WifiP2pManager.GroupInfoListener {
        public void onGroupInfoAvailable(WifiP2pGroup group);
    }
    // 接受到 P2P 设备成员列表时回调，requestPeers 方法使用
    public static interface WifiP2pManager.PeerListListener {
        public void onPeersAvailable(WifiP2pDeviceList peers);
    }
}
                    </pre>
                        <p>WiFi P2P/ Wi-Fi Direct 是 Wi-Fi 联盟推出的在没有 AP 的情况下设备相互连接的技术规范。</p>
                        <p>真实处理的是系统服务中的 <code>WifiP2pService</code> 类。</p>
                        <p>WiFi P2P/ Wi-Fi Direct 可以支持一对一直连，也可以实现多台设备同时连接。</p>
                        <p>P2P 架构中定义了三个组件:</p>
                        <ul>
                            <li><p><b>P2P Device</b> -- P2P 设备，组建 P2P Group 之前， 智能终端都是 P2P Device；
                            </p></li>
                            <li><p><b>P2P Group Owner(GO)</b> -- 组拥有者，当这些 P2P Device 设备之间完成 P2P 协商后，
                                其中将有一个并且只能有一个 Device 来扮演 Owner 的角色，相当于 AP；</p></li>
                            <li><p><b>P2P Client(GC)</b> -- 客户端，P2P Group 中的所有设备，除去 P2P Group
                                Owner，而其他 Device 来扮演 Client 的角色。</p></li>
                        </ul>
                        <pre class="brush: java;">
1.如何确定谁是 GO,谁是 GC ?
GO 还是 GC 的身份是随机的。可以使用 P2pConfig 的 groupOwnerIntent 做建议

2.如果一定要确定谁是 GO，谁是 GC，怎么办?
GO 端先调用 WifiP2pManger.createGroup() 方法

3.如何断开连接？
WifiP2pManger.removeGroup() 是移除 Group，断开连接。
WifiP2pManger.cancelConnect() 断开一个正在进行的连接。

4.那么如何保证本机一直处于搜索状态呢？
一般情况下，本机 Scan 一次，能够保持在线状态为几十秒到几分钟不等，取决于手机性能或者 WIFI 芯片；
如果保证一直处于搜索状态，方案就是如果搜索结束，就重启一次搜索。

5.如何把一个文件非常方便的发送给多个设备？
发送方做 GO，接收方全部做 GC，即可。

6.如何进行 Socket 通信？
因为 GC 可以知道 GO 的地址，而 GO 是不知道 GC 的地址的。
一般的 Socket 编程思路是，GO 做 Server 端，GC 做 Client 端。
                        </pre>
                    </div>

                    <div class="sub-item">
                        <p><b><a href="docs/reference/android/net/wifi/p2p/WifiP2pManager.html"
                                 target="_blank">WifiP2pManager</a> 基础 API:</b></p>
                        <ol>
                            <li><p><code>WifiP2pManager.Channel initialize(Context srcContext,
                                Looper srcLooper, WifiP2pManager.ChannelListener listener)</code> --
                                通过 Wi-Fi 框架对应用来进行注册</p></li>
                            <li><p><code>void discoverPeers(WifiP2pManager.Channel c,
                                WifiP2pManager.ActionListener listener)</code> -- 初始化对等设备的发现</p>
                            </li>
                            <li><p><code>void stopPeerDiscovery(WifiP2pManager.Channel c,
                                WifiP2pManager.ActionListener listener)</code> -- 停止对等设备的发现</p></li>
                            <li><p><code>void requestPeers(WifiP2pManager.Channel c,
                                WifiP2pManager.PeerListListener listener)</code> -- 获取当前发现的对等设备列表
                            </p></li>

                            <li><p><code>void connect(WifiP2pManager.Channel c, WifiP2pConfig
                                config, WifiP2pManager.ActionListener listener)</code> -- 连接一个设备</p>
                            </li>
                            <li><p><code>void cancelConnect(WifiP2pManager.Channel c,
                                WifiP2pManager.ActionListener listener)</code> -- 取消一个正在进行的连接</p>
                            </li>

                            <li><p><code>void requestConnectionInfo(WifiP2pManager.Channel c,
                                WifiP2pManager.ConnectionInfoListener listener)</code> --
                                获取连接信息，连接成功后才能获取到</p></li>
                            <li><p><code>void requestGroupInfo(WifiP2pManager.Channel c,
                                WifiP2pManager.GroupInfoListener listener)</code> -- 获取连接组信息</p>
                            </li>

                            <li><p><code>void createGroup(WifiP2pManager.Channel c,
                                WifiP2pManager.ActionListener listener)</code> --
                                以当前设备为组拥有者来创建一个点对点连接组</p></li>
                            <li><p><code>void removeGroup(WifiP2pManager.Channel c,
                                WifiP2pManager.ActionListener listener)</code> -- 移除当前的点对点连接组</p>
                            </li>
                        </ol>
                        <pre class="brush: java;">
WifiP2pManager wm = (WifiP2pManager) getSystemService(Context.WIFI_P2P_SERVICE);

/** 1.先注册一个广播处理事件 */
BroadcastReceiver directReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION.equals(action)) {
            AppUtil.logDebug("WIFI_P2P_STATE_CHANGED_ACTION" + intent.getExtras());
            int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1);
            if (state == WifiP2pManager.WIFI_P2P_STATE_ENABLED) {
                AppUtil.logDebug("WIFI_P2P_STATE_ENABLED");
            } else {
                AppUtil.logDebug("WIFI_P2P_STATE_DISABLED");
            }
        }
        if(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION.equals(action)) {
            AppUtil.logDebug("WIFI_P2P_PEERS_CHANGED_ACTION" + intent.getExtras());
        }
        if(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION.equals(action)) {
            if (wm == null) { return; }
            NetworkInfo networkInfo = intent.getParcelableExtra(WifiP2pManager.EXTRA_NETWORK_INFO);
            if (networkInfo.isConnected()) { // 连接成功，在这里获取到 GO 的信息
                wm.requestConnectionInfo(mChannel, new WifiP2pManager.ConnectionInfoListener() {
                    @Override
                    public void onConnectionInfoAvailable(WifiP2pInfo info) {
                        AppUtil.logDebug("info:"+info.toString());
                    }
                });
            } else {

            }
        }
        if(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION.equals(action)) {
            AppUtil.logDebug("WIFI_P2P_THIS_DEVICE_CHANGED_ACTION" + intent.getExtras());
        }
    }
};

IntentFilter filter = new IntentFilter();
// 当设备的 Wifi 直连功能打开或关闭时进行广播
filter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
// 当调用 discoverPeers() 方法的时候进行广播
filter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
// 当设备的 Wi-Fi P2P 连接信息状态改变时候进行广播
filter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
// 当当前设备的详细信息改变的时候进行广播
filter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);

registerReceiver(directReceiver, filter);

/** 2.通过 Wi-Fi 框架对应用来进行注册，得到 Channel */
Channel mChannel = wm.initialize(MainActivity.this, getMainLooper(),
                            new WifiP2pManager.ChannelListener() {
    @Override
    public void onChannelDisconnected() {
        AppUtil.logDebug("== onChannelDisconnected == ");
    }
});

/** 3.初始化对等设备的发现 */
wm.discoverPeers(mChannel, new WifiP2pManager.ActionListener() {
    @Override
    public void onSuccess() {
        // 也会触发这个广播 Action: WIFI_P2P_PEERS_CHANGED_ACTION
        text.setText("发现成功！");
    }

    @Override
    public void onFailure(int reason) {
        AppUtil.logDebug("onFailure(" + reason + ")");
    }
});

/** 4.获取当前发现的对等设备列表 */
wm.requestPeers(mChannel, new WifiP2pManager.PeerListListener() {
    @Override
    public void onPeersAvailable(WifiP2pDeviceList peers) {
        for (WifiP2pDevice wifiP2pDevice : peers.getDeviceList()) {
            mWifiP2pDevice = wifiP2pDevice;
            AppUtil.logDebug(wifiP2pDevice.toString());
        }
    }
});

/** 5.连接到一个指定的对等设备 */
WifiP2pConfig config = new WifiP2pConfig();
config.deviceAddress = mWifiP2pDevice.deviceAddress;
wm.connect(mChannel, config, new WifiP2pManager.ActionListener() {
    @Override
    public void onSuccess() {
        text.setText("连接成功！");
    }

    @Override
    public void onFailure(int reason) {
        AppUtil.logDebug("content:onFailure(" + reason + ")");
    }
});

/** 6.连接成功后可以传输数据，不论是使用 Socket, Http 等
 * WiFi Direct 连接成功后，可以接受到广播，调用：
 * requestConnectionInfo 方法，得到 Group Owner 的 IP 等信息
 * 注意：Client 可以知道 Group Owner 的地址；反过来不行；
 * 因此，Socket 变成时，Group Owner 为 ServerSocket
 */
</pre>
                        <p><b><a href="docs/reference/android/net/wifi/p2p/WifiP2pManager.html"
                                 target="_blank">WifiP2pManager</a> API -- Service Discovery
                            搜索特定网络设备的搜索方式：</b></p>
                        <p>在进行 Wifi Direct 搜索时，会搜索到到附近所有处于 Wifi Direct
                            搜索状态的网络设备，而这些设备中不一定都是你想进行连接的。</p>
                        <p>Android WifiDirect API 提供了一个仅搜索特定网络设备的搜索方式，叫做 <b>Service Discovery</b>，它
                            是Wi-Fi Direct API 在 Android 4.1 中被增强以支持在 WifiP2pManager
                            中的预先关联服务发现。这允许在连接之前使用 Wi-Fi Direct 通过服务(Service)发现和筛选周围的设备。</p>
                        <p>Android 已经提供了两种 Service，一种是 <b>Bonjour Service</b>，一种是 <b>Upnp
                            Service</b>，开发者也可以自己设计一套 Service，一般情况下，这两种 Service 已经足够用了。</p>
                        <p><b>Service Discovery 基本使用方法:</b></p>
                        <p>为了广播你的应用作为一个 Wi-Fi 上的服务，以便于其他设备能够发现并连接你的应用，需要调用
                            <code>addLocalService()</code> 方法并传输一个 <code>WifiP2pServiceInfo</code>
                            对象。这个对象描述了你的应用服务。</p>
                        <p>为了通过 Wi-Fi 开始发现附近的设备，首先你应当决定使用 <b>Bonjour Service</b> 还是 <b>Upnp
                            Service</b> 实现通信。如果使用 <b>Bonjour</b>，首先要用 <code>setDnsSdResponseListeners()</code>
                            设置好一些回调监听器，这个方法需要
                            <code>WifiP2pManager.DnsSdServiceResponseListener</code> 和 <code>DnsSdTxtRecordListener</code>
                            两个作参数；如果使用 <b>Upnp</b>，则要调用
                            <code>setUpnpServiceResponseListener()</code>，这个方法需要 <code>UpnpServiceResponseListener</code>
                            作为参数。</p>
                        <p>在你开始发现本地设备上的服务之前，你也需要调用 <code>addServiceRequest()</code> 方法。当你传递给这个方法的接口
                            <code>ActionListener</code> 收到一个成功的回调，接着你可以通过调用
                            <code>discoverServices()</code> 开始探索在本地设备上的服务。</p>
                        <p>当本地服务被发现，你会收到一个回调，来自
                            <code>WifiP2pManager.DnsSdServiceResponseListener</code> 或者 <code>WifiP2pManager.UpnpServiceResponseListener</code>，这个取决于你注册使用的是
                            <b>Bonjour</b> 还是 <b>Upnp</b>。收到的回调都会包含一个 <code>WifiP2pDevice</code>
                            对象，代表了对应的设备。</p>
                        <ol start="11">
                            <li><p><code>void addLocalService(WifiP2pManager.Channel c,
                                WifiP2pServiceInfo servInfo, WifiP2pManager.ActionListener
                                listener)</code> -- 向 Service Discovery 注册一个本地服务</p></li>
                            <li><p><code>void removeLocalService(WifiP2pManager.Channel c,
                                WifiP2pServiceInfo servInfo, WifiP2pManager.ActionListener
                                listener)</code> -- 移除 servInfo 指定的本地服务</p></li>
                            <li><p><code>void clearLocalServices(WifiP2pManager.Channel c,
                                WifiP2pManager.ActionListener listener)</code> -- 清除 Channel
                                所有的的本地服务</p></li>

                            <li class="group"><p><code>void discoverServices(WifiP2pManager.Channel
                                c, WifiP2pManager.ActionListener listener)</code> -- 初始化 Service
                                Discovery</p></li>

                            <li class="group"><p><code>void addServiceRequest(WifiP2pManager.Channel
                                c, WifiP2pServiceRequest req, WifiP2pManager.ActionListener
                                listener)</code> -- 添加服务请求</p></li>
                            <li><p><code>void removeServiceRequest(WifiP2pManager.Channel c,
                                WifiP2pServiceRequest req, WifiP2pManager.ActionListener
                                listener)</code> -- 移除服务请求</p></li>
                            <li><p><code>void clearServiceRequests(WifiP2pManager.Channel c,
                                WifiP2pManager.ActionListener listener)</code> -- 清除所有注册的服务请求</p>
                            </li>

                            <li class="group"><p><code>void
                                setServiceResponseListener(WifiP2pManager.Channel c,
                                WifiP2pManager.ServiceResponseListener listener)</code> -- 设置服务响应监听
                            </p></li>
                            <li><p><code>void setUpnpServiceResponseListener(WifiP2pManager.Channel
                                c, WifiP2pManager.UpnpServiceResponseListener listener)</code> -- 设置
                                Upnp 服务响应监听</p></li>
                            <li><p><code>void setDnsSdResponseListeners(WifiP2pManager.Channel c,
                                WifiP2pManager.DnsSdServiceResponseListener servListener,
                                WifiP2pManager.DnsSdTxtRecordListener txtListener)</code> -- 设置
                                Bonjour 服务响应监听</p></li>
                        </ol>
                        <pre class="brush: java;">
/** 连接到一个指定的服务，关键在第三步，可以发现服务是否为想要连接的，并返回了 P2pDevice */

// 1.设备-A: 通过 Wi-Fi 框架对应用来进行注册
mChannel = wm.initialize(MainActivity.this, getMainLooper(), new WifiP2pManager.ChannelListener() {
    @Override
    public void onChannelDisconnected() {
        AppUtil.logDebug("== onChannelDisconnected == ");
    }
});

// 2.设备-A: 向 Service Discovery 注册一个本地服务
Map&lt;String, String> map = new HashMap<>();
map.put("ip", "192.168.1.100");
map.put("port", "1028");
info = WifiP2pDnsSdServiceInfo.newInstance("nate", "_presence._tcp", map);
wm.addLocalService(mChannel, info, new WifiP2pManager.ActionListener() {
    @Override
    public void onSuccess() {
        AppUtil.logDebug("=== addLocalService:onSuccess ===");
    }

    @Override
    public void onFailure(int reason) {
        AppUtil.logDebug("=== addLocalService:onFailure(" + reason + ") ===");
    }
});

// 3.设备-B: 注册响应回调，这之前，也要通过 Wi-Fi 框架对应用来进行注册
wm.setDnsSdResponseListeners(mChannel, new WifiP2pManager.DnsSdServiceResponseListener() {
    @Override
    public void onDnsSdServiceAvailable(String instanceName, String registrationType,
                                        WifiP2pDevice srcDevice) {
        /** instanceName -- 第二部中的 'nate'
         * registrationType -- 也是第二部加了个后缀 '_presence._tcp.local.'
         * srcDevice -- 设备
         */
    }
}, new WifiP2pManager.DnsSdTxtRecordListener() {
    @Override
    public void onDnsSdTxtRecordAvailable(String fullDomainName, Map&lt;String, String> txtRecordMap,
                                          WifiP2pDevice srcDevice) {
        /** fullDomainName -- 'nate._presence._tcp.local.'
         * txtRecordMap -- 第二步中的 map: '{ip=192.168.1.100, port=1028}'
         * srcDevice -- 设备
         */
    }
});

// 4.设备-B: 创建服务请求
req = WifiP2pDnsSdServiceRequest.newInstance();
wm.addServiceRequest(mChannel, req, new WifiP2pManager.ActionListener() {
    @Override
    public void onSuccess() {
        AppUtil.logDebug("=== addServiceRequest:onSuccess ===");
    }

    @Override
    public void onFailure(int reason) {
        AppUtil.logDebug("=== addServiceRequest:onFailure(" + reason + ") ===");
    }
});

// 5.设备-B: 寻找服务
wm.discoverServices(mChannel, new WifiP2pManager.ActionListener() {
    @Override
    public void onSuccess() {
        AppUtil.logDebug("=== discoverServices:onSuccess ===");
    }

    @Override
    public void onFailure(int reason) {
        AppUtil.logDebug("=== discoverServices:onFailure(" + reason + ") ===");
    }
});
</pre>
                    </div>

                    <div class="sub-item">
                        <p><a href="">WifiP2pManager</a> 相关类:</p>
                        <ul>
                            <li><p><a href="docs/reference/android/net/wifi/p2p/WifiP2pDevice.html"
                                      target="_blank">WifiP2pDevice</a> -- 表示 Wifi Direct 框架中的
                                设备，在获取当前发现的对等设备列表时，回调接口返回 Device 列表</p>
                                <pre class="brush: java;">
/** 主要有以下属性和方法:
 * deviceAddress -- 设备的 MAC 地址
 * deviceName -- P2P 设备名
 * primaryDeviceType -- 主设备类型标识设备的类型
 * status -- 状态， 有：AVAILABLE，CONNECTED，FAILED， INVITED， UNAVAILABLE
 * isGroupOwner() -- 是否为 GO
 * isServiceDiscoveryCapable() -- 是否有 Service Discovery 能力
 */
                            </pre>
                            </li>
                            <li><p><a
                                    href="docs/reference/android/net/wifi/p2p/WifiP2pDeviceList.html"
                                    target="_blank">WifiP2pDeviceList</a> -- 存储 WifiP2pDevice
                                列表，多数方法为 <code>@hide</code></p>
                                <pre class="brush: java;">
/** 公有方法只有这两个 */
WifiP2pDevice get(String deviceAddress) -- 使用 deviceAddress 查找指定的 WifiP2pDevice
Collection&lt;WifiP2pDevice> getDeviceList() -- 获取 WifiP2pDevice 列表
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/net/wifi/p2p/WifiP2pInfo.html"
                                      target="_blank">WifiP2pInfo</a> -- 只有三个字段，连接成功后，调用 <code>requestConnectionInfo</code>
                                方法，可以拿到 GO 的地址</p>
                                <pre class="brush: java;">
boolean groupFormed -- P2P 是否已经形成
boolean isGroupOwner -- 是否为 Group Owner
InetAddress groupOwnerAddress -- GO 的地址
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/net/wifi/p2p/WifiP2pGroup.html"
                                      target="_blank">WifiP2pGroup</a> -- 表示 Wi-Fi P2P 组的类，连接成功后，调用
                                <code>requestGroupInfo</code> 方法，获取组信息。P2P 组由单个组所有者和一个或多个客户机组成。</p>
                                <pre class="brush: java;">
String getNetworkName() -- P2P 组名，一般由 GO 自动生成
boolean isGroupOwner() -- 是否为 GO
WifiP2pDevice getOwner() -- 获取 GO
Collection&lt;WifiP2pDevice> getClientList() -- 获取所有 GX 列表
                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/net/wifi/p2p/WifiP2pConfig.html"
                                      target="_blank">WifiP2pConfig</a> -- 配置连接，<code>connect</code>
                                方法需要它作参数，并指定 deviceAddress</p>
                                <pre class="brush: java;">
String deviceAddress -- 指定要连接的设备 Mac 地址
int groupOwnerIntent -- 表示建议做 GO 的倾向，0-15，值越大，越建议做 GO
WpsInfo wps -- WPS 配置
                            </pre>
                            </li>
                            <li><p><a
                                    href="docs/reference/android/net/wifi/p2p/nsd/WifiP2pServiceInfo.html"
                                    target="_blank">WifiP2pServiceInfo</a> -- 请求服务的信息，具体看两个子类：<a
                                    href="docs/reference/android/net/wifi/p2p/nsd/WifiP2pUpnpServiceInfo.html"
                                    target="_blank">WifiP2pUpnpServiceInfo</a> 和 <a
                                    href="docs/reference/android/net/wifi/p2p/nsd/WifiP2pDnsSdServiceInfo.html"
                                    target="_blank">WifiP2pDnsSdServiceInfo</a></p>
                                <pre class="brush: java;">
/** 此类本身只有几个常量，表示服务的类型：
 * int SERVICE_TYPE_ALL -- 所有协议
 * int SERVICE_TYPE_BONJOUR -- 基于 DNS 的服务发现协议
 * int SERVICE_TYPE_UPNP -- UPnP 协议
 * int SERVICE_TYPE_VENDOR_SPECIFIC -- 供应商特定的协议
 */

/** 两个子类各有一个静态构造方法:
 **** WifiP2pUpnpServiceInfo 构造方法:
 * WifiP2pUpnpServiceInfo newInstance(String uuid, String device, List&lt;String> services)
 *
 **** WifiP2pDnsSdServiceInfo 构造方法:
 *     instanceName：服务的实例名称
 *     serviceType：服务的类型，这个好像可以自定义，反正我用的是自己定义的名称
 *     txtMap：服务携带的信息，在被发现的时候可以由对方获取，很有用！比如讲 IP 和端口 附加到 txtMap 中
 * WifiP2pDnsSdServiceInfo newInstance(String instanceName, String type, Map&lt;String, String> txtMap)
 */

                            </pre>
                            </li>
                            <li><p><a
                                    href="docs/reference/android/net/wifi/p2p/nsd/WifiP2pServiceRequest.html"
                                    target="_blank">WifiP2pServiceRequest</a> -- 服务发现请求，具体看两个子类：<a
                                    href="docs/reference/android/net/wifi/p2p/nsd/WifiP2pUpnpServiceRequest.html"
                                    target="_blank">WifiP2pUpnpServiceRequest</a> 和 <a
                                    href="docs/reference/android/net/wifi/p2p/nsd/WifiP2pDnsSdServiceRequest.html"
                                    target="_blank">WifiP2pDnsSdServiceRequest</a></p>
                                <pre class="brush: java;">
/** 此类本身只有两个静态构造方法：
 **** 类型为: SERVICE_TYPE_ALL 或 SERVICE_TYPE_VENDOR_SPECIFIC, 否则使用其子类
 * static WifiP2pServiceRequest newInstance(int protocolType)
 **** queryData 可为 null, 否则为供应商特别指定的值
 * static WifiP2pServiceRequest newInstance(int protocolType, String queryData)
 */

/** 两个子类也只有静态构造方法:
 **** WifiP2pDnsSdServiceRequest 构造方法：
 * static WifiP2pDnsSdServiceRequest newInstance()
 * static WifiP2pDnsSdServiceRequest newInstance(String serviceType)
 * static WifiP2pDnsSdServiceRequest newInstance(String instanceName, String serviceType)
 *
 **** WifiP2pUpnpServiceRequest 构造方法：
 * static WifiP2pUpnpServiceRequest newInstance()
 * static WifiP2pUpnpServiceRequest newInstance(String st)
 */
                            </pre>
                            </li>


                        </ul>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-net-ConnectivityManager"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">ConnectivityManager</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <pre class="brush: java;">
java.lang.Object
    android.net.ConnectivityManager

public class ConnectivityManager {
    public static class ConnectivityManager.NetworkCallback {}

    public static interface ConnectivityManager.OnNetworkActiveListener {
        abstract void onNetworkActive();
    }
}

&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
&lt;uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" />
&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
&lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />

ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);
</pre>
                        <p><a href="docs/reference/android/net/ConnectivityManager.html"
                              target="_blank">ConnectivityManager</a>
                            是网络连接相关的管理器，它主要用于查询网络状态并在网络发生改变时发出状态变化通知。</p>
                    </div>

                    <div class="sub-item">
                        <p><a href="docs/reference/android/net/ConnectivityManager.html"
                              target="_blank">ConnectivityManager</a> 方法：</p>
                        <ol>
                            <li><p><code><a href="#NetworkInfo">NetworkInfo</a>
                                getActiveNetworkInfo()</code> -- 获取当前活跃的 NetworkInfo，没有返回 NULL</p>
                            </li>
                            <li><p><code><a href="#NetworkInfo">NetworkInfo</a> getNetworkInfo(int
                                networkType)</code> -- API 23 后使用下面的方法，获取特定网络类型的状态信息</p></li>
                            <li><p><code><a href="#NetworkInfo">NetworkInfo</a>
                                getNetworkInfo(Network network)</code> -- API 21, 获取特定网络状态信息</p>
                            </li>
                            <li><p><code>boolean isDefaultNetworkActive()</code> -- 默认网络是否活跃</p>
                            </li>
                            <li><p><code><a href="#Network">Network</a> getActiveNetwork()</code> --
                                API 23，当前的 Network</p></li>
                            <li><p><code><a href="#Network">Network</a>[] getAllNetworks()</code> --
                                API 21，所有的 Networks</p></li>
                            <li><p><code>boolean bindProcessToNetwork(<a href="#Network">Network</a>
                                network)</code> -- API 23, 将当前进程绑定到网络</p></li>
                            <li><p><code><a href="#Network">Network</a> getBoundNetworkForProcess()</code>
                                -- API 23，获取当强进程绑定的网络</p></li>
                            <li><p><code>void reportNetworkConnectivity(<a
                                    href="#Network">Network</a> network, boolean
                                hasConnectivity)</code> -- 向 Framework
                                报告网络是否具有工作连通性，为系统提供了一个提示，作为回应，Framework 可能重新评估网络的连通性，并可能随后采取进一步行动。
                            </p></li>
                            <li><p><code>boolean requestBandwidthUpdate(<a
                                    href="#Network">Network</a> network)</code> --
                                请求对一个给定的网络带宽更新,，返回是否更新请求被接受</p></li>
                            <li><p><code>void requestNetwork(<a href="#NetworkRequest">NetworkRequest</a>
                                request, PendingIntent operation)</code> -- 请求建立某种类型的网络</p></li>
                            <li><p><code>void releaseNetworkRequest(PendingIntent operation)</code>
                                -- 释放网络请求</p></li>
                            <li><p><code>void requestNetwork(<a href="#NetworkRequest">NetworkRequest</a>
                                request, ConnectivityManager.NetworkCallback networkCallback)</code>
                                -- 同上，但有一个回调</p></li>
                            <li><p><code><a href="#LinkProperties">LinkProperties</a>
                                getLinkProperties(<a href="#Network">Network</a> network)</code> --
                                API 21，获取一个指定网络的属性，包括: DNSs, IPs, ROUTEs, Proxy...</p></li>
                            <li><p><code><a href="#NetworkCapabilities">NetworkCapabilities</a>
                                getNetworkCapabilities(<a href="#Network">Network</a> network)
                            </code> -- API 21，获取 NetworkCapabilities</p></li>
                            <li><p><code><a href="#ProxyInfo">ProxyInfo</a> getDefaultProxy()</code>
                                -- 获取代理，Wifi > 高级 里面可以设置代理</p></li>
                            <li><p><code>boolean isActiveNetworkMetered()</code> -- API
                                16，查询是否开启流量节省模式</p></li>
                            <li><p><code>int getRestrictBackgroundStatus()</code> -- API 24
                                添加，确定后台运行时候是否受到流量限制</p>
                                <pre class="brush: java;">
/** 在设置中可以打开任何一个 APP，移动数据中由：后台允许使用流量和任意使用流量两个选项
 * RESTRICT_BACKGROUND_STATUS_DISABLED -- 设备不限制计量网络活动
 * RESTRICT_BACKGROUND_STATUS_ENABLED -- 在这种状态下，应用程序不应该在后台运行时使用网络，因为它将被拒绝
 * RESTRICT_BACKGROUND_STATUS_WHITELISTED -- 当应用程序在后台运行时，设备限制了计量网络活动，但应用程序可以绕过它
 *      应用程序应该采取措施减轻计量网络访问。例如，音乐流应用程序应该切换到低带宽的比特率。
 */

                            </pre>
                            </li>
                            <li><p><code>void
                                addDefaultNetworkActiveListener(ConnectivityManager.OnNetworkActiveListener
                                l) </code> -- 监听默认网络连接是否激活</p></li>
                            <li><p><code>void
                                removeDefaultNetworkActiveListener(ConnectivityManager.OnNetworkActiveListener
                                l)</code> -- 移除监听</p></li>
                            <li><p><code>void
                                registerDefaultNetworkCallback(ConnectivityManager.NetworkCallback
                                networkCallback) </code> -- 监听默认网络连接的状态</p></li>
                            <li><p><code>void registerNetworkCallback(<a href="#NetworkRequest">NetworkRequest</a>
                                request, ConnectivityManager.NetworkCallback networkCallback)</code>
                                -- 监听某个网络请求的状态，可用时进行回调</p></li>
                            <li><p><code>void
                                unregisterNetworkCallback(ConnectivityManager.NetworkCallback
                                networkCallback)</code> -- 移除监听</p></li>
                            <li><p><code>void registerNetworkCallback(<a href="#NetworkRequest">NetworkRequest</a>
                                request, PendingIntent operation)</code> -- 监听某个网络请求的状态</p></li>
                            <li><p><code>void unregisterNetworkCallback(PendingIntent
                                operation)</code> -- 移除监听</p></li>
                        </ol>
                    </div>

                    <div class="sub-item">
                        <p><a href="docs/reference/android/net/ConnectivityManager.html"
                              target="_blank">ConnectivityManager</a> 相关类：</p>
                        <ul>
                            <li><a class="offset" id="NetworkInfo"></a>
                                <p><a href="docs/reference/android/net/NetworkInfo.html"
                                      target="_blank">NetworkInfo</a> -- 网络状态，网络是否连接等。</p>
                                <pre class="brush: java;">
java.lang.Object
    android.net.NetworkInfo

public class NetworkInfo implements Parcelable {
    public enum State {     // 状态
        CONNECTING, CONNECTED, SUSPENDED, DISCONNECTING, DISCONNECTED, UNKNOWN
    }

    public enum DetailedState {} // 详细状态
}
/** getType() / getTypeName() -- 网络类型，来自 ConnectivityManager 常量，下面几种使用最多
 *      TYPE_MOBILE -- 移动网络
 *      TYPE_WIFI -- WIFI 网络
 *      TYPE_VPN -- VPN 网络
 *      TYPE_BLUETOOTH -- 蓝牙连接
 *      TYPE_ETHERNET -- 以太网数据连接
 *      ...
 * getState() / getDetailedState() -- 网络状态，看两个内部枚举类
 * getSubType() / getSybTypeName() -- 子类型，移动网络有，如：subType:13, subTypeName:LTE
 * getExtraInfo() -- 附加信息，一般为网络的名字
 * isConnected() -- 是否已连接
 * isAvailable() -- 是否可达
 * isRoaming() -- 网络漫游
 * getReason() -- 如果数据网络连接可用，但是连接失败，可获得尝试链接失败的原因
 */
                            </pre>
                            </li>
                            <li><a class="offset" id="Network"></a>
                                <p><a href="docs/reference/android/net/Network.html"
                                      target="_blank">Network</a> -- API 21
                                    加入的类，标识一个网络，被用来引导流量到指定的网络。</p>
                                <pre class="brush: java;">
Network active = cm.getActiveNetwork();
// 多数是将 Network 当网络标识，作为参数使用
LinkProperties properties = cm.getLinkProperties(active);
                            </pre>
                            </li>
                            <li><a class="offset" id="ProxyInfo"></a>
                                <p><a href="docs/reference/android/net/ProxyInfo.html"
                                      target="_blank">ProxyInfo</a> -- 网络代理</p>
                                <pre class="brush: java;">
/** 三个静态构造方法，用于构造 ProxyInfo，三个参数：IP, 端口，排除列表
 * 在设置中：WIFI > 指定 WIFI > 修改网络 > 高级选项，可看到参数的配置
 */
static ProxyInfo buildDirectProxy(String host, int port, List&lt;String> exclList)
static ProxyInfo buildDirectProxy(String host, int port)
static ProxyInfo buildPacProxy(Uri pacUri)

java.net.Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress("192.168.1.1", 9000));
// OkHttp 设置代理
OkHttpClient.Builder builder = new OkHttpClient().newBuilder();
builder.proxy(proxy);

// HttpURLConnection 设置代理
java.net.Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress("10.0.0.172", 80));
URL url = new URL("http://www.baidu.com");
HttpURLConnection connection = (HttpURLConnection) url.openConnection(proxy);
                            </pre>
                            </li>
                            <li><a class="offset" id="LinkProperties"></a>
                                <p><a href="docs/reference/android/net/LinkProperties.html"
                                      target="_blank">LinkProperties</a> -- 只是一个网络信息的封装类，包括: DNSs,
                                    ROUTEs, IPs, Proxy...</p>
                                <pre class="brush: java;">
LinkProperties properties = cm.getLinkProperties(cm.getActiveNetwork());
properties.getDnsServers();
properties.getRoutes();
properties.getLinkAddresses();
properties.getDomains();
properties.getHttpProxy();
                            </pre>
                            </li>
                            <li><a class="offset" id="NetworkCapabilities"></a>
                                <p><a href="docs/reference/android/net/NetworkCapabilities.html"
                                      target="_blank">NetworkCapabilities</a> --
                                    表示网络功能的类，指定某种网络能力和传输类型</p>
                                <pre class="brush: java;">
/** 此类可查看网络类型 */
NetworkCapabilities capabilities = cm.getNetworkCapabilities(cm.getActiveNetwork());
/** 主要有两个方法，由很多常量，分为 CAPABILITY(网络能力) 和 TRANSPORT(传输类型) 两种：
 * NET_CAPABILITY_CAPTIVE_PORTAL --
 * NET_CAPABILITY_CBS -- 网络可以接收基站广播消息
 * NET_CAPABILITY_DUN -- 网络支持拨号的方式接入
 * NET_CAPABILITY_EIMS -- 能够到达紧急状态的 IMS 服务器或其他服务的网络
 * NET_CAPABILITY_FOTA -- 网络可以使用 FOTA 服务器进行软件升级
 * NET_CAPABILITY_IA -- 能够到达载波的初始附加服务器的网络
 * NET_CAPABILITY_IMS -- 网络可以使用多媒体系统服务
 * NET_CAPABILITY_INTERNET -- 网络支持互联网访问
 * NET_CAPABILITY_MMS -- 表示网络可以通过 MMSC 发送 MMS（彩信）
 * NET_CAPABILITY_NOT_METERED -- 非计量网络
 * NET_CAPABILITY_NOT_RESTRICTED -- 不受限制的网络
 * NET_CAPABILITY_NOT_VPN -- 非 VPN 网络
 * NET_CAPABILITY_RCS -- 载波的 RCS 服务器，用于富通信服务
 * NET_CAPABILITY_SUPL -- 网络可以使用基站进行辅助 GPS 定位
 * NET_CAPABILITY_TRUSTED -- 可信任的网络
 * NET_CAPABILITY_VALIDATED -- 网络连接被成功验证
 * NET_CAPABILITY_WIFI_P2P -- 网络支持 WIFI 直连
 * NET_CAPABILITY_XCAP -- 载波的 XCAP 服务器的能力，用于配置和控制
 *
 * TRANSPORT_BLUETOOTH -- 蓝牙传输
 * TRANSPORT_CELLULAR -- 蜂窝网络
 * TRANSPORT_ETHERNET -- 以太网传输
 * TRANSPORT_VPN -- VPN 传输
 * TRANSPORT_WIFI -- WIFI 传输
 */
boolean internet = capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);

boolean bluetooth = capabilities.hasTransport(NetworkCapabilities.TRANSPORT_BLUETOOTH);
                            </pre>
                            </li>
                            <li><a class="offset" id="NetworkRequest"></a>
                                <p><a href="docs/reference/android/net/NetworkRequest.html"
                                      target="_blank">NetworkRequest</a> -- 定义一个网络请求(用内部 Builder
                                    构造，可以指定 Capability 和 Transport)，用于请求一个网络，或者监听网络的变化。</p>
                                <pre class="brush: java;">
ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);

/** 监听网络可用（WIFI或者移动数据）的变化 */
NetworkRequest.Builder builder = new NetworkRequest.Builder();
NetworkRequest request = builder
    .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI) // 添加 WIFI 传输类型
    .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR) // 添加蜂窝传输类型
    .build();

cm.requestNetwork(request, new ConnectivityManager.NetworkCallback() {
    @Override
    public void onAvailable(Network network) {
        super.onAvailable(network);
        AppUtil.logDebug("onAvailable");
    }

    @Override
    public void onLosing(Network network, int maxMsToLive) {
        super.onLosing(network, maxMsToLive);
        AppUtil.logDebug("onLosing");
    }

    @Override
    public void onLost(Network network) {
        super.onLost(network);
        AppUtil.logDebug("onLost");
    }

    @Override
    public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
        super.onCapabilitiesChanged(network, networkCapabilities);
        AppUtil.logDebug("onCapabilitiesChanged");
    }

    @Override
    public void onLinkPropertiesChanged(Network network, LinkProperties linkProperties) {
        super.onLinkPropertiesChanged(network, linkProperties);
        AppUtil.logDebug("onLinkPropertiesChanged");
    }
});
                            </pre>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="android-net-Uri"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">android.net.Uri / java.net.URI</h3>
                </div>
                <div class="panel-body">
<pre class="brush: java;">
java.lang.Object
    android.net.Uri

public abstract class Uri implements Parcelable, Comparable&lt;Uri> {
    public static final class Builder {}
}
</pre>
                    <p><a href="docs/reference/android/net/Uri.html" target="_blank">Uri</a>
                        通用资源标志符。Java 也由一个 <a href="docs/reference/java/net/URI.html"
                                             target="_blank">URI</a> 类，两者差别不大。</p>
                    <p><a href="docs/reference/java/net/URL.html" target="_blank">URL</a>
                        通用资源定位符。URI 是一种宽泛的含义更广的定义，而 URL 则是 URI 的一个子集，就是说 URL 是 URI 的一部分。</p>
                    <pre class="brush: java;">
&lt;scheme>://&lt;authority>&lt;path>?&lt;query>#&lt;fragment>

content://com.example.project:8080/folder/subfolder/etc?name=bqt&age=28#android
|------|  |------------------||---||-------------------||--------------|-------|
 scheme           host         port         path              query     fragment
          |-----------------------|
                 authority

/** 完整的 Uri 组成如下： */
&lt;scheme>://&lt;user>:&lt;password>@&lt;host>:&lt;port>/&lt;path>;&lt;params>?&lt;query>#&lt;fragment>
/** 一共由 9 个参数组成，
 * scheme -- 获取资源使用的协议，例如http、ftp等
 * user:password -- 用户名与密码，这个是一个特殊的存在，一般访问 ftp 时会用到
 * host -- 主机，访问那台主机
 * port -- 端口，访问主机时的端口
 * path -- 路径
 * params -- 这个很少见，主要作用就是向服务器提供额外的参数
 * query -- 查询参数，如通过 get 方式请求的参数
 * fragment -- 片段，比如 HTML 定义锚点
 */

String url = "content://nate:123456@lesson.com:8080/folder/subfolder/etc?name=bqt&age=28#android";

/** android.net.Uri 处理，类似的: java.net.URI */
Uri uri = Uri.parse(url);
uri.getScheme();        // -> content
uri.getUserInfo();      // -> nate:123456
uri.getHost();          // -> lesson.com
uri.getPort();          // -> 8080
uri.getPath();          // -> /folder/subfolder/etc
uri.getQuery();         // -> name=bqt&age=28
uri.getFragment();      // -> android

uri.getSchemeSpecificPart();    // -> nate:123456@lesson.com:8080/folder/subfolder/etc?name=bqt&age=28
uri.getAuthority();             // -> nate:123456@lesson.com:8080

/** java.net.URL 处理也差不多，但是支持的 Scheme 只有： http, https, ftp, file, jar */
                    </pre>
                    <p><a href="docs/reference/android/net/Uri.html" target="_blank">Uri</a> 类的 API:
                    </p>
                    <ol>
                        <li><p><code>static Uri parse(String uriString)</code> -- 从 String 得到一个 Uri
                            实例.</p></li>
                        <li><p><code>static String encode(String s)</code> -- 进行 Uri 编码</p></li>
                        <li><p><code>static String encode(String s, String allow)</code> -- Uri
                            编码时排除 allow 中的字符</p></li>
                        <li><p><code>static String decode(String s)</code> -- 进行 Uri 反编码</p></li>
                        <li><p><code>boolean isAbsolute()</code> -- 是否为绝对 Uri(以 Scheme 开头)</p></li>
                        <li><p><code>abstract boolean isRelative()</code> -- 是否为相对 Uri</p></li>
                        <li><p><code>boolean isOpaque()</code> -- SchemeSpecificPart 部分不以 ‘/’ 开头</p>
                        </li>
                        <li><p><code>abstract boolean isHierarchical()</code> -- SchemeSpecificPart
                            部分以 ‘/’ 开头</p></li>
                        <li><p><code>String getQueryParameter(String key)</code> -- 查询 Query 部分参数
                        </p></li>
                        <li><p><code>List&lt;String> getQueryParameters(String key)</code> -- 查询
                            Query 部分参数列表</p></li>
                        <li><p><code>boolean getBooleanQueryParameter(String key, boolean
                            defaultValue)</code> -- 查询 boolean 类型参数，没有返回默认值</p></li>
                    </ol>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="..."></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">...</h3>
                </div>
                <div class="panel-body">

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="..."></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">...</h3>
                </div>
                <div class="panel-body">

                </div>
            </div>
            <!-- item over -->
        </div>
    </div>
</div>

<div class="btn-group-vertical bottom-button">
    <a href="#" type="button" class="btn btn-default dropdown-toggle dropup"
       data-toggle="dropup">
        <span class="caret"></span>
    </a>
    <a href="#" type="button" class="btn btn-default dropdown-toggle btn-primary"
       data-toggle="dropup">
        TOP
    </a>
    <a href="docs/reference/index.html" type="button"
       class="btn btn-default dropdown-toggle btn-primary" target="_blank"
       data-toggle="dropup"> DOCS </a>

    <a href="docs/guide/index.html" type="button"
       class="btn btn-default dropdown-toggle btn-primary" target="_blank"
       data-toggle="dropup"> GUIDE </a>
</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="../support/jquery/jquery-3.1.1.min.js"></script>
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../support/bootstrap/js/bootstrap.min.js"></script>
<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
<script src="../support/syntaxhighlighter/scripts/shBrushXml.js"></script>
<script src="res/menu.js"></script>
<script src="../commons/js/common.js"></script>
</body>
</html>
