<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--VIEW</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">VIEW</h3>
					</div>
					<div class="list-group">
						<a href="#" class="list-group-item">概述</a>
						<a href="#view-measure" class="list-group-item">View 框架的 measure 机制</a>
						<a href="#view-layout" class="list-group-item">View 框架的 layout 机制</a>
						<a href="#view-draw" class="list-group-item">View 框架的 draw 机制</a>
						<a href="#view-event" class="list-group-item">View 框架的事件分发机制</a>
						<a href="#view-View" class="list-group-item">View 类</a>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#view-Child" aria-expanded="true">
							常用的 View<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="view-Child" class="panel-collapse collapse"
							role="tabpanel">

							<a href="#view-TextView" class="list-group-item">TextView</a>
							<a href="#view-ImageView" class="list-group-item">ImageView</a>
							<a href="#view-EditText" class="list-group-item">EditText</a>
							<a href="#view-Button" class="list-group-item">Button</a>
							<a href="#view-" class="list-group-item">RadioButton</a>
							<a href="#view-" class="list-group-item">CheckBox</a>
							<a href="#view-" class="list-group-item">ProgressBar</a>
							<a href="#view-" class="list-group-item">ListView</a>
							<a href="#view-" class="list-group-item">Spinner</a>
							<a href="#view-" class="list-group-item">SeekBar</a>
							<a href="#view-" class="list-group-item">AutoCompleteTextView</a>
							<a href="#view-" class="list-group-item">ViewPager</a>
							<a href="#view-" class="list-group-item">ActionBar</a>
							<a href="#view-" class="list-group-item">GridView</a>
							<a href="#view-" class="list-group-item">ScrollView</a>
							<a href="#view-" class="list-group-item">Toast</a>
						</div>
						<a href="#view-SurfaceView" class="list-group-item">SurfaceView</a>
						<a href="#view-layout-class" class="list-group-item">ViewGroup 类</a>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#view-layout-container"
							aria-expanded="true">常用的 ViewGroup<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="view-layout-container" class="panel-collapse collapse in" role="tabpanel">
							<a href="#android-support-constraint-ConstraintLayout" class="list-group-item">ConstraintLayout</a>
                            <a href="#android-support-v7-widget-RecyclerView" class="list-group-item">RecyclerView 及子类</a>
							<a href="#view-LinearLayout" class="list-group-item">LinearLayout</a>
							<a href="#view-FrameLayout" class="list-group-item">FrameLayout</a>
							<a href="#view-RelativeLayout" class="list-group-item">RelativeLayout</a>
							<a href="#view-TableLayout" class="list-group-item">TableLayout</a>
						</div>

					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">概述</h3>
					</div>
					<div class="panel-body">
                        <p><b>本文基于 Android API 24</b></p>
                        <p>View 类是用户接口的基础构件。 View 表示屏幕上的一块矩形区域，负责绘制这个区域和事件处理。</p>
                        <p>View 是所有 widget 类的基类，Widget 类用于创建交互式UI构件（按钮，输入框等）。</p>
                        <p>View 类的 ViewGroup 子类是 layout 的基类，Layout 是一个不可见的容器，它保存着 View（或 ViewGroup）并定义这些 View 的 layout 属性。</p>
						<p>Android 中 View 框架的工作机制中，主要有三个过程：</p>
						<ol>
							<li><a href="#view-measure">View 树的测量（measure）机制</a></li>
							<li><a href="#view-layout">View 树的布局（layout）机制</a></li>
							<li><a href="#view-draw">View 树的绘制（draw）机制</a></li>
						</ol>
                        <p>View 的生命周期：(不包括触摸，按键事件等)</p>
                        <ol>
                            <li><p><code>Constructors</code> -- 先调用合适的构造方法构造对象</p></li>
                            <li><p><code>onFinishInflate()</code> -- 如果是从 xml 加载的 View, 会调用此方法</p></li>
                            <li><p><code>onAttachedToWindow()</code> -- 当 View 添加到 Window 的时候调用（在 Activity 第一次执行完 onResume 方法后被调用）</p></li>
                            <li><p><code>onWindowVisibilityChanged(int)</code> -- 窗口可见性变化时候回调(比如：每次窗口进入前台或回到后台，但是电源键不会触发)</p></li>
                            <li><p><code>onMeasure(int, int)</code> -- 测量方法，可能会调用多次</p></li>
                            <li><p><code>onLayout(boolean, int, int, int, int)</code> -- 布局方法，可能会调用多次</p></li>
                            <li><p><code>onSizeChanged(int, int, int, int)</code> -- 尺寸大小改变回调</p></li>
                            <li><p><code>onWindowFocusChanged(boolean)</code> -- 窗体焦点改变时回调(比如：每次窗口进入前台或回到后台，，但是电源键不会触发)</p></li>
                            <li><p><code>onDraw(Canvas)</code> -- 绘制 View(比如：每次窗口进入前台)</p></li>
                            <li><p><code>onDetachedFromWindow</code> -- 从 Window 移除时回调(在 Activity 调用 onDestroy 方法时)</p></li>
                        </ol>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-measure"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">View框架的measure机制</h3>
					</div>
					<div class="panel-body">
						<p>开发人员在绘制 UI 的时候，基本都是通过 XML 布局文件的方式来配置 UI，而每个 View 必须要设置的两个属性就是 layout_width 和 layout_height，这两个属性代表着当前 View 的尺寸。</p>
						<h5 class="text-primary">1、系统为什么要有 measure 过程？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 layout_width 和 layout_height 这两个属性只允许设置固定的大小，那么每个 View 的尺寸在绘制的时候就已经确定了，所以可能都不需要 measure 过程。但是由于需要满足自适应尺寸的机制，所以需要一个 measure 过程。</p>
						<h5 class="text-primary">2、measure 过程都干了点什么事？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于前面提到的自适应尺寸的机制，所以在用自适应尺寸来定义 View 大小的时候，View 的真实尺寸还不能确定。但是 View 尺寸最终需要映射到屏幕上的像素大小，所以 measure 过程就是干这件事，把各种尺寸值，经过计算，得到具体的像素值。measure 过程会遍历整棵 View 树，然后依次测量每个 View 真实的尺寸。具体是每个 ViewGroup 会向它内部的每个子 View 发送 measure 命令，然后由具体子 View 的 onMeasure() 来测量自己的尺寸。最后测量的结果保存在 View 的 mMeasuredWidth 和 mMeasuredHeight 中，保存的数据单位是像素。</p>
						<h5 class="text-primary">3、对于自适应的尺寸机制，如何合理的测量一颗View树？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统在遍历完布局文件后，针对布局文件，在内存中生成对应的 View 树结构，这个时候，整棵 View 树种的所有 View 对象，都还没有具体的尺寸，因为 measure 过程最终是要确定每个 View 的准确尺寸，也就是准确的像素值。但是刚开始的时候，View 中 layout_width 和 layout_height 两个属性的值，都只是自适应的尺寸，也就是 match_parent 和 wrap_content，这两个值在系统中为负数，所以系统不会把它们当成具体的尺寸值。所以当一个 View 需要把它内部的 match_parent 或者 wrap_content 转换成具体的像素值的时候，他需要知道两个信息。</p>
						<ol>
							<li>针对于 match_parent，父布局当前具体像素值是多少，因为 match_parent 就是子 View 想要和父布局一样大。</li>
							<li>针对 wrap_content，子 View 需要根据当前自己内部的 content，算出一个合理的能包裹所有内容的最小值。但是如果这个最小值比当前父布局还大，那不行，父布局会告诉你，我只有这么大，你也不应该超过这个尺寸。</li>
						</ol>
						<h5 class="text-primary">4、那么 ViewGroup 是如何向子 View 传递限制信息的？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;谈到传递限制信息，那就是 MeasureSpec 类了，该类贯穿于整个 measure 过程，用来传递父布局对子 View 尺寸测量的约束信息。简单来说，该类就保存两类数据。</p>
						<ol>
                            <li><p>子 View 当前所在父布局的具体尺寸。</p></li>
                            <li><p>父布局对子 View 的限制类型。</p></li>
						</ol>
						<p>那么限制类型又分为三种类型(int 值的最高两位表示, 另外还有一个 <code>MEASURED_STATE_TOO_SMALL = 0x01000000</code> 表示测量的大小小于视图希望拥有的空间, 剩下的 24 位表示尺寸大小)：</p>
						<ol>
							<li><p><b>MeasureSpec.UNSPECIFIED(<code>0 << 30</code>)</b></p> -- 不限定。意思就是，子 View 想要多大，我就可以给你多大，你放心大胆的 measure 吧，不用管其他的。也不用管我传递给你的尺寸值。（其实 Android 高版本中推荐，只要是这个模式，尺寸设置为 0）;</li>
							<li><p><b>MeasureSpec.EXACTLY(<code>1 << 30</code>)</b></p> -- 精确的。意思就是，根据我当前的状况，结合你指定的尺寸参数来考虑，你就应该是这个尺寸，具体大小在 MeasureSpec 的尺寸属性中，自己去查看吧，你也不要管你的 content 有多大了，就用这个尺寸吧;</li>
							<li><p><b>MeasureSpec.AT_MOST(<code>2 << 30</code>)</b></p> -- 最多的。意思就是，根据我当前的情况，结合你指定的尺寸参数来考虑，在不超过我给你限定的尺寸的前提下，你测量一个恰好能包裹你内容的尺寸就可以了。</li>
						</ol>
						<h5 class="text-primary">MeasureSpec 类:</h5>
						<ul>
							<li><p><code>static int getMode(int measureSpec)</code> -- 根据提供的测量值(格式)提取模式(上述三个模式之一) </p></li>
							<li><p><code>static int getSize(int measureSpec)</code> -- 根据提供的测量值(格式)提取大小值(这个大小就是尺寸)</p></li>
							<li><p><code>static int makeMeasureSpec(int size, int mode)</code> -- 根据提供的大小值和模式创建一个测量值(格式)</p></li>
						</ul>
                        <p class="text-primary">ViewGroup 和 View 的 measure 相关方法(都可能调用多次)：</p>
                        <pre class="brush: java;">
/** 重写 ViewGroup 的 onMeasure 方法： */
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // 确定 ViewGroup 自身的大小
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    // 此方法是 ViewGroup 的方法，要求测量子 View 的大小(会分别调用每个子 View(包括 ViewGroup) 的 onMeasure 方法)
    measureChildren(widthMeasureSpec, heightMeasureSpec);
}

/** 重写 View 的 onMeasure 方法: */
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // 可以更改 View 的尺寸，比如这里将原来的宽度 +100, 单位为像素
    int size = MeasureSpec.getSize(widthMeasureSpec); // 获取到从 xml 传过来的尺寸, 单位为像素
    int newWidthMeasureSpec = MeasureSpec.makeMeasureSpec(size + 100, MeasureSpec.EXACTLY);
    // 确定 View 的大小
    super.onMeasure(newWidthMeasureSpec, heightMeasureSpec);
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-layout"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">View 框架的 layout 机制</h3>
					</div>
					<div class="panel-body">
						<h5 class="text-primary">1、系统为什么要有 layout 过程？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							View 框架在经过第一步的 measure 过程后，成功计算了每一个 View 的尺寸。但是要成功的把 View 绘制到屏幕上，只有 View 的尺寸还不行，还需要准确的知道该 View 应该被绘制到什么位置。除此之外，对一个 ViewGroup 而言，还需要根据自己特定的 layout 规则，来正确的计算出子 View 的绘制位置，已达到正确的 layout 目的。这也就是 layout 过程的职责。</p>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							该位置是 View 相对于父布局坐标系的相对位置，而不是以屏幕坐标系为准的绝对位置。这样更容易保持树型结构的递归性和内部自治性。而 View 的位置，可以无限大，超出当前 ViewGroup 的可视范围，这也是通过改变 View 位置而实现滑动效果的原理。</p>
						<p>&nbsp;</p>
						<h5 class="text-primary">2、layout 过程都干了点什么事？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							由于 View 是以树结构进行存储，所以典型的数据操作就是递归操作，所以，View 框架中，采用了内部自治的 layout 过程。</p>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							每个叶子节点根据父节点传递过来的位置信息，设置自己的位置数据，每个非叶子节点，除了负责根据父节点传递过来的位置信息，设置自己的位置数据外（如果有父节点的话），还需要根据自己内部的 layout 规则（比如垂直排布等），计算出每一个子节点的位置信息，然后向子节点传递 layout 过程。</p>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							对于 ViewGroup，除了根据自己的 parent 传递的位置信息，来设置自己的位置之外，还需要根据自己的 layout 规则，为每一个子 View 计算出准确的位置（相对于子 View 的父布局的位置）。</p>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							对于 View，根据自己的 parent 传递的位置信息，来设置自己的位置。</p>
						<p>
							<img src="images/view-layout-1.png" class="center-block img-responsive">
						</p>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							View 对象的位置信息，在内部是以 4 个成员变量的保存的，分别是 mLeft、mRight、mTop、mBottom。他们的含义如图所示。</p>
						<p>
							<img src="images/view-layout-2.png" class="center-block img-responsive">
						</p>
                        <p class="text-primary">ViewGroup 的 layout 相关方法：(View 的 onLayout 方法是空实现)</p>
                        <pre class="brush: java;">
/** ViewGroup 的 onLayout 方法，指定子 View 的位置: */
@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    int count = getChildCount();
    View child = null;
    int left = 0;
    int top = 0;
    for (int i = 0; i < count; i++) {
        child = getChildAt(i);
        int right = left + child.getMeasuredWidth();
        int bottom = top + child.getMeasuredHeight();
        /** 这个方法指定子 View 的位置和大小 */
        child.layout(left, top, right, bottom);
        left = (left + right) / 2;
        top = (top + bottom) / 2;
    }
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-draw"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">View 框架的 draw 机制</h3>
					</div>
					<div class="panel-body">
						<h5 class="text-primary">1、系统为什么要有 draw 过程？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							View 框架在经过了 measure 过程和 layout 过程之后，就已经确定了每一个 View 的尺寸和位置。那么接下来，也是一个重要的过程，就是 draw 过程，draw 过程是用来绘制 View 的过程，它的作用就是使用 graphic 框架提供的各种绘制功能，绘制出当前 View 想要的样子。</p>
						<h5 class="text-primary">2、draw 过程都干了点什么事？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							View 框架中，draw 过程主要是绘制 View 的外观。ViewGroup 除了负责绘制自己之外，还需要负责绘制所有的子 View。而不含子 View 的 View 对象，就负责绘制自己就可以了。</p>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; draw 过程的主要流程如下：</p>
						<ol>
							<li><p>绘制 backgroud（drawBackground）</p></li>
							<li><p>如果需要的话，保存 canvas 的 layer，来准备 fading（不是必要的步骤）</p></li>
							<li><p>绘制 view 的 content（onDraw方法）</p></li>
							<li><p>绘制 children（dispatchDraw方法）</p></li>
							<li><p>如果需要的话，绘制 fading edges，然后还原 layer（不是必要的步骤）</p></li>
							<li><p>绘制装饰器、比如 scrollBar（onDrawForeground）</p></li>
						</ol>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-event"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">View 框架的事件分发机制</h3>
					</div>
					<div class="panel-body">
						<p>Android 事件传递机制也是 Android 系统中比较重要的一块，事件类型有很多种，这里主要讨论 TouchEvent 的事件在 framework 层的传递处理机制。</p>
						<h5 class="text-primary">1、为什么要有事件分发过程？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							当 Android 设备的屏幕，接收到触摸的动作时，屏幕驱动把压力信号（包括压力大小，压力位置等）传递给系统底层，然后操作系统经过一系列的处理，然后把触摸事件一层一层的向上传递，最终事件会被准确的传递到产生事件的对象上，系统会遍历每一个 View 对象，然后计算触摸点在哪一个 View 中。比如 A 和 B 两个 View，是兄弟 View，AView 产生的触摸事件，是不会被分发到 B 上面的。</p>
						<h5 class="text-primary">2、怎么看待事件序列？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							在 Android 系统中，一个单独的事件基本上是没什么作用的，只有一个事件序列，才有意义。一个事件序列正常情况下，定义为 DOWN、MOVE（0 或者多个）、UP/CANCEL。事件序列以 DOWN 事件开始，中间会有 0 或者多个 MOVE 事件，最后以 UP 事件或者 CANCEL 事件结束。</p>
						<p>DOWN 事件作为序列的开始，有一个很重要的职责，就是寻找事件序列的接受者，怎么理解呢？framework
							在 DOWN 事件的传递过程中，需要根据 View 事件处理方法（onTouchEvent）的返回值来确定事件序列的接受者。如果一个 View 的 onTouchEvent 事件，在处理 DOWN 事件的时候返回 true，说明它愿意接受并处理该事件序列。</p>
						<h5 class="text-primary">3、Android 的 framework 层如何处理事件的分发过程？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							触摸事件到了 framework 层之后，首先会被传递到 Activity，然后 Activity 会把事件委托给它内部的 Window 对象进行分发处理，而 Window 对象又会委托它内部的 DecorView 进行事件分发处理。我们都知道，DecorView 是整棵 View 树的根节点，所以整个事件传递过程的复杂度就是事件在 View 树种分发传递的复杂度。
							Android View 框架提供了 3 个对事件的主要操作概念。</p>
						<p>
							&nbsp;&nbsp;&nbsp; <strong>1、事件的分发机制，dispatchTouchEvent。</strong>主要是 parent 根据触摸事件的产生位置，以及 child 是否愿意负责处理该系列事件等状态，向其 child 分发事件的机制。
						</p>
						<p>
							&nbsp;&nbsp;&nbsp; <strong>2、事件的拦截机制，onInterceptTouchEvent。</strong>主要是 parent 根据它内部的状态、或者 child 的状态，来把事件拦截下来，阻止其进一步传递到 child 的机制。
						</p>
						<p>
							&nbsp;&nbsp;&nbsp; <strong>3、事件的处理机制，onTouchEvent。</strong>主要是事件序列的接受者（可以是一个 View 或者 ViewGroup），对事件作出处理，并且向其 parent 传递处理结果的机制。
						</p>
						<h5 class="text-primary">4、上述三个机制，是怎么向其调用者传递处理结果的？</h5>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
							在 Java 中，传递计算结果，有很多种途径，这里采用的是一种适用于同步调用的方法，返回值的方法。每个机制都使用 boolean 类型作为其返回值，那么每个机制的每个返回值是什么含义呢。</p>
						<p>
							&nbsp;&nbsp;&nbsp; <strong>1、事件的分发机制，dispatchTouchEvent。</strong>
						</p>
						<p>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>true</strong> - 事件被以该节点为根节点的 View 树成功处理，此时该事件就算是处理完成了，事件不会再向上返还给 View 的父节点（把事件分发过来的那个节点）。
						</p>
						<p>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>false</strong> - 以该节点为根节点的 View 树中，没有一个 View（包括该 ViewGroup）成功处理了此事件，所以事件会向上返还给 View 的父节点（把事件分发过来的那个节点）。
						</p>
						<p>
							&nbsp;&nbsp;&nbsp; <strong>2、事件的拦截机制，onInterceptTouchEvent。</strong>主要是 parent 根据它内部的状态、或者 child 的状态，来把事件拦截下来，阻止其进一步传递到 child 的机制。
						</p>
						<p>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>true</strong> - 当前 ViewGroup（<span
								style="color: #ff0000;">因为 View 中没有该方法，而没有 child 的 View也不需要有拦截机制</span>）希望该事件不再传递给其 child，而是希望自己处理。
						</p>
						<p>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>false</strong> - 当前 ViewGroup 不准备拦截该事件，事件正常向下分发给其 child。
						</p>
						<p>
							&nbsp;&nbsp;&nbsp;<strong> 3、事件的处理机制，onTouchEvent。</strong>主要是事件序列的接受者（可以是一个 View 或者 ViewGroup），对事件作出处理，并且向其 parent 传递处理结果的机制。
						</p>
						<p>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>true</strong> - 表示该 View 成功处理了该事件，该处理结果会向上通知给其 parent。
						</p>
						<p>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>false</strong> - 表示该 View 没有成功处理该事件，那么它的 parent 会有机会来处理该事件（parent 标记为事件序列接受者，parent
							的 onTouchEvent 在 Down 事件时返回 true）。
						</p>

                        <p class="text-primary">ViewGroup 和 View 的 <code>dispatchTouchEvent(MotionEvent)</code>, <code>onInterceptTouchEvent(MotionEvent)</code> 和 <code>onTouchEvent(MotionEvent)</code></p>
                        <ol>
                            <li><p>如果调用 ViewGroup 的 <code>dispatchTouchEvent(MotionEvent)</code> 直接返回 true, 那么触控一直调用此方法，不会调用其他方法和子 View 的其他方法；</p></li>
                            <li><p>如果调用 ViewGroup 的 <code>dispatchTouchEvent(MotionEvent)</code> 直接返回 false, 那么触控事件只调用一次此方法，不会调用其他方法和子 View 的其他方法；</p></li>
                            <li><p>如果调用 ViewGroup 的 <code>dispatchTouchEvent(MotionEvent)</code> 返回 <code>super.dispatchTouchEvent(MotionEvent)</code>, 参见下面的所有项：</p></li>

                            <li class="group"><p>如果调用 ViewGroup 的 <code>onInterceptTouchEvent(MotionEvent)</code> 直接返回 true, 事件不会传递到子 View 中去。</p>
                                <ol>
                                    <li><p>如果 <code>onTouchEvent(MotionEvent)</code>  也直接返回 true, 那么调用一次 <code>onInterceptTouchEvent(MotionEvent)</code>, 不断调用 <code>dispatchTouchEvent(MotionEvent)</code> 和 <code>onTouchEvent(MotionEvent)</code></p></li>
                                    <li><p>如果 <code>onTouchEvent(MotionEvent)</code>  返回 <code>super.onTouchEvent(MotionEvent)</code> 或者 false, 那么调用一次 <code>onInterceptTouchEvent(MotionEvent)</code>, <code>dispatchTouchEvent(MotionEvent)</code> 和 <code>onTouchEvent(MotionEvent)</code></p></li>
                                </ol>
                            </li>
                            <li><p>如果调用 ViewGroup 的 <code>onInterceptTouchEvent(MotionEvent)</code> 返回 <code>super.onTouchEvent(MotionEvent)</code> 或者 false, 事件传递到子 View 中去。</p>
                                <ol>
                                    <li><p>如果 <code>onTouchEvent(MotionEvent)</code>  返回 <code>super.onTouchEvent(MotionEvent)</code> 或者 true, 那么调用一次 <code>onInterceptTouchEvent(MotionEvent)</code>, 不断调用 <code>dispatchTouchEvent(MotionEvent)</code> 和 <code>onTouchEvent(MotionEvent)</code></p></li>
                                    <li><p>如果 <code>onTouchEvent(MotionEvent)</code>  直接返回 false, 那么调用一次 <code>onInterceptTouchEvent(MotionEvent)</code>, <code>dispatchTouchEvent(MotionEvent)</code> 和 <code>onTouchEvent(MotionEvent)</code></p></li>
                                </ol>
                            </li>

                            <li class="group"><p>如果调用 View 的 <code>dispatchTouchEvent(MotionEvent)</code> 返回 <code>super.dispatchTouchEvent(MotionEvent)</code></p>
                                <ol>
                                    <li><p>如果 <code>onTouchEvent(MotionEvent)</code>  返回 false, 那么调用一次 <code>dispatchTouchEvent(MotionEvent)</code> 和 <code>onTouchEvent(MotionEvent)</code></p></li>
                                    <li><p>如果 <code>onTouchEvent(MotionEvent)</code>  返回 true, 那么不断调用 <code>dispatchTouchEvent(MotionEvent)</code> 和 <code>onTouchEvent(MotionEvent)</code></p></li>
                                </ol>
                            </li>
                            <li><p>如果调用 View 的 <code>dispatchTouchEvent(MotionEvent)</code> 直接返回 false, 那么调用一次 <code>dispatchTouchEvent(MotionEvent)</code>，不会调用其他方法；</p></li>
                            <li><p>如果调用 View 的 <code>dispatchTouchEvent(MotionEvent)</code> 直接返回 true</p>
                                <ol>
                                    <li><p>如果 <code>onTouchEvent(MotionEvent)</code>  返回 true, 那么触控一直调用 <code>dispatchTouchEvent(MotionEvent)</code> 和 <code>onTouchEvent(MotionEvent)</code></p></li>
                                    <li><p>如果 <code>onTouchEvent(MotionEvent)</code>  返回 <code>super.onTouchEvent(MotionEvent)</code> 或者 false, 那么触控一直调用 <code>dispatchTouchEvent(MotionEvent)</code></p></li>
                                </ol>
                            </li>
                        </ol>

						<h5 class="text-primary">下面提供几个实例：</h5>
						<ul>
							<li>
								ViewPager 中嵌套子 ViewPager 冲突问题解决(子 ViewPager 不可滑动)
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#view-example-viewpager" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="view-example-viewpager"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
public class ChildViewPager extends ViewPager {
    /** 触摸时按下的点 **/
    PointF downP = new PointF();
    /** 触摸时当前的点 **/
    PointF curP = new PointF();
    OnSingleTouchListener onSingleTouchListener;

    public ChildViewPager(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public ChildViewPager(Context context) {
        super(context);
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent arg0) {
        // 当拦截触摸事件到达此位置的时候，返回true，
        // 说明将onTouch拦截在此控件，进而执行此控件的onTouchEvent
        return true;
    }

    @Override
    public boolean onTouchEvent(MotionEvent arg0) {
        // 每次进行onTouch事件都记录当前的按下的坐标
        curP.x = arg0.getX();
        curP.y = arg0.getY();

        if (arg0.getAction() == MotionEvent.ACTION_DOWN) {
            // 记录按下时候的坐标
            // 切记不可用 downP = curP ，这样在改变curP的时候，downP也会改变
            downP.x = arg0.getX();
            downP.y = arg0.getY();
            // 此句代码是为了通知他的父ViewPager现在进行的是本控件的操作，不要对我的操作进行干扰
            getParent().requestDisallowInterceptTouchEvent(true);
        }

        if (arg0.getAction() == MotionEvent.ACTION_MOVE) {
            // 此句代码是为了通知他的父ViewPager现在进行的是本控件的操作，不要对我的操作进行干扰
            getParent().requestDisallowInterceptTouchEvent(true);
        }

        if (arg0.getAction() == MotionEvent.ACTION_UP) {
            // 在up时判断是否按下和松手的坐标为一个点
            // 如果是一个点，将执行点击事件，这是我自己写的点击事件，而不是onclick
            if (downP.x == curP.x && downP.y == curP.y) {
                onSingleTouch();
                return true;
            }
        }

        return super.onTouchEvent(arg0);
    }

    /**
     * 单击
     */
    public void onSingleTouch() {
        if (onSingleTouchListener != null) {

            onSingleTouchListener.onSingleTouch();
        }
    }

    /**
     * 创建点击事件接口
     */
    public interface OnSingleTouchListener {
        public void onSingleTouch();
    }

    public void setOnSingleTouchListener(OnSingleTouchListener onSingleTouchListener) {
        this.onSingleTouchListener = onSingleTouchListener;
    }

}
</pre>
									</div>
								</div>
							</li>
							<li>
								ViewPager 中嵌套 ListView 冲突问题解决
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#view-example-viewpager-listview" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="view-example-viewpager-listview"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
public class MyViewPager extends ViewPager {
	private int startX;
	private int startY;

	public MyViewPager(Context context) {
		super(context);
	}

	@Override
	public boolean onInterceptTouchEvent(MotionEvent ev) {
		switch (ev.getAction()) {
		case MotionEvent.ACTION_DOWN:
			startX = (int) ev.getX();
			startY = (int) ev.getY();
			break;
		case MotionEvent.ACTION_MOVE:

			int dX = (int) (ev.getX() - startX);
			int dY = (int) (ev.getY() - startX);
			if (Math.abs(dX) > Math.abs(dY)) {// 左右滑动
				return true;
			} else {// 上下滑动
				return false;
			}
		case MotionEvent.ACTION_UP:
			break;
		}
		return super.onInterceptTouchEvent(ev);
	}
}
</pre>
									</div>
								</div>
							</li>
							<li>
								ScrollView 中嵌套 ListView 冲突问题解决(ListView 不可滑动)
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#view-example-listview" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="view-example-listview" class="panel-collapse collapse"
										style="" aria-expanded="true">
										<pre class="brush: java;">
public class MyListView exdents ListView {
	public MyListView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyListView(Context context) {
        super(context);
    }
    
	@Override
	public boolean onTouchEvent(MotionEvent ev) {
	    super.onTouchEvent(ev);
	    switch (ev.getAction()) {
	        case MotionEvent.ACTION_DOWN:
	        	// 通知parent，是否拦截后续事件，如果设置为true，parent就不会拦截该事件，不管什么状态。
	            getParent().requestDisallowInterceptTouchEvent(true);
	            break;
	        case MotionEvent.ACTION_MOVE:
	            break;
	        case MotionEvent.ACTION_UP:
	        	// 设置为false，parent走正常的拦截流程
	            getParent().requestDisallowInterceptTouchEvent(false);
	            break;
	        default:
	            break;
	    }
	    return  true;
	}
}
</pre>
									</div>
								</div>
							</li>
						</ul>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-View"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">View 类</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p><b>View 类和其实现的接口</b></p>
							<pre class="brush: java;">
java.lang.Object
	android.view.View

public class View implements Drawable.Callback, Drawable.Callback2, KeyEvent.Callback, 
                             AccessibilityEventSource {
    /** View 的可见性，参见：setVisibility(int) 和 xml 属性 android:visibility */
    public static final int VISIBLE     = 0x00000000; // 可见
    public static final int INVISIBLE   = 0x00000004; // 不可见，占空间
    public static final int GONE        = 0x00000008; // 不可见，不占空间

    /** 导航栏和状态栏设置，参见：setSystemUiVisibility(int)， 可同时使用多个参数 */
    public static final int SYSTEM_UI_FLAG_VISIBLE                = 0; // 显示导航栏和状态栏
    public static final int SYSTEM_UI_FLAG_LOW_PROFILE            = 0x00000001; // 系统UI变暗(触摸又变亮)
    public static final int SYSTEM_UI_FLAG_HIDE_NAVIGATION        = 0x00000002; // 隐藏导航栏(触摸又可见)
    public static final int SYSTEM_UI_FLAG_FULLSCREEN             = 0x00000004; // 全屏模式(隐藏状态栏)
    public static final int SYSTEM_UI_FLAG_LAYOUT_STABLE          = 0x00000100; // 状态栏改变不影响布局
    public static final int SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION = 0x00000200; // 视图希望布局成无导航栏
    public static final int SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN      = 0x00000400; // 视图希望布局成全屏模式
    public static final int SYSTEM_UI_FLAG_IMMERSIVE              = 0x00000800; // 隐藏导航栏时触摸也不可见
    public static final int SYSTEM_UI_FLAG_IMMERSIVE_STICKY       = 0x00001000; // 可理解为同上
    public static final int SYSTEM_UI_FLAG_LIGHT_STATUS_BAR       = 0x00002000; // 改变状态栏颜色(深/浅)
    public static final int SYSTEM_UI_LAYOUT_FLAGS = SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                                | SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN; // 定义可以影响系统 UI 的标志

    /** 拖放操作，参见：startDragAndDrop (ClipData, View.DragShadowBuilder, Object myLocalState,  int) */
    public static final int DRAG_FLAG_GLOBAL = 1 << 8;  // 256, 指示拖动可以跨越窗口边界
    public static final int DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION =
                                Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION;
    public static final int DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION =
                                Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;
    public static final int DRAG_FLAG_GLOBAL_URI_READ = Intent.FLAG_GRANT_READ_URI_PERMISSION;
    public static final int DRAG_FLAG_GLOBAL_URI_WRITE = Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
    public static final int DRAG_FLAG_OPAQUE = 1 << 9; // 512，指示拖动阴影将不透明的标志

    /** 绘图缓存质量，参见：setDrawingCacheQuality(int) 和 xml 属性  android:drawingCacheQuality */
    public static final int DRAWING_CACHE_QUALITY_AUTO = 0x00000000; // 自动
    public static final int DRAWING_CACHE_QUALITY_LOW  = 0x00080000; // 低
    public static final int DRAWING_CACHE_QUALITY_HIGH = 0x00100000; // 高

    /** 查找包含给定文本的视图，参见：findViewsWithText(ArrayList&lt;View>, CharSequence, int) */
    public static final int FIND_VIEWS_WITH_TEXT                = 0x00000001;
    public static final int FIND_VIEWS_WITH_CONTENT_DESCRIPTION = 0x00000002;

    /** 添加可获得焦点的的视图列表模式，参见：addFocusables(ArrayList, int, int) */
    public static final int FOCUSABLES_ALL        = 0x00000000; // 添加所有视图
    public static final int FOCUSABLES_TOUCH_MODE = 0x00000001; // 只添加可在触摸模式下聚焦的视图
    /** 查找下一个焦点视图，参见：addFocusables(ArrayList, int, int) 和 focusSearch (int) */
    public static final int FOCUS_BACKWARD = 0x00000001; // 向后查找
    public static final int FOCUS_FORWARD  = 0x00000002; // 向前查找
    public static final int FOCUS_LEFT     = 0x00000011; // 向左查找
    public static final int FOCUS_UP       = 0x00000021; // 向上查找
    public static final int FOCUS_RIGHT    = 0x00000042; // 向右查找
    public static final int FOCUS_DOWN     = 0x00000082; // 向下查找

	/** 指示屏幕应该保持打开，setKeepScreenOn(boolean) 及 xml 属性 android:keepScreenOn */
    public static final int KEEP_SCREEN_ON   = 0x04000000;
	/** 屏幕状态改变（按下电源键），参见：onScreenStateChanged(int) */
    public static final int SCREEN_STATE_OFF = 0x0; // 关闭
    public static final int SCREEN_STATE_ON  = 0x1; // 打开

    public static final int NO_ID = -1; // 用于标记没有 ID 的 View
    /** 是否有点击事件的声音效果，参见： setSoundEffectsEnabled(boolean) 和 android:soundEffectsEnabled */
    public static final int SOUND_EFFECTS_ENABLED   = 0x08000000;
    /** 是否有长按等触觉反馈，参见： setHapticFeedbackEnabled(boolean) 和 android:hapticFeedbackEnabled */
    public static final int HAPTIC_FEEDBACK_ENABLED = 0x10000000;

    /** 支持此视图的层的类型，参见：setLayerType(int, Paint) 和 android:layerType */
    public static final int LAYER_TYPE_NONE     = 0; // 无图层
    public static final int LAYER_TYPE_SOFTWARE = 1; // 软件层
    public static final int LAYER_TYPE_HARDWARE = 2; // 硬件层

    /** 水平布局方向，参见：setLayoutDirection(int) 和 android:layoutDirection */
    public static final int LAYOUT_DIRECTION_INHERIT = LayoutDirection.INHERIT; // 继承父容器
    public static final int LAYOUT_DIRECTION_LOCALE  = LayoutDirection.LOCALE;  // 本地语言
    public static final int LAYOUT_DIRECTION_LTR     = LayoutDirection.LTR;     // 左 - 右
    public static final int LAYOUT_DIRECTION_RTL     = LayoutDirection.RTL;     // 右 - 左

    /** 参见：getMeasuredState() 和 resolveSizeAndState(int, int, int) */
    public static final int MEASURED_HEIGHT_STATE_SHIFT = 16;
    public static final int MEASURED_SIZE_MASK       = 0x00ffffff;
    public static final int MEASURED_STATE_MASK      = 0xff000000;
    public static final int MEASURED_STATE_TOO_SMALL = 0x01000000;

    /** 滚动条的可见性，参见：setOverScrollMode(int) 和 android:overScrollMode */
    public static final int OVER_SCROLL_ALWAYS             = 0; // 总是可见
    public static final int OVER_SCROLL_IF_CONTENT_SCROLLS = 1; // 需要的时候可见
    public static final int OVER_SCROLL_NEVER              = 2; // 不可见

    /** 滚动条样式，参见：setScrollBarStyle(int) 和 xml 属性 android:scrollbarStyle */
    public static final int SCROLLBARS_INSIDE_OVERLAY  = 0;          // 在内容区域内显示滚动条，而不增加填充
    public static final int SCROLLBARS_INSIDE_INSET    = 0x01000000; // 填充区域内显示滚动条，增加视图的填充
    public static final int SCROLLBARS_OUTSIDE_OVERLAY = 0x02000000; // 视图的边缘显示滚动条，而不增加填充
    public static final int SCROLLBARS_OUTSIDE_INSET   = 0x03000000; // 视图的边缘显示滚动条，增加视图的填充

    /** 纵向滚动条的位置，参见：setVerticalScrollbarPosition(int) 和 android:verticalScrollbarPosition */
    public static final int SCROLLBAR_POSITION_DEFAULT = 0; // 默认位置
    public static final int SCROLLBAR_POSITION_LEFT    = 1; // 左边
    public static final int SCROLLBAR_POSITION_RIGHT   = 2; // 右边

    /** 滚动条的滚动方向 */
    public static final int SCROLL_AXIS_NONE = 0;             // 指示没有滚动轴滚动
    public static final int SCROLL_AXIS_HORIZONTAL = 1 << 0;  // 横向滚动轴
    public static final int SCROLL_AXIS_VERTICAL = 1 << 1;    // 纵向滚动轴

    /** 滚动条指示器，参见： setScrollIndicators(int) 和 android:scrollIndicators */
    public static final int SCROLL_INDICATOR_BOTTOM = ... // 可向下滚动
    public static final int SCROLL_INDICATOR_TOP    = ... // 可向上滚动
    public static final int SCROLL_INDICATOR_LEFT   = ... // 可向左滚动
    public static final int SCROLL_INDICATOR_RIGHT  = ... // 可向右滚动
    public static final int SCROLL_INDICATOR_START  = ... // 可向开始位置滚动
    public static final int SCROLL_INDICATOR_END    = ... // 可向结束位置滚动

    /** 文本对齐方式，参见：setTextAlignment(int) 和 android:textAlignment */
    public static final int TEXT_ALIGNMENT_INHERIT    = 0; // 从父容器继承
    public static final int TEXT_ALIGNMENT_GRAVITY    = 1; // 重力方向
    public static final int TEXT_ALIGNMENT_TEXT_START = 2; // 段落的开头
    public static final int TEXT_ALIGNMENT_VIEW_END   = 3; // 对齐视图的开始
    public static final int TEXT_ALIGNMENT_CENTER     = 4; // 居中
    public static final int TEXT_ALIGNMENT_VIEW_START = 5; // 对齐视图的结尾
    public static final int TEXT_ALIGNMENT_TEXT_END   = 6; // 段落的结尾
    /** 文本方向，参见：setTextDirection(int) 和 android:textDirection */
    public static final int TEXT_DIRECTION_INHERIT          = 0;
    public static final int TEXT_DIRECTION_FIRST_STRONG     = 1;
    public static final int TEXT_DIRECTION_ANY_RTL          = 2;
    public static final int TEXT_DIRECTION_LTR              = 3;
    public static final int TEXT_DIRECTION_RTL              = 4;
    public static final int TEXT_DIRECTION_LOCALE           = 5;
    public static final int TEXT_DIRECTION_FIRST_STRONG_LTR = 6;
    public static final int TEXT_DIRECTION_FIRST_STRONG_RTL = 7;

	/** 可访问性服务相关，参见：setAccessibilityLiveRegion(int mode) 和 android:accessibilityLiveRegion */
    public static final int ACCESSIBILITY_LIVE_REGION_NONE      = 0x00000000;
    public static final int ACCESSIBILITY_LIVE_REGION_POLITE    = 0x00000001;
    public static final int ACCESSIBILITY_LIVE_REGION_ASSERTIVE = 0x00000002;
	/** 对于可访问性是否重要，参见：setImportantForAccessibility(int) 和 android:importantForAccessibility */
	public static final int IMPORTANT_FOR_ACCESSIBILITY_AUTO = 0x00000000;
    public static final int IMPORTANT_FOR_ACCESSIBILITY_YES = 0x00000001;
    public static final int IMPORTANT_FOR_ACCESSIBILITY_NO = 0x00000002;
    public static final int IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS = 0x00000004;

	/** 触摸 */
	public interface OnTouchListener { boolean onTouch(View v, MotionEvent event); }
	/** 拖动 */
	public interface OnDragListener { boolean onDrag(View v, DragEvent event); }
	/** 响应鼠标滚轮等事件 */
	public interface OnGenericMotionListener { boolean onGenericMotion(View v, MotionEvent event); }
	/** 点击 */
	public interface OnClickListener { void onClick(View v); }
	/** 长按 */
	public interface OnLongClickListener { boolean onLongClick(View v); }
	/** 按键 */
	public interface OnKeyListener { boolean onKey(View v, int keyCode, KeyEvent event); }
	/** 鼠标划过 */
	public interface OnHoverListener { boolean onHover(View v, MotionEvent event); }
	/** 滑动位置改变 */
	public interface OnScrollChangeListener {
        void onScrollChange(View v, int scrollX, int scrollY, int oldScrollX, int oldScrollY);
    }
	/** 焦点改变 */
	public interface OnFocusChangeListener { void onFocusChange(View v, boolean hasFocus);
	/** ContextMenu 点击 */
	public interface OnContextClickListener { boolean onContextClick(View v); }
	/** 创建 ContextMenu */
	public interface OnCreateContextMenuListener {
        void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo);
	}
	/** 状态栏可见性改变 */
	public interface OnSystemUiVisibilityChangeListener {
        public void onSystemUiVisibilityChange(int visibility);
    }
	/** View 被添加到 Window 或者 从 Window 移除 */
	public interface OnAttachStateChangeListener {
        public void onViewAttachedToWindow(View v);
        public void onViewDetachedFromWindow(View v);
	}
	/** 监听器,参见:WindowInsets */
	public interface OnApplyWindowInsetsListener {
        public WindowInsets onApplyWindowInsets(View v, WindowInsets insets);
	}
	/** 布局边界改变 */
	public interface OnLayoutChangeListener {
        void onLayoutChange(View v, int left, int top, int right, int bottom,
            int oldLeft, int oldTop, int oldRight, int oldBottom);
	}

	/** 尺寸及尺寸模式 */
	public static class MeasureSpec {}
	/** 拖曳阴影构建器 */
	public static class DragShadowBuilder {};
	/** 保存 View 的状态，自定义可继承此类，参见：onSaveInstanceState() 和 onRestoreInstanceState(Parcelable) */
	public static class BaseSavedState extends AbsSavedState {}
	/** 该类表示可以在视图中注册的委托，以通过构造函数而不是继承来增强可访问性支持 */
	public static class AccessibilityDelegate {}

	/** 构造函数 */
	public View(Context context) {}
	public View(Context context, AttributeSet attrs) {}
	public View(Context context, AttributeSet attrs, int defStyleAttr) {}
	public View(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {}
}

/** Drawable.Callback 接口 */
public interface Callback {
    public void invalidateDrawable(Drawable who);
    public void scheduleDrawable(Drawable who, Runnable what, long when);
    public void unscheduleDrawable(Drawable who, Runnable what);
}

/** Drawable.Callback2 接口 */
public int getResolvedLayoutDirection(Drawable who);

/** KeyEvent.Callback 接口 */
public interface Callback {
    boolean onKeyDown(int keyCode, KeyEvent event);
    boolean onKeyLongPress(int keyCode, KeyEvent event);
    boolean onKeyUp(int keyCode, KeyEvent event);
    boolean onKeyMultiple(int keyCode, int count, KeyEvent event);
}

/** AccessibilityEventSource 接口 */
public interface AccessibilityEventSource {
    public void sendAccessibilityEvent(int eventType);
    public void sendAccessibilityEventUnchecked(AccessibilityEvent event);
}
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>View 类的 XML 属性</b>
							</p>
							<ul class="code-list">
								<li>
									<p>
										<code>android:layout_width</code>
										-- 宽度设置
									</p>
								</li>
								<li>
									<p>
										<code>android:layout_height</code>
										-- 高度设置
									</p>
								</li>
								<li>
									<p>
										<code>android:background</code>
										-- 设置背景色/背景图片。可以通过以下两种方法设置背景为透明：
										<code>@android:color/transparent</code>
										和
										<code>@null</code>
										。
									</p>
								</li>
								<li>
									<p>
										<code>android:alpha</code>
										-- 透明度设置。
									</p>
								</li>
								<li>
									<p>
										<code>android:clickable</code>
										-- 是否响应点击事件。
									</p>
								</li>
								<li>
									<p>
										<code>android:theme</code>
										-- 主题设置
									</p>
								<li>
									<p>
										<code>android:id</code>
										-- 给当前 View 设置一个在当前 layout.xml 中的唯一编号，可 以通过调用
										View.findViewById() 或 Activity.findViewById() 根据这个编号查找到对应的
										View。不同的 layout.xml 之间 定义相同的 id 不会冲突。格式如
										<code>@+id/btnName</code>
									</p>
								</li>
								<li>
									<p>
										<code>android:contentDescription</code>
										-- 设置 View 的备注说明，作为一种辅助功能提供，为一些没 有文字描述的 View 提供说明，如
										ImageButton。这里在界 面上不会有效果，自己在程序中控制，可临时放一点字符 串数据。
									</p>
								</li>
								<li>
									<p>
										<code>android:drawingCacheQuality</code>
										-- 设置绘图时半透明质量。有以下值可设置：auto（默认， 由框架决定）/ high（高质量，使用较高的颜色深度，消耗
										更多的内存）/ low（低质量，使用较低的颜色深度，但是 用更少的内存）。
									</p>
								</li>
								<li>
									<p>
										<code>android:duplicateParentState</code>
										-- 如果设置此属性，将直接从父容器中获取绘图状态（光标， 按下等）。 见下面代码部分，注意根据目前测试情况仅仅是
										获取绘图状态，而没有获取事件，也就是你点一下 LinearLayout 时 Button 有被点击的效果，但是不执行点击事
										件。
									</p>
								</li>
								<li>
									<p>
										<code>android:fadingEdge</code>
										-- 设置拉滚动条时 ，边框渐变的放向。none（边框颜色不
										变），horizontal（水平方向颜色变淡），vertical （垂直方向颜色变淡）。
									</p>
								</li>
								<li>
									<p>
										<code>android:fadingEdgeLength</code>
										-- 设置边框渐变的长度。
									</p>
								</li>
								<li>
									<p>
										<code>android:fitsSystemWindows</code>
										-- 设置布局调整时是否考虑系统窗口（如状态栏）
									</p>
								</li>
								<li>
									<p>
										<code>android:focusable</code>
										-- 设置是否获得焦点。若有 requestFocus() 被调用时，后者 优先处理。注意在表单中想设置某一个如
										EditText 获取焦 点，光设置这个是不行的，需要将这个 EditText 前面的 focusable 都设置为
										false 才行。在 Touch 模式下获取焦点 需要设置 focusableInTouchMode 为 true。
									</p>
								</li>
								<li>
									<p>
										<code>android:focusableInTouchMode</code>
										-- 设置在Touch模式下View是否能取得焦点。
									</p>
								</li>
								<li>
									<p>
										<code>android:hapticFeedbackEnabled</code>
										-- 设置触感反馈。（按软键以及进行某些 UI 交互时振动）
									</p>
								</li>
								<li>
									<p>
										<code>android:isScrollContainer</code>
										-- 设置当前 View 为滚动容器。这里没有测试出效果来， ListView/ GridView / ScrollView
										根本就不用设置这个属性， 而 EdidText 设置 android:scrollbars 也能出滚动条。
									</p>
								</li>
								<li>
									<p>
										<code>android:keepScreenOn</code>
										-- View 在可见的情况下是否保持唤醒状态.
									</p>
								</li>
								<li>
									<p>
										<code>android:longClickable</code>
										-- 设置是否响应长按事件.
									</p>
								</li>
								<li>
									<p>
										<code>android:minHeight</code>
										-- 设置视图最小高度
									</p>
								</li>
								<li>
									<p>
										<code>android:minWidth</code>
										-- 设置视图最小宽度度
									</p>
								</li>
								<li>
									<p>
										<code>android:nextFocusDown</code>
										-- 设置下方指定视图获得下一个焦点。焦点移动是基于一个 在给定方向查找最近邻居的算法。如果指定视图不存在，
										移动焦点时将报运行时错误。可以设置 imeOptions=actionDone，这样输入完即跳到下一个焦点。
									</p>
								</li>
								<li>
									<p>
										<code>android:nextFocusLeft</code>
										-- 设置左边指定视图获得下一个焦点。
									</p>
								</li>
								<li>
									<p>
										<code>android:nextFocusRight</code>
										-- 设置右边指定视图获得下一个焦点。
									</p>
								</li>
								<li>
									<p>
										<code>android:nextFocusUp</code>
										-- 设置上方指定视图获得下一个焦点。
									</p>
								</li>
								<li>
									<p>
										<code>android:onClick</code>
										-- 点击时从上下文中调用指定的方法。这里指定一个方法名 称(
										<code>android:onClick=”onClickButton”</code>
										)，一般在 Activity 定义符合如下参数和返回值的函数并将 方法名字符串指定为该值即可：
										<code> public void onClickButton(View view) {}</code>
									</p>
								</li>
								<li>
									<p>
										<code>android:padding</code>
										-- 设置上下左右的边距，以像素为单位填充空白。
									</p>
								</li>
								<li>
									<p>
										<code>android:paddingBottom</code>
										-- 设置底部的边距，以像素为单位填充空白。
									</p>
								</li>
								<li>
									<p>
										<code>android:paddingLeft</code>
										-- 设置左边的边距，以像素为单位填充空白。
									</p>
								</li>
								<li>
									<p>
										<code>android:paddingRight</code>
										-- 设置右边的边距，以像素为单位填充空白。
									</p>
								</li>
								<li>
									<p>
										<code>android:paddingTop</code>
										-- 设置上方的边距，以像素为单位填充空白。
									</p>
								</li>
								<li>
									<p>
										<code>android:saveEnabled</code>
										-- 设置是否在窗口冻结时（如旋转屏幕）保存 View 的数据，默认为 true，但是前提是你需要设置 id 才能自动保存
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollX</code>
										-- 以像素为单位设置水平方向滚动的的偏移值，在 GridView 中可看的这个效果。
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollY</code>
										-- 以像素为单位设置垂直方向滚动的的偏移值
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollbarAlwaysDrawHorizontalTrack</code>
										-- 设置是否始终显示垂直滚动条。这里用 ScrollView、ListView 测试均没有效果。
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollbarAlwaysDrawVerticalTrack</code>
										-- 设置是否始终显示垂直滚动条。这里用 ScrollView、ListView 测试均没有效果。
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollbarDefaultDelayBeforeFade</code>
										-- 设置滚动条 N 毫秒后开始淡化，以毫秒为单位。
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollbarFadeDuration</code>
										-- 设置滚动条淡出效果（从有到慢慢的变淡直至消失）时间， 以毫秒为单位。
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollbarSize</code>
										-- 设置滚动条的宽度
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollbarStyle</code>
										-- 设置滚动条的模式
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollbarThumbHorizontal</code>
										-- 设置水平滚动条的 Drawable
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollbarThumbVertical</code>
										-- 设置垂直滚动条的 Drawable
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollbarTrackHorizontal</code>
										-- 设置水平滚动条背景（轨迹）的色 Drawable
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollbarTrackVertical</code>
										-- 设置垂直滚动条背景（轨迹）的 Drawable
									</p>
								</li>
								<li>
									<p>
										<code>android:scrollbars</code>
										-- 设置滚动条显示。none（隐藏），horizontal（水平），vertical （垂直）。
									</p>
								</li>
								<li>
									<p>
										<code>android:soundEffectsEnabled</code>
										-- 设置点击或触摸时是否有声音效果
									</p>
								</li>
								<li>
									<p>
										<code>android:tag</code>
										-- 设置一个文本标签，通常用来保存数据。
									</p>
								</li>
								<li>
									<p>
										<code>android:visibility</code>
										-- 设置是否显示View。设置值：visible（默认值，显示），
										invisible（不显示，但是仍然占用空间），gone （不显示，不占用空间）
									</p>
								</li>
							</ul>

						</div>

						<div class="sub-item">
                            <p><b>View 类的 <code>static</code> API:</b></p>
                            <ol>
                                <li><p><code>static View 	inflate(Context context, int resource, ViewGroup root)</code> -- 从 xml 文件加载一个布局文件到 root 中, root 可为 NULL</p></li>
                                <li><p><code>static int 	generateViewId()</code> -- 生成一个可用于 View 的 ID 的值，此值不会与 R.id 中的值冲突</p></li>
                                <li><p><code>static int 	resolveSize(int size, int measureSpec)</code> -- 获取 size 值，参数 size 为 sizeMeasureSpec 类型</p></li>
                                <li><p><code>static int 	resolveSizeAndState(int size, int measureSpec, int childMeasuredState)</code> -- 获取 size 值(包括一个可能的状态位: <code>MEASURED_STATE_TOO_SMALL</code>)</p></li>
                                <li><p><code>static int 	getDefaultSize(int size, int measureSpec)</code> -- 获取默认大小（如果 measureSpec 是精确值，则返回 size; 否则从 measureSpec 获取 size 值返回）</p></li>
                                <li><p><code>static int 	combineMeasuredStates(int curState, int newState)</code> -- 合并两个 getMeasureState() 的值(按位或)</p></li>
                            </ol>

                            <p><b>View 类的 <code>protected</code> API:</b></p>
                            <ol start="7">
								<li class="group"><p><code>protected void 	onFinishInflate()</code> -- 如果是从 xml 加载的 View, 会调用此方法</p></li>
								<li><p><code>protected void 	onAttachedToWindow()</code> -- 当 View 添加到 Window 的时候调用（在 Activity 第一次执行完 onResume 方法后被调用）</p></li>
								<li><p><code>protected void 	onWindowVisibilityChanged(int visibility)</code> -- 窗口可见性变化时候回调(比如：每次窗口进入前台或回到后台，但是电源键不会触发)</p></li>
								<li><p><code>protected void 	onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> -- 测量方法，可能会调用多次</p></li>
								<li><p><code>protected void 	onLayout(boolean changed, int left, int top, int right, int bottom)</code> -- 布局方法，可能会调用多次</p></li>
								<li><p><code>protected void 	onSizeChanged(int w, int h, int oldw, int oldh)</code> -- 尺寸大小改变回调</p></li>
								<li><p><code>protected void 	onDraw(Canvas canvas)</code> -- 绘制 View(比如：每次窗口进入前台)</p></li>
								<li><p><code>protected void 	onVisibilityChanged(View changedView, int visibility)</code> -- 可见性改变回调</p></li>
								<li><p><code>protected void 	onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect)</code> -- 焦点状态改变回调</p></li>
								<li><p><code>protected void 	onDetachedFromWindow()</code> -- 从 Window 移除时回调(在 Activity 调用 onDestroy 方法时)</p></li>

								<li class="group"><p><code>protected void 	onConfigurationChanged(Configuration newConfig)</code> -- 使用的资源的当前配置改变时调用</p></li>
								<li><p><code>protected Parcelable 	onSaveInstanceState()</code> -- 保存用户数据(比如横竖屏切换)</p></li>
								<li><p><code>protected void 	onRestoreInstanceState(Parcelable state)</code> -- 恢复用户数据(比如横竖屏切换)</p>
                                    <pre class="brush: java;">
/** 自定义内部类，用于保存用户数据 */
class MyViewSavedState extends BaseSavedState {
    public int item;
    public MyViewSavedState(Parcelable source) {
        super(source);
    }
}

@Override
protected Parcelable onSaveInstanceState() {
    Parcelable superState = super.onSaveInstanceState();
    MyViewSavedState savedState = new MyViewSavedState(superState);
    savedState.item = 10;
    return savedState;
}

@Override
protected void onRestoreInstanceState(Parcelable state) {
    super.onRestoreInstanceState(state);

    MyViewSavedState myState = (MyViewSavedState) state;
    LogUtil.dd(TAG, "onRestoreInstanceState", myState.item);
}
</pre>
                                </li>

								<li class="group"><p><code>protected void 	onCreateContextMenu(ContextMenu menu)</code> -- 创建 ContextMenu 回调</p></li>

								<li class="group"><p><code>protected void 	onAnimationStart()</code> -- 补间动画开始回调</p></li>
								<li><p><code>protected void 	onAnimationEnd()</code> -- 补间动画结束回调</p></li>

								<li class="group"><p><code>protected int[] 	onCreateDrawableState(int extraSpace)</code> -- 为该视图生成新的可绘制状态</p></li>
								<li><p><code>protected boolean 	onSetAlpha(int alpha)</code> -- 设置透明度回调(透明度动画也会调用此方法)</p></li>
								<li><p><code>protected void 	onDisplayHint(int hint)</code> -- 显示提示信息回调</p></li>

								<li class="group"><p><code>protected void 	onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY)</code> -- 调用 overScroll(...) 方法回调</p></li>
								<li><p><code>protected void 	onScrollChanged(int l, int t, int oldl, int oldt)</code> -- 滚动改变回调(调用 <code>scrollTo(int,  int)</code> 等方法可能会回调)</p></li>

                                <li class="group"><p><code>protected void 	dispatchDraw(Canvas canvas)</code> -- </p></li>
                                <li><p><code>protected boolean 	dispatchGenericFocusedEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>protected boolean 	dispatchGenericPointerEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>protected boolean 	dispatchHoverEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchRestoreInstanceState(SparseArray&lt;Parcelable> container)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchSaveInstanceState(SparseArray&lt;Parcelable> container)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchSetActivated(boolean activated)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchSetPressed(boolean pressed)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchSetSelected(boolean selected)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchVisibilityChanged(View changedView, int visibility)</code> -- </p></li>

                                <li><p><code>boolean 	awakenScrollBars(int startDelay, boolean invalidate)</code> -- </p></li>
                                <li><p><code>boolean 	awakenScrollBars(int startDelay)</code> -- </p></li>
                                <li><p><code>boolean 	awakenScrollBars()</code> -- </p></li>
                                <li><p><code>int 	computeHorizontalScrollExtent()</code> -- </p></li>
                                <li><p><code>int 	computeHorizontalScrollOffset()</code> -- </p></li>
                                <li><p><code>int 	computeHorizontalScrollRange()</code> -- </p></li>
                                <li><p><code>int 	computeVerticalScrollExtent()</code> -- </p></li>
                                <li><p><code>int 	computeVerticalScrollOffset()</code> -- </p></li>
                                <li><p><code>int 	computeVerticalScrollRange()</code> -- </p></li>
                                <li><p><code>protected boolean 	overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent)</code> -- </p></li>
                                <li><p><code>void 	drawableStateChanged()</code> -- </p></li>
                                <li><p><code>boolean 	fitSystemWindows(Rect insets)</code> -- </p></li>
                                <li><p><code>float 	getBottomFadingEdgeStrength()</code> -- </p></li>
                                <li><p><code>int 	getBottomPaddingOffset()</code> -- </p></li>
                                <li><p><code>ContextMenu.ContextMenuInfo 	getContextMenuInfo()</code> -- </p></li>
                                <li><p><code>int 	getHorizontalScrollbarHeight()</code> -- </p></li>
                                <li><p><code>float 	getLeftFadingEdgeStrength()</code> -- </p></li>
                                <li><p><code>int 	getLeftPaddingOffset()</code> -- </p></li>
                                <li><p><code>float 	getRightFadingEdgeStrength()</code> -- </p></li>
                                <li><p><code>int 	getRightPaddingOffset()</code> -- </p></li>
                                <li><p><code>int 	getSuggestedMinimumHeight()</code> -- </p></li>
                                <li><p><code>int 	getSuggestedMinimumWidth()</code> -- </p></li>
                                <li><p><code>float 	getTopFadingEdgeStrength()</code> -- </p></li>
                                <li><p><code>int 	getTopPaddingOffset()</code> -- </p></li>
                                <li><p><code>int 	getWindowAttachCount()</code> -- </p></li>
                                <li><p><code>boolean 	isPaddingOffsetRequired()</code> -- </p></li>
                                <li><p><code>static int[] 	mergeDrawableStates(int[] baseState, int[] additionalState)</code> -- </p></li>
                                <li><p><code>final void 	setMeasuredDimension(int measuredWidth, int measuredHeight)</code> -- </p></li>
                                <li><p><code>boolean 	verifyDrawable(Drawable who)</code> -- </p></li>
                            </ol>

                            <p><b>View 类的 <code>public</code> API:</b></p>
                            <ol start="68">
                                <li class="group"><p><code>void 	onWindowSystemUiVisibilityChanged(int visible)</code> -- 状态栏可见性改变回调，参数参见常量</p></li>
                                <li><p><code>void 	onScreenStateChanged(int screenState)</code> -- 屏幕状态改变回调（按下电源键），参数参见常量</p></li>
                                <li><p><code>void 	onWindowFocusChanged(boolean hasWindowFocus)</code> -- 窗口焦点改变回调</p></li>
                                <li><p><code>void 	onVisibilityAggregated(boolean isVisible)</code> -- 可见性改变</p></li>

                                <li class="group"><p><code>WindowInsets 	onApplyWindowInsets(WindowInsets insets)</code> -- </p></li>

                                <li><p><code>void 	onCancelPendingInputEvents()</code> -- </p></li>
                                <li><p><code>boolean 	onCheckIsTextEditor()</code> -- </p></li>
                                <li><p><code>InputConnection 	onCreateInputConnection(EditorInfo outAttrs)</code> -- </p></li>
                                <li><p><code>boolean 	onDragEvent(DragEvent event)</code> -- </p></li>
                                <li><p><code>void 	onDrawForeground(Canvas canvas)</code> -- 绘制前景内容时回调，比如滚动条</p></li>
                                <li><p><code>boolean 	onFilterTouchEventForSecurity(MotionEvent event)</code> -- </p></li>
                                <li><p><code>void 	onFinishTemporaryDetach()</code> -- </p></li>
                                <li><p><code>boolean 	onGenericMotionEvent(MotionEvent event)</code> -- 响应鼠标滚轮等事件</p></li>
                                <li><p><code>void 	onHoverChanged(boolean hovered)</code> -- </p></li>
                                <li><p><code>boolean 	onHoverEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>void 	onInitializeAccessibilityEvent(AccessibilityEvent event)</code> -- </p></li>
                                <li><p><code>void 	onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info)</code> -- </p></li>


                                <li><p><code>boolean 	onKeyDown(int keyCode, KeyEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	onKeyLongPress(int keyCode, KeyEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	onKeyPreIme(int keyCode, KeyEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	onKeyShortcut(int keyCode, KeyEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	onKeyUp(int keyCode, KeyEvent event)</code> -- </p></li>

                                <li><p><code>void 	onPopulateAccessibilityEvent(AccessibilityEvent event)</code> -- </p></li>
                                <li><p><code>void 	onProvideStructure(ViewStructure structure)</code> -- </p></li>
                                <li><p><code>void 	onProvideVirtualStructure(ViewStructure structure)</code> -- </p></li>
                                <li><p><code>PointerIcon 	onResolvePointerIcon(MotionEvent event, int pointerIndex)</code> -- </p></li>
                                <li><p><code>void 	onRtlPropertiesChanged(int layoutDirection)</code> -- </p></li>

                                <li><p><code>void 	onStartTemporaryDetach()</code> -- </p></li>
                                <li><p><code>boolean 	onTouchEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	onTrackballEvent(MotionEvent event)</code> -- </p></li>

                                <li><p><code>void 	setOnApplyWindowInsetsListener(View.OnApplyWindowInsetsListener listener)</code> -- </p></li>
                                <li><p><code>void 	setOnClickListener(View.OnClickListener l)</code> -- </p></li>
                                <li><p><code>void 	setOnContextClickListener(View.OnContextClickListener l)</code> -- </p></li>
                                <li><p><code>void 	setOnCreateContextMenuListener(View.OnCreateContextMenuListener l)</code> -- </p></li>
                                <li><p><code>void 	setOnDragListener(View.OnDragListener l)</code> -- </p></li>
                                <li><p><code>void 	setOnFocusChangeListener(View.OnFocusChangeListener l)</code> -- </p></li>
                                <li><p><code>void 	setOnGenericMotionListener(View.OnGenericMotionListener l)</code> -- 设置响应鼠标滚轮等事件监听器</p></li>
                                <li><p><code>void 	setOnHoverListener(View.OnHoverListener l)</code> -- </p></li>
                                <li><p><code>void 	setOnKeyListener(View.OnKeyListener l)</code> -- </p></li>
                                <li><p><code>void 	setOnLongClickListener(View.OnLongClickListener l)</code> -- </p></li>
                                <li><p><code>void 	setOnScrollChangeListener(View.OnScrollChangeListener l)</code> -- </p></li>
                                <li><p><code>void 	setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener l)</code> -- </p></li>
                                <li><p><code>void 	setOnTouchListener(View.OnTouchListener l)</code> -- </p></li>

                                <li><p><code>WindowInsets 	dispatchApplyWindowInsets(WindowInsets insets)</code> -- </p></li>
                                <li><p><code>void 	dispatchConfigurationChanged(Configuration newConfig)</code> -- </p></li>
                                <li><p><code>void 	dispatchDisplayHint(int hint)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchDragEvent(DragEvent event)</code> -- </p></li>
                                <li><p><code>void 	dispatchDrawableHotspotChanged(float x, float y)</code> -- </p></li>
                                <li><p><code>void 	dispatchFinishTemporaryDetach()</code> -- </p></li>
                                <li><p><code>boolean 	dispatchGenericMotionEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchKeyEvent(KeyEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchKeyEventPreIme(KeyEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchKeyShortcutEvent(KeyEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchNestedFling(float velocityX, float velocityY, boolean consumed)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchNestedPreFling(float velocityX, float velocityY)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchNestedPrePerformAccessibilityAction(int action, Bundle arguments)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchPopulateAccessibilityEvent(AccessibilityEvent event)</code> -- </p></li>
                                <li><p><code>void 	dispatchProvideStructure(ViewStructure structure)</code> -- </p></li>
                                <li><p><code>void 	dispatchStartTemporaryDetach()</code> -- </p></li>
                                <li><p><code>void 	dispatchSystemUiVisibilityChanged(int visibility)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchTouchEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchTrackballEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchUnhandledMove(View focused, int direction)</code> -- </p></li>
                                <li><p><code>void 	dispatchWindowFocusChanged(boolean hasFocus)</code> -- </p></li>
                                <li><p><code>void 	dispatchWindowSystemUiVisiblityChanged(int visible)</code> -- </p></li>
                                <li><p><code>void 	dispatchWindowVisibilityChanged(int visibility)</code> -- </p></li>

                                <li><p><code>View.OnFocusChangeListener 	getOnFocusChangeListener()</code> -- </p></li>

                                <li><p><code>boolean 	performAccessibilityAction(int action, Bundle arguments)</code> -- </p></li>
                                <li><p><code>boolean 	performClick()</code> -- </p></li>
                                <li><p><code>boolean 	performContextClick(float x, float y)</code> -- </p></li>
                                <li><p><code>boolean 	performContextClick()</code> -- </p></li>
                                <li><p><code>boolean 	performHapticFeedback(int feedbackConstant)</code> -- </p></li>
                                <li><p><code>boolean 	performHapticFeedback(int feedbackConstant, int flags)</code> -- </p></li>
                                <li><p><code>boolean 	performLongClick(float x, float y)</code> -- </p></li>
                                <li><p><code>boolean 	performLongClick()</code> -- </p></li>

                                <li><p><code>void 	addOnAttachStateChangeListener(View.OnAttachStateChangeListener listener)</code> -- </p></li>
                                <li><p><code>void 	addOnLayoutChangeListener(View.OnLayoutChangeListener listener)</code> -- </p></li>
                                <li><p><code>void 	removeOnAttachStateChangeListener(View.OnAttachStateChangeListener listener)</code> -- </p></li>
                                <li><p><code>void 	removeOnLayoutChangeListener(View.OnLayoutChangeListener listener)</code> -- </p></li>

                                <li><p><code>void 	addChildrenForAccessibility(ArrayList&lt;View> outChildren)</code> -- </p></li>
                                <li><p><code>void 	addFocusables(ArrayList&lt;View> views, int direction)</code> -- </p></li>
                                <li><p><code>void 	addFocusables(ArrayList&lt;View> views, int direction, int focusableMode)</code> -- </p></li>

                                <li><p><code>void 	addTouchables(ArrayList&lt;View> views)</code> -- </p></li>
                                <li><p><code>ViewPropertyAnimator 	animate()</code> -- </p></li>
                                <li><p><code>void 	announceForAccessibility(CharSequence text)</code> -- </p></li>
                                <li><p><code>void 	bringToFront()</code> -- </p></li>
                                <li><p><code>void 	buildDrawingCache(boolean autoScale)</code> -- </p></li>
                                <li><p><code>void 	buildDrawingCache()</code> -- </p></li>
                                <li><p><code>void 	buildLayer()</code> -- </p></li>
                                <li><p><code>boolean 	callOnClick()</code> -- </p></li>
                                <li><p><code>boolean 	canResolveLayoutDirection()</code> -- </p></li>
                                <li><p><code>boolean 	canResolveTextAlignment()</code> -- </p></li>
                                <li><p><code>boolean 	canResolveTextDirection()</code> -- </p></li>
                                <li><p><code>boolean 	canScrollHorizontally(int direction)</code> -- </p></li>
                                <li><p><code>boolean 	canScrollVertically(int direction)</code> -- </p></li>
                                <li><p><code>final void 	cancelDragAndDrop()</code> -- </p></li>
                                <li><p><code>void 	cancelLongPress()</code> -- </p></li>
                                <li><p><code>final void 	cancelPendingInputEvents()</code> -- </p></li>
                                <li><p><code>boolean 	checkInputConnectionProxy(View view)</code> -- </p></li>
                                <li><p><code>void 	clearAnimation()</code> -- </p></li>
                                <li><p><code>void 	clearFocus()</code> -- </p></li>

                                <li><p><code>void 	computeScroll()</code> -- </p></li>
                                <li><p><code>WindowInsets 	computeSystemWindowInsets(WindowInsets in, Rect outLocalInsets)</code> -- </p></li>
                                <li><p><code>AccessibilityNodeInfo 	createAccessibilityNodeInfo()</code> -- </p></li>
                                <li><p><code>void 	createContextMenu(ContextMenu menu)</code> -- </p></li>
                                <li><p><code>void 	destroyDrawingCache()</code> -- </p></li>

                                <li><p><code>void 	draw(Canvas canvas)</code> -- </p></li>
                                <li><p><code>void 	drawableHotspotChanged(float x, float y)</code> -- </p></li>
                                <li><p><code>View 	findFocus()</code> -- </p></li>
                                <li><p><code>final View 	findViewById(int id)</code> -- </p></li>
                                <li><p><code>final View 	findViewWithTag(Object tag)</code> -- </p></li>
                                <li><p><code>void 	findViewsWithText(ArrayList&lt;View> outViews, CharSequence searched, int flags)</code> -- </p></li>
                                <li><p><code>View 	focusSearch(int direction)</code> -- </p></li>
                                <li><p><code>void 	forceHasOverlappingRendering(boolean hasOverlappingRendering)</code> -- </p></li>
                                <li><p><code>void 	forceLayout()</code> -- </p></li>

                                <li><p><code>CharSequence 	getAccessibilityClassName()</code> -- </p></li>
                                <li><p><code>int 	getAccessibilityLiveRegion()</code> -- </p></li>
                                <li><p><code>AccessibilityNodeProvider 	getAccessibilityNodeProvider()</code> -- </p></li>
                                <li><p><code>int 	getAccessibilityTraversalAfter()</code> -- </p></li>
                                <li><p><code>int 	getAccessibilityTraversalBefore()</code> -- </p></li>
                                <li><p><code>float 	getAlpha()</code> -- </p></li>
                                <li><p><code>Animation 	getAnimation()</code> -- </p></li>
                                <li><p><code>IBinder 	getApplicationWindowToken()</code> -- </p></li>
                                <li><p><code>Drawable 	getBackground()</code> -- </p></li>
                                <li><p><code>ColorStateList 	getBackgroundTintList()</code> -- </p></li>
                                <li><p><code>PorterDuff.Mode 	getBackgroundTintMode()</code> -- </p></li>
                                <li><p><code>int 	getBaseline()</code> -- </p></li>
                                <li><p><code>final int 	getBottom()</code> -- </p></li>
                                <li><p><code>float 	getCameraDistance()</code> -- </p></li>
                                <li><p><code>boolean 	getClipBounds(Rect outRect)</code> -- </p></li>
                                <li><p><code>Rect 	getClipBounds()</code> -- </p></li>
                                <li><p><code>final boolean 	getClipToOutline()</code> -- </p></li>
                                <li><p><code>CharSequence 	getContentDescription()</code> -- </p></li>
                                <li><p><code>final Context 	getContext()</code> -- </p></li>

                                <li><p><code>Display 	getDisplay()</code> -- </p></li>
                                <li><p><code>final int[] 	getDrawableState()</code> -- </p></li>
                                <li><p><code>Bitmap 	getDrawingCache()</code> -- </p></li>
                                <li><p><code>Bitmap 	getDrawingCache(boolean autoScale)</code> -- </p></li>
                                <li><p><code>int 	getDrawingCacheBackgroundColor()</code> -- </p></li>
                                <li><p><code>int 	getDrawingCacheQuality()</code> -- </p></li>
                                <li><p><code>void 	getDrawingRect(Rect outRect)</code> -- </p></li>
                                <li><p><code>long 	getDrawingTime()</code> -- </p></li>
                                <li><p><code>float 	getElevation()</code> -- </p></li>
                                <li><p><code>boolean 	getFilterTouchesWhenObscured()</code> -- </p></li>
                                <li><p><code>boolean 	getFitsSystemWindows()</code> -- </p></li>
                                <li><p><code>ArrayList&lt;View> 	getFocusables(int direction)</code> -- </p></li>
                                <li><p><code>void 	getFocusedRect(Rect r)</code> -- </p></li>
                                <li><p><code>Drawable 	getForeground()</code> -- </p></li>
                                <li><p><code>int 	getForegroundGravity()</code> -- </p></li>
                                <li><p><code>ColorStateList 	getForegroundTintList()</code> -- </p></li>
                                <li><p><code>PorterDuff.Mode 	getForegroundTintMode()</code> -- </p></li>
                                <li><p><code>final boolean 	getGlobalVisibleRect(Rect r)</code> -- </p></li>
                                <li><p><code>boolean 	getGlobalVisibleRect(Rect r, Point globalOffset)</code> -- </p></li>
                                <li><p><code>Handler 	getHandler()</code> -- </p></li>
                                <li><p><code>final boolean 	getHasOverlappingRendering()</code> -- </p></li>
                                <li><p><code>final int 	getHeight()</code> -- </p></li>
                                <li><p><code>void 	getHitRect(Rect outRect)</code> -- </p></li>
                                <li><p><code>int 	getHorizontalFadingEdgeLength()</code> -- </p></li>
                                <li><p><code>int 	getId()</code> -- </p></li>
                                <li><p><code>int 	getImportantForAccessibility()</code> -- </p></li>
                                <li><p><code>boolean 	getKeepScreenOn()</code> -- </p></li>
                                <li><p><code>KeyEvent.DispatcherState 	getKeyDispatcherState()</code> -- </p></li>
                                <li><p><code>int 	getLabelFor()</code> -- </p></li>
                                <li><p><code>int 	getLayerType()</code> -- </p></li>
                                <li><p><code>int 	getLayoutDirection()</code> -- </p></li>
                                <li><p><code>ViewGroup.LayoutParams 	getLayoutParams()</code> -- </p></li>
                                <li><p><code>final int 	getLeft()</code> -- </p></li>
                                <li><p><code>final boolean 	getLocalVisibleRect(Rect r)</code> -- </p></li>
                                <li><p><code>void 	getLocationInWindow(int[] outLocation)</code> -- </p></li>
                                <li><p><code>void 	getLocationOnScreen(int[] outLocation)</code> -- </p></li>
                                <li><p><code>Matrix 	getMatrix()</code> -- </p></li>
                                <li><p><code>final int 	getMeasuredHeight()</code> -- </p></li>
                                <li><p><code>final int 	getMeasuredHeightAndState()</code> -- </p></li>
                                <li><p><code>final int 	getMeasuredState()</code> -- </p></li>
                                <li><p><code>final int 	getMeasuredWidth()</code> -- </p></li>
                                <li><p><code>final int 	getMeasuredWidthAndState()</code> -- </p></li>
                                <li><p><code>int 	getMinimumHeight()</code> -- </p></li>
                                <li><p><code>int 	getMinimumWidth()</code> -- </p></li>
                                <li><p><code>int 	getNextFocusDownId()</code> -- </p></li>
                                <li><p><code>int 	getNextFocusForwardId()</code> -- </p></li>
                                <li><p><code>int 	getNextFocusLeftId()</code> -- </p></li>
                                <li><p><code>int 	getNextFocusRightId()</code> -- </p></li>
                                <li><p><code>int 	getNextFocusUpId()</code> -- </p></li>

                                <li><p><code>ViewOutlineProvider 	getOutlineProvider()</code> -- </p></li>
                                <li><p><code>int 	getOverScrollMode()</code> -- </p></li>
                                <li><p><code>ViewOverlay 	getOverlay()</code> -- </p></li>
                                <li><p><code>int 	getPaddingBottom()</code> -- </p></li>
                                <li><p><code>int 	getPaddingEnd()</code> -- </p></li>
                                <li><p><code>int 	getPaddingLeft()</code> -- </p></li>
                                <li><p><code>int 	getPaddingRight()</code> -- </p></li>
                                <li><p><code>int 	getPaddingStart()</code> -- </p></li>
                                <li><p><code>int 	getPaddingTop()</code> -- </p></li>
                                <li><p><code>final ViewParent 	getParent()</code> -- </p></li>
                                <li><p><code>ViewParent 	getParentForAccessibility()</code> -- </p></li>
                                <li><p><code>float 	getPivotX()</code> -- </p></li>
                                <li><p><code>float 	getPivotY()</code> -- </p></li>
                                <li><p><code>PointerIcon 	getPointerIcon()</code> -- </p></li>
                                <li><p><code>Resources 	getResources()</code> -- </p></li>
                                <li><p><code>final int 	getRight()</code> -- </p></li>
                                <li><p><code>View 	getRootView()</code> -- </p></li>
                                <li><p><code>WindowInsets 	getRootWindowInsets()</code> -- </p></li>
                                <li><p><code>float 	getRotation()</code> -- </p></li>
                                <li><p><code>float 	getRotationX()</code> -- </p></li>
                                <li><p><code>float 	getRotationY()</code> -- </p></li>
                                <li><p><code>float 	getScaleX()</code> -- </p></li>
                                <li><p><code>float 	getScaleY()</code> -- </p></li>
                                <li><p><code>int 	getScrollBarDefaultDelayBeforeFade()</code> -- </p></li>
                                <li><p><code>int 	getScrollBarFadeDuration()</code> -- </p></li>
                                <li><p><code>int 	getScrollBarSize()</code> -- </p></li>
                                <li><p><code>int 	getScrollBarStyle()</code> -- </p></li>
                                <li><p><code>int 	getScrollIndicators()</code> -- </p></li>
                                <li><p><code>final int 	getScrollX()</code> -- </p></li>
                                <li><p><code>final int 	getScrollY()</code> -- </p></li>
                                <li><p><code>int 	getSolidColor()</code> -- </p></li>
                                <li><p><code>StateListAnimator 	getStateListAnimator()</code> -- </p></li>
                                <li><p><code>int 	getSystemUiVisibility()</code> -- </p></li>
                                <li><p><code>Object 	getTag()</code> -- </p></li>
                                <li><p><code>Object 	getTag(int key)</code> -- </p></li>
                                <li><p><code>int 	getTextAlignment()</code> -- </p></li>
                                <li><p><code>int 	getTextDirection()</code> -- </p></li>
                                <li><p><code>final int 	getTop()</code> -- </p></li>
                                <li><p><code>TouchDelegate 	getTouchDelegate()</code> -- </p></li>
                                <li><p><code>ArrayList&lt;View> 	getTouchables()</code> -- </p></li>
                                <li><p><code>String 	getTransitionName()</code> -- </p></li>
                                <li><p><code>float 	getTranslationX()</code> -- </p></li>
                                <li><p><code>float 	getTranslationY()</code> -- </p></li>
                                <li><p><code>float 	getTranslationZ()</code> -- </p></li>
                                <li><p><code>int 	getVerticalFadingEdgeLength()</code> -- </p></li>
                                <li><p><code>int 	getVerticalScrollbarPosition()</code> -- </p></li>
                                <li><p><code>int 	getVerticalScrollbarWidth()</code> -- </p></li>
                                <li><p><code>ViewTreeObserver 	getViewTreeObserver()</code> -- </p></li>
                                <li><p><code>int 	getVisibility()</code> -- </p></li>
                                <li><p><code>final int 	getWidth()</code> -- </p></li>
                                <li><p><code>WindowId 	getWindowId()</code> -- </p></li>
                                <li><p><code>int 	getWindowSystemUiVisibility()</code> -- </p></li>
                                <li><p><code>IBinder 	getWindowToken()</code> -- </p></li>
                                <li><p><code>int 	getWindowVisibility()</code> -- </p></li>
                                <li><p><code>void 	getWindowVisibleDisplayFrame(Rect outRect)</code> -- </p></li>
                                <li><p><code>float 	getX()</code> -- </p></li>
                                <li><p><code>float 	getY()</code> -- </p></li>
                                <li><p><code>float 	getZ()</code> -- </p></li>
                                <li><p><code>boolean 	hasFocus()</code> -- </p></li>
                                <li><p><code>boolean 	hasFocusable()</code> -- </p></li>
                                <li><p><code>boolean 	hasNestedScrollingParent()</code> -- </p></li>
                                <li><p><code>boolean 	hasOnClickListeners()</code> -- </p></li>
                                <li><p><code>boolean 	hasOverlappingRendering()</code> -- </p></li>
                                <li><p><code>boolean 	hasTransientState()</code> -- </p></li>
                                <li><p><code>boolean 	hasWindowFocus()</code> -- </p></li>

                                <li><p><code>void 	invalidate()</code> -- </p></li>
                                <li><p><code>void 	invalidate(Rect dirty)</code> -- </p></li>
                                <li><p><code>void 	invalidate(int l, int t, int r, int b)</code> -- </p></li>
                                <li><p><code>void 	invalidateDrawable(Drawable drawable)</code> -- </p></li>
                                <li><p><code>void 	invalidateOutline()</code> -- </p></li>
                                <li><p><code>boolean 	isAccessibilityFocused()</code> -- </p></li>
                                <li><p><code>boolean 	isActivated()</code> -- </p></li>
                                <li><p><code>boolean 	isAttachedToWindow()</code> -- </p></li>
                                <li><p><code>boolean 	isClickable()</code> -- </p></li>
                                <li><p><code>boolean 	isContextClickable()</code> -- </p></li>
                                <li><p><code>boolean 	isDirty()</code> -- </p></li>
                                <li><p><code>boolean 	isDrawingCacheEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isDuplicateParentStateEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isEnabled()</code> -- </p></li>
                                <li><p><code>final boolean 	isFocusable()</code> -- </p></li>
                                <li><p><code>final boolean 	isFocusableInTouchMode()</code> -- </p></li>
                                <li><p><code>boolean 	isFocused()</code> -- </p></li>
                                <li><p><code>boolean 	isHapticFeedbackEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isHardwareAccelerated()</code> -- </p></li>
                                <li><p><code>boolean 	isHorizontalFadingEdgeEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isHorizontalScrollBarEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isHovered()</code> -- </p></li>
                                <li><p><code>boolean 	isImportantForAccessibility()</code> -- </p></li>
                                <li><p><code>boolean 	isInEditMode()</code> -- </p></li>
                                <li><p><code>boolean 	isInLayout()</code> -- </p></li>
                                <li><p><code>boolean 	isInTouchMode()</code> -- </p></li>
                                <li><p><code>boolean 	isLaidOut()</code> -- </p></li>
                                <li><p><code>boolean 	isLayoutDirectionResolved()</code> -- </p></li>
                                <li><p><code>boolean 	isLayoutRequested()</code> -- </p></li>
                                <li><p><code>boolean 	isLongClickable()</code> -- </p></li>
                                <li><p><code>boolean 	isNestedScrollingEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isOpaque()</code> -- </p></li>
                                <li><p><code>boolean 	isPaddingRelative()</code> -- </p></li>
                                <li><p><code>boolean 	isPressed()</code> -- </p></li>
                                <li><p><code>boolean 	isSaveEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isSaveFromParentEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isScrollContainer()</code> -- </p></li>
                                <li><p><code>boolean 	isScrollbarFadingEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isSelected()</code> -- </p></li>
                                <li><p><code>boolean 	isShown()</code> -- </p></li>
                                <li><p><code>boolean 	isSoundEffectsEnabled()</code> -- </p></li>
                                <li><p><code>final boolean 	isTemporarilyDetached()</code> -- </p></li>
                                <li><p><code>boolean 	isTextAlignmentResolved()</code> -- </p></li>
                                <li><p><code>boolean 	isTextDirectionResolved()</code> -- </p></li>
                                <li><p><code>boolean 	isVerticalFadingEdgeEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isVerticalScrollBarEnabled()</code> -- </p></li>
                                <li><p><code>void 	jumpDrawablesToCurrentState()</code> -- </p></li>
                                <li><p><code>void 	layout(int l, int t, int r, int b)</code> -- </p></li>
                                <li><p><code>final void 	measure(int widthMeasureSpec, int heightMeasureSpec)</code> -- </p></li>
                                <li><p><code>void 	offsetLeftAndRight(int offset)</code> -- </p></li>
                                <li><p><code>void 	offsetTopAndBottom(int offset)</code> -- </p></li>

                                <li><p><code>void 	playSoundEffect(int soundConstant)</code> -- </p></li>
                                <li><p><code>boolean 	post(Runnable action)</code> -- </p></li>
                                <li><p><code>boolean 	postDelayed(Runnable action, long delayMillis)</code> -- </p></li>
                                <li><p><code>void 	postInvalidate()</code> -- </p></li>
                                <li><p><code>void 	postInvalidate(int left, int top, int right, int bottom)</code> -- </p></li>
                                <li><p><code>void 	postInvalidateDelayed(long delayMilliseconds, int left, int top, int right, int bottom)</code> -- </p></li>
                                <li><p><code>void 	postInvalidateDelayed(long delayMilliseconds)</code> -- </p></li>
                                <li><p><code>void 	postInvalidateOnAnimation(int left, int top, int right, int bottom)</code> -- </p></li>
                                <li><p><code>void 	postInvalidateOnAnimation()</code> -- </p></li>
                                <li><p><code>void 	postOnAnimation(Runnable action)</code> -- </p></li>
                                <li><p><code>void 	postOnAnimationDelayed(Runnable action, long delayMillis)</code> -- </p></li>
                                <li><p><code>void 	refreshDrawableState()</code> -- </p></li>
                                <li><p><code>boolean 	removeCallbacks(Runnable action)</code> -- </p></li>

                                <li><p><code>void 	requestApplyInsets()</code> -- </p></li>
                                <li><p><code>void 	requestFitSystemWindows()</code> -- </p></li>
                                <li><p><code>final boolean 	requestFocus(int direction)</code> -- </p></li>
                                <li><p><code>final boolean 	requestFocus()</code> -- </p></li>
                                <li><p><code>boolean 	requestFocus(int direction, Rect previouslyFocusedRect)</code> -- </p></li>
                                <li><p><code>final boolean 	requestFocusFromTouch()</code> -- </p></li>
                                <li><p><code>void 	requestLayout()</code> -- </p></li>
                                <li><p><code>boolean 	requestRectangleOnScreen(Rect rectangle)</code> -- </p></li>
                                <li><p><code>boolean 	requestRectangleOnScreen(Rect rectangle, boolean immediate)</code> -- </p></li>
                                <li><p><code>final void 	requestUnbufferedDispatch(MotionEvent event)</code> -- </p></li>

                                <li><p><code>void 	restoreHierarchyState(SparseArray&lt;Parcelable> container)</code> -- </p></li>
                                <li><p><code>void 	saveHierarchyState(SparseArray&lt;Parcelable> container)</code> -- </p></li>
                                <li><p><code>void 	scheduleDrawable(Drawable who, Runnable what, long when)</code> -- </p></li>
                                <li><p><code>void 	scrollBy(int x, int y)</code> -- </p></li>
                                <li><p><code>void 	scrollTo(int x, int y)</code> -- </p></li>
                                <li><p><code>void 	sendAccessibilityEvent(int eventType)</code> -- </p></li>
                                <li><p><code>void 	sendAccessibilityEventUnchecked(AccessibilityEvent event)</code> -- </p></li>
                                <li><p><code>void 	setAccessibilityDelegate(View.AccessibilityDelegate delegate)</code> -- </p></li>
                                <li><p><code>void 	setAccessibilityLiveRegion(int mode)</code> -- </p></li>
                                <li><p><code>void 	setAccessibilityTraversalAfter(int afterId)</code> -- </p></li>
                                <li><p><code>void 	setAccessibilityTraversalBefore(int beforeId)</code> -- </p></li>
                                <li><p><code>void 	setActivated(boolean activated)</code> -- </p></li>
                                <li><p><code>void 	setAlpha(float alpha)</code> -- </p></li>
                                <li><p><code>void 	setAnimation(Animation animation)</code> -- </p></li>
                                <li><p><code>void 	setBackground(Drawable background)</code> -- </p></li>
                                <li><p><code>void 	setBackgroundColor(int color)</code> -- </p></li>
                                <li><p><code>void 	setBackgroundDrawable(Drawable background)</code> -- </p></li>
                                <li><p><code>void 	setBackgroundResource(int resid)</code> -- </p></li>
                                <li><p><code>void 	setBackgroundTintList(ColorStateList tint)</code> -- </p></li>
                                <li><p><code>void 	setBackgroundTintMode(PorterDuff.Mode tintMode)</code> -- </p></li>
                                <li><p><code>final void 	setBottom(int bottom)</code> -- </p></li>
                                <li><p><code>void 	setCameraDistance(float distance)</code> -- </p></li>
                                <li><p><code>void 	setClickable(boolean clickable)</code> -- </p></li>
                                <li><p><code>void 	setClipBounds(Rect clipBounds)</code> -- </p></li>
                                <li><p><code>void 	setClipToOutline(boolean clipToOutline)</code> -- </p></li>
                                <li><p><code>void 	setContentDescription(CharSequence contentDescription)</code> -- </p></li>
                                <li><p><code>void 	setContextClickable(boolean contextClickable)</code> -- </p></li>
                                <li><p><code>void 	setDrawingCacheBackgroundColor(int color)</code> -- </p></li>
                                <li><p><code>void 	setDrawingCacheEnabled(boolean enabled)</code> -- </p></li>
                                <li><p><code>void 	setDrawingCacheQuality(int quality)</code> -- </p></li>
                                <li><p><code>void 	setDuplicateParentStateEnabled(boolean enabled)</code> -- </p></li>
                                <li><p><code>void 	setElevation(float elevation)</code> -- </p></li>
                                <li><p><code>void 	setEnabled(boolean enabled)</code> -- </p></li>
                                <li><p><code>void 	setFadingEdgeLength(int length)</code> -- </p></li>
                                <li><p><code>void 	setFilterTouchesWhenObscured(boolean enabled)</code> -- </p></li>
                                <li><p><code>void 	setFitsSystemWindows(boolean fitSystemWindows)</code> -- </p></li>
                                <li><p><code>void 	setFocusable(boolean focusable)</code> -- </p></li>
                                <li><p><code>void 	setFocusableInTouchMode(boolean focusableInTouchMode)</code> -- </p></li>
                                <li><p><code>void 	setForeground(Drawable foreground)</code> -- </p></li>
                                <li><p><code>void 	setForegroundGravity(int gravity)</code> -- </p></li>
                                <li><p><code>void 	setForegroundTintList(ColorStateList tint)</code> -- </p></li>
                                <li><p><code>void 	setForegroundTintMode(PorterDuff.Mode tintMode)</code> -- </p></li>
                                <li><p><code>void 	setHapticFeedbackEnabled(boolean hapticFeedbackEnabled)</code> -- </p></li>
                                <li><p><code>void 	setHasTransientState(boolean hasTransientState)</code> -- </p></li>
                                <li><p><code>void 	setHorizontalFadingEdgeEnabled(boolean horizontalFadingEdgeEnabled)</code> -- </p></li>
                                <li><p><code>void 	setHorizontalScrollBarEnabled(boolean horizontalScrollBarEnabled)</code> -- </p></li>
                                <li><p><code>void 	setHovered(boolean hovered)</code> -- </p></li>
                                <li><p><code>void 	setId(int id)</code> -- </p></li>
                                <li><p><code>void 	setImportantForAccessibility(int mode)</code> -- </p></li>
                                <li><p><code>void 	setKeepScreenOn(boolean keepScreenOn)</code> -- </p></li>
                                <li><p><code>void 	setLabelFor(int id)</code> -- </p></li>
                                <li><p><code>void 	setLayerPaint(Paint paint)</code> -- </p></li>
                                <li><p><code>void 	setLayerType(int layerType, Paint paint)</code> -- </p></li>
                                <li><p><code>void 	setLayoutDirection(int layoutDirection)</code> -- </p></li>
                                <li><p><code>void 	setLayoutParams(ViewGroup.LayoutParams params)</code> -- </p></li>
                                <li><p><code>final void 	setLeft(int left)</code> -- </p></li>
                                <li><p><code>void 	setLongClickable(boolean longClickable)</code> -- </p></li>
                                <li><p><code>void 	setMinimumHeight(int minHeight)</code> -- </p></li>
                                <li><p><code>void 	setMinimumWidth(int minWidth)</code> -- </p></li>
                                <li><p><code>void 	setNestedScrollingEnabled(boolean enabled)</code> -- </p></li>
                                <li><p><code>void 	setNextFocusDownId(int nextFocusDownId)</code> -- </p></li>
                                <li><p><code>void 	setNextFocusForwardId(int nextFocusForwardId)</code> -- </p></li>
                                <li><p><code>void 	setNextFocusLeftId(int nextFocusLeftId)</code> -- </p></li>
                                <li><p><code>void 	setNextFocusRightId(int nextFocusRightId)</code> -- </p></li>
                                <li><p><code>void 	setNextFocusUpId(int nextFocusUpId)</code> -- </p></li>

                                <li><p><code>void 	setOutlineProvider(ViewOutlineProvider provider)</code> -- </p></li>
                                <li><p><code>void 	setOverScrollMode(int overScrollMode)</code> -- </p></li>
                                <li><p><code>void 	setPadding(int left, int top, int right, int bottom)</code> -- </p></li>
                                <li><p><code>void 	setPaddingRelative(int start, int top, int end, int bottom)</code> -- </p></li>
                                <li><p><code>void 	setPivotX(float pivotX)</code> -- </p></li>
                                <li><p><code>void 	setPivotY(float pivotY)</code> -- </p></li>
                                <li><p><code>void 	setPointerIcon(PointerIcon pointerIcon)</code> -- </p></li>
                                <li><p><code>void 	setPressed(boolean pressed)</code> -- </p></li>
                                <li><p><code>final void 	setRight(int right)</code> -- </p></li>
                                <li><p><code>void 	setRotation(float rotation)</code> -- </p></li>
                                <li><p><code>void 	setRotationX(float rotationX)</code> -- </p></li>
                                <li><p><code>void 	setRotationY(float rotationY)</code> -- </p></li>
                                <li><p><code>void 	setSaveEnabled(boolean enabled)</code> -- </p></li>
                                <li><p><code>void 	setSaveFromParentEnabled(boolean enabled)</code> -- </p></li>
                                <li><p><code>void 	setScaleX(float scaleX)</code> -- </p></li>
                                <li><p><code>void 	setScaleY(float scaleY)</code> -- </p></li>
                                <li><p><code>void 	setScrollBarDefaultDelayBeforeFade(int scrollBarDefaultDelayBeforeFade)</code> -- </p></li>
                                <li><p><code>void 	setScrollBarFadeDuration(int scrollBarFadeDuration)</code> -- </p></li>
                                <li><p><code>void 	setScrollBarSize(int scrollBarSize)</code> -- </p></li>
                                <li><p><code>void 	setScrollBarStyle(int style)</code> -- </p></li>
                                <li><p><code>void 	setScrollContainer(boolean isScrollContainer)</code> -- </p></li>
                                <li><p><code>void 	setScrollIndicators(int indicators, int mask)</code> -- </p></li>
                                <li><p><code>void 	setScrollIndicators(int indicators)</code> -- </p></li>
                                <li><p><code>void 	setScrollX(int value)</code> -- </p></li>
                                <li><p><code>void 	setScrollY(int value)</code> -- </p></li>
                                <li><p><code>void 	setScrollbarFadingEnabled(boolean fadeScrollbars)</code> -- </p></li>
                                <li><p><code>void 	setSelected(boolean selected)</code> -- </p></li>
                                <li><p><code>void 	setSoundEffectsEnabled(boolean soundEffectsEnabled)</code> -- </p></li>
                                <li><p><code>void 	setStateListAnimator(StateListAnimator stateListAnimator)</code> -- </p></li>
                                <li><p><code>void 	setSystemUiVisibility(int visibility)</code> -- </p></li>
                                <li><p><code>void 	setTag(int key, Object tag)</code> -- </p></li>
                                <li><p><code>void 	setTag(Object tag)</code> -- </p></li>
                                <li><p><code>void 	setTextAlignment(int textAlignment)</code> -- </p></li>
                                <li><p><code>void 	setTextDirection(int textDirection)</code> -- </p></li>
                                <li><p><code>final void 	setTop(int top)</code> -- </p></li>
                                <li><p><code>void 	setTouchDelegate(TouchDelegate delegate)</code> -- </p></li>
                                <li><p><code>final void 	setTransitionName(String transitionName)</code> -- </p></li>
                                <li><p><code>void 	setTranslationX(float translationX)</code> -- </p></li>
                                <li><p><code>void 	setTranslationY(float translationY)</code> -- </p></li>
                                <li><p><code>void 	setTranslationZ(float translationZ)</code> -- </p></li>
                                <li><p><code>void 	setVerticalFadingEdgeEnabled(boolean verticalFadingEdgeEnabled)</code> -- </p></li>
                                <li><p><code>void 	setVerticalScrollBarEnabled(boolean verticalScrollBarEnabled)</code> -- </p></li>
                                <li><p><code>void 	setVerticalScrollbarPosition(int position)</code> -- </p></li>
                                <li><p><code>void 	setVisibility(int visibility)</code> -- </p></li>
                                <li><p><code>void 	setWillNotCacheDrawing(boolean willNotCacheDrawing)</code> -- </p></li>
                                <li><p><code>oid 	setWillNotDraw(boolean willNotDraw)</code> -- </p></li>
                                <li><p><code>oid 	setX(float x)</code> -- </p></li>
                                <li><p><code>void 	setY(float y)</code> -- </p></li>
                                <li><p><code>void 	setZ(float z)</code> -- </p></li>
                                <li><p><code>boolean 	showContextMenu()</code> -- </p></li>
                                <li><p><code>boolean 	showContextMenu(float x, float y)</code> -- </p></li>
                                <li><p><code>ActionMode 	startActionMode(ActionMode.Callback callback, int type)</code> -- </p></li>
                                <li><p><code>ActionMode 	startActionMode(ActionMode.Callback callback)</code> -- </p></li>
                                <li><p><code>void 	startAnimation(Animation animation)</code> -- </p></li>
                                <li><p><code>final boolean 	startDrag(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)</code> -- </p></li>
                                <li><p><code>final boolean 	startDragAndDrop(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)</code> -- </p></li>
                                <li><p><code>boolean 	startNestedScroll(int axes)</code> -- </p></li>
                                <li><p><code>void 	stopNestedScroll()</code> -- </p></li>
                                <li><p><code>String 	toString()</code> -- </p></li>
                                <li><p><code>void 	unscheduleDrawable(Drawable who, Runnable what)</code> -- </p></li>
                                <li><p><code>void 	unscheduleDrawable(Drawable who)</code> -- </p></li>
                                <li><p><code>final void 	updateDragShadow(View.DragShadowBuilder shadowBuilder)</code> -- </p></li>
                                <li><p><code>boolean 	willNotCacheDrawing()</code> -- </p></li>
                                <li><p><code>boolean 	willNotDraw()</code> -- </p></li>
                            </ol>
						</div>

                        <div class="sub-item">
                            <div class="split-item">
                                <p><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.LayoutManager" target="_blank">RecyclerView.LayoutManager</a> 用于管理 RecyclerView 的布局。</p>
                                <pre class="brush: java;">

</pre>
                            </div>
                            <div class="split-item">
                                <p><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.LayoutManager" target="_blank">RecyclerView.LayoutManager</a> 用于管理 RecyclerView 的布局。</p>
                                <pre class="brush: java;">

</pre>
                            </div>
                            <div class="split-item">
                                <p><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.LayoutManager" target="_blank">RecyclerView.LayoutManager</a> 用于管理 RecyclerView 的布局。</p>
                                <pre class="brush: java;">

</pre>
                            </div>
                            <div class="split-item">
                                <p><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.LayoutManager" target="_blank">RecyclerView.LayoutManager</a> 用于管理 RecyclerView 的布局。</p>
                                <pre class="brush: java;">

</pre>
                            </div>
                        </div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-TextView"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">TextView</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
	android.view.View
		android.widget.TextView
public class TextView extends View implements ViewTreeObserver.OnPreDrawListener {}

/** ViewTreeObserver.OnPreDrawListener 接口 */
public boolean onPreDraw();
</pre>
						<div class="sub-item">
							<p>
								<b>TextView 类的 XML 属性</b>
							</p>
							<ul class="code-list">
								<li>
									<p>
										<code>includeFontPadding="false"</code>
										-- TextView 默认上下是有一定的 padding, 如果不想要可以设置为false
									</p>
								</li>
								<li>
									<p>
										<code>android:singleLine</code>
										-- 设置单行显示。和 layout_width 一起使用，当文本不能全部显示时，后面用“…”来表示。
									</p>
								</li>
								<li>
									<p>
										<code>android:lines</code>
										-- 设置行间距的倍数。
									</p>
								</li>
								<li>
									<p>
										<code>android:maxLines</code>
										设置文本的最大显示行数，超出部分自动换行，超出行数将不显示。
									</p>
								</li>
								<li>
									<p>
										<code>android:minLines</code>
										-- 设置文本的最小行数，与lines类似。
									</p>
								</li>
								<li>
									<p>
										<code>android:lineSpacingMultiplier</code>
										-- 设置行间距的倍数
									</p>
								</li>
								<li>
									<p>
										<code>android:lineSpacingExtra</code>
										-- 设置行间距。
									</p>
								</li>
								<li>
									<p>
										<code>android:ems</code>
										-- 设置TextView的宽度为N个字符的宽度。
									</p>
								</li>
								<li>
									<p>
										<code>android:maxEms</code>
										-- 设置TextView的宽度为最长为N个字符的宽度。
									</p>
								</li>
								<li>
									<p>
										<code>android:minEms</code>
										-- 设置TextView的宽度为最短为N个字符的宽度。
									</p>
								</li>
								<li>
									<p>
										<code>android:maxLength</code>
										-- 限制显示的文本长度，超出部分不显示。
									</p>
								</li>
								<li>
									<p>
										<code>android:shadowColor</code>
										-- 指定文本阴影的颜色，需要与shadowRadius一起使用。
									</p>
								</li>
								<li>
									<p>
										<code>android:shadowRadius</code>
										-- 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。
									</p>
								</li>
								<li>
									<p>
										<code>android:shadowDx</code>
										-- 设置阴影横向坐标开始位置。
									</p>
								</li>
								<li>
									<p>
										<code>android:shadowDy</code>
										-- 设置阴影纵向坐标开始位置。
									</p>
								</li>
								<li>
									<p>
										<code>android:drawableLeft/drawableRight/drawableTop/drawableBottom</code>
										-- 设置 text 的左/右/上/下的 drawable。
									</p>
								</li>
								<li>
									<p>
										<code>android:drawablePadding</code>
										-- 设置 text 与 drawable (图片)的间隔。
									</p>
								</li>
								<li>
									<p>
										<code>android:autoLink</code>
										-- 设置是否当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接。
									</p>
								</li>
							</ul>
						</div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-ImageView"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">ImageView</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-EditText"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">EditText</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-Button"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Button</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-SurfaceView"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">SurfaceView</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-layout-class"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">ViewGroup 类</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object
	android.view.View
		android.view.ViewGroup 

public abstract class ViewGroup extends View implements ViewParent, ViewManager {
    protected static final int CLIP_TO_PADDING_MASK = FLAG_CLIP_TO_PADDING | FLAG_PADDING_NOT_NULL;

    public static final int FOCUS_AFTER_DESCENDANTS  = 0x40000;
    public static final int FOCUS_BEFORE_DESCENDANTS = 0x20000;
    public static final int FOCUS_BLOCK_DESCENDANTS  = 0x60000;

    public static final int LAYOUT_MODE_CLIP_BOUNDS    = 0;
    public static final int LAYOUT_MODE_OPTICAL_BOUNDS = 1;

    public static final int PERSISTENT_NO_CACHE        = 0x0;
    public static final int PERSISTENT_ANIMATION_CACHE = 0x1;
    public static final int PERSISTENT_SCROLLING_CACHE = 0x2;
    public static final int PERSISTENT_ALL_CACHES      = 0x3;

    /** 为其中的 View 提供宽度和高度支持：
     * android:layout_height -- 高度值，可以为带单位的具体值，也可以为 match_parent / wrap_content
     * android:layout_width -- 宽度值，可以为带单位的具体值，也可以为 match_parent / wrap_content
     */
    public static class LayoutParams {
        public static final int MATCH_PARENT = -1;
        public static final int WRAP_CONTENT = -2;
        public int width;
        public int height;

        public LayoutParams(int width, int height) {}
        public LayoutParams(Context c, AttributeSet attrs) {}
        public LayoutParams(ViewGroup.LayoutParams source) {}
    }

    /** 为其中的 View 提供边距支持，多数的 LayoutParams 都继承了此类：
     * android:layout_marginLeft -- 左侧边距
     * android:layout_marginTop -- 顶部边距
     * android:layout_marginRight -- 右部边距
     * android:layout_marginBottom -- 底部边距
     * android:layout_marginStart -- 根据布局方向决定左侧或者右侧
     * android:layout_marginEnd -- 根据布局方向决定左侧或者右侧
     */
    public static class MarginLayoutParams extends ViewGroup.LayoutParams {
        public static final int DEFAULT_MARGIN_RELATIVE = Integer.MIN_VALUE;

        public int leftMargin;
        public int topMargin;
        public int rightMargin;
        public int bottomMargin;

        public MarginLayoutParams(int width, int height) {}
        public MarginLayoutParams(Context c, AttributeSet attrs) {}
        public MarginLayoutParams(ViewGroup.MarginLayoutParams source) {}
        public MarginLayoutParams(ViewGroup.LayoutParams source) {}
    }

    /** 当视图中的层次结构发生变化时回调接口，WebView 实现了此接口 */
    public interface OnHierarchyChangeListener {
        void onChildViewAdded(View parent, View child);
        void onChildViewRemoved(View parent, View child);
    }

    public ViewGroup(Context context) {}
    public ViewGroup(Context context, AttributeSet attrs) {}
    public ViewGroup(Context context, AttributeSet attrs, int defStyleAttr) {}
    public ViewGroup(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {}
}
</pre>
                            <p><a href="" target="_blank">ViewGroup</a> </p>
                            <ol>

                                <li><p><code>void 	addChildrenForAccessibility(ArrayList&lt;View> outChildren)</code> -- </p></li>
                                <li><p><code>void 	addFocusables(ArrayList&lt;View> views, int direction, int focusableMode)</code> -- </p></li>
                                <li><p><code>boolean 	addStatesFromChildren()</code> -- </p></li>
                                <li><p><code>void 	addTouchables(ArrayList&lt;View> views)</code> -- </p></li>
                                <li><p><code>void 	addView(View child, ViewGroup.LayoutParams params)</code> -- </p></li>
                                <li><p><code>void 	addView(View child, int index)</code> -- </p></li>
                                <li><p><code>void 	addView(View child, int index, ViewGroup.LayoutParams params)</code> -- </p></li>
                                <li><p><code>void 	addView(View child)</code> -- </p></li>
                                <li><p><code>void 	addView(View child, int width, int height)</code> -- </p></li>
                                <li><p><code>void 	bringChildToFront(View child)</code> -- </p></li>
                                <li><p><code>void 	childDrawableStateChanged(View child)</code> -- </p></li>
                                <li><p><code>void 	childHasTransientStateChanged(View child, boolean childHasTransientState)</code> -- </p></li>
                                <li><p><code>void 	clearChildFocus(View child)</code> -- </p></li>
                                <li><p><code>void 	clearDisappearingChildren()</code> -- </p></li>
                                <li><p><code>void 	clearFocus()</code> -- </p></li>
                                <li><p><code>WindowInsets 	dispatchApplyWindowInsets(WindowInsets insets)</code> -- </p></li>
                                <li><p><code>void 	dispatchConfigurationChanged(Configuration newConfig)</code> -- </p></li>
                                <li><p><code>void 	dispatchDisplayHint(int hint)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchDragEvent(DragEvent event)</code> -- </p></li>
                                <li><p><code>void 	dispatchDrawableHotspotChanged(float x, float y)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchKeyEvent(KeyEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchKeyEventPreIme(KeyEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchKeyShortcutEvent(KeyEvent event)</code> -- </p></li>
                                <li><p><code>void 	dispatchProvideStructure(ViewStructure structure)</code> -- </p></li>
                                <li><p><code>void 	dispatchSetActivated(boolean activated)</code> -- </p></li>
                                <li><p><code>void 	dispatchSetSelected(boolean selected)</code> -- </p></li>
                                <li><p><code>void 	dispatchSystemUiVisibilityChanged(int visible)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchTouchEvent(MotionEvent ev)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchTrackballEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchUnhandledMove(View focused, int direction)</code> -- </p></li>
                                <li><p><code>void 	dispatchWindowFocusChanged(boolean hasFocus)</code> -- </p></li>
                                <li><p><code>void 	dispatchWindowSystemUiVisiblityChanged(int visible)</code> -- </p></li>
                                <li><p><code>void 	dispatchWindowVisibilityChanged(int visibility)</code> -- </p></li>
                                <li><p><code>void 	endViewTransition(View view)</code> -- </p></li>
                                <li><p><code>View 	findFocus()</code> -- </p></li>
                                <li><p><code>void 	findViewsWithText(ArrayList&lt;View> outViews, CharSequence text, int flags)</code> -- </p></li>
                                <li><p><code>View 	focusSearch(View focused, int direction)</code> -- </p></li>
                                <li><p><code>void 	focusableViewAvailable(View v)</code> -- </p></li>
                                <li><p><code>boolean 	gatherTransparentRegion(Region region)</code> -- </p></li>
                                <li><p><code>ViewGroup.LayoutParams 	generateLayoutParams(AttributeSet attrs)</code> -- </p></li>
                                <li><p><code>CharSequence 	getAccessibilityClassName()</code> -- </p></li>
                                <li><p><code>View 	getChildAt(int index)</code> -- </p></li>
                                <li><p><code>int 	getChildCount()</code> -- </p></li>
                                <li><p><code>static int 	getChildMeasureSpec(int spec, int padding, int childDimension)</code> -- </p></li>
                                <li><p><code>boolean 	getChildVisibleRect(View child, Rect r, Point offset)</code> -- </p></li>
                                <li><p><code>boolean 	getClipChildren()</code> -- </p></li>
                                <li><p><code>boolean 	getClipToPadding()</code> -- </p></li>
                                <li><p><code>int 	getDescendantFocusability()</code> -- </p></li>
                                <li><p><code>View 	getFocusedChild()</code> -- </p></li>
                                <li><p><code>LayoutAnimationController 	getLayoutAnimation()</code> -- </p></li>
                                <li><p><code>Animation.AnimationListener 	getLayoutAnimationListener()</code> -- </p></li>
                                <li><p><code>int 	getLayoutMode()</code> -- </p></li>
                                <li><p><code>LayoutTransition 	getLayoutTransition()</code> -- </p></li>
                                <li><p><code>int 	getNestedScrollAxes()</code> -- </p></li>
                                <li><p><code>ViewGroupOverlay 	getOverlay()</code> -- </p></li>
                                <li><p><code>int 	getPersistentDrawingCache()</code> -- </p></li>
                                <li><p><code>boolean 	getTouchscreenBlocksFocus()</code> -- </p></li>
                                <li><p><code>boolean 	hasFocus()</code> -- </p></li>
                                <li><p><code>boolean 	hasFocusable()</code> -- </p></li>
                                <li><p><code>boolean 	hasTransientState()</code> -- </p></li>
                                <li><p><code>int 	indexOfChild(View child)</code> -- </p></li>
                                <li><p><code>final void 	invalidateChild(View child, Rect dirty)</code> -- </p></li>
                                <li><p><code>ViewParent 	invalidateChildInParent(int[] location, Rect dirty)</code> -- </p></li>
                                <li><p><code>boolean 	isAlwaysDrawnWithCacheEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isAnimationCacheEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isMotionEventSplittingEnabled()</code> -- </p></li>
                                <li><p><code>boolean 	isTransitionGroup()</code> -- </p></li>
                                <li><p><code>void 	jumpDrawablesToCurrentState()</code> -- </p></li>
                                <li><p><code>final void 	layout(int l, int t, int r, int b)</code> -- </p></li>
                                <li><p><code>void 	notifySubtreeAccessibilityStateChanged(View child, View source, int changeType)</code> -- </p></li>
                                <li><p><code>final void 	offsetDescendantRectToMyCoords(View descendant, Rect rect)</code> -- </p></li>
                                <li><p><code>final void 	offsetRectIntoDescendantCoords(View descendant, Rect rect)</code> -- </p></li>
                                <li><p><code>boolean 	onInterceptHoverEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>boolean 	onInterceptTouchEvent(MotionEvent ev)</code> -- </p></li>
                                <li><p><code>boolean 	onNestedFling(View target, float velocityX, float velocityY, boolean consumed)</code> -- </p></li>
                                <li><p><code>boolean 	onNestedPreFling(View target, float velocityX, float velocityY)</code> -- </p></li>
                                <li><p><code>boolean 	onNestedPrePerformAccessibilityAction(View target, int action, Bundle args)</code> -- </p></li>
                                <li><p><code>void 	onNestedPreScroll(View target, int dx, int dy, int[] consumed)</code> -- </p></li>
                                <li><p><code>void 	onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)</code> -- </p></li>
                                <li><p><code>void 	onNestedScrollAccepted(View child, View target, int axes)</code> -- </p></li>
                                <li><p><code>boolean 	onRequestSendAccessibilityEvent(View child, AccessibilityEvent event)</code> -- </p></li>
                                <li><p><code>PointerIcon 	onResolvePointerIcon(MotionEvent event, int pointerIndex)</code> -- </p></li>
                                <li><p><code>boolean 	onStartNestedScroll(View child, View target, int nestedScrollAxes)</code> -- </p></li>
                                <li><p><code>void 	onStopNestedScroll(View child)</code> -- </p></li>
                                <li><p><code>void 	onViewAdded(View child)</code> -- </p></li>
                                <li><p><code>void 	onViewRemoved(View child)</code> -- </p></li>
                                <li><p><code>void 	recomputeViewAttributes(View child)</code> -- </p></li>
                                <li><p><code>void 	removeAllViews()</code> -- </p></li>
                                <li><p><code>void 	removeAllViewsInLayout()</code> -- </p></li>
                                <li><p><code>void 	removeView(View view)</code> -- </p></li>
                                <li><p><code>void 	removeViewAt(int index)</code> -- </p></li>
                                <li><p><code>void 	removeViewInLayout(View view)</code> -- </p></li>
                                <li><p><code>void 	removeViews(int start, int count)</code> -- </p></li>
                                <li><p><code>void 	removeViewsInLayout(int start, int count)</code> -- </p></li>
                                <li><p><code>void 	requestChildFocus(View child, View focused)</code> -- </p></li>
                                <li><p><code>boolean 	requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate)</code> -- </p></li>
                                <li><p><code>void 	requestDisallowInterceptTouchEvent(boolean disallowIntercept)</code> -- </p></li>
                                <li><p><code>boolean 	requestFocus(int direction, Rect previouslyFocusedRect)</code> -- </p></li>
                                <li><p><code>boolean 	requestSendAccessibilityEvent(View child, AccessibilityEvent event)</code> -- </p></li>
                                <li><p><code>void 	requestTransparentRegion(View child)</code> -- </p></li>
                                <li><p><code>void 	scheduleLayoutAnimation()</code> -- </p></li>
                                <li><p><code>void 	setAddStatesFromChildren(boolean addsStates)</code> -- </p></li>
                                <li><p><code>void 	setAlwaysDrawnWithCacheEnabled(boolean always)</code> -- </p></li>
                                <li><p><code>void 	setAnimationCacheEnabled(boolean enabled)</code> -- </p></li>
                                <li><p><code>void 	setClipChildren(boolean clipChildren)</code> -- </p></li>
                                <li><p><code>void 	setClipToPadding(boolean clipToPadding)</code> -- </p></li>
                                <li><p><code>void 	setDescendantFocusability(int focusability)</code> -- </p></li>
                                <li><p><code>void 	setLayoutAnimation(LayoutAnimationController controller)</code> -- </p></li>
                                <li><p><code>void 	setLayoutAnimationListener(Animation.AnimationListener animationListener)</code> -- </p></li>
                                <li><p><code>void 	setLayoutMode(int layoutMode)</code> -- </p></li>
                                <li><p><code>void 	setLayoutTransition(LayoutTransition transition)</code> -- </p></li>
                                <li><p><code>void 	setMotionEventSplittingEnabled(boolean split)</code> -- </p></li>
                                <li><p><code>void 	setOnHierarchyChangeListener(ViewGroup.OnHierarchyChangeListener listener)</code> -- </p></li>
                                <li><p><code>void 	setPersistentDrawingCache(int drawingCacheToKeep)</code> -- </p></li>
                                <li><p><code>void 	setTouchscreenBlocksFocus(boolean touchscreenBlocksFocus)</code> -- </p></li>
                                <li><p><code>void 	setTransitionGroup(boolean isTransitionGroup)</code> -- </p></li>
                                <li><p><code>boolean 	shouldDelayChildPressedState()</code> -- </p></li>
                                <li><p><code>boolean 	showContextMenuForChild(View originalView, float x, float y)</code> -- </p></li>
                                <li><p><code>boolean 	showContextMenuForChild(View originalView)</code> -- </p></li>
                                <li><p><code>ActionMode 	startActionModeForChild(View originalView, ActionMode.Callback callback, int type)</code> -- </p></li>
                                <li><p><code>ActionMode 	startActionModeForChild(View originalView, ActionMode.Callback callback)</code> -- </p></li>
                                <li><p><code>void 	startLayoutAnimation()</code> -- </p></li>
                                <li><p><code>void 	startViewTransition(View view)</code> -- </p></li>
                                <li><p><code>void 	updateViewLayout(View view, ViewGroup.LayoutParams params)</code> -- </p></li>

                                <li class="group"><p><code>protected boolean 	addViewInLayout(View child, int index, ViewGroup.LayoutParams params, boolean preventRequestLayout)</code> -- </p></li>
                                <li><p><code>protected boolean 	addViewInLayout(View child, int index, ViewGroup.LayoutParams params)</code> -- </p></li>
                                <li><p><code>protected void 	attachLayoutAnimationParameters(View child, ViewGroup.LayoutParams params, int index, int count)</code> -- </p></li>
                                <li><p><code>protected void 	attachViewToParent(View child, int index, ViewGroup.LayoutParams params)</code> -- </p></li>
                                <li><p><code>protected boolean 	canAnimate()</code> -- </p></li>
                                <li><p><code>protected boolean 	checkLayoutParams(ViewGroup.LayoutParams p)</code> -- </p></li>
                                <li><p><code>protected void 	cleanupLayoutState(View child)</code> -- </p></li>
                                <li><p><code>protected void 	debug(int depth)</code> -- </p></li>
                                <li><p><code>protected void 	detachAllViewsFromParent()</code> -- </p></li>
                                <li><p><code>protected void 	detachViewFromParent(int index)</code> -- </p></li>
                                <li><p><code>protected void 	detachViewFromParent(View child)</code> -- </p></li>
                                <li><p><code>protected void 	detachViewsFromParent(int start, int count)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchDraw(Canvas canvas)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchFreezeSelfOnly(SparseArray&lt;Parcelable> container)</code> -- </p></li>
                                <li><p><code>protected boolean 	dispatchGenericFocusedEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>protected boolean 	dispatchGenericPointerEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>protected boolean 	dispatchHoverEvent(MotionEvent event)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchRestoreInstanceState(SparseArray&lt;Parcelable> container)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchSaveInstanceState(SparseArray&lt;Parcelable> container)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchSetPressed(boolean pressed)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchThawSelfOnly(SparseArray&lt;Parcelable> container)</code> -- </p></li>
                                <li><p><code>protected void 	dispatchVisibilityChanged(View changedView, int visibility)</code> -- </p></li>
                                <li><p><code>protected boolean 	drawChild(Canvas canvas, View child, long drawingTime)</code> -- </p></li>
                                <li><p><code>protected void 	drawableStateChanged()</code> -- </p></li>
                                <li><p><code>protected ViewGroup.LayoutParams 	generateDefaultLayoutParams()</code> -- </p></li>
                                <li><p><code>protected ViewGroup.LayoutParams 	generateLayoutParams(ViewGroup.LayoutParams p)</code> -- </p></li>
                                <li><p><code>protected int 	getChildDrawingOrder(int childCount, int i)</code> -- </p></li>
                                <li><p><code>protected boolean 	getChildStaticTransformation(View child, Transformation t)</code> -- </p></li>
                                <li><p><code>protected boolean 	isChildrenDrawingOrderEnabled()</code> -- </p></li>
                                <li><p><code>protected boolean 	isChildrenDrawnWithCacheEnabled()</code> -- </p></li>
                                <li><p><code>protected void 	measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)</code> -- </p></li>
                                <li><p><code>protected void 	measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)</code> -- </p></li>
                                <li><p><code>protected void 	measureChildren(int widthMeasureSpec, int heightMeasureSpec)</code> -- </p></li>
                                <li><p><code>protected void 	onAttachedToWindow()</code> -- </p></li>
                                <li><p><code>protected int[] 	onCreateDrawableState(int extraSpace)</code> -- </p></li>
                                <li><p><code>protected void 	onDetachedFromWindow()</code> -- </p></li>
                                <li><p><code>protected abstract void 	onLayout(boolean changed, int l, int t, int r, int b)</code> -- </p></li>
                                <li><p><code>protected boolean 	onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect)</code> -- </p></li>
                                <li><p><code>protected void 	removeDetachedView(View child, boolean animate)</code> -- </p></li>
                                <li><p><code>protected void 	setChildrenDrawingCacheEnabled(boolean enabled)</code> -- </p></li>
                                <li><p><code>protected void 	setChildrenDrawingOrderEnabled(boolean enabled)</code> -- </p></li>
                                <li><p><code>protected void 	setChildrenDrawnWithCacheEnabled(boolean enabled)</code> -- </p></li>
                                <li><p><code>protected void 	setStaticTransformationsEnabled(boolean enabled)</code> -- </p></li>
                            </ol>
						</div>

						<div class="sub-item">
								<div class="row">
										<div class="col-md-3 col-md-push-1">
											<img src="images/ViewGroup-sample.png" class="img-responsive">
											<p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">ViewGroup</span></p>
										</div>
										<div class="col-md-3 col-md-push-1">
											<img src="images/ViewGroup-sample.png" class="img-responsive">
											<p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">ViewGroup</span></p>
										</div>
										<div class="col-md-3 col-md-push-1">
											<img src="images/ViewGroup-sample.png" class="img-responsive">
											<p class="text-center" style="margin: 15px;"><span style="border-bottom: 2px dashed #FDD;">ViewGroup</span></p>
										</div>
									</div>

<pre class="brush: java;">
/** ViewGroup 可以只重写以下两个方法,这样的写法 ViewGroup 的宽高为 wrap_conent 不会生效 */
@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
	int count = getChildCount();
	View child = null;
	int left = 0;
	int top = 0;
	for (int i = 0; i &lt; count; i++) {
		child = getChildAt(i);
		int right = left + child.getMeasuredWidth();
		int bottom = top + child.getMeasuredHeight();
		/** 这个方法指定子 View 的位置和大小 */
		child.layout(left, top, right, bottom);
		left = (left + right) / 2;
		top = (top + bottom) / 2;
	}
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
	super.onMeasure(widthMeasureSpec, heightMeasureSpec);
	measureChildren(widthMeasureSpec, heightMeasureSpec);
}

/** 向 ViewGroup 中添加 View */
ImageView image = null;
ViewGroup.LayoutParams params = null;

for (String img : Value.Image.Icon.J256x256) {
	image = new ImageView(getContext());
	params = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, 
			ViewGroup.LayoutParams.WRAP_CONTENT);
	image.setLayoutParams(params);

	myViewGroup.addView(image);

	Picasso.with(getContext()).load(img).into(image);
}
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="android-support-constraint-ConstraintLayout"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">ConstraintLayout</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
/** ConstraintLayout 属于 support 内容，需要单独引入，此包中包含以下内容(还有一个 values.xml)：
 * ConstraintLayout -- 约束布局，使用 ConstraintSet 保存子元素的 constraints，margins 和 padding
 * ConstraintSet -- 允许以编程方式定义与约束布局一起使用的一组约束。允许您创建和保存约束，并将它们应用到现有的约束布局中
 * Placeholder -- View 的子类，提供可以定位现有对象的虚拟对象
 * Guideline -- View 的子类，锚向基线，是条不可见的线，可以是横向/纵向的，可以作为一条参考线
 * Barrier -- 翻译为栅栏，是 ConstraintHelper 的子类，栅栏的位置可以根据其中的内容改变。
 * Group -- 用于控制多个控件的可见性，是 ConstraintHelper 的子类
 */
implementation 'com.android.support.constraint:constraint-layout:1.1.3'

public class ConstraintLayout extends ViewGroup {
    /** 布局参数，是 MarginLayoutParams 子类 */
    public static class LayoutParams extends MarginLayoutParams {
        public static final int UNSET = -1;
        public static final int PARENT_ID = 0;
        public static final int LEFT = 1;
        public static final int TOP = 3;
        public static final int RIGHT = 2;
        public static final int BOTTOM = 4;
        public static final int BASELINE = 5;
        public static final int START = 6;
        public static final int END = 7;

        public static final int HORIZONTAL = 0;
        public static final int VERTICAL = 1;

        public static final int MATCH_CONSTRAINT = 0;
        public static final int MATCH_CONSTRAINT_WRAP = 1;
        public static final int MATCH_CONSTRAINT_SPREAD = 0;
        public static final int MATCH_CONSTRAINT_PERCENT = 2;

        /** 对应 xml 属性为: layout_constraint[Vertical|Horizontal]_chainStyle 值 */
        public static final int CHAIN_SPREAD = 0;
        public static final int CHAIN_SPREAD_INSIDE = 1;
        public static final int CHAIN_PACKED = 2;

        /** 约束，对应 xml 属性为: layout_constraintXXX_toYYYOf */
        public int leftToLeft = -1;
        public int leftToRight = -1;
        public int rightToLeft = -1;
        public int rightToRight = -1;
        public int topToTop = -1;
        public int topToBottom = -1;
        public int bottomToTop = -1;
        public int bottomToBottom = -1;
        public int startToEnd = -1;
        public int startToStart = -1;
        public int endToStart = -1;
        public int endToEnd = -1;
        public int baselineToBaseline = -1;

        /** 横向/纵向约束力强度 */
        public float horizontalBias = 0.5F;
        public float verticalBias = 0.5F;

        /** 参照点可见性 */
        public int goneLeftMargin = -1;
        public int goneTopMargin = -1;
        public int goneRightMargin = -1;
        public int goneBottomMargin = -1;
        public int goneStartMargin = -1;
        public int goneEndMargin = -1;

        /** 宽高比 */
        public String dimensionRatio = null;

        /** 锚向指示线 */
        public int guideBegin = -1;
        public int guideEnd = -1;
        public float guidePercent = -1.0F;

        /** 圆形定位 */
        public int circleConstraint = -1;
        public int circleRadius = 0;
        public float circleAngle = 0.0F;

        /** 横向/纵向重力比例 */
        public float horizontalWeight = -1.0F;
        public float verticalWeight = -1.0F;

        /** 当控件不能填满 ConstraintLayout 时，空白部分和控件如何排列 */
        public int horizontalChainStyle = 0;
        public int verticalChainStyle = 0;

        /** 约束宽度/高度 */
        public boolean constrainedWidth = false;
        public boolean constrainedHeight = false;

        /** MATCH_CONSTRAINT dimensions（填充父窗体约束） */
        public int matchConstraintDefaultWidth = 0;
        public int matchConstraintDefaultHeight = 0;
        public int matchConstraintMinWidth = 0;
        public int matchConstraintMinHeight = 0;
        public int matchConstraintMaxWidth = 0;
        public int matchConstraintMaxHeight = 0;
        public float matchConstraintPercentWidth = 1.0F;
        public float matchConstraintPercentHeight = 1.0F;

        public int editorAbsoluteX = -1;
        public int editorAbsoluteY = -1;
        public int orientation = -1;

        public boolean helped = false;

        public LayoutParams(ConstraintLayout.LayoutParams source) {...}
        public LayoutParams(Context c, AttributeSet attrs) {...}
        public LayoutParams(int width, int height) {...}
        public LayoutParams(android.view.ViewGroup.LayoutParams source) {...}
    }

    public ConstraintLayout(Context context) {}
    public ConstraintLayout(Context context, AttributeSet attrs) {}
    public ConstraintLayout(Context context, AttributeSet attrs, int defStyleAttr) {}
}
</pre>
						    <p><b>ConstraintLayout</b> 为约束布局，也有人把它称作增强型的相对布局，由 2016 年 Google I/O 推出。扁平式的布局方式，无任何嵌套，减少布局的层级，优化渲染性能。从支持力度而言，将成为主流布局样式，完全代替其他布局。</p>
                            <p><b>ConstraintLayout</b> 是 Android Studio 2.2 中主要的新增功能之一，也是 Google 在 I/O 大会上重点宣传的一个功能。</p>
                            <p><b>ConstraintLayout</b> 和传统编写界面的方式恰恰相反，非常适合使用可视化的方式来编写界面，但并不太适合使用 XML 的方式来进行编写。当然，可视化操作的背后仍然还是使用的 XML 代码来实现的，只不过这些代码是由 Android Studio 根据我们的操作自动生成的。</p>
                            <p><b>ConstraintLayout</b>  还有一个优点，它可以有效地解决布局嵌套过多的问题。</p>
                            <p><b>ConstraintLayout</b> 的 <code>xml</code> 属性：</p>
                            <ol type="I">
                                <li>
                                    <p><code>layout_constraintXXX_toYYYOf</code> 格式的属性 -- View 的方向 XXX 边与指定 View 的 YYY 边对齐，如果添加了互斥的约束，比如：
                                    <code>layout_constraintLeft_toLeftOf="parent" layout_constraintRight_toRightOf="parent"</code>，那么此 View 是左右居中的，还可以使用 <code>ayout_constraintHorizontal_bias="0.2"</code> 来控制约束力强度；</p>
                                    <code>layout_constraintTop_toTopOf="parent" layout_constraintBottom_toBottomOf="parent"</code>，那么此 View 是左右居中的，还可以使用 <code>layout_constraintVertical_bias ="0.1"</code> 来控制约束力强度；</p>
                                    <pre class="brush: xml;">
<!-- 约束，此类属性公 13 个，其值对应 ConstraintLayout.LayoutParams 的 xxxToYyy 值
    layout_constraintLeft_toLeftOf         -- 左侧和指定 View(parent / @+id/xx) 的左侧对齐
    layout_constraintLeft_toRightOf        -- 左侧和指定 View(parent / @+id/xx) 的右侧对齐
    layout_constraintRight_toLeftOf        -- 右侧和指定 View(parent / @+id/xx) 的左侧对齐
    layout_constraintRight_toRightOf       -- 右侧和指定 View(parent / @+id/xx) 的右侧对齐
    layout_constraintTop_toTopOf           -- 顶部和指定 View(parent / @+id/xx) 的顶部对齐
    layout_constraintTop_toBottomOf        -- 顶部和指定 View(parent / @+id/xx) 的底部对齐
    layout_constraintBottom_toTopOf        -- 底部和指定 View(parent / @+id/xx) 的顶部对齐
    layout_constraintBottom_toBottomOf     -- 底部和指定 View(parent / @+id/xx) 的底部对齐
    layout_constraintStart_toStartOf       -- 开始边和指定 View(parent / @+id/xx) 的开始边对齐
    layout_constraintStart_toEndOf         -- 开始边和指定 View(parent / @+id/xx) 的结束边对齐
    layout_constraintEnd_toStartOf         -- 结束边和指定 View(parent / @+id/xx) 的开始边对齐
    layout_constraintEnd_toEndOf           -- 结束边和指定 View(parent / @+id/xx) 的结束边对齐
    layout_constraintBaseline_toBaselineOf -- 基线和指定 View(parent / @+id/xx) 的基线对齐
-->
<!-- 约束力强度：当 上/下 或者 左/右 都添加了约束时，可以使用比例类控制其约束力强度
    layout_constraintVertical_bias   -- 纵向约束力强度(浮点值: 0 - 1.0)
    layout_constraintHorizontal_bias -- 横向约束力强度(浮点值: 0 - 1.0)
-->
&lt;android.support.constraint.ConstraintLayout ...
    xmlns:app="http://schemas.android.com/apk/res-auto">
    &lt;Button ...
        android:id="@+id/button_01"
        app:layout_constraintLeft_toLeftOf="parent"     <!-- 左侧和 parent 的左侧对齐 -->
        app:layout_constraintRight_toRightOf="parent"   <!-- 右侧和 parent 的右侧对齐 -->
        app:layout_constraintHorizontal_bias="0.2"      <!-- 横向约束比例为 0.2 -->
        app:layout_constraintTop_toTopOf="parent"       <!-- 顶部和 parent 的顶部对齐 -->
        app:layout_constraintBottom_toBottomOf="parent" <!-- 底部和 parent 的底部对齐 -->
        app:layout_constraintVertical_bias="0.1" />     <!-- 纵向约束比例为 0.1 -->

    &lt;Button ...
        android:id="@+id/button_02"
        app:layout_constraintLeft_toRightOf="@+id/button_01"   &lt;!-- 左侧和 button_01 右侧对齐 -->
        app:layout_constraintTop_toBottomOf="@+id/button_01"/> <!-- 顶部和 button_01 底部对齐 -->
&lt;/android.support.constraint.ConstraintLayout>
</pre>
                                    <p>使用 Java 代码实现以上布局</p>
                                    <pre class="brush: java;">
ConstraintLayout constraintLayout = findViewById(R.id.constraint_root);

ConstraintLayout.LayoutParams params = new ConstraintLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
params.leftToLeft = ConstraintLayout.LayoutParams.PARENT_ID;

Button button01 = new Button(this);
int idButton01 = View.generateViewId();
button01.setId(idButton01);
button01.setText("Button01");
button01.setLayoutParams(params);
constraintLayout.addView(button01);

Button button02 = new Button(this);
int idButton02 = View.generateViewId();
button02.setId(idButton02);
button02.setText("Button02");

params = new ConstraintLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT);
params.leftToRight = idButton01;
params.topToBottom = idButton01;
button02.setLayoutParams(params);
constraintLayout.addView(button02);
constraintLayout.requestLayout();
</pre>
                                </li>
                                <li>
                                    <p><code>MATCH_CONSTRAINT</code> -- 填充父窗体约束,在约束布局中宽高的维度 <code>match_parent</code> 被 <code>0dp</code> 代替，默认生成的大小占所有的可用空间。</p>
                                    <pre class="brush: xml;">
<!-- 可用的属性如下：
    layout_constraintWidth_min      -- 最小宽度
    layout_constraintHeight_min     -- 最小高度
    layout_constraintWidth_max      -- 最大宽度
    layout_constraintHeight_max     -- 最大高度
    layout_constraintWidth_default  -- 默认宽度
    layout_constraintHeight_default -- 默认高度
    layout_constraintWidth_percent  -- 宽度占比
    layout_constraintHeight_percent -- 高度占比
-->
&lt;android.support.constraint.ConstraintLayout ..
    xmlns:app="http://schemas.android.com/apk/res-auto"">

    &lt;View
        android:id="@+id/v_01"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:background="#336699"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintWidth_percent="0.5"
        app:layout_constraintHeight_min="50dp"/>

&lt;/android.support.constraint.ConstraintLayout>
</pre>
                                </li>
                                <li>
                                    <p><code>layout_constrained[Width|Height]</code> 属性 -- 当 宽度/高度 使用 wrap_content 时，如果不使用以下属性，其 宽度/高度 的约束可能会失效。</p>
                                    <pre class="brush: xml;">
<!-- 当 宽度/高度 使用 wrap_content 时，如果不使用以下属性，其 宽度/高度 的约束可能会失效
    layout_constrainedWidth  -- 约束宽度
    layout_constrainedHeight -- 约束高度
-->
&lt;android.support.constraint.ConstraintLayout ...
    xmlns:app="http://schemas.android.com/apk/res-auto">

    &lt;View ...
        android:id="@+id/v_01"/>
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="50dp"
        android:background="#dd3366"
        android:text="aaaaaaaaaaaaaaa"
        android:gravity="center"
        app:layout_constrainedWidth="true"  <!-- 如果没有此属性，那么当 text 长度超出时，宽度约束将会失效 -->
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/v_01"
        app:layout_constraintLeft_toRightOf="@+id/v_01"/>
&lt;/android.support.constraint.ConstraintLayout>
</pre>
                                </li>
                                <li>
                                    <p><code>layout_goneMarginXXX</code> 格式的属性 -- 当参照的 View 的 <code>android:visibility="gone"</code> 时候，View 的位置会发生改变(此时参照点为原来的 View 的中心位置)，还可以使用设置边距的形式来设置其位置，但是这些属性只在参照点为不可见的时候才起作用。</p>
                                    <pre class="brush: xml;">
&lt;!-- 参照点的 android:visibility="gone" 时，设置和原参照点的中点的距离
    layout_goneMarginLeft   -- 左侧和原参照点中点的距离
    layout_goneMarginTop    -- 顶部和原参照点中点的距离
    layout_goneMarginRight  -- 右侧和原参照点中点的距离
    layout_goneMarginBottom -- 底部和原参照点中点的距离
    layout_goneMarginStart  -- 开始边和原参照点中点的距离
    layout_goneMarginEnd    -- 结束边和原参照点中点的距离
-->
&lt;android.support.constraint.ConstraintLayout ...
  xmlns:app="http://schemas.android.com/apk/res-auto">
  &lt;Button ...
    android:id="@+id/btn_01"
    android:visibility="gone" />

  &lt;Button ...
    android:id="@+id/btn_02"
    app:layout_constraintLeft_toRightOf="@+id/btn_01" <!-- 如果 btn_01 不可见，参照点为 btn_01 中点 -->
    app:layout_constraintTop_toBottomOf="@+id/btn_01" <!-- 如果 btn_01 不可见，参照点为 btn_01 中点 -->
    app:layout_goneMarginLeft="50dp"   <!-- 在 btn_01 不可见时才生效，左侧距离 btn_01 中点 50dp  -->
    app:layout_goneMarginTop="10dp" /> <!-- 在 btn_01 不可见时才生效，顶部距离 btn_01 中点 10dp  -->
&lt;/android.support.constraint.ConstraintLayout>
</pre>
                                </li>
                                <li>
                                    <p><code>layout_constraintDimensionRatio</code> 属性 -- 用于根据屏幕或容器的宽度来为 View 设置固定的宽高比。要使用 <code>layout_constraintDimensionRatio</code> 属性，需要至少设置宽度或者高度为 0dp。</p>
                                    <pre class="brush: xml;">
<!-- 宽高比 layout_constraintDimensionRatio 的值有以下三种写法：(w, h 不区分大小写)
    h,float:float -- 指定约束高度
    w,float:float -- 指定约束宽度
    float:float   -- 根据情况决定约束高度/宽度(如果指定了宽度，就是约束高度；如果指定了高度，就是约束宽度)
-->
&lt;android.support.constraint.ConstraintLayout ...
    xmlns:app="http://schemas.android.com/apk/res-auto">

    &lt;LinearLayout ...
        android:id="@+id/layout_01"
        android:layout_width="match_parent"        <!-- 屏幕宽度 -->
        android:layout_height="0dp"
        app:layout_constraintDimensionRatio="3:1"  <!-- 因为指定了宽度，那么这里就是约束高度 -->
        android:background="#336699"/>

    &lt;LinearLayout ...
        android:id="@+id/layout_02"
        android:layout_width="0dp"
        android:layout_height="100dp"
        app:layout_constraintDimensionRatio="3:1" <!-- 因为指定了高度，那么这里就是约束宽度 -->
        android:background="#993399"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/layout_01" />

    &lt;android.support.constraint.ConstraintLayout
        android:id="@+id/layout_03"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintDimensionRatio="h,3:1" <!-- 指定约束宽度 -->
        android:background="#CC6699"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/layout_02" />

    &lt;LinearLayout ...
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintDimensionRatio="w,1:3" <!-- 指定约束宽度 -->
        android:background="#336699"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/layout_03"/>
</pre>
                                </li>
                                <li>
                                    <p><code>layout_constraint[Horizontal|Vertical]_weight</code> 属性 -- 像 LinearLayout 的 weight, ConstraintLayout 也支持重力布局。</p>
                                    <pre class="brush: xml;">
&lt;android.support.constraint.ConstraintLayout ...
	xmlns:app="http://schemas.android.com/apk/res-auto">
	<!-- 横向比例 -->
    &lt;android.support.constraint.ConstraintLayout
		android:id="@+id/layout_01"
		android:layout_width="0dp"
		android:layout_height="0dp"
		app:layout_constraintDimensionRatio="h,4:1"
		app:layout_constraintLeft_toLeftOf="parent"
		app:layout_constraintRight_toRightOf="parent">
        &lt;View
			android:id="@+id/c1"
			android:layout_width="0dp"
			android:layout_height="match_parent"
			android:background="#336699"
			app:layout_constraintLeft_toLeftOf="parent"
			app:layout_constraintHorizontal_weight="2"
			app:layout_constraintRight_toLeftOf="@id/c2"/>
        &lt;View
			android:id="@+id/c2"
			android:layout_width="0dp"
			android:layout_height="match_parent"
			android:background="#996699"
			app:layout_constraintHorizontal_weight="1"
			app:layout_constraintLeft_toRightOf="@id/c1"
			app:layout_constraintRight_toRightOf="parent"/>
    &lt;/android.support.constraint.ConstraintLayout>

	<!-- 纵向比例 -->
    &lt;android.support.constraint.ConstraintLayout
		android:id="@+id/layout_02"
		android:layout_width="0dp"
		android:layout_height="0dp"
		app:layout_constraintDimensionRatio="h,3:1"
		app:layout_constraintLeft_toLeftOf="parent"
		app:layout_constraintRight_toRightOf="parent"
		app:layout_constraintTop_toBottomOf="@id/layout_01">
        &lt;View
			android:id="@+id/c3"
			android:layout_width="match_parent"
			android:layout_height="0dp"
			android:background="#33DD99"
			app:layout_constraintVertical_weight="2"
			app:layout_constraintLeft_toLeftOf="parent"
			app:layout_constraintRight_toRightOf="parent"
			app:layout_constraintTop_toTopOf="parent"
			app:layout_constraintBottom_toTopOf="@id/c4"/>
        <&lt;View
			android:id="@+id/c4"
			android:layout_width="match_parent"
			android:layout_height="0dp"
			android:background="#DD6699"
			app:layout_constraintVertical_weight="1"
			app:layout_constraintTop_toBottomOf="@id/c3"
			app:layout_constraintBottom_toBottomOf="parent"
			app:layout_constraintLeft_toLeftOf="@+id/c3"
			app:layout_constraintRight_toRightOf="parent"/>
    &lt;/android.support.constraint.ConstraintLayout>
&lt;/android.support.constraint.ConstraintLayout>
</pre>
                                </li>
                                <li>
                                    <p><code>layout_constraint[Horizontal|Vertical]_chainStyle</code> 属性 -- 用于指定当控件不能填满空间时，里面的空白和控件如何分布。使用时只需要在第一个控件中指定就可以了。当其宽度/高度设置成 <code>0dp</code> 时，效果相当于使用 weight 一样。 </p>
                                    <pre class="brush: xml;">
<!-- layout_constraint[Horizontal|Vertical]_chainStyle 有以下值：
    假设方括号代表 ConstraintLayout 的宽度，* 号代表控件，空格代表空白部分，以下三种值排列如下：
    [ * * * ]spread -- 默认值，将所有的间距均匀分布到控件和 两侧/上下
    [*  *  *]spread_inside -- 将所有的间距均匀分布到控件之间，两侧/上下 不留空间
    [  ***  ]packed -- 控件间不留间距，两侧/上下 均匀分布间距
-->
&lt;android.support.constraint.ConstraintLayout
    android:id="@+id/layout_01"
    android:layout_width="0dp"
    android:layout_height="0dp"
    app:layout_constraintDimensionRatio="h,4:1"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent">
    &lt;View
        android:id="@+id/c1"
        android:layout_width="200dp"
        android:layout_height="match_parent"
        android:background="#336699"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintHorizontal_chainStyle="packed"
        app:layout_constraintRight_toLeftOf="@id/c2"/>
    &lt;View
        android:id="@+id/c2"
        android:layout_width="50dp"
        android:layout_height="match_parent"
        android:background="#996699"
        app:layout_constraintLeft_toRightOf="@id/c1"
        app:layout_constraintRight_toLeftOf="@+id/c5"
        app:layout_constraintRight_toRightOf="parent"/>
    &lt;View
        android:id="@+id/c5"
        android:layout_width="100dp"
        android:layout_height="match_parent"
        android:background="#DD6699"
        app:layout_constraintLeft_toRightOf="@id/c2"
        app:layout_constraintRight_toRightOf="parent"/>
&lt;android.support.constraint.ConstraintLayout>
</pre>
                                </li>
                                <li>
                                    <p><code>layout_constraintCircle</code> 等属性 -- 圆形定位，可以使 View 的中点基于某个参照 View 的中点为原心，再分别指定其半径和角度来定位。</p>
                                    <pre class="brush: xml;">
<!-- 圆形定位主要有以下属性：
    layout_constraintCircle       -- 指定参照点的 View 的 ID
    layout_constraintCircleAngle  -- 指定角度(0-360)
    layout_constraintCircleRadius -- 指定半径(带单位的尺寸值)
-->
&lt;android.support.constraint.ConstraintLayout ...
    xmlns:app="http://schemas.android.com/apk/res-auto"">
    &lt;View
        android:id="@+id/v_01"
        android:layout_width="100dp"
        android:layout_height="50dp"
        android:background="#336699"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"/>
    &lt;View
        android:layout_width="100dp"
        android:layout_height="50dp"
        android:background="#dd3366"
        app:layout_constraintCircle="@+id/v_01"     <!-- 参照点,以参照点的中点为圆心 -->
        app:layout_constraintCircleAngle="45"       <!-- 角度(顺时针方向，12 点方向为 0) -->
        app:layout_constraintCircleRadius="100dp"/> <!-- 半径，参照点的中点到此 View 的中点的距离 -->
&lt;/android.support.constraint.ConstraintLayout>
</pre>
                                </li>

                            </ol>
                            <p><b>ConstraintLayout</b> 包中的其他几个类：</p>
                            <ol type="I">
                                <li>
                                    <p><b>android.support.constraint.Guideline</b> 类 -- 是锚向指示线，是 View 的子类，相当于一条不可见的无宽高的线条，添加约束的时候，可以将其作为参考点。</p>
                                    <pre class="brush: xml;">
<!-- Guideline 主要有以下属性：
    layout_constraintGuide_begin -- 带单位的尺寸值，横向锚线为距离左侧的距离，纵向锚线为距离顶部的距离
    layout_constraintGuide_end   -- 带单位的尺寸值，横向锚线为距离右侧的距离，纵向锚线为距离底部的距离
    layout_constraintGuide_percent -- 浮点值(-1.0F - 1.0F)，横向为距离左侧的百分比，纵向为距离顶部的百分比
-->
&lt;android.support.constraint.ConstraintLayout ...
    xmlns:app="http://schemas.android.com/apk/res-auto">
    &lt;android.support.constraint.Guideline
        android:id="@+id/gl_v1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"                  <!-- 纵向锚线 -->
        app:layout_constraintGuide_percent="0.5" />     <!-- 居中 -->

    &lt;android.support.constraint.Guideline
        android:id="@+id/gl_h1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"                <!-- 横向锚线 -->
        app:layout_constraintGuide_begin="100dp" />     <!-- 距离顶部 100dp -->

    &lt;TextView
        android:layout_width="150dp"
        android:layout_height="150dp"
        android:background="#f5ec7e"
        android:gravity="center"
        android:text="Hello World!"
        app:layout_constraintLeft_toRightOf="@+id/gl_v1"    <!-- 基于锚线的约束-->
        app:layout_constraintTop_toBottomOf="@+id/gl_h1" /> <!-- 基于锚线的约束-->

&lt;/android.support.constraint.ConstraintLayout>
</pre>
                                </li>
                                <li>
                                    <p><b>android.support.constraint.Barrier</b> 类 -- 可以翻译为栅栏，是 ConstraintHelper 的子类，栅栏的位置可以根据其中的内容改变。也有点类似锚向指示线，其他的 View 可以参照 Barrier 的位置添加约束。</p>
                                    <pre class="brush: xml;">
<!-- Barrier 的位置始终在 tv_name,tv_contract 的右侧 -->
&lt;android.support.constraint.ConstraintLayout ...
    xmlns:app="http://schemas.android.com/apk/res-auto">

    &lt;TextView
        android:id="@+id/tv_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="姓名："
        app:layout_constraintBottom_toBottomOf="@+id/et_name"
        app:layout_constraintTop_toTopOf="@+id/et_name" />

    &lt;TextView
        android:id="@+id/tv_contract"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="联系方式："
        app:layout_constraintBottom_toBottomOf="@+id/et_contract"
        app:layout_constraintTop_toTopOf="@+id/et_contract" />

    &lt;android.support.constraint.Barrier
        android:id="@+id/barrier"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:barrierDirection="right" <!-- 栅栏的位置在 constraint_referenced_ids 引用的所有控件右侧 -->
        app:constraint_referenced_ids="tv_name,tv_contract" /> <!-- 指定引用的控件(多个 id 以逗号隔开) -->

    &lt;EditText
        android:id="@+id/et_name"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:hint="请输入姓名"
        app:layout_constraintLeft_toLeftOf="@+id/barrier"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    &lt;EditText
        android:id="@+id/et_contract"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:hint="请输入联系方式"
        app:layout_constraintLeft_toLeftOf="@+id/barrier"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/et_name" />
&lt;/android.support.constraint.ConstraintLayout>
</pre>
                                </li>
                                <li>
                                    <p><b>android.support.constraint.Group</b> 类 -- 用于控制多个控件的可见性。是 ConstraintHelper 的子类。将 Group 设为不可见时，其引用的控件也将不可见。</p>
                                    <pre class="brush: xml;">
&lt;android.support.constraint.ConstraintLayout ...
    xmlns:app="http://schemas.android.com/apk/res-auto">
    &lt;TextView ...
        android:id="@+id/tv_name" />

    &lt;TextView ...
        android:id="@+id/tv_contract" />

    &lt;android.support.constraint.Group
        android:id="@+id/group"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:constraint_referenced_ids="tv_name, tv_contract"/> <!-- 指定引用的控件(多个 id 以逗号隔开) -->

&lt;/android.support.constraint.ConstraintLayout>
</pre>
                                </li>
                                <li>
                                    <p><b>android.support.constraint.Placeholder</b> 类 -- View 的子类，提供可以定位现有对象的虚拟对象。</p>
                                    <pre class="brush: xml;">
&lt;android.support.constraint.ConstraintLayout ...
    xmlns:app="http://schemas.android.com/apk/res-auto">
    &lt;android.support.constraint.Placeholder
        android:id="@+id/placeholder"
        android:layout_width="50dp"
        android:layout_height="50dp"
        app:layout_constraintTop_toTopOf="parent"/>
    &lt;Button
        android:id="@+id/event"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintLeft_toRightOf="@+id/placeholder"
        android:text="Event" />
&lt;/android.support.constraint.ConstraintLayout>
</pre>
                                </li>
                                <li>
                                    <p><b>android.support.constraint.ConstraintSet</b> 类 -- 以 Java 代码的形式类指定 ConstraintLayout 中的控件添加约束，内部有一个 HashMap 以 ViewId 为键, Constraint 为值保存了所有的 View 的约束条件。</p>
                                    <p><code>ConstraintLayout.LayoutParams</code> 也可以为 ConstraintLayout 中的控件添加约束，但此类更加方便。</p>
                                    <p>比如将控件通过 xml 的形式加入到 ConstraintLayout 布局中，而不指定其约束条件，通过 ConstraintSet 在 Java 代码中为控件添加约束：</p>
                                    <div class="row">
                                        <div class="col-md-6">
                                            <p><b>内部的控件并未添加任何约束，默认堆叠在左上角:</b></p>
                                            <pre class="brush: xml; gutter: false;">
&lt;android.support.constraint.ConstraintLayout
    android:id="@+id/container"
    android:layout_width="match_parent"
    android:background="#99ccdd"
    android:layout_height="200dp">
    <!-- 布局中的约束也能被 clone 过去 -->
    &lt;Button
        android:id="@+id/top_left"
        android:text="Top Left"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
    &lt;Button
        android:id="@+id/center"
        android:text="Center"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
    &lt;Button
        android:id="@+id/bottom_right"
        android:text="Bottom Right"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
&lt;/android.support.constraint.ConstraintLayout>
</pre>
                                        </div>
                                        <div class="col-md-6" style="position:relative; margin-left:-20px;">
                                            <p><b>通过 ConstraintSet 实现第一个按钮在容器左上角，第二个按钮在容器中央，第三个按钮在容器右下角：</b></p>
                                            <pre class="brush: java; gutter: false;">
ConstraintLayout l = findViewById(R.id.container);
ConstraintSet s = new ConstraintSet();
s.clone(l); // 复制 xml 已有的约束

// 第一个按钮左上角，这里可以省略，默认就是左上角
s.connect(R.id.top_left, ConstraintSet.LEFT,
    ConstraintSet.PARENT_ID, ConstraintSet.LEFT);
s.connect(R.id.top_left, ConstraintSet.TOP,
    ConstraintSet.PARENT_ID, ConstraintSet.TOP);

// 第二个按钮横向和纵向居中
s.centerHorizontally(R.id.c,ConstraintSet.PARENT_ID);
s.centerVertically(R.id.c, ConstraintSet.PARENT_ID);

// 第三个按钮在容器右下角
s.connect(R.id.bottom_right, ConstraintSet.BOTTOM,
    ConstraintSet.PARENT_ID, ConstraintSet.BOTTOM);
s.connect(R.id.bottom_right, ConstraintSet.RIGHT,
    ConstraintSet.PARENT_ID, ConstraintSet.RIGHT);
s.applyTo(l); // 应用到指定的 ConstraintLayout 中
</pre>
                                        </div>
                                    </div>
                                    <pre class="brush: java;">
public class ConstraintSet {
    public static final int UNSET = -1;
    public static final int MATCH_CONSTRAINT = 0;
    public static final int WRAP_CONTENT = -2;
    public static final int MATCH_CONSTRAINT_WRAP = 1;
    public static final int MATCH_CONSTRAINT_SPREAD = 0;

    public static final int PARENT_ID = 0; // 通指 parent, 相当于 xml 的的 parent

    public static final int HORIZONTAL = 0;
    public static final int VERTICAL = 1;

    public static final int HORIZONTAL_GUIDELINE = 0;
    public static final int VERTICAL_GUIDELINE = 1;

    public static final int VISIBLE = 0;
    public static final int INVISIBLE = 4;
    public static final int GONE = 8;

    public static final int LEFT = 1;
    public static final int RIGHT = 2;
    public static final int TOP = 3;
    public static final int BOTTOM = 4;
    public static final int BASELINE = 5;
    public static final int START = 6;
    public static final int END = 7;

    public static final int CHAIN_SPREAD = 0;
    public static final int CHAIN_SPREAD_INSIDE = 1;
    public static final int CHAIN_PACKED = 2;

    /** 内部有一个 HashMap 以 ViewId 为键, Constraint 为值保存了所有的 View 的约束条件 */
    private HashMap&lt;Integer, Constraint> mConstraints = new HashMap();
    /** 此类用于般保存约束条件，类似于 ConstraintLayout.LayoutParams 类 */
    private static class Constraint {...}
}
</pre>
                                    <p><b>按照前面的 ConstraintLayout 的 xml 属性顺序来排列来分析其 API:</b></p>
									<ol>

                                        <li><p><code>void 	clone(ConstraintLayout constraintLayout)</code> -- 从 ConstraintLayout 复制已有的约束</p></li>
                                        <li><p><code>void 	clone(Constraints constraints)</code> -- 从 Constraints 复制已有的约束</p></li>
                                        <li><p><code>void 	clone(ConstraintSet set)</code> -- 从 ConstraintSet 复制已有的约束</p></li>
                                        <li><p><code>void 	clone(Context context, int constraintLayoutId)</code> -- 从 布局文件 复制已有的约束</p></li>

                                        <li class="group"><p><code>void 	load(Context context, XmlPullParser parser)</code> -- 从 布局文件 加载 ConstraintSet</p></li>
                                        <li><p><code>void 	load(Context context, int resourceId)</code> -- 从 布局文件 加载 ConstraintSet</p></li>

                                        <li class="group"><p><code>void 	clear(int viewId)</code> -- 清除指定 viewId 的所有方向的约束</p></li>
                                        <li><p><code>void 	clear(int viewId, int anchor)</code> -- 清除指定 viewId 的指定方向的约束</p></li>

                                        <li class="group"><p><code>ConstraintSet.Constraint 	getParameters(int viewId)</code> -- 获取某个指定 View 的布局参数</p></li>

                                        <li class="group"><p><code>void 	applyTo(ConstraintLayout constraintLayout)</code> -- 将此 ConstraintSet 应用到 ConstraintLayout 中</p></li>

                                        <li class="group"><p><code>void 	connect(int startID, int startSide, int endID, int endSide)</code> -- 添加约束</p></li>
                                        <li><p><code>void 	connect(int startID, int startSide, int endID, int endSide, int margin)</code> -- 添加约束，并有一个边距</p></li>
                                        <li><p><code>void 	setHorizontalBias(int viewId, float bias)</code> -- 横向约束力强度</p></li>
                                        <li><p><code>void 	setVerticalBias(int viewId, float bias)</code> -- 纵向约束力强度</p></li>
                                        <li><p><code>void 	setMargin(int viewId, int anchor, int value)</code> -- 设置指定方向的边距</p>
                                            <pre class="brush: java;">
/** 此部分的 API，相当于 ConstraintLayout 的 layout_constraintXXX_toYYYOf 属性和 layout_marginXXX */
ConstraintSet set = new ConstraintSet();

Button cancel = new Button(this);
int cancelId = View.generateViewId(); // 生成一个和 R.id 不冲突的 id 值, ok 为参照点 View
cancel.setId(cancelId);
cancel.setText("取 消");
constraintContent.addView(cancel);

set.constrainWidth(cancelId, ConstraintSet.WRAP_CONTENT);
set.setMargin(cancelId, ConstraintSet.RIGHT, ScreenUtil.dip2Px(this, 10));  // 指定边距
set.connect(cancelId, ConstraintSet.TOP, ok.getId(), ConstraintSet.TOP);    // topToTop
set.connect(cancelId, ConstraintSet.RIGHT, ok.getId(), ConstraintSet.LEFT); // rightToLeft

constraintSet.applyTo(constraintContent); // 应用到指定的 ConstraintLayout 容器中
</pre>
                                        </li>

                                        <li class="group"><p><code>void 	centerHorizontally(int viewId, int toView)</code> -- View 的中点横向和 toView 的中点对齐</p></li>
                                        <li><p><code>void 	centerHorizontally(int vID, int lvId, int leftSide, int leftMargin, int rvId, int rightSide, int rightMargin, float bias)</code> -- 横向将左侧与指点 lvId 的指定边对齐，右侧与 rvId  的指定边对齐，并可以指定边距和横向束力强度</p>
                                            <pre class="brush: java;">
/** 此方法调用了以下代码: */
this.connect(vID, LEFT, lvId, leftSide, leftMargin);    // 左侧和参照点的指定边对齐，并有一个边距
this.connect(vID, RIGHT, rvId, rightSide, rightMargin); // 右侧和参照点的指定边对齐，并有一个边距
ConstraintSet.Constraint constraint = (ConstraintSet.Constraint)this.mConstraints.get(centerID);
constraint.horizontalBias = bias; // 横向重力设置为指定值
</pre>
                                        </li>
                                        <li><p><code>void 	centerHorizontallyRtl(int viewId, int toView)</code> -- RTL 布局</p></li>
                                        <li><p><code>void 	centerHorizontallyRtl(int centerID, int startId, int startSide, int startMargin, int endId, int endSide, int endMargin, float bias)</code> -- RTL 布局， 同 centerHorizontally(...) 将 LEFT, RIGHT 换成 START, END</p></li>
                                        <li><p><code>void 	centerVertically(int viewId, int toView)</code> -- View 的中点纵向和 toView 的中点对齐</p></li>
                                        <li><p><code>void 	centerVertically(int centerID, int tvId, int topSide, int topMargin, int bvId, int bottomSide, int bottomMargin, float bias)</code> -- 纵向将顶部与指点 tvId 的指定边对齐，底部与 bvId  的指定边对齐，并可以指定边距和纵向约束力强度</p>
                                            <pre class="brush: java;">
/** 此方法调用了以下代码: */
this.connect(vID, TOP, tvId, topSide, topMargin);          // 顶部和参照点的指定边对齐，并有一个边距
this.connect(vID, BOTTOM, bvId, bottomSide, bottomMargin); // 底部和参照点的指定边对齐，并有一个边距
ConstraintSet.Constraint constraint = (ConstraintSet.Constraint)this.mConstraints.get(centerID);
constraint.verticalBias = bias; // 横向重力设置为指定值
</pre>
                                        </li>
                                        <li><p><code>void 	center(int centerID, int firstID, int firstSide, int firstMargin, int secondId, int secondSide, int secondMargin, float bias)</code> -- 参照前面，根据 firstSide 的值判断</p></li>

                                        <li class="group"><p><code>void 	constrainWidth(int viewId, int w)</code> -- 宽度，w 可以为: 像素 或者 <code>WRAP_CONTENT</code>, <code>MATCH_CONSTRAINT</code></p></li>
                                        <li><p><code>void 	constrainHeight(int viewId, int h)</code> -- 高度，h 可以为: 像素 或者 <code>WRAP_CONTENT</code>, <code>MATCH_CONSTRAINT</code></p></li>

                                        <li class="group"><p><code>void 	constrainDefaultHeight(int viewId, int height)</code> -- 默认高度</p></li>
                                        <li><p><code>void 	constrainDefaultWidth(int viewId, int width)</code> -- 默认宽度</p></li>
                                        <li><p><code>void 	constrainMaxHeight(int viewId, int height)</code> -- 最大高度</p></li>
                                        <li><p><code>void 	constrainMaxWidth(int viewId, int width)</code> -- 最大宽度</p></li>
                                        <li><p><code>void 	constrainMinHeight(int viewId, int height)</code> -- 最小高度</p></li>
                                        <li><p><code>void 	constrainMinWidth(int viewId, int width)</code> -- 最小宽度</p></li>
                                        <li><p><code>void 	constrainPercentHeight(int viewId, float percent)</code> -- 高度占比</p></li>
                                        <li><p><code>void 	constrainPercentWidth(int viewId, float percent)</code> -- 宽度占比</p></li>

                                        <li class="group"><p><code>void 	setVisibility(int viewId, int visibility)</code> -- 设置可见性</p></li>
                                        <li><p><code>void 	setGoneMargin(int viewId, int anchor, int value)</code> -- 当参照点不可时，设置指定边(anchor = LEFT, RIGHT...)的边距，参见前面: layout_goneMarginXXX 格式的属性</p></li>

                                        <li class="group"><p><code>void 	setHorizontalWeight(int viewId, float weight)</code> -- 横向重力</p></li>
                                        <li><p><code>void 	setVerticalWeight(int viewId, float weight)</code> -- 纵向重力</p></li>

                                        <li class="group"><p><code>void 	addToHorizontalChain(int viewId, int leftId, int rightId)</code> -- 添加横向 chain</p></li>
                                        <li><p><code>void 	addToHorizontalChainRTL(int viewId, int leftId, int rightId)</code> -- RTL 布局</p></li>
                                        <li><p><code>void 	addToVerticalChain(int viewId, int topId, int bottomId)</code> -- 添加纵向 chain</p></li>
                                        <li><p><code>void 	removeFromHorizontalChain(int viewId)</code> -- 移除横向 chain</p></li>
                                        <li><p><code>void 	removeFromVerticalChain(int viewId)</code> -- 移除纵向 chain</p></li>

                                        <li class="group"><p><code>void 	setHorizontalChainStyle(int viewId, int chainStyle)</code> -- 设置横向 chain 样式，只需要在链头的元素设置：<code>CHAIN_SPREAD</code>, <code>CHAIN_SPREAD_INSIDE</code>, <code>CHAIN_PACKED</code></p></li>
                                        <li><p><code>void 	setVerticalChainStyle(int viewId, int chainStyle)</code> -- 设置纵向 chain 样式，只需要在链头的元素设置：<code>CHAIN_SPREAD</code>, <code>CHAIN_SPREAD_INSIDE</code>, <code>CHAIN_PACKED</code></p></li>

                                        <li class="group"><p><code>void 	createHorizontalChain(int leftId, int leftSide, int rightId, int rightSide, int[] chainIds, float[] weights, int style)</code> -- 将 chainIds 指定的多个元素添加到此横向 chain 中类</p></li>
                                        <li><p><code>void 	createHorizontalChainRtl(int startId, int startSide, int endId, int endSide, int[] chainIds, float[] weights, int style)</code> -- 同上，RTL 布局</p></li>
                                        <li><p><code>void 	createVerticalChain(int topId, int topSide, int bottomId, int bottomSide, int[] chainIds, float[] weights, int style)</code> -- 将 chainIds 指定的多个元素添加到此纵向 chain 中类</p></li>

                                        <li class="group"><p><code>void 	setDimensionRatio(int viewId, String ratio)</code> -- 宽高比</p></li>

                                        <li class="group"><p><code>void 	constrainCircle(int viewId, int id, int radius, float angle)</code> -- 圆形约束</p></li>

                                        <li class="group"><p><code>void 	create(int guidelineID, int orientation)</code> -- 创建一条 Guideline，并指定方向</p></li>
                                        <li><p><code>void 	setGuidelineBegin(int guidelineID, int margin)</code> -- 设置 Guideline 开始位置</p></li>
                                        <li><p><code>void 	setGuidelineEnd(int guidelineID, int margin)</code> -- 设置 Guideline 结束位置</p></li>
                                        <li><p><code>void 	setGuidelinePercent(int guidelineID, float ratio)</code> -- 百分比设置 Guideline 位置</p>
                                            <pre class="brush: java;">
int gId = View.generateViewId();
set.create(gId, ConstraintSet.VERTICAL_GUIDELINE);
set.setGuidelinePercent(gId, 0.2f);
set.connect(R.id.guide_line, ConstraintSet.LEFT, gId, ConstraintSet.RIGHT);
set.connect(R.id.guide_line, ConstraintSet.TOP, R.id.center, ConstraintSet.BOTTOM);
</pre>
                                        </li>

                                        <li class="group"><p><code>void 	createBarrier(int id, int direction, int... referenced)</code> -- 创建一个栅栏(Barrier), 指定方向和引用的元素</p></li>
                                        <li><p><code>void 	setBarrierType(int id, int type)</code> -- 指定栅栏(Barrier)类型，空方法<code></code></p></li>

                                        <li class="group"><p><code>void 	setAlpha(int viewId, float alpha)</code> -- 设置透明度，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setTranslation(int viewId, float translationX, float translationY)</code> -- 设置偏移，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setTranslationX(int viewId, float translationX)</code> -- 设置 X 偏移，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setTranslationY(int viewId, float translationY)</code> -- 设置 Y 偏移，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setTranslationZ(int viewId, float translationZ)</code> -- 设置 Z 偏移，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setRotation(int viewId, float rotation)</code> -- 中心点旋转，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setRotationX(int viewId, float rotationX)</code> -- X 轴旋转，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setRotationY(int viewId, float rotationY)</code> -- Y 轴旋转，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setScaleX(int viewId, float scaleX)</code> -- X 方向缩放，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setScaleY(int viewId, float scaleY)</code> -- Y 方向缩放，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setTransformPivot(int viewId, float transformPivotX, float transformPivotY)</code> -- 设置变换中点，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setTransformPivotX(int viewId, float transformPivotX)</code> -- 设置变换 X 坐标，调用 <code>applyTo()</code> 生效</p></li>
                                        <li><p><code>void 	setTransformPivotY(int viewId, float transformPivotY)</code> -- 设置变换 X 坐标，调用 <code>applyTo()</code> 生效</p></li>

                                        <li class="group"><p><code>void 	setApplyElevation(int viewId, boolean apply)</code> -- 是否应用高度</p></li>
                                        <li><p><code>boolean 	getApplyElevation(int viewId)</code> -- 获取是否应用高度，默认不启用</p></li>
                                        <li><p><code>void 	setElevation(int viewId, float elevation)</code> -- 设置高度值</p></li>
                                    </ol>
                                </li>
                            </ol>
                            <p><b>ConstraintLayout</b> 的 API：</p>
                            <ol>

                                <li><p><code>int 	getMaxHeight()</code> -- </p></li>
                                <li><p><code>void 	setMaxHeight(int value)</code> -- </p></li>
                                <li><p><code>int 	getMaxWidth()</code> -- </p></li>
                                <li><p><code>void 	setMaxWidth(int value)</code> -- </p></li>

                                <li class="group"><p><code>int 	getMinHeight()</code> -- </p></li>
                                <li><p><code>void 	setMinHeight(int value)</code> -- </p></li>
                                <li><p><code>int 	getMinWidth()</code> -- </p></li>
                                <li><p><code>void 	setMinWidth(int value)</code> -- </p></li>

                                <li class="group"><p><code>int 	getOptimizationLevel()</code> -- </p></li>
                                <li><p><code>void 	setOptimizationLevel(int level)</code> -- </p></li>

                                <li class="group"><p><code>void 	requestLayout()</code> -- </p></li>
                                <li><p><code>void 	loadLayoutDescription(int layoutDescription)</code> -- </p></li>

                                <li class="group"><p><code>void 	setConstraintSet(ConstraintSet set)</code> -- </p></li>
                                <li><p><code>void 	setState(int id, int screenWidth, int screenHeight)</code> -- </p></li>
                                <li><p><code>void 	setOnConstraintsChanged(ConstraintsChangedListener constraintsChangedListener)</code> -- </p></li>

                                <li class="group"><p><code>protected boolean 	checkLayoutParams(ViewGroup.LayoutParams p)</code> -- </p></li>
                                <li><p><code>protected ConstraintLayout.LayoutParams 	generateDefaultLayoutParams()</code> -- </p></li>
                                <li><p><code>protected ViewGroup.LayoutParams 	generateLayoutParams(ViewGroup.LayoutParams p)</code> -- </p></li>
                                <li><p><code>protected void 	onLayout(boolean changed, int left, int top, int right, int bottom)</code> -- </p></li>
                                <li><p><code>protected void 	onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> -- </p></li>
                            </ol>
                        </div>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="android-support-v7-widget-RecyclerView"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">RecyclerView 及子类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
public class RecyclerView extends ViewGroup implements ScrollingView, NestedScrollingChild {
	public static final int HORIZONTAL = LinearLayout.HORIZONTAL;
    public static final int VERTICAL = LinearLayout.VERTICAL;

    public static final int NO_POSITION = -1;
    public static final long NO_ID = -1;
    public static final int INVALID_TYPE = -1;

    public static final int TOUCH_SLOP_DEFAULT = 0;
    public static final int TOUCH_SLOP_PAGING = 1;

    /** 滚动状态，参见： onScrollStateChanged(int) */
    public static final int SCROLL_STATE_IDLE     = 0; // 滚动停止
    public static final int SCROLL_STATE_DRAGGING = 1; // 正在拖动
    public static final int SCROLL_STATE_SETTLING = 2; // 已经停止拖动，但还是在滚动

    /** 条目被回收监听 */
    public interface RecyclerListener {
        void onViewRecycled(@NonNull ViewHolder holder);
    }

    /** 可以用来改变 RecyclerView 子项目的绘制顺序的回调接口 */
    public interface ChildDrawingOrderCallback {
        int onGetChildDrawingOrder(int var1, int var2);
    }

    /** Item 从 RecyclerView 添加/移除事件监听器 */
    public interface OnChildAttachStateChangeListener {
        void onChildViewAttachedToWindow(@NonNull View var1);
        void onChildViewDetachedFromWindow(@NonNull View var1);
    }

    /** 添加 Item 触摸监听器(ItemClick 等事件可以从此处实现) */
    public interface OnItemTouchListener {
        boolean onInterceptTouchEvent(@NonNull RecyclerView var1, @NonNull MotionEvent var2);
        void onTouchEvent(@NonNull RecyclerView var1, @NonNull MotionEvent var2);
        void onRequestDisallowInterceptTouchEvent(boolean var1);
    }

    /** OnItemTouchListener 的简单实现 */
    public static class SimpleOnItemTouchListener implements OnItemTouchListener {
        public SimpleOnItemTouchListener() {}
        public boolean onInterceptTouchEvent(@NonNull RecyclerView rv, @NonNull MotionEvent e) {...}
        public void onTouchEvent(@NonNull RecyclerView rv, @NonNull MotionEvent e) {}
        public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) {}
    }

    /** 滚动监听器 */
    public abstract static class OnScrollListener {
        public OnScrollListener() {}
        public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {}
        public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {}
    }

    /** 滚动速度监听 */
    public abstract static class OnFlingListener {
        public OnFlingListener() {}
        public abstract boolean onFling(int velocityX, int velocityY);
    }

    /** 适配器提供了展示在 RecyclerView 中的特定数据集从应用程序到视图上的绑定 */
    public abstract static class Adapter&lt;VH extends ViewHolder> {...}

    /**  观察 RecyclerView.Adapter 的更改的观察者基类 */
    public abstract static class AdapterDataObserver {...}

    /** 定义了当适配器中的子项目发生变化时所发生的动画 */
    public abstract static class ItemAnimator {...}

    /** Item 装饰,比如分隔符 */
    public abstract static class ItemDecoration {...}

    /** 标准化的 ViewHodler 类，写 ViewHolder 要继承子类 */
    public abstract static class ViewHolder {...}

    /** 布局管理器，一般使用它的几个子类，也可以继承此类来自定义布局管理器 */
    public abstract static class LayoutManager {...}

    /** 布局参数 */
    public static class LayoutParams extends MarginLayoutParams {...}

    public static class State {...}
    public static class SavedState extends AbsSavedState {...}
    public abstract static class SmoothScroller {...}
    public abstract static class ViewCacheExtension {...}
    public final class Recycler {...}
    public static class RecycledViewPool {...}
    public static class EdgeEffectFactory {...}

    public RecyclerView(Context context) {}
    public RecyclerView(Context context, AttributeSet attrs) {}
    public RecyclerView(Context context, AttributeSet attrs, int defStyle) {}
}

public interface ScrollingView {
    int computeHorizontalScrollRange();
    int computeHorizontalScrollOffset();
    int computeHorizontalScrollExtent();
    int computeVerticalScrollRange();
    int computeVerticalScrollOffset();
    int computeVerticalScrollExtent();
}

public interface NestedScrollingChild2 extends NestedScrollingChild {
    boolean startNestedScroll(@ScrollAxis int axes, @NestedScrollType int type);
    void stopNestedScroll(@NestedScrollType int type);
    boolean hasNestedScrollingParent(@NestedScrollType int type);
    boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed,
        int dyUnconsumed, @Nullable int[] offsetInWindow, @NestedScrollType int type);
    boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed,
        @Nullable int[] offsetInWindow, @NestedScrollType int type);
}

public interface NestedScrollingChild {
    void setNestedScrollingEnabled(boolean enabled);
    boolean isNestedScrollingEnabled();
    boolean startNestedScroll(@ScrollAxis int axes);
    void stopNestedScroll();
    boolean hasNestedScrollingParent();
    boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,
            int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow);
    boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed,
            @Nullable int[] offsetInWindow);
    boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed);
    boolean dispatchNestedPreFling(float velocityX, float velocityY);
}
</pre>
                            <p><a href="docs/reference/android/support/v7/widget/RecyclerView.html" target="_blank">RecyclerView</a> 一种灵活的视图，用于向大数据集提供有限窗口。可以用来代替传统的 ListView，更加强大和灵活</p>
                            <p><b>RecyclerView</b> 的使用需要引入依赖：</p>
                            <pre class="brush: java;">
implementation 'androidx.recyclerview:recyclerview:1.0.0'          // androidx
// implementation 'com.android.support:recyclerview-v7:28.0.0'     // support
</pre>
                            <p><code>recyclerview</code> 包内主要还包括了以下类：</p>
                            <ul>
                                <li><p><a href="docs/reference/android/support/v7/widget/LinearLayoutManager.html" target="_blank">LinearLayoutManager</a> -- 是 RecyclerView.LayoutManager 的子类。参照：<a href="#RecyclerView-LayoutManager">RecyclerView.LayoutManager</a></p></li>
                                <li><p><a href="docs/reference/android/support/v7/widget/GridLayoutManager.html" target="_blank">GridLayoutManager</a> -- 是 LinearLayoutManager 的子类。参照：<a href="#RecyclerView-LayoutManager">RecyclerView.LayoutManager</a></p></li>
                                <li><p><a href="docs/reference/android/support/v7/widget/StaggeredGridLayoutManager.html" target="_blank">StaggeredGridLayoutManager</a> -- 是 RecyclerView.LayoutManager 的子类。参照：<a href="#RecyclerView-LayoutManager">RecyclerView.LayoutManager</a></p></li>
                                <li><p><a href="docs/reference/android/support/v7/widget/ListAdapter.html" target="_blank">ListAdapter</a> -- 是 RecyclerView.Adapter 的子类。参照：<a href="#RecyclerView-Adapter">RecyclerView.Adapter</a></p></li>
                                <li><p><a href="https://developer.android.com/reference/androidx/recyclerview/widget/DividerItemDecoration" target="_blank">DividerItemDecoration,</a> -- 是 RecyclerView.ItemDecoration 的子类。参照：<a href="#RecyclerView-ItemDecoration">RecyclerView.ItemDecoration</a></p></li>
                                <li><p><a href="docs/reference/android/support/v7/widget/helper/ItemTouchHelper.html" target="_blank">ItemTouchHelper</a> -- 是 RecyclerView.ItemDecoration 的子类。参照：<a href="#RecyclerView-LayoutManager">RecyclerView.ItemDecoration</a></p></li>
                                <li><p><a href="docs/reference/android/support/v7/widget/SimpleItemAnimator.html" target="_blank">SimpleItemAnimator</a> -- 是 RecyclerView.ItemAnimator 的子类。参照：<a href="#RecyclerView-ItemAnimator">RecyclerView.ItemAnimator</a></p></li>
                                <li><p><a href="docs/reference/android/support/v7/widget/DefaultItemAnimator.html" target="_blank">DefaultItemAnimator</a> -- 是 SimpleItemAnimator 的子类。参照：<a href="#RecyclerView-ItemAnimator">RecyclerView.ItemAnimator</a></p></li>
                                <li><p><a href="docs/reference/android/support/v7/widget/...html" target="_blank">...</a> -- </p></li>
                            </ul>
                            <p>在使用 <b>RecyclerView</b> 时候，必须指定一个适配器 Adapter 和一个布局管理器 LayoutManager。适配器继承 Adapter 类，具体实现类似 ListView 的适配器，取决于数据信息以及展示的 UI。布局管理器用于确定 RecyclerView 中 Item 的展示方式以及决定何时复用已经不可见的 Item，避免重复创建以及执行高成本的 findViewById() 方法。</p>
                            <p><b>RecyclerView</b> 关于 Item 的点击和长按事件，需要用户自己去实现。</p>
                            <p><b>RecyclerView</b> 相对于 ListView 的优点罗列如下：</p>
                            <ul>
                                <li><p>封装了 ViewHolder 的回收复用，也就是说 RecyclerView 标准化了 ViewHolder，编写 Adapter 面向的是 ViewHolder 而不再是 View 了，复用的逻辑被封装了，写起来更加简单。</p></li>
                                <li><p>提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个 Item 的显示 RecyclerView 专门抽取出了相应的类，来控制 Item 的显示，使其的扩展性非常强。</p></li>
                                <li><p>设置布局管理器以控制 Item 的布局方式，横向、竖向以及瀑布流方式，也就是说 RecyclerView 不再拘泥于 ListView 的线性展示方式，它也可以实现 GridView 的效果等多种效果。</p></li>
                                <li><p>可设置 Item 的间隔样式（可绘制），通过继承 RecyclerView 的 ItemDecoration 这个类，然后针对自己的业务需求去书写代码。</p></li>
                                <li><p>可以控制 Item 增删的动画，可以通过 ItemAnimator 这个类进行控制，当然针对增删的动画，RecyclerView 有其自己默认的实现。</p></li>
                            </ul>
                            <div class="panel panel-default">
                                <div class="panel-heading">
                                    <a data-toggle="collapse" data-parent="#accordion" href="#RecyclerView-example" aria-expanded="false" class="code-header collapsed">
                                        <span class="glyphicon glyphicon-plus"></span> View Code
                                    </a>
                                </div>
                                <div id="RecyclerView-example" class="panel-collapse collapse" style="height: 0px;" aria-expanded="false">
                                    <pre class="brush: java;">
LinearLayoutManager layoutManager = new LinearLayoutManager(this);
// 设置为垂直布局，默认
layoutManager.setOrientation(OrientationHelper.VERTICAL);
// 布局管理器
recyclerView.setLayoutManager(layoutManager);
// Adapter
recyclerView.setAdapter(new NormalAdapter(datas));
// 分割线，可以设置其方向（比如当布局为为水平时，就应该设置为水平分割线）
recyclerView.addItemDecoration(new DividerItemDecoration(context, DividerItemDecoration.VERTICAL));
// 默认，添加/移除 Item 时候的动画，动画的展示要调用 Adapter 的 notityItemXXX(int) 方法
recyclerView.setItemAnimator(new DefaultItemAnimator());

public class NormalAdapter extends RecyclerView.Adapter&lt;NormalAdapter.VH> {
    private List&lt;String> mDatas;

    public NormalAdapter(List&lt;String> data) { this.mDatas = data; }

    // 创建 ViewHolder
    public class VH extends RecyclerView.ViewHolder {
        public final ImageView icon;
        public final TextView title, description;

        public VH(View v) {
            super(v);
            icon = v.findViewById(R.id.icon);
            title = v.findViewById(R.id.title);
            description = v.findViewById(R.id.description);
        }
    }


    @Override
    public void onBindViewHolder(VH holder, int position) {
        holder.title.setText(mDatas.get(position));
        // ...
        holder.itemView.setOnClickListener(v -> {
            // ...
        });
        holder.itemView.setOnLongClickListener(v -> {
            // ...
            return true;
        });
    }

    @Override
    public int getItemCount() {
        return mDatas.size();
    }

    @Override
    public VH onCreateViewHolder(ViewGroup parent, int viewType) {
        /** 注意这里的 inflater 和 ListView 等不一样
         * 如果要 Ripple 效果：android:background/foreground="?android:attr/selectableItemBackground"
         */
        View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.img_txt2line, parent, false);
        return new VH(v);
    }
}
</pre>
                                </div>
                            </div>

                            <ol>
                                <li><p><code>void 	setLayoutManager(RecyclerView.LayoutManager layout)</code> -- 设置布局管理器</p></li>
                                <li><p><code>RecyclerView.LayoutManager 	getLayoutManager()</code> -- 获取布局管理器</p></li>

                                <li class="group"><p><code>void 	setAdapter(Adapter adapter)</code> -- 设置数据适配器</p></li>
                                <li><p><code>Adapter 	getAdapter()</code> -- 获取适配器</p></li>

                                <li class="group"><p><code>void 	setItemAnimator(RecyclerView.ItemAnimator animator)</code> -- 设置添加/删除条目动画</p></li>
                                <li><p><code>RecyclerView.ItemAnimator 	getItemAnimator()</code> -- 获取添加/删除条目动画</p></li>

                                <li class="group"><p><code>void 	addItemDecoration(RecyclerView.ItemDecoration decor)</code> -- 添加 Item 条目装饰，比如分隔符</p></li>
                                <li><p><code>void 	removeItemDecoration(RecyclerView.ItemDecoration decor)</code> -- 移除条目装饰</p></li>
                                <li><p><code>oid 	addItemDecoration(RecyclerView.ItemDecoration decor, int index)</code> -- 添加 Item 条目装饰(装饰可以有多个)</p></li>
                                <li><p><code>void 	removeItemDecorationAt(int index)</code> -- 移除指定索引的条目装饰</p></li>
                                <li><p><code>RecyclerView.ItemDecoration 	getItemDecorationAt(int index)</code> -- 获取指定索引的 Item 装饰</p></li>
                                <li><p><code>int 	getItemDecorationCount()</code> -- 获取 Item 装饰的数量</p></li>

                                <li class="group"><p><code>void 	addFocusables(ArrayList&lt;View> views, int direction, int focusableMode)</code> -- 将需要获得焦点的 View 添加到获得焦点视图的列表中</p></li>

                                <li class="group"><p><code>void 	addOnChildAttachStateChangeListener(RecyclerView.OnChildAttachStateChangeListener listener)</code> -- 添加一个 Item 从 RecyclerView 添加/移除 监听器</p></li>
                                <li><p><code>void 	removeOnChildAttachStateChangeListener(RecyclerView.OnChildAttachStateChangeListener listener)</code> -- 移除指定的 Item 添加/移除 监听器</p></li>
                                <li><p><code>void 	clearOnChildAttachStateChangeListeners()</code> -- 清除 Item 添加/移除 监听器</p></li>

                                <li class="group"><p><code>void 	addOnItemTouchListener(RecyclerView.OnItemTouchListener listener)</code> -- 添加 Item 触摸监听器(ItemClick 等事件可以从此处实现)</p></li>
                                <li><p><code>void 	removeOnItemTouchListener(RecyclerView.OnItemTouchListener listener)</code> -- 移除指定的触摸监听器</p></li>

                                <li class="group"><p><code>void 	addOnScrollListener(RecyclerView.OnScrollListener listener)</code> -- 添加滚动监听器</p></li>
                                <li><p><code>void 	removeOnScrollListener(RecyclerView.OnScrollListener listener)</code> -- 移除指定的滚动监听器</p></li>
                                <li><p><code>void 	clearOnScrollListeners()</code> -- 清除滚动监听器</p></li>

                                <li class="group"><p><code>void 	setOnFlingListener(RecyclerView.OnFlingListener onFlingListener)</code> -- 设置滚动速度监听器</p></li>
                                <li><p><code>RecyclerView.OnFlingListener 	getOnFlingListener()</code> -- 获取滚动速度监听器</p></li>

                                <li class="group"><p><code>void 	onChildAttachedToWindow(View child)</code> -- Item 添加监听回调</p></li>
                                <li><p><code>void 	onChildDetachedFromWindow(View child)</code> -- Item 移除监听回调</p></li>
                                <li><p><code>void 	onDraw(Canvas c)</code> -- 绘制方法回调</p></li>
                                <li><p><code>void 	onScrollStateChanged(int state)</code> -- 滚动状态监听回调，参见常量</p></li>
                                <li><p><code>void 	onScrolled(int dx, int dy)</code> -- 滚动位置监听回调</p></li>
                                <li><p><code>boolean 	onTouchEvent(MotionEvent e)</code> -- 触摸事件回调</p></li>
                                <li><p><code>boolean 	onGenericMotionEvent(MotionEvent event)</code> -- 响应鼠标滚轮等事件回调</p></li>
                                <li><p><code>boolean 	onInterceptTouchEvent(MotionEvent e)</code> -- 触摸事件拦截方法回调</p></li>

                                <li class="group"><p><code>RecyclerView.ViewHolder 	findViewHolderForLayoutPosition(int position)</code> -- 获取指定位置的 ViewHolder,可能为 NULL</p></li>
                                <li><p><code>RecyclerView.ViewHolder 	findViewHolderForAdapterPosition(int pos)</code> -- 获取指定位置的 ViewHolder,可能为 NULL</p></li>
                                <li><p><code>RecyclerView.ViewHolder 	findContainingViewHolder(View view)</code> -- 查询包括指定 View 的 ViewHolder</p></li>
                                <li><p><code>RecyclerView.ViewHolder 	findViewHolderForItemId(long id)</code> -- 查询包括指定 id 的 ViewHolder</p></li>
                                <li><p><code>View 	findChildViewUnder(float x, float y)</code> -- 查询指定位置的 View</p></li>
                                <li><p><code>View 	findContainingItemView(View view)</code> -- 遍历给定视图的祖先并返回包含它的项视图</p></li>

                                <li class="group"><p><code>int 	computeHorizontalScrollExtent()</code> -- </p></li>
                                <li><p><code>int 	computeHorizontalScrollOffset()</code> -- </p></li>
                                <li><p><code>int 	computeHorizontalScrollRange()</code> -- </p></li>
                                <li><p><code>int 	computeVerticalScrollExtent()</code> -- </p></li>
                                <li><p><code>int 	computeVerticalScrollOffset()</code> -- </p></li>
                                <li><p><code>int 	computeVerticalScrollRange()</code> -- </p></li>

                                <li><p><code>boolean 	dispatchNestedFling(float velocityX, float velocityY, boolean consumed)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchNestedPreFling(float velocityX, float velocityY)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow, int type)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow, int type)</code> -- </p></li>
                                <li><p><code>boolean 	dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)</code> -- </p></li>
                                <li><p><code>void 	draw(Canvas c)</code> -- </p></li>
                                <li><p><code>boolean 	drawChild(Canvas canvas, View child, long drawingTime)</code> -- </p></li>

                                <li><p><code>boolean 	fling(int velocityX, int velocityY)</code> -- </p></li>
                                <li><p><code>View 	focusSearch(View focused, int direction)</code> -- </p></li>
                                <li><p><code>ViewGroup.LayoutParams 	generateLayoutParams(AttributeSet attrs)</code> -- </p></li>

                                <li><p><code>int 	getBaseline()</code> -- </p></li>
                                <li><p><code>int 	getChildAdapterPosition(View child)</code> -- </p></li>
                                <li><p><code>long 	getChildItemId(View child)</code> -- </p></li>
                                <li><p><code>int 	getChildLayoutPosition(View child)</code> -- </p></li>
                                <li><p><code>RecyclerView.ViewHolder 	getChildViewHolder(View child)</code> -- </p></li>
                                <li><p><code>boolean 	getClipToPadding()</code> -- </p></li>
                                <li><p><code>RecyclerViewAccessibilityDelegate 	getCompatAccessibilityDelegate()</code> -- </p></li>
                                <li><p><code>void 	getDecoratedBoundsWithMargins(View view, Rect outBounds)</code> -- </p></li>
                                <li><p><code>RecyclerView.EdgeEffectFactory 	getEdgeEffectFactory()</code> -- </p></li>



                                <li><p><code>int 	getMaxFlingVelocity()</code> -- </p></li>
                                <li><p><code>int 	getMinFlingVelocity()</code> -- </p></li>

                                <li><p><code>boolean 	getPreserveFocusAfterLayout()</code> -- </p></li>
                                <li><p><code>RecyclerView.RecycledViewPool 	getRecycledViewPool()</code> -- </p></li>
                                <li><p><code>int 	getScrollState()</code> -- </p></li>
                                <li><p><code>boolean 	hasFixedSize()</code> -- </p></li>
                                <li><p><code>boolean 	hasNestedScrollingParent()</code> -- </p></li>
                                <li><p><code>boolean 	hasNestedScrollingParent(int type)</code> -- </p></li>
                                <li><p><code>boolean 	hasPendingAdapterUpdates()</code> -- </p></li>
                                <li><p><code>void 	invalidateItemDecorations()</code> -- </p></li>
                                <li><p><code>boolean 	isAnimating()</code> -- </p></li>
                                <li><p><code>boolean 	isAttachedToWindow()</code> -- </p></li>
                                <li><p><code>boolean 	isComputingLayout()</code> -- </p></li>
                                <li><p><code>boolean 	isLayoutFrozen()</code> -- </p></li>
                                <li><p><code>boolean 	isNestedScrollingEnabled()</code> -- </p></li>
                                <li><p><code>void 	offsetChildrenHorizontal(int dx)</code> -- </p></li>
                                <li><p><code>void 	offsetChildrenVertical(int dy)</code> -- </p></li>


                                <li><p><code>void 	requestChildFocus(View child, View focused)</code> -- </p></li>
                                <li><p><code>boolean 	requestChildRectangleOnScreen(View child, Rect rect, boolean immediate)</code> -- </p></li>
                                <li><p><code>void 	requestDisallowInterceptTouchEvent(boolean disallowIntercept)</code> -- </p></li>
                                <li><p><code>void 	requestLayout()</code> -- </p></li>
                                <li><p><code>void 	scrollBy(int x, int y)</code> -- </p></li>
                                <li><p><code>void 	scrollTo(int x, int y)</code> -- </p></li>
                                <li><p><code>void 	scrollToPosition(int position)</code> -- </p></li>
                                <li><p><code>void 	sendAccessibilityEventUnchecked(AccessibilityEvent event)</code> -- </p></li>
                                <li><p><code>void 	setAccessibilityDelegateCompat(RecyclerViewAccessibilityDelegate accessibilityDelegate)</code> -- </p></li>

                                <li><p><code>void 	setChildDrawingOrderCallback(RecyclerView.ChildDrawingOrderCallback childDrawingOrderCallback)</code> -- </p></li>
                                <li><p><code>void 	setClipToPadding(boolean clipToPadding)</code> -- </p></li>
                                <li><p><code>void 	setEdgeEffectFactory(RecyclerView.EdgeEffectFactory edgeEffectFactory)</code> -- </p></li>
                                <li><p><code>void 	setHasFixedSize(boolean hasFixedSize)</code> -- </p></li>

                                <li><p><code>void 	setItemViewCacheSize(int size)</code> -- </p></li>
                                <li><p><code>void 	setLayoutFrozen(boolean frozen)</code> -- </p></li>

                                <li><p><code>void 	setNestedScrollingEnabled(boolean enabled)</code> -- </p></li>

                                <li><p><code>void 	setPreserveFocusAfterLayout(boolean preserveFocusAfterLayout)</code> -- </p></li>
                                <li><p><code>void 	setRecycledViewPool(RecyclerView.RecycledViewPool pool)</code> -- </p></li>
                                <li><p><code>void 	setRecyclerListener(RecyclerView.RecyclerListener listener)</code> -- </p></li>
                                <li><p><code>void 	setScrollingTouchSlop(int slopConstant)</code> -- </p></li>
                                <li><p><code>void 	setViewCacheExtension(RecyclerView.ViewCacheExtension extension)</code> -- </p></li>
                                <li><p><code>void 	smoothScrollBy(int dx, int dy)</code> -- </p></li>
                                <li><p><code>void 	smoothScrollBy(int dx, int dy, Interpolator interpolator)</code> -- </p></li>
                                <li><p><code>void 	smoothScrollToPosition(int position)</code> -- </p></li>
                                <li><p><code>boolean 	startNestedScroll(int axes)</code> -- </p></li>
                                <li><p><code>boolean 	startNestedScroll(int axes, int type)</code> -- </p></li>
                                <li><p><code>void 	stopNestedScroll()</code> -- </p></li>
                                <li><p><code>void 	stopNestedScroll(int type)</code> -- </p></li>
                                <li><p><code>void 	stopScroll()</code> -- </p></li>
                                <li><p><code>void 	swapAdapter(Adapter adapter, boolean removeAndRecycleExistingViews)</code> -- </p></li>

                                <li class="group"><p><code>boolean 	checkLayoutParams(ViewGroup.LayoutParams p)</code> -- </p></li>
                                <li><p><code>void 	dispatchRestoreInstanceState(SparseArray&lt;Parcelable> container)</code> -- </p></li>
                                <li><p><code>void 	dispatchSaveInstanceState(SparseArray&lt;Parcelable> container)</code> -- </p></li>
                                <li><p><code>ViewGroup.LayoutParams 	generateDefaultLayoutParams()</code> -- </p></li>
                                <li><p><code>ViewGroup.LayoutParams 	generateLayoutParams(ViewGroup.LayoutParams p)</code> -- </p></li>
                                <li><p><code>int 	getChildDrawingOrder(int childCount, int i)</code> -- </p></li>
                                <li><p><code>void 	onAttachedToWindow()</code> -- </p></li>
                                <li><p><code>void 	onDetachedFromWindow()</code> -- </p></li>
                                <li><p><code>void 	onLayout(boolean changed, int l, int t, int r, int b)</code> -- </p></li>
                                <li><p><code>void 	onMeasure(int widthSpec, int heightSpec)</code> -- </p></li>
                                <li><p><code>boolean 	onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect)</code> -- </p></li>
                                <li><p><code>void 	onRestoreInstanceState(Parcelable state)</code> -- </p></li>
                                <li><p><code>Parcelable 	onSaveInstanceState()</code> -- </p></li>
                                <li><p><code>void 	onSizeChanged(int w, int h, int oldw, int oldh)</code> -- </p></li>
                                <li><p><code>void 	removeDetachedView(View child, boolean animate)</code> -- </p></li>
                            </ol>
                        </div>

                        <a id="RecyclerView-LayoutManager" class="offset"></a>
                        <div class="sub-item">
                            <div class="split-item">
                                <p><a href="docs/reference/android/support/v7/widget/RecyclerView.LayoutManager.html" target="_blank">RecyclerView.LayoutManager</a> </p>
								<pre class="brush: java;">
public abstract static class LayoutManager {
	public interface LayoutPrefetchRegistry {
		void addPosition(int layoutPosition, int pixelDistance);
	}

	public static class Properties {
		public int orientation;
		public int spanCount;
		public boolean reverseLayout;
		public boolean stackFromEnd;
	}
}
</pre>
								<ol>
                                    <li><p><code>void 	addDisappearingView(View child, int index)</code> -- </p></li>
                                    <li><p><code>void 	addDisappearingView(View child)</code> -- </p></li>
                                    <li><p><code>void 	addView(View child, int index)</code> -- </p></li>
                                    <li><p><code>void 	addView(View child)</code> -- </p></li>
                                    <li><p><code>void 	assertInLayoutOrScroll(String message)</code> -- </p></li>
                                    <li><p><code>void 	assertNotInLayoutOrScroll(String message)</code> -- </p></li>
                                    <li><p><code>void 	attachView(View child)</code> -- </p></li>
                                    <li><p><code>void 	attachView(View child, int index, RecyclerView.LayoutParams lp)</code> -- </p></li>
                                    <li><p><code>void 	attachView(View child, int index)</code> -- </p></li>
                                    <li><p><code>void 	calculateItemDecorationsForChild(View child, Rect outRect)</code> -- </p></li>
                                    <li><p><code>boolean 	canScrollHorizontally()</code> -- </p></li>
                                    <li><p><code>boolean 	canScrollVertically()</code> -- </p></li>
                                    <li><p><code>boolean 	checkLayoutParams(RecyclerView.LayoutParams lp)</code> -- </p></li>
                                    <li><p><code>static int 	chooseSize(int spec, int desired, int min)</code> -- </p></li>
                                    <li><p><code>void 	collectAdjacentPrefetchPositions(int dx, int dy, RecyclerView.State state, RecyclerView.LayoutManager.LayoutPrefetchRegistry layoutPrefetchRegistry)</code> -- </p></li>
                                    <li><p><code>void 	collectInitialPrefetchPositions(int adapterItemCount, RecyclerView.LayoutManager.LayoutPrefetchRegistry layoutPrefetchRegistry)</code> -- </p></li>
                                    <li><p><code>int 	computeHorizontalScrollExtent(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeHorizontalScrollOffset(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeHorizontalScrollRange(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeVerticalScrollExtent(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeVerticalScrollOffset(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeVerticalScrollRange(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	detachAndScrapAttachedViews(RecyclerView.Recycler recycler)</code> -- </p></li>
                                    <li><p><code>void 	detachAndScrapView(View child, RecyclerView.Recycler recycler)</code> -- </p></li>
                                    <li><p><code>void 	detachAndScrapViewAt(int index, RecyclerView.Recycler recycler)</code> -- </p></li>
                                    <li><p><code>void 	detachView(View child)</code> -- </p></li>
                                    <li><p><code>void 	detachViewAt(int index)</code> -- </p></li>
                                    <li><p><code>void 	endAnimation(View view)</code> -- </p></li>
                                    <li><p><code>View 	findContainingItemView(View view)</code> -- </p></li>
                                    <li><p><code>View 	findViewByPosition(int position)</code> -- </p></li>
                                    <li><p><code>abstract RecyclerView.LayoutParams 	generateDefaultLayoutParams()</code> -- </p></li>
                                    <li><p><code>RecyclerView.LayoutParams 	generateLayoutParams(Context c, AttributeSet attrs)</code> -- </p></li>
                                    <li><p><code>RecyclerView.LayoutParams 	generateLayoutParams(ViewGroup.LayoutParams lp)</code> -- </p></li>
                                    <li><p><code>int 	getBaseline()</code> -- </p></li>
                                    <li><p><code>int 	getBottomDecorationHeight(View child)</code> -- </p></li>
                                    <li><p><code>View 	getChildAt(int index)</code> -- </p></li>
                                    <li><p><code>int 	getChildCount()</code> -- </p></li>
                                    <li><p><code>static int 	getChildMeasureSpec(int parentSize, int parentMode, int padding, int childDimension, boolean canScroll)</code> -- </p></li>
                                    <li><p><code>static int 	getChildMeasureSpec(int parentSize, int padding, int childDimension, boolean canScroll)</code> -- </p></li>
                                    <li><p><code>boolean 	getClipToPadding()</code> -- </p></li>
                                    <li><p><code>int 	getColumnCountForAccessibility(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	getDecoratedBottom(View child)</code> -- </p></li>
                                    <li><p><code>void 	getDecoratedBoundsWithMargins(View view, Rect outBounds)</code> -- </p></li>
                                    <li><p><code>int 	getDecoratedLeft(View child)</code> -- </p></li>
                                    <li><p><code>int 	getDecoratedMeasuredHeight(View child)</code> -- </p></li>
                                    <li><p><code>int 	getDecoratedMeasuredWidth(View child)</code> -- </p></li>
                                    <li><p><code>int 	getDecoratedRight(View child)</code> -- </p></li>
                                    <li><p><code>int 	getDecoratedTop(View child)</code> -- </p></li>
                                    <li><p><code>View 	getFocusedChild()</code> -- </p></li>
                                    <li><p><code>int 	getHeight()</code> -- </p></li>
                                    <li><p><code>int 	getHeightMode()</code> -- </p></li>
                                    <li><p><code>int 	getItemCount()</code> -- </p></li>
                                    <li><p><code>int 	getItemViewType(View view)</code> -- </p></li>
                                    <li><p><code>int 	getLayoutDirection()</code> -- </p></li>
                                    <li><p><code>int 	getLeftDecorationWidth(View child)</code> -- </p></li>
                                    <li><p><code>int 	getMinimumHeight()</code> -- </p></li>
                                    <li><p><code>int 	getMinimumWidth()</code> -- </p></li>
                                    <li><p><code>int 	getPaddingBottom()</code> -- </p></li>
                                    <li><p><code>int 	getPaddingEnd()</code> -- </p></li>
                                    <li><p><code>int 	getPaddingLeft()</code> -- </p></li>
                                    <li><p><code>int 	getPaddingRight()</code> -- </p></li>
                                    <li><p><code>int 	getPaddingStart()</code> -- </p></li>
                                    <li><p><code>int 	getPaddingTop()</code> -- </p></li>
                                    <li><p><code>int 	getPosition(View view)</code> -- </p></li>
                                    <li><p><code>static RecyclerView.LayoutManager.Properties 	getProperties(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)</code> -- </p></li>
                                    <li><p><code>int 	getRightDecorationWidth(View child)</code> -- </p></li>
                                    <li><p><code>int 	getRowCountForAccessibility(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	getSelectionModeForAccessibility(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	getTopDecorationHeight(View child)</code> -- </p></li>
                                    <li><p><code>void 	getTransformedBoundingBox(View child, boolean includeDecorInsets, Rect out)</code> -- </p></li>
                                    <li><p><code>int 	getWidth()</code> -- </p></li>
                                    <li><p><code>int 	getWidthMode()</code> -- </p></li>
                                    <li><p><code>boolean 	hasFocus()</code> -- </p></li>
                                    <li><p><code>void 	ignoreView(View view)</code> -- </p></li>
                                    <li><p><code>boolean 	isAttachedToWindow()</code> -- </p></li>
                                    <li><p><code>boolean 	isAutoMeasureEnabled()</code> -- </p></li>
                                    <li><p><code>boolean 	isFocused()</code> -- </p></li>
                                    <li><p><code>final boolean 	isItemPrefetchEnabled()</code> -- </p></li>
                                    <li><p><code>boolean 	isLayoutHierarchical(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>boolean 	isMeasurementCacheEnabled()</code> -- </p></li>
                                    <li><p><code>boolean 	isSmoothScrolling()</code> -- </p></li>
                                    <li><p><code>boolean 	isViewPartiallyVisible(View child, boolean completelyVisible, boolean acceptEndPointInclusion)</code> -- </p></li>
                                    <li><p><code>void 	layoutDecorated(View child, int left, int top, int right, int bottom)</code> -- </p></li>
                                    <li><p><code>void 	layoutDecoratedWithMargins(View child, int left, int top, int right, int bottom)</code> -- </p></li>
                                    <li><p><code>void 	measureChild(View child, int widthUsed, int heightUsed)</code> -- </p></li>
                                    <li><p><code>void 	measureChildWithMargins(View child, int widthUsed, int heightUsed)</code> -- </p></li>
                                    <li><p><code>void 	moveView(int fromIndex, int toIndex)</code> -- </p></li>
                                    <li><p><code>void 	offsetChildrenHorizontal(int dx)</code> -- </p></li>
                                    <li><p><code>void 	offsetChildrenVertical(int dy)</code> -- </p></li>
                                    <li><p><code>void 	onAdapterChanged(Adapter oldAdapter, Adapter newAdapter)</code> -- </p></li>
                                    <li><p><code>boolean 	onAddFocusables(RecyclerView recyclerView, ArrayList&lt;View> views, int direction, int focusableMode)</code> -- </p></li>
                                    <li><p><code>void 	onAttachedToWindow(RecyclerView view)</code> -- </p></li>
                                    <li><p><code>void 	onDetachedFromWindow(RecyclerView view)</code> -- </p></li>
                                    <li><p><code>void 	onDetachedFromWindow(RecyclerView view, RecyclerView.Recycler recycler)</code> -- </p></li>
                                    <li><p><code>View 	onFocusSearchFailed(View focused, int direction, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	onInitializeAccessibilityEvent(AccessibilityEvent event)</code> -- </p></li>
                                    <li><p><code>void 	onInitializeAccessibilityEvent(RecyclerView.Recycler recycler, RecyclerView.State state, AccessibilityEvent event)</code> -- </p></li>
                                    <li><p><code>void 	onInitializeAccessibilityNodeInfo(RecyclerView.Recycler recycler, RecyclerView.State state, AccessibilityNodeInfoCompat info)</code> -- </p></li>
                                    <li><p><code>void 	onInitializeAccessibilityNodeInfoForItem(RecyclerView.Recycler recycler, RecyclerView.State state, View host, AccessibilityNodeInfoCompat info)</code> -- </p></li>
                                    <li><p><code>View 	onInterceptFocusSearch(View focused, int direction)</code> -- </p></li>
                                    <li><p><code>void 	onItemsAdded(RecyclerView recyclerView, int positionStart, int itemCount)</code> -- </p></li>
                                    <li><p><code>void 	onItemsChanged(RecyclerView recyclerView)</code> -- </p></li>
                                    <li><p><code>void 	onItemsMoved(RecyclerView recyclerView, int from, int to, int itemCount)</code> -- </p></li>
                                    <li><p><code>void 	onItemsRemoved(RecyclerView recyclerView, int positionStart, int itemCount)</code> -- </p></li>
                                    <li><p><code>void 	onItemsUpdated(RecyclerView recyclerView, int positionStart, int itemCount)</code> -- </p></li>
                                    <li><p><code>void 	onItemsUpdated(RecyclerView recyclerView, int positionStart, int itemCount, Object payload)</code> -- </p></li>
                                    <li><p><code>void 	onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	onLayoutCompleted(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	onMeasure(RecyclerView.Recycler recycler, RecyclerView.State state, int widthSpec, int heightSpec)</code> -- </p></li>
                                    <li><p><code>boolean 	onRequestChildFocus(RecyclerView parent, View child, View focused)</code> -- </p></li>
                                    <li><p><code>boolean 	onRequestChildFocus(RecyclerView parent, RecyclerView.State state, View child, View focused)</code> -- </p></li>
                                    <li><p><code>void 	onRestoreInstanceState(Parcelable state)</code> -- </p></li>
                                    <li><p><code>Parcelable 	onSaveInstanceState()</code> -- </p></li>
                                    <li><p><code>void 	onScrollStateChanged(int state)</code> -- </p></li>
                                    <li><p><code>boolean 	performAccessibilityAction(RecyclerView.Recycler recycler, RecyclerView.State state, int action, Bundle args)</code> -- </p></li>
                                    <li><p><code>boolean 	performAccessibilityActionForItem(RecyclerView.Recycler recycler, RecyclerView.State state, View view, int action, Bundle args)</code> -- </p></li>
                                    <li><p><code>void 	postOnAnimation(Runnable action)</code> -- </p></li>
                                    <li><p><code>void 	removeAllViews()</code> -- </p></li>
                                    <li><p><code>void 	removeAndRecycleAllViews(RecyclerView.Recycler recycler)</code> -- </p></li>
                                    <li><p><code>void 	removeAndRecycleView(View child, RecyclerView.Recycler recycler)</code> -- </p></li>
                                    <li><p><code>void 	removeAndRecycleViewAt(int index, RecyclerView.Recycler recycler)</code> -- </p></li>
                                    <li><p><code>boolean 	removeCallbacks(Runnable action)</code> -- </p></li>
                                    <li><p><code>void 	removeDetachedView(View child)</code> -- </p></li>
                                    <li><p><code>void 	removeView(View child)</code> -- </p></li>
                                    <li><p><code>void 	removeViewAt(int index)</code> -- </p></li>
                                    <li><p><code>boolean 	requestChildRectangleOnScreen(RecyclerView parent, View child, Rect rect, boolean immediate, boolean focusedChildVisible)</code> -- </p></li>
                                    <li><p><code>boolean 	requestChildRectangleOnScreen(RecyclerView parent, View child, Rect rect, boolean immediate)</code> -- </p></li>
                                    <li><p><code>void 	requestLayout()</code> -- </p></li>
                                    <li><p><code>void 	requestSimpleAnimationsInNextLayout()</code> -- </p></li>
                                    <li><p><code>int 	scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	scrollToPosition(int position)</code> -- </p></li>
                                    <li><p><code>int 	scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	setAutoMeasureEnabled(boolean enabled)</code> -- </p></li>
                                    <li><p><code>final void 	setItemPrefetchEnabled(boolean enabled)</code> -- </p></li>
                                    <li><p><code>void 	setMeasuredDimension(int widthSize, int heightSize)</code> -- </p></li>
                                    <li><p><code>void 	setMeasuredDimension(Rect childrenBounds, int wSpec, int hSpec)</code> -- </p></li>
                                    <li><p><code>void 	setMeasurementCacheEnabled(boolean measurementCacheEnabled)</code> -- </p></li>
                                    <li><p><code>void 	smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position)</code> -- </p></li>
                                    <li><p><code>void 	startSmoothScroll(RecyclerView.SmoothScroller smoothScroller)</code> -- </p></li>
                                    <li><p><code>void 	stopIgnoringView(View view)</code> -- </p></li>
                                    <li><p><code>boolean 	supportsPredictiveItemAnimations()</code> -- </p></li>
                                </ol>

                            </div>

                            <div class="split-item">
                                <p><b>LayoutManager 有以下子类：</b></p>
                                <p><a href="">LinearLayoutManager</a> -- 以垂直或者水平滚动列表方式显示 Item。</p>
                                <pre class="brush: java;">
public class LinearLayoutManager extends RecyclerView.LayoutManager implements
    ItemTouchHelper.ViewDropHandler, RecyclerView.SmoothScroller.ScrollVectorProvider {

    public static final int HORIZONTAL = RecyclerView.HORIZONTAL;
    public static final int VERTICAL = RecyclerView.VERTICAL;

    public static final int INVALID_OFFSET = Integer.MIN_VALUE;

    protected static class LayoutChunkResult {
        public int mConsumed;
        public boolean mFinished;
        public boolean mIgnoreConsumed;
        public boolean mFocusable;

        void resetInternal() {
            mConsumed = 0;
            mFinished = false;
            mIgnoreConsumed = false;
            mFocusable = false;
        }
    }

    public LinearLayoutManager(Context cx) {}
    public LinearLayoutManager(Context cx, int orientation, boolean reverseLayout) {}
    public LinearLayoutManager(Context cx, AttributeSet attrs, int defStyleAttr, int defStlRes) {}
}
</pre>
                                <ol>
                                    <li><p><code>void 	assertNotInLayoutOrScroll(String message)</code> -- </p></li>
                                    <li><p><code>boolean 	canScrollHorizontally()</code> -- </p></li>
                                    <li><p><code>boolean 	canScrollVertically()</code> -- </p></li>
                                    <li><p><code>void 	collectAdjacentPrefetchPositions(int dx, int dy, RecyclerView.State state, RecyclerView.LayoutManager.LayoutPrefetchRegistry layoutPrefetchRegistry)</code> -- </p></li>
                                    <li><p><code>void 	collectInitialPrefetchPositions(int adapterItemCount, RecyclerView.LayoutManager.LayoutPrefetchRegistry layoutPrefetchRegistry)</code> -- </p></li>
                                    <li><p><code>int 	computeHorizontalScrollExtent(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeHorizontalScrollOffset(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeHorizontalScrollRange(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>PointF 	computeScrollVectorForPosition(int targetPosition)</code> -- </p></li>
                                    <li><p><code>int 	computeVerticalScrollExtent(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeVerticalScrollOffset(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeVerticalScrollRange(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	findFirstCompletelyVisibleItemPosition()</code> -- </p></li>
                                    <li><p><code>int 	findFirstVisibleItemPosition()</code> -- </p></li>
                                    <li><p><code>int 	findLastCompletelyVisibleItemPosition()</code> -- </p></li>
                                    <li><p><code>int 	findLastVisibleItemPosition()</code> -- </p></li>
                                    <li><p><code>View 	findViewByPosition(int position)</code> -- </p></li>
                                    <li><p><code>RecyclerView.LayoutParams 	generateDefaultLayoutParams()</code> -- </p></li>
                                    <li><p><code>int 	getInitialPrefetchItemCount()</code> -- </p></li>
                                    <li><p><code>int 	getOrientation()</code> -- </p></li>
                                    <li><p><code>boolean 	getRecycleChildrenOnDetach()</code> -- </p></li>
                                    <li><p><code>boolean 	getReverseLayout()</code> -- </p></li>
                                    <li><p><code>boolean 	getStackFromEnd()</code> -- </p></li>
                                    <li><p><code>boolean 	isAutoMeasureEnabled()</code> -- </p></li>
                                    <li><p><code>boolean 	isSmoothScrollbarEnabled()</code> -- </p></li>
                                    <li><p><code>void 	onDetachedFromWindow(RecyclerView view, RecyclerView.Recycler recycler)</code> -- </p></li>
                                    <li><p><code>View 	onFocusSearchFailed(View focused, int focusDirection, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	onInitializeAccessibilityEvent(AccessibilityEvent event)</code> -- </p></li>
                                    <li><p><code>void 	onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	onLayoutCompleted(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	onRestoreInstanceState(Parcelable state)</code> -- </p></li>
                                    <li><p><code>Parcelable 	onSaveInstanceState()</code> -- </p></li>
                                    <li><p><code>int 	scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	scrollToPosition(int position)</code> -- </p></li>
                                    <li><p><code>void 	scrollToPositionWithOffset(int position, int offset)</code> -- </p></li>
                                    <li><p><code>int 	scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	setInitialPrefetchItemCount(int itemCount)</code> -- </p></li>
                                    <li><p><code>void 	setOrientation(int orientation)</code> -- </p></li>
                                    <li><p><code>void 	setRecycleChildrenOnDetach(boolean recycleChildrenOnDetach)</code> -- </p></li>
                                    <li><p><code>void 	setReverseLayout(boolean reverseLayout)</code> -- </p></li>
                                    <li><p><code>void 	setSmoothScrollbarEnabled(boolean enabled)</code> -- </p></li>
                                    <li><p><code>void 	setStackFromEnd(boolean stackFromEnd)</code> -- </p></li>
                                    <li><p><code>void 	smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position)</code> -- </p></li>
                                    <li><p><code>boolean 	supportsPredictiveItemAnimations()</code> -- </p></li>

                                    <li class="group"><p><code>int 	getExtraLayoutSpace(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>boolean 	isLayoutRTL()</code> -- </p></li>
                                </ol>
                            </div>
                            <div class="split-item">
                                <p><a href="">GridLayoutManager</a> -- 以网格方式显示 Item。</p>
                                <pre class="brush: java;">
public class GridLayoutManager extends LinearLayoutManager {
    public static final int DEFAULT_SPAN_COUNT = -1;

    public abstract static class SpanSizeLookup {}
    public static final class DefaultSpanSizeLookup extends SpanSizeLookup {}
    public static class LayoutParams extends RecyclerView.LayoutParams {}

    public GridLayoutManager(Context context, int spanCount) {}
    public GridLayoutManager(Context context, int spanCount, int orientation, boolean reverseLayout) {}
    public GridLayoutManager(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {}
}
</pre>
                                <ol>
                                    <li><p><code>boolean 	checkLayoutParams(RecyclerView.LayoutParams lp)</code> -- </p></li>
                                    <li><p><code>RecyclerView.LayoutParams 	generateDefaultLayoutParams()</code> -- </p></li>
                                    <li><p><code>RecyclerView.LayoutParams 	generateLayoutParams(Context c, AttributeSet attrs)</code> -- </p></li>
                                    <li><p><code>RecyclerView.LayoutParams 	generateLayoutParams(ViewGroup.LayoutParams lp)</code> -- </p></li>
                                    <li><p><code>int 	getColumnCountForAccessibility(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	getRowCountForAccessibility(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	getSpanCount()</code> -- </p></li>
                                    <li><p><code>GridLayoutManager.SpanSizeLookup 	getSpanSizeLookup()</code> -- </p></li>
                                    <li><p><code>View 	onFocusSearchFailed(View focused, int focusDirection, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	onInitializeAccessibilityNodeInfoForItem(RecyclerView.Recycler recycler, RecyclerView.State state, View host, AccessibilityNodeInfoCompat info)</code> -- </p></li>
                                    <li><p><code>void 	onItemsAdded(RecyclerView recyclerView, int positionStart, int itemCount)</code> -- </p></li>
                                    <li><p><code>void 	onItemsChanged(RecyclerView recyclerView)</code> -- </p></li>
                                    <li><p><code>void 	onItemsMoved(RecyclerView recyclerView, int from, int to, int itemCount)</code> -- </p></li>
                                    <li><p><code>void 	onItemsRemoved(RecyclerView recyclerView, int positionStart, int itemCount)</code> -- </p></li>
                                    <li><p><code>void 	onItemsUpdated(RecyclerView recyclerView, int positionStart, int itemCount, Object payload)</code> -- </p></li>
                                    <li><p><code>void 	onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	onLayoutCompleted(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	setMeasuredDimension(Rect childrenBounds, int wSpec, int hSpec)</code> -- </p></li>
                                    <li><p><code>void 	setSpanCount(int spanCount)</code> -- </p></li>
                                    <li><p><code>void 	setSpanSizeLookup(GridLayoutManager.SpanSizeLookup spanSizeLookup)</code> -- </p></li>
                                    <li><p><code>void 	setStackFromEnd(boolean stackFromEnd)</code> -- </p></li>
                                    <li><p><code>boolean 	supportsPredictiveItemAnimations()</code> -- </p></li>
                                </ol>
                            </div>

                            <div class="split-item">
                                <p><a href="">StaggeredGridLayoutManager</a> -- 在分散对齐网格中显示 Item(瀑布流)。</p>
                                <pre class="brush: java;">
public class StaggeredGridLayoutManager extends RecyclerView.LayoutManager implements
        RecyclerView.SmoothScroller.ScrollVectorProvider {

    public static final int HORIZONTAL = RecyclerView.HORIZONTAL;
    public static final int VERTICAL = RecyclerView.VERTICAL;

    public static final int GAP_HANDLING_NONE = 0;
    public static final int GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS = 2;

    public static class LayoutParams extends RecyclerView.LayoutParams {}

    public StaggeredGridLayoutManager(int spanCount, int orientation) {}
    public StaggeredGridLayoutManager(Context cx, AttributeSet attrs, int defStyleAttr, int defStyleRes) {}
}
</pre>
                                <ol>
                                    <li><p><code>void 	assertNotInLayoutOrScroll(String message)</code> -- </p></li>
                                    <li><p><code>boolean 	canScrollHorizontally()</code> -- </p></li>
                                    <li><p><code>boolean 	canScrollVertically()</code> -- </p></li>
                                    <li><p><code>boolean 	checkLayoutParams(RecyclerView.LayoutParams lp)</code> -- </p></li>
                                    <li><p><code>int 	computeHorizontalScrollExtent(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeHorizontalScrollOffset(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeHorizontalScrollRange(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>PointF 	computeScrollVectorForPosition(int targetPosition)</code> -- </p></li>
                                    <li><p><code>int 	computeVerticalScrollExtent(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeVerticalScrollOffset(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	computeVerticalScrollRange(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int[] 	findFirstCompletelyVisibleItemPositions(int[] into)</code> -- </p></li>
                                    <li><p><code>int[] 	findFirstVisibleItemPositions(int[] into)</code> -- </p></li>
                                    <li><p><code>int[] 	findLastCompletelyVisibleItemPositions(int[] into)</code> -- </p></li>
                                    <li><p><code>int[] 	findLastVisibleItemPositions(int[] into)</code> -- </p></li>
                                    <li><p><code>RecyclerView.LayoutParams 	generateDefaultLayoutParams()</code> -- </p></li>
                                    <li><p><code>RecyclerView.LayoutParams 	generateLayoutParams(Context c, AttributeSet attrs)</code> -- </p></li>
                                    <li><p><code>RecyclerView.LayoutParams 	generateLayoutParams(ViewGroup.LayoutParams lp)</code> -- </p></li>
                                    <li><p><code>int 	getColumnCountForAccessibility(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	getGapStrategy()</code> -- </p></li>
                                    <li><p><code>int 	getOrientation()</code> -- </p></li>
                                    <li><p><code>boolean 	getReverseLayout()</code> -- </p></li>
                                    <li><p><code>int 	getRowCountForAccessibility(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>int 	getSpanCount()</code> -- </p></li>
                                    <li><p><code>void 	invalidateSpanAssignments()</code> -- </p></li>
                                    <li><p><code>boolean 	isAutoMeasureEnabled()</code> -- </p></li>
                                    <li><p><code>void 	offsetChildrenHorizontal(int dx)</code> -- </p></li>
                                    <li><p><code>void 	offsetChildrenVertical(int dy)</code> -- </p></li>
                                    <li><p><code>void 	onDetachedFromWindow(RecyclerView view, RecyclerView.Recycler recycler)</code> -- </p></li>
                                    <li><p><code>View 	onFocusSearchFailed(View focused, int direction, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	onInitializeAccessibilityEvent(AccessibilityEvent event)</code> -- </p></li>
                                    <li><p><code>void 	onInitializeAccessibilityNodeInfoForItem(RecyclerView.Recycler recycler, RecyclerView.State state, View host, AccessibilityNodeInfoCompat info)</code> -- </p></li>
                                    <li><p><code>void 	onItemsAdded(RecyclerView recyclerView, int positionStart, int itemCount)</code> -- </p></li>
                                    <li><p><code>void 	onItemsChanged(RecyclerView recyclerView)</code> -- </p></li>
                                    <li><p><code>void 	onItemsMoved(RecyclerView recyclerView, int from, int to, int itemCount)</code> -- </p></li>
                                    <li><p><code>void 	onItemsRemoved(RecyclerView recyclerView, int positionStart, int itemCount)</code> -- </p></li>
                                    <li><p><code>void 	onItemsUpdated(RecyclerView recyclerView, int positionStart, int itemCount, Object payload)</code> -- </p></li>
                                    <li><p><code>void 	onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	onLayoutCompleted(RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	onRestoreInstanceState(Parcelable state)</code> -- </p></li>
                                    <li><p><code>Parcelable 	onSaveInstanceState()</code> -- </p></li>
                                    <li><p><code>void 	onScrollStateChanged(int state)</code> -- </p></li>
                                    <li><p><code>int 	scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	scrollToPosition(int position)</code> -- </p></li>
                                    <li><p><code>void 	scrollToPositionWithOffset(int position, int offset)</code> -- </p></li>
                                    <li><p><code>int 	scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state)</code> -- </p></li>
                                    <li><p><code>void 	setGapStrategy(int gapStrategy)</code> -- </p></li>
                                    <li><p><code>void 	setMeasuredDimension(Rect childrenBounds, int wSpec, int hSpec)</code> -- </p></li>
                                    <li><p><code>void 	setOrientation(int orientation)</code> -- </p></li>
                                    <li><p><code>void 	setReverseLayout(boolean reverseLayout)</code> -- </p></li>
                                    <li><p><code>void 	setSpanCount(int spanCount)</code> -- </p></li>
                                    <li><p><code>void 	smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position)</code> -- </p></li>
                                    <li><p><code>boolean 	supportsPredictiveItemAnimations()</code> -- </p></li>
                                </ol>
                            </div>

                        </div>

                        <a id="RecyclerView-Adapter" class="offset"></a>
                        <div class="sub-item">
                            <p><a href="docs/reference/android/support/v7/widget/RecyclerView.Adapter.html">RecyclerView.Adapter</a> </p>
                            <pre class="brush: java;">

</pre>
                        </div>

                        <a id="RecyclerView-ItemDecoration" class="offset"></a>
                        <div class="sub-item">
                            <p><a href="docs/reference/android/support/v7/widget/RecyclerView.ItemDecoration.html">RecyclerView.ItemDecoration</a> </p>
                            <pre class="brush: java;">

</pre>
                        </div>

                        <a id="RecyclerView-ItemAnimator" class="offset"></a>
                        <div class="sub-item">
                            <p><a href="docs/reference/android/support/v7/widget/RecyclerView.ItemAnimator.html">RecyclerView.ItemAnimator</a> </p>
                            <pre class="brush: java;">

</pre>
                        </div>

                        <a id="RecyclerView-..." class="offset"></a>
                        <div class="sub-item">
                            <p><a href="docs/reference/android/support/v7/widget/"></a> </p>
                            <pre class="brush: java;">

</pre>
                        </div>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-LinearLayout"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">LinearLayout</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="view-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title"></h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
		<a href="docs/reference/index.html" type="button"
			class="btn btn-default dropdown-toggle btn-primary" target="_blank"
			data-toggle="dropup"> DOCS </a>
		<a href="docs/guide/index.html" type="button"
		   class="btn btn-default dropdown-toggle btn-primary" target="_blank"
		   data-toggle="dropup"> GUIDE </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushXml.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
