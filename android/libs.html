<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport"
          content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="keywords" content="key1, key2"/>
    <meta name="description" content=””>
    <meta name="author" content="nate">
    <meta name="author" content="nate &lt;jiwanger@126.com&gt;">
    <link href="images/favicon.ico" rel="bookmark" type="image/x-icon"/>
    <link href="images/favicon.ico" rel="icon" type="image/x-icon"/>
    <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
    <title>NATE--笔记--LIBS</title>
    <!-- Bootstrap -->
    <link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
          rel="stylesheet">
    <!--
    <link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
    -->
    <link type="text/css" rel="stylesheet"
          href="../support/syntaxhighlighter/styles/shCoreDefault.css"/>
    <link href="../commons/css/common.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<!-- nav start -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse"
                    data-target="#bs-example-navbar-collapse-1">
                <span class="icon-bar"></span> <span class="icon-bar"></span> <span
                    class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../index.html">
                <img src="../commons/images/icon.png">
            </a>
        </div>

        <div class="collapse navbar-collapse"
             id="bs-example-navbar-collapse-1">
            <ul id="my-nav" class="nav navbar-nav">

            </ul>
        </div>
    </div>
</nav>
<!-- nav end -->


<div class="container">
    <div class="row">
        <!-- left-menu start -->
        <div class="col-md-3">
            <div class="panel panel-default"
                 style="position: fixed; top: 70px; width: 260px; height: 85%; overflow: auto; float: left;">
                <div class="panel-heading">
                    <h3 class="panel-title">LIBS</h3>
                </div>
                <div class="list-group">
                    <a href="#" class="list-group-item">简介</a>
                    <a class="list-group-item active dropup" data-toggle="collapse"
                       data-parent="#accordion" href="#libs-data" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        网络类<span class="caret pull-right" style="margin-top: 5px;"></span>
                    </a>
                    <div id="libs-data" class="panel-collapse collapse in"
                         role="tabpanel">
                        <a href="#data-OkHttp" class="list-group-item">OkHttp + Okio</a>
                        <a href="#data-Retrofit" class="list-group-item">Retrofit</a>
                        <a href="#data-Volley" class="list-group-item">Volley</a>
                    </div>
                    <a class="list-group-item active dropup" data-toggle="collapse"
                       data-parent="#accordion" href="#libs-image" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        图片类<span class="caret pull-right" style="margin-top: 5px;"></span>
                    </a>
                    <div id="libs-image" class="panel-collapse collapse in"
                         role="tabpanel">
                        <a href="#image-Picasso" class="list-group-item">Picasso</a>
                        <a href="#image-Glide" class="list-group-item">Glide</a>
                    </div>

                    <a class="list-group-item active dropup" data-toggle="collapse"
                       data-parent="#accordion" href="#libs-other" aria-expanded="true"
                       style="border-top: 1px solid #DDDDDD;">
                        其它类<span class="caret pull-right" style="margin-top: 5px;"></span>
                    </a>
                    <div id="libs-other" class="panel-collapse collapse in"
                         role="tabpanel">
                        <a href="#other-RxJava" class="list-group-item">RxJava / RxAndroid</a>
                        <a href="#other-DBFlow" class="list-group-item">DBFlow</a>
                        <a href="#other-EventBus" class="list-group-item">EventBus</a>
                        <a href="#other-ButterKnife" class="list-group-item">ButterKnife</a>

                        <a href="#other-" class="list-group-item"></a>
                    </div>
                </div>
            </div>
        </div>
        <!-- left-menu over -->
    </div>
</div>


<div class="container" style="margin-top: 70px;">
    <div class="row">
        <div class="col-md-9 col-md-push-3" style="float: left;">
            <!-- item start -->
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">简介</h3>
                </div>
                <div class="panel-body">
                    <p class="alert alert-success">
                        <b>本文收集 Android 常用的框架和各种库的使用示例。</b>
                    </p>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="data-OkHttp"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">OkHttp</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <p>Volley, Retrofit, android-async-http 帮你封装了具体的请求，线程切换以及数据转换。</p>
                        <p>而 <a href="http://square.github.io/okhttp/">OkHttp</a> 是基于 http
                            协议封装的一套请求客户端，虽然它也可以开线程，但根本上它更偏向真正的请求，跟 HttpClient, HttpUrlConnection
                            的职责是一样的。</p>
                        <p><b>OkHttp</b> 用于替代 HttpUrlConnection 和 Apache HttpClient, ANDROID API 23
                            里已移除 HttpClient。</p>
                        <p>OkHttp 是要依赖于 Okio 的，因为所有的 http 请求都是基于流的，Okio 是对流的再次封装的一个工具框架。</p>
                        <p>Retrofit, Picasso, OkHttp, Okio 都是 Square 公司开源库。</p>
                        <pre class="brush: java;">
compile 'com.squareup.okhttp3:okhttp:3.9.0'
compile 'com.squareup.io:okio:1.13.0'        // 如果只使用 Okio
                            </pre>
                    </div>

                    <div class="sub-item">
                        <p><b>Okio 简介</b></p>
                        <p>Okio 是一个包装了 <code>java.io</code> 和 <code>java.nio</code> api
                            的库，以便可以更容易的访问、存储以及处理数据。</p>
                        <p>Okio 优化了缓存，使 io 操作更高效。</p>
                        <p>Source 和 Sink 类似于 InputStream 和 OutputStream，是 io 操作的顶级接口类。Source
                            用于读，Sink 用于写。</p>
                        <p>Source 对象每次 read，Sink 对象每次 write 都需要一个 Buffer 对象，Buffer 管理着循环双向链表
                            Segment，每次读写数据都先保存在 segment 中进行缓冲，BufferedSource 和 BufferedSink
                            进行读写操作时都是间接调用 Buffer 对 Segment 的操作来完成的，整个过程层层嵌套还是有点绕的。</p>
                        <p>Segment 是链表的结构，读取和写入都是将熟据先放入 Segment 中。当新写入数据，就通过链表加入数据，我们写入的数据都是存储在
                            Segment 中的。写入数据成功后，会调用 sink 的 write 方法，而这个 write 方法，就是前面 Sink
                            类中的方法，这里获取之前存储在 Segment 中的数据，然后用 OutputStream 的 write
                            方法，将数据写入到需要写入的地方，然后调用 Segment 的 pop 方法，释放之前存储的内容。</p>
                        <p><b>Okio 使用</b></p>
                        <pre class="brush: java;">
Okio.sink(new File("***"));
Okio.sink(new FileOutputStream(new File("***")));
Okio.sink(new Socket("****",888));

Okio.source(new File("***"));
Okio.source(new FileInputStream(new File("***")));
Okio.source(new Socket("****",888));

BufferedSink bufferedSink = Okio.buffer(Okio.sink(new File("***")));
bufferedSink.writeInt(1);

BufferedSource bufferedSource = Okio.buffer(Okio.source(new File("***")));
bufferedSource.readInt();

// 网络请求中可能会用到 Gzip 功能
GzipSink gzipSink = new GzipSink(Okio.sink(new File("***")));
BufferedSink bufferedSink1 = Okio.buffer(gzipSink);
bufferedSink1.writeInt(1);
</pre>

                        <p><b>Okio 实战</b></p>
                        <ol>
                            <li><p>读写文本文件</p>
                                <pre class="brush: java;">
private String path = "./source.txt";

public void read() {
	try {
		Source mSource = Okio.source(new File(path));
		BufferedSource mBufferedSource = Okio.buffer(mSource);
		String tmp = null;
		while((tmp = mBufferedSource.readUtf8Line()) != null) {
			System.out.println(tmp);
		}
		mBufferedSource.close();
	} catch (IOException e) {
		e.printStackTrace();
	}
}

public void write() {
	try {
		String str = "This is a text file.\nThis is a test!";
		Sink mSink = Okio.sink(new File(path));
		// buffer 方法返回真实的 RealBufferedSink
		BufferedSink mBufferedSink = Okio.buffer(mSink);
		mBufferedSink.writeUtf8(str);
		mBufferedSink.flush();
		mBufferedSink.close();
	} catch (IOException e) {
		e.printStackTrace();
	}
}
</pre>
                            </li>
                            <li><p>带进度复制文件 -- 采用装饰 Forwarding 流的方式来监控和拦截一些操作</p>
                                <pre class="brush: java;">
class CountingSink extends ForwardingSink {
    private long bytesWritten = 0;
    private Listen listen;
    private File file;
    private long totalLength;

    public CountingSink(Sink delegate, File file, Listen listen) {
        super(delegate);
        this.listen = listen;
        this.file = file;
        totalLength = contentLength();
    }

    public long contentLength() {
        if (file != null) {
            return file.length();
        } else {
            return 0;
        }
    }

    @Override
    public void write(Buffer source, long byteCount) throws IOException {
        super.write(source, byteCount);
        bytesWritten += byteCount;
        listen.onProgress(bytesWritten, totalLength);
    }

    interface Listen {
        void onProgress(long bytesWritten, long contentLength);
    }
}

public void copy(String src, String target) {
    File fileSrc = new File(src);
    File fileCopy = new File(target);
    CountingSink.Listen listen = new CountingSink.Listen() {
        @Override
        public void onProgress(long bytesWritten, long contentLength) {
            float pos = bytesWritten * 1.0f / contentLength;
            System.out.println(pos);// 输出进度信息
        }
    };
    BufferedSink bufferedSink = null;
    Source source = null;
    try {
        CountingSink countingSink = new CountingSink(Okio.sink(fileCopy), fileSrc, listen);
        bufferedSink = Okio.buffer(countingSink);
        source = Okio.source(fileSrc);
        bufferedSink.writeAll(source);
        bufferedSink.flush();
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            bufferedSink.close();
            source.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</pre>
                            </li>
                        </ol>
                    </div>

                    <div class="sub-item">
                        <p><b>OkHttp</b> 使用</p>
                        <p>Java 使用</p>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <a data-toggle="collapse" data-parent="#accordion"
                                   href="#OkHttp-JavaOkHttpUtil" aria-expanded="false"
                                   class="code-header collapsed">
                                    <span class="glyphicon glyphicon-plus"></span> View Code
                                </a>
                            </div>
                            <div id="OkHttp-JavaOkHttpUtil" class="panel-collapse collapse"
                                 style="height: 0px;" aria-expanded="false">
<pre class="brush: java;">
/**
 * OkHttp 使用步骤
 * 1.构造一个 OkHttpClient(一般使用单例模式)
 * 2.构陷一个 Request 请求对象
 * 3.执行请求
 */
public class JavaOkHttpUtil {
    private static volatile JavaOkHttpUtil okHttpUtil;
    private OkHttpClient okHttpClient;

    private JavaOkHttpUtil() {
        okHttpClient = new OkHttpClient();
    }

    public static JavaOkHttpUtil getInstance() {
        if (okHttpUtil == null) {
            synchronized (JavaOkHttpUtil.class) {
                if (okHttpUtil == null) {
                    okHttpUtil = new JavaOkHttpUtil();
                }
            }
        }
        return okHttpUtil;
    }

    public ResponseBody syncGetResponseBody(String url) {
        return syncGetResponseBody(url, null);
    }

    public ResponseBody syncGetResponseBody(String url, String[][] headers) {
        Request.Builder builder = new Request.Builder();
        if (null != headers) {
            for (String[] header : headers) {
                builder.addHeader(header[0], header[1]);
            }
        }
        Request request = builder.url(url).build();
        try {
            Response response = okHttpClient.newCall(request).execute();
            if (null != response && response.isSuccessful()) {
                return response.body();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public String syncGetForString(String url) {
        return syncGetForString(url, null);
    }

    public String syncGetForString(String url, String[][] headers) {
        String result = null;
        ResponseBody body = syncGetResponseBody(url, headers);
        if (null != body) {
            try {
                result = body.string();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public ResponseBody syncPostResponseBody(String url) {
        return syncPostResponseBody(url, null, null);
    }

    public ResponseBody syncPostResponseBody(String url, String[][] headers) {
        return syncPostResponseBody(url, headers, null);
    }

    public ResponseBody syncPostResponseBody(String url, HashMap&lt;String, String> args) {
        return syncPostResponseBody(url, null, args);
    }

    public ResponseBody syncPostResponseBody(String url, String[][] headers, HashMap&lt;String, String> args) {
        Request.Builder builder = new Request.Builder();
        if (null != headers) {
            for (String[] header : headers) {
                builder.addHeader(header[0], header[1]);
            }
        }
        FormBody.Builder bodyBuilder = new FormBody.Builder();
        if (null != args) {
            for (Map.Entry&lt;String, String> entry : args.entrySet()) {
                bodyBuilder.add(entry.getKey(), entry.getValue());
            }
        }
        Request request = builder.url(url).post(bodyBuilder.build()).build();
        try {
            Response response = okHttpClient.newCall(request).execute();
            if (null != response && response.isSuccessful()) {
                return response.body();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public String syncPostForString(String url) {
        return syncPostForString(url, null, null);
    }

    public String syncPostForString(String url, String[][] headers) {
        return syncPostForString(url, headers, null);
    }

    public String syncPostForString(String url, HashMap&lt;String, String> args) {
        return syncPostForString(url, null, args);
    }

    public String syncPostForString(String url, String[][] headers, HashMap&lt;String, String> args) {
        String result = null;
        ResponseBody body = syncPostResponseBody(url, headers, args);
        if (null != body) {
            try {
                result = body.string();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public void aysncGetResponseBody(String url, final GeneralCallBack callback) {
        aysncGetResponseBody(url, null , callback);
    }

    public void aysncGetResponseBody(String url, String[][] headers, final GeneralCallBack callback) {
        Request.Builder builder = new Request.Builder();
        if (null != headers) {
            for (String[] header : headers) {
                builder.addHeader(header[0], header[1]);
            }
        }
        Request request = builder.url(url).build();
        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure();
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                if(null != response && response.isSuccessful()) {
                    callback.onSucess(response.body());
                }
            }
        });
    }

    public void aysncPostResponseBody(String url, String[][] headers, final GeneralCallBack callback) {
        aysncPostResponseBody(url, headers, null, callback);
    }

    public void aysncPostResponseBody(String url, HashMap&lt;String, String> args, final GeneralCallBack callback) {
        aysncPostResponseBody(url, null, args, callback);
    }

    public void aysncPostResponseBody(String url, String[][] headers, HashMap&lt;String, String> args, final GeneralCallBack callback) {
        Request.Builder builder = new Request.Builder();
        if (null != headers) {
            for (String[] header : headers) {
                builder.addHeader(header[0], header[1]);
            }
        }
        FormBody.Builder bodyBuilder = new FormBody.Builder();
        if (null != args) {
            for (Map.Entry&lt;String, String> entry : args.entrySet()) {
                bodyBuilder.add(entry.getKey(), entry.getValue());
            }
        }
        Request request = builder.url(url).post(bodyBuilder.build()).build();
        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure();
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                if(null != response && response.isSuccessful()) {
                    callback.onSucess(response.body());
                }
            }
        });
    }

    public void asyncGetForString(String url, StringCallBack callBack) {
        aysncGetResponseBody(url, null, callBack);
    }

    public void asyncGetForString(String url, String[][] headers, StringCallBack callBack) {
        aysncGetResponseBody(url, headers, callBack);
    }

    public void asyncPostForString(String url, StringCallBack callBack) {
        aysncPostResponseBody(url, null, null, callBack);
    }

    public void asyncPostForString(String url, String[][] headers, StringCallBack callBack) {
        aysncPostResponseBody(url, headers, null, callBack);
    }

    public void asyncPostForString(String url, HashMap&lt;String, String> args, StringCallBack callBack) {
        aysncPostResponseBody(url, null, args, callBack);
    }

    public void asyncPostForString(String url, String[][] headers, HashMap&lt;String, String> args, StringCallBack callBack) {
        aysncPostResponseBody(url, headers, args, callBack);
    }

    public static abstract class GeneralCallBack {
        public void onFailure(){}

        public void onSucess(ResponseBody body){}

        public abstract void onFailureInMainThread();
    }

    public static abstract class StringCallBack extends GeneralCallBack {
        @Override
        public void onSucess(ResponseBody body) {
            if(null != body) {
                try {
                    onResponse(body.string());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            } else {
                onFailure();
            }
        }

        public abstract void onResponse(String result);
    }
}
</pre>
                            </div>
                        </div>

                        <p>Android 使用 -- 相对于 Java 代码，Android 使用加了线程切换。</p>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <a data-toggle="collapse" data-parent="#accordion"
                                   href="#OkHttp-AndroidOkHttpUtil" aria-expanded="false"
                                   class="code-header collapsed">
                                    <span class="glyphicon glyphicon-plus"></span> View Code
                                </a>
                            </div>
                            <div id="OkHttp-AndroidOkHttpUtil" class="panel-collapse collapse"
                                 style="height: 0px;" aria-expanded="false">
                                    <pre class="brush: java;">
public class AndroidOkHttpUtil {
    private static volatile AndroidOkHttpUtil okHttpUtil;
    private OkHttpClient okHttpClient;
    private static Handler mHandler;
    private static final int BODY_REQUEST_SUCCESS = 0x0;
    private static final int STRING_REQUEST_SUCCESS = 0x2;
    private static final int REQUEST_FAILD = 0x01;
    private Interceptor mAppInterceptor;
    private Interceptor mNetworkInterceptor;


    private Interceptor appInterceptor = new Interceptor() {
        @Override
        public Response intercept(Chain chain) throws IOException {
            return null == mAppInterceptor ? chain.proceed(chain.request()) : mAppInterceptor.intercept(chain);
        }
    };

    private Interceptor networkInterceptor = new Interceptor() {
        @Override
        public Response intercept(Chain chain) throws IOException {
            return null == mNetworkInterceptor ? chain.proceed(chain.request()) : mNetworkInterceptor.intercept(chain);
        }
    };

    @SuppressLint("HandlerLeak")
    private AndroidOkHttpUtil() {
        okHttpClient = new OkHttpClient.Builder()
            .addInterceptor(appInterceptor)
            .addNetworkInterceptor(networkInterceptor)
            .build();
        mHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                switch (msg.what) {
                    case BODY_REQUEST_SUCCESS:
                        HashMap&lt;String, Object> map = (HashMap&lt;String, Object>) msg.obj;
                        BitmapCallBack callBack = (BitmapCallBack) map.get("call");
                        Bitmap response = (Bitmap) map.get("response");
                        callBack.onResponseInMainThread(response);
                        break;
                    case STRING_REQUEST_SUCCESS:
                        HashMap&lt;String, Object> map2 = (HashMap&lt;String, Object>) msg.obj;
                        StringCallBack strCallBack = (StringCallBack) map2.get("call");
                        String strResponse = (String) map2.get("response");
                        strCallBack.onResponseInMainThread(strResponse);
                        break;
                    case REQUEST_FAILD:
                        GeneralCallBack back = (GeneralCallBack)msg.obj;
                        back.onFailureInMainThread();
                        break;
                }
            }
        };
    }

    public static AndroidOkHttpUtil getInstance() {
        if (okHttpUtil == null) {
            synchronized (AndroidOkHttpUtil.class) {
                if (okHttpUtil == null) {
                    okHttpUtil = new AndroidOkHttpUtil();
                }
            }
        }
        return okHttpUtil;
    }

    public void setAppInterceptor(Interceptor appInterceptor) {
        this.mAppInterceptor = appInterceptor;
    }

    public void setNetworkInterceptor(Interceptor networkInterceptor) {
        this.mNetworkInterceptor = networkInterceptor;
    }

    public ResponseBody syncGetResponseBody(String url) {
        return syncGetResponseBody(url, null);
    }

    public ResponseBody syncGetResponseBody(String url, String[][] headers) {
        Request.Builder builder = new Request.Builder();
        if (null != headers) {
            for (String[] header : headers) {
                builder.addHeader(header[0], header[1]);
            }
        }
        Request request = builder.url(url).build();
        try {
            Response response = okHttpClient.newCall(request).execute();
            if (null != response && response.isSuccessful()) {
                return response.body();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public String syncGetForString(String url) {
        return syncGetForString(url, null);
    }

    public String syncGetForString(String url, String[][] headers) {
        String result = null;
        ResponseBody body = syncGetResponseBody(url, headers);
        if (null != body) {
            try {
                result = body.string();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public ResponseBody syncPostResponseBody(String url) {
        return syncPostResponseBody(url, null, null);
    }

    public ResponseBody syncPostResponseBody(String url, String[][] headers) {
        return syncPostResponseBody(url, headers, null);
    }

    public ResponseBody syncPostResponseBody(String url, HashMap&lt;String, String> args) {
        return syncPostResponseBody(url, null, args);
    }

    public ResponseBody syncPostResponseBody(String url, String[][] headers, HashMap&lt;String, String> args) {
        Request.Builder builder = new Request.Builder();
        if (null != headers) {
            for (String[] header : headers) {
                builder.addHeader(header[0], header[1]);
            }
        }
        FormBody.Builder bodyBuilder = new FormBody.Builder();
        if (null != args) {
            for (Map.Entry&lt;String, String> entry : args.entrySet()) {
                bodyBuilder.add(entry.getKey(), entry.getValue());
            }
        }
        Request request = builder.url(url).post(bodyBuilder.build()).build();
        try {
            Response response = okHttpClient.newCall(request).execute();
            if (null != response && response.isSuccessful()) {
                return response.body();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public String syncPostForString(String url) {
        return syncPostForString(url, null, null);
    }

    public String syncPostForString(String url, String[][] headers) {
        return syncPostForString(url, headers, null);
    }

    public String syncPostForString(String url, HashMap&lt;String, String> args) {
        return syncPostForString(url, null, args);
    }

    public String syncPostForString(String url, String[][] headers, HashMap&lt;<String, String> args) {
        String result = null;
        ResponseBody body = syncPostResponseBody(url, headers, args);
        if (null != body) {
            try {
                result = body.string();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public void aysncGetResponseBody(String url, final GeneralCallBack callback) {
        aysncGetResponseBody(url, null , callback);
    }

    public void aysncGetResponseBody(String url, String[][] headers, final GeneralCallBack callback) {
        Request.Builder builder = new Request.Builder();
        if (null != headers) {
            for (String[] header : headers) {
                builder.addHeader(header[0], header[1]);
            }
        }
        Request request = builder.url(url).build();
        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure();
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                if(null != response && response.isSuccessful()) {
                    callback.onSucess(response.body());
                }
            }
        });
    }

    public void aysncPosResponseBody(String url, final BitmapCallBack callback) {
        aysncPostResponseBody(url, null, null, callback);
    }

    public void aysncPostResponseBody(String url, String[][] headers, final GeneralCallBack callback) {
        aysncPostResponseBody(url, headers, null, callback);
    }

    public void aysncPostResponseBody(String url, HashMap&lt;String, String> args, final GeneralCallBack callback) {
        aysncPostResponseBody(url, null, args, callback);
    }

    public void aysncPostResponseBody(String url, String[][] headers, HashMap&lt;String, String> args, final GeneralCallBack callback) {
        Request.Builder builder = new Request.Builder();
        if (null != headers) {
            for (String[] header : headers) {
                builder.addHeader(header[0], header[1]);
            }
        }
        FormBody.Builder bodyBuilder = new FormBody.Builder();
        if (null != args) {
            for (Map.Entry&lt;String, String> entry : args.entrySet()) {
                bodyBuilder.add(entry.getKey(), entry.getValue());
            }
        }
        Request request = builder.url(url).post(bodyBuilder.build()).build();
        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure();
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                if(null != response && response.isSuccessful()) {
                    callback.onSucess(response.body());
                }
            }
        });
    }

    public void asyncGetForString(String url, StringCallBack callBack) {
        aysncGetResponseBody(url, null, callBack);
    }

    public void asyncGetForString(String url, String[][] headers, StringCallBack callBack) {
        aysncGetResponseBody(url, headers, callBack);
    }

    public void asyncPostForString(String url, StringCallBack callBack) {
        aysncPostResponseBody(url, null, null, callBack);
    }

    public void asyncPostForString(String url, String[][] headers, StringCallBack callBack) {
        aysncPostResponseBody(url, headers, null, callBack);
    }

    public void asyncPostForString(String url, HashMap&lt;String, String> args, StringCallBack callBack) {
        aysncPostResponseBody(url, null, args, callBack);
    }

    public void asyncPostForString(String url, String[][] headers, HashMap&lt;String, String> args, StringCallBack callBack) {
        aysncPostResponseBody(url, headers, args, callBack);
    }

    public static abstract class GeneralCallBack {
        public void onFailure(){}

        public void onSucess(ResponseBody body){}

        public abstract void onFailureInMainThread();
    }

    public static abstract class BitmapCallBack extends GeneralCallBack {
        @Override
        public void onSucess(ResponseBody body) {
            if(null != body) {
                InputStream in = body.byteStream();
                HashMap&lt;String, Object> map = new HashMap<>();
                map.put("call", this);
                map.put("response", BitmapFactory.decodeStream(in));
                mHandler.obtainMessage(BODY_REQUEST_SUCCESS, map).sendToTarget();
            } else {
                onFailure();
                mHandler.obtainMessage(REQUEST_FAILD, this).sendToTarget();
            }
        }

        public abstract void onResponseInMainThread(Bitmap bitmap);
    }

    public static abstract class StringCallBack extends GeneralCallBack {
        public void onSucess(ResponseBody body) {
            if(null != body) {
                try {
                    String result = body.string();
                    onResponse(result);
                    HashMap&lt;String, Object> map = new HashMap<>();
                    map.put("call", this);
                    map.put("response", result);
                    mHandler.obtainMessage(STRING_REQUEST_SUCCESS, map).sendToTarget();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            } else {
                onFailure();
                mHandler.obtainMessage(REQUEST_FAILD, this).sendToTarget();
            }
        }

        public void onResponse(String result){}

        public abstract void onResponseInMainThread(String result);
    }
}
</pre>
                            </div>


                        </div>
                    </div>

                    <div class="sub-item">
                        <p><b>OkHttp 拦截器</b></p>
                        <ul>
                            <li><p>拦截器可以一次性对所有的请求和返回值进行修改；</p></li>
                            <li><p>拦截器可以一次性对请求的参数和返回的结果进行编码；</p></li>
                            <li><p>拦截器可以对所有的请求做统一的日志记录；</p></li>
                            <li><p>其他需要对请求和返回进行统一处理的需求。</p></li>
                        </ul>
                        <p>OkHttp 中的拦截器分 2 个：<b>APP 层面的拦截器</b>和<b>网络请求层面的拦截器</b>，如下图：</p>
                        <p>
                            <img src="images/okhttp-interceptor.png"
                                 class="img-responsive center-block" width="400px">
                        </p>
                        <p>拦截器的调用过程：(除了红色圈出的拦截器之外都是系统提供的拦截器，这整个过程是递归的执行过程)</p>
                        <p>
                            <img src="images/okhttp-interceptors.png"
                                 class="img-responsive center-block" width="600px">
                        </p>
                        <pre class="brush: java;">
OkHttpClient okHttpClient = new OkHttpClient.Builder()
    .addInterceptor(new LoggingInterceptor())       // 添加应用层面的拦截器
    .addNetworkInterceptor(networkInterceptor)      // 添加网络请求层面的拦截器
    .build();

/** 使用拦截器记录日志 */
class LoggingInterceptor implements Interceptor {
    @Override
    public Response intercept(Interceptor.Chain chain) throws IOException {
        Request request = chain.request();

        long t1 = System.nanoTime();
        logger.info(String.format("Sending request %s on %s%n%s",
            request.url(), chain.connection(), request.headers()));

        Response response = chain.proceed(request);

        long t2 = System.nanoTime();
        logger.info(String.format("Received response for %s in %.1fms%n%s",
            response.request().url(), (t2 - t1) / 1e6d, response.headers()));

        return response;
      }
}
</pre>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="data-Retrofit"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Retrofit</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <p><a href="http://square.github.io/retrofit/">Retrofit</a> 一个针对 Android 和
                            Java 类型安全的 http 客户端。</p>
                        <p>Retrofit, Picasso, OkHttp, Okio 都是 Square 公司开源库。其中 Retrofit 和 Picasso 依赖
                            OkHttp, OkHttp 依赖 Okio。</p>
                        <pre class="brush: java;">compile 'com.squareup.retrofit2:retrofit:2.3.0'</pre>
                        <p>Retrofit 使用基本步骤：</p>
                        <pre class="brush: java;">
/** 1.构建 Retrofit 对象实例
 * BASE_URL 为公用，以 '/' 结尾，如： http://api.lesson1234.com:8080/ilesson-data-manager/
 */
Retrofit retrofit = new Retrofit.Builder()
                .client(mOkHttpClient); // 可构建自己的 OkHttpClient, 推荐使用 Singleton
                .baseUrl(BASE_URL)
                .build();
/** 2.定义访问接口
 * 这里使用 GET 方法访问，最终的 URL 为：
 * http://api.lesson1234.com:8080/ilesson-data-manager/OfflineExtraServlet？bid=3&cp=1
 */
public interface BlogService {
    @GET("OfflineExtraServlet")
    Call&lt;ResponseBody> getBlog(@Query("bid") int bid, @Query("cp") int cp);
}

/** 3.调用接口, 在 Android 中使用时，Retrofit 帮我们将回调切换到了主线程 */
BlogService service = retrofit.create(BlogService.class);
Call&lt;ResponseBody> call = service.getBlog(3, 1); // 传入 bid 和 cp
// 用法和 OkHttp 的 call 如出一辙, 不同的是:如果是 Android 系统回调方法执行在主线程
call.enqueue(new Callback&lt;ResponseBody>() {
    @Override
    public void onResponse(Call&lt;ResponseBody> call, Response&lt;ResponseBody> response) {
        // 这里拿到 Response 对象
    }

    @Override
    public void onFailure(Call&lt;ResponseBody> call, Throwable t) {
        t.printStackTrace();
    }
});
</pre>
                    </div>

                    <div class="sub-item">
                        <p><b>Retrofit 注解</b> -- 共 22 个注解</p>
                        <ul>
                            <li><p>请求方法类 -- <code>GET</code>, <code>POST</code>, <code>HEAD</code>,
                                <code>OPTIONS</code>, <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code>,
                                <code>HTTP</code></p>
                                <p>分别对应 HTTP 的请求方法，接收一个字符串表示接口路径，与 baseUrl 组成完整的 Url，可以使用变量，如 {id}
                                    ，并使用 @Path("id") 注解为 {id} 提供值。</p>
                                <pre class="brush: java;">
public interface BlogService{
    @GET("BlogServlet")     // Get 方法, 参数可以用 Query 传入
    Call&lt;ResponseBody> getBlog(@Query("bid") int id);

    @GET("blog/{id}")       // 路径由 Path 传入
    Call&lt;ResponseBody> getBlog(@Path("id") int id);

    @POST("BlogServlet")    // Post 方法
    Call&lt;ResponseBody> getBlog(@Query("id") int id);

    // 可用于替代前面的 7 个，及其他扩展方法
    @HTTP(method = "get", path = "blog/{id}", hasBody = false)
    Call&lt;ResponseBody> getBlog(@Path("id") int id);
}
</pre>
                            </li>
                            <li><p>标记类 -- <code>FormUrlEncoded</code>, <code>Multipart</code>,
                                <code>Streaming</code>
                            </p>
                                <pre class="brush: java;">
/** FormUrlEncoded -- 请求体是 From 表单
 *  Multipart -- 请求体是支持文件上传的 From 表单
 *  Streaming -- 响应体的数据用流的形式返回
 */
</pre>
                            </li>
                            <li><p>参数类 -- <code>Headers</code>, <code>Header</code>,
                                <code>Body</code>, <code>Field</code>, <code>FieldMap</code>,
                                <code>Part</code>, <code>PartMap</code>, <code>Path</code>, <code>Query</code>,
                                <code>QueryMap</code>, <code>Url</code>
                            </p>
                                <pre class="brush: java;">
/** Headers -- 添加请求头，作用于方法
 *  Header -- 添加不固定的 Header， 作用于方法参数
 *  Body -- 非表单请求体
 *  Field -- 表单字段，与 FieldMap、FormUrlEncoded 配合, 支持数组和实现了 Iterable 接口的类型
 *  FieldMap -- 表单字段，与 Field、FormUrlEncoded 配合；接受 Map<&lt;String, String> 类型
 *  Part -- 表单字段，与 PartMap 配合，适合文件上传情况, 支持数组和实现了 Iterable 接口的类型
 *  PartMap -- 表单字段，与 Part 配合，适合文件上传情况；默认接受 Map&lt;String, RequestBody> 类型
 *  Path -- 用于 URL 路径
 *  Query -- 用于 URL 参数, 支持数组和实现了 Iterable 接口的类型
 *  QueryMap -- 用于 URL 参数， 接受 Map<&lt;String, String> 类型
 *  Url -- 支持的类型有 okhttp3.HttpUrl, String, java.net.URI, android.net.Uri
 */
@Headers("Cache-Control: max-age=640000")
@GET("widget/list")
Call&lt;ResponseBody> widgetList();

@GET("user")
Call&lt;User> getUser(@Header("Authorization") String authorization)

@POST("users/new")
Call&lt;User> createUser(@Body User user);

@FormUrlEncoded
@POST("v1/login")
Call&lt;ResponseBody> userLogin(@Field("phone") String phone, @Field("password") String password);
</pre>
                            </li>
                        </ul>

                    </div>

                    <div class="sub-item">
                        <p><b>Gson 与 Converter</b></p>
                        <p>默认情况下 Retrofit 只支持将 HTTP 的响应体转换换为 <code>ResponseBody</code>，而 <code>Converter</code>
                            就是 Retrofit 为我们提供用于将 <code>ResponseBody</code> 转换为我们想要的类型。</p>
                        <pre class="brush: java;">
/** 1. 引入 Retrofit 的 Gson 支持: */
compile 'com.squareup.retrofit2:converter-gson:2.3.0'
// 同时还有其他的转换器，参见官方网站，下面这个是 xml 转换器
compile 'com.squareup.retrofit2:converter-simplexml:2.3.0'

/** 2. 实体类 */
class Error {
    int errorCode;
    String errorString;
}

/** 3. 构建接口 */
public interface BlogService {
    @GET("OfflineExtraServlet")
    Call&lt;Error> getContent(@Query("bid") int bid, @Query("cp") int cp);
}

/** 4. 调用接口，构建时要将 ConverterFactory 加入 */
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(BASE_URL)
    .addConverterFactory(GsonConverterFactory.create())
    .build();

BlogService service = retrofit.create(BlogService.class);
Call&lt;Error> call = service.getContent(3, 1);
call.enqueue(new Callback&lt;Error>() {
    @Override
    public void onResponse(Call&lt;Error> call, Response&lt;Error> response) {
        // resonpse.body() 自动转换为 Error 类型
    }

    @Override
    public void onFailure(Call&lt;Error> call, Throwable t) {

    }
});
</pre>
                        <p>自定义 Converter</p>
                        <pre class="brush: java;">
public static class StringConverterFactory extends Converter.Factory {
    public static final StringConverterFactory INSTANCE = new StringConverterFactory();
    public static StringConverterFactory create() {
        return INSTANCE;
    }

    // 我们只关实现从 ResponseBody 到 String 的转换，所以其它方法可不覆盖
    @Override
    public Converter&lt;ResponseBody, ?> responseBodyConverter(
                                Type type, Annotation[] annotations, Retrofit retrofit) {
        if (type == String.class) {
            return StringConverter.INSTANCE;
        }
        // 其它类型我们不处理，返回 null 就行
        return null;
    }
}

/** 如果有多个 ConverterFactory 都支持同一种类型，那么就是只有第一个才会被使用 */
Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(BASE_URL)
         // 如是有 Gson 这类的Converter 一定要放在其它前面
         .addConverterFactory(StringConverterFactory.create())
         .addConverterFactory(GsonConverterFactory.create())
         .build();
</pre>
                    </div>

                    <div class="sub-item">
                        <p><b>RxJava 与 CallAdapter</b></p>
                        <p><b>RxJava</b> 主要用于观察者模式和异步线程切换，具体介绍查看： <a href="#other-RxJava">RxJava</a>
                        </p>
                        <pre class="brush: java;">
/** 1. 引入 Retrofit 的 RxJava2 支持 */
compile 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'

/** 2. 实体类 */
class Error {
    int errorCode;
    String errorString;
}

/** 3. 构建接口 */
public interface BlogService {
    @GET("OfflineExtraServlet")
    Observable&lt;Error> getContent(@Query("bid") int bid, @Query("cp") int cp);
}

/** 4. 调用接口，构建时要将 CallAdapterFactory 加入 */
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(BASE_URL)
    .addConverterFactory(GsonConverterFactory.create())
    .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) // RxJava2 加入
    .build();

BlogService service = retrofit.create(BlogService.class);
service.getContent(3, 1)
    .observeOn(Schedulers.io())     // Observer 的 onNext 在子线程执行，详情看 RxJava
    .subscribe(new Observer&lt;Error>() {
        @Override
        public void onSubscribe(Disposable d) {
            System.out.println("onSubscribe:" + Thread.currentThread().getId());
        }

        @Override
        public void onNext(Error error) {
            System.out.println(Thread.currentThread().getId() + ":" + error.errorString);
        }

        @Override
        public void onError(Throwable e) {

        }

        @Override
        public void onComplete() {
            System.out.println("onComplete");
        }
    });
</pre>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="data-Volley"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Volley</h3>
                </div>
                <div class="panel-body">
                    <p>Volley 项目主页：<a href="https://github.com/mcxiaoke/android-volley">Volley</a>
                    </p>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="image-Picasso"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Picasso</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <p><a href="https://github.com/square/picasso/" target="_blank">Picasso</a>
                            是一款优秀的 Android
                            图片加载框架。
                        </p>
                        <p>Retrofit, Picasso, OkHttp, Okio 都是 Square 公司开源库。</p>

                        <pre class="brush: java;">compile 'com.squareup.picasso:picasso:2.5.2'</pre>
                        <p>Picasso 简单使用</p>
                        <pre class="brush: java;">
/** 1.传统的ImageVIew设置图片 */
Picasso.with(context).load(url).placeholder(R.drawable.tab_item_bg).into(imageView);

/** 2.自定义的布局设置图片，target 是指实现了 Target 接口的自定义 View */
Picasso.with(context).load(url).placeholder(R.drawable.tab_item_bg).into(target);

/** 3.自动设置图片宽高像素的大小，如果宽度或高度为 0, Picasso 会按原图比例拉伸 */
Picasso.with(context).load(url).resize(50, 0).into(imageView)
                    </pre>
                        <p>Picasso 调式模式</p>
                        <pre class="brush: java;">
/** 可以开启调试模式:
 * 左上角是红色的表示从网络上加载
 * 蓝色表示从本地(磁盘)中加载
 * 绿色表示从内存中加载
 */
Picasso.with(context).setIndicatorsEnabled(true);
</pre>
                    </div>

                    <div class="sub-item">
                        <p><b>Picasso 原理分析</b></p>
                        <p>首先来认识几个类:</p>
                        <ul>
                            <li><p><code>RequestHandler</code> --
                                抽象类，由不同的子类来实现不同来源的图片的获取与加载，<code></code></p>
                                <pre class="brush: java;">
/** 最重要的就是这个方法，都是调用子类的这个方法加载 Bitmap */
public abstract Result load(Request request, int networkPolicy) throws IOException;

/** RequestHandler 的常见子类：
 * AssetRequestHandler -- 加载 asset 里的图片
 * FileRequestHandler -- 加载硬盘里的图片
 * ResourceRequestHandler -- 加载资源图片
 * NetworkRequestHandler -- 加载网络图片
 * ...
 */

/** 在 Picasso 构造方法中，加入了上面所有的 RequestHandler 到 List&lt;RequestHandler> requestHandlers; 中，
 * 最后在 BitmapHunter.forRequest() 方法中来判断该使用哪一个 RequestHandler
 */
                                </pre>
                            </li>
                            <li><p><code>BitmapHunter</code> -- 是一个 Runnable 的子类，用来进行 Bitmap
                                的获取，处理，然后执行分发器 (Dispatcher)的回调处理。</p></li>
                            <li><p><code>PicassoDrawable</code> -- 实现了引入图片渐变功能和 Debug 状态的标识的
                                Drawable，用来在最后 Bitmap 转换成 PicassoDrawable，然后设置给
                                ImageView，可以根据图片的来源可以在图片的左上角显示一个不同颜色的三角形色块。</p></li>
                            <li><p><code>Action</code> --
                                代表了一个具体的加载任务，主要用于图片加载后的结果回调，有两个抽象方法，complete 和 error，并保存了每个请求的各种信息。
                            </p>
                                <pre class="brush: java;">
/** 最终要调用这个方法来将 Bitmap 设置到 ImageView 中 */
abstract void complete(Bitmap result, Picasso.LoadedFrom from);

/** 在 into() 方法就决定了要使用的 Action 类型:
 * ImageViewAction -- 最常用的 Action，主要用来给 ImageView 加载图片
 * TargetAction -- 一般在自定义 View 或者 ViewHolder 中用来加载图片,需要实现 Target 接口
 * RemoteViewsAction -- 用来更新远程图片（notification等）的抽象类
 * FetchAction -- 当不需要 ImageView 来安置 Bitmap 时的异步请求，通常用来预热缓存，RequestCreator.fetch()
 * GetAction -- 同步执行请求时使用，RequestCreator.get()
 */
</pre>
                            </li>
                        </ul>
                        <p>从初始化到从网络上加载一张图片，最后设置到 ImageView 中。<br/>就是执行：<code>Picasso.with(content).load(url).into(image);</code>
                            所发生的事：</p>
                        <ol>
                            <li><code>.with(Context)</code> -- Picasso 对象的创建
                                <pre class="brush: java;">
/** 单例模式构建 */
public static Picasso with(Context context) {
    if (singleton == null) {
        synchronized (Picasso.class) {
            if (singleton == null) {
                singleton = new Builder(context).build();
            }
        }
    }
    return singleton;
}

public Picasso build() {
    Context context = this.context;
    // 初始化下载器，先尝试使用 OkHttpClient，如果不存在使用 HttpURLConnection
    if (downloader == null) {
        downloader = Utils.createDefaultDownloader(context);
    }

    /* 初始化内存缓存 LruCache， 有一个 LinkedHashMap&lt;String, Bitmap>，用键值对保存 Bitmap
     * 初始化的最大值为： 1024 * 1024 * memoryClass / 7;  (memoryClass 为系统给应用分配的最大内存，单位 MB)
     */
    if (cache == null) {
        cache = new LruCache(context);
    }
    // 初始化线程池，核心线程数为 3，使用优先队列
    if (service == null) {
        service = new PicassoExecutorService();
    }
    // 初始化前置处理器，在请求发出去之前执行，类似于拦截器
    if (transformer == null) {
        transformer = RequestTransformer.IDENTITY;
    }
    // 初始化状态控制类，用来发送各种消息，例如查找图片缓存的结果（击中/未击中），下载完成等
    Stats stats = new Stats(cache);
    // 初始化分发器，用来分发任务
    Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);

    return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,
      defaultBitmapConfig, indicatorsEnabled, loggingEnabled);
}
</pre>
                            </li>
                            <li><code>.load(String)</code> -- 加载 url，创建并返回一个图片下载请求的构建器
                                RequestCreator
                                <pre class="brush: java;">
RequestCreator(Picasso picasso, Uri uri, int resourceId) {
    if (picasso.shutdown) {
      throw new IllegalStateException(
            "Picasso instance already shut down. Cannot submit new requests.");
    }
    this.picasso = picasso;
    this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);
}

                                </pre>
                            </li>
                            <li><code>.into(ImageView)</code> -- 修改图片的尺寸，填充图片进 ImageView
                                <pre class="brush: java;">
public void into(ImageView target, Callback callback) {
    long started = System.nanoTime();
    checkMain();    // 检查是否在主线程，如果不是，抛出异常

    if (target == null) {
        throw new IllegalArgumentException("Target must not be null.");
    }

    if (!data.hasImage()) { // 如果设置 url 或 resId 则取消请求
        picasso.cancelRequest(target);
        if (setPlaceholder) { // 设置默认图
            setPlaceholder(target, getPlaceholderDrawable());
        }
        return;
    }

    /** 仅有 fit() 方法会修改 deferred 为 true，该方法只能由开发者显式调用，因此下面的代码默认是不会执行的，
     * fit() -- 尝试调整图片的大小让其正好适合 ImageView 时
     */
    if (deferred) {
        if (data.hasSize()) { // 判断 ImageView 大小，即如果 ImageView 已经渲染完成，则无法改变大小
            throw new IllegalStateException("Fit cannot be used with resize.");
        }
        int width = target.getWidth();
        int height = target.getHeight();
        if (width == 0 || height == 0) {
            if (setPlaceholder) {   // 设置默认图
              setPlaceholder(target, getPlaceholderDrawable());
            }
            picasso.defer(target, new DeferredRequestCreator(this, target, callback));
            return;
        }
        data.resize(width, height);
    }

    Request request = createRequest(started);
    // 根据请求的 URL，图片的处理等参数创建一个字符串 Key
    String requestKey = createKey(request);
    // 缓存策略，是否应该从内存中读取
    if (shouldReadFromMemoryCache(memoryPolicy)) {
        // 从内存的快速读取 Bitmap
        Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);
        if (bitmap != null) { // 如果缓存中已存在，则取消请求并直接设置给 ImageView
            picasso.cancelRequest(target);
            setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);
            if (picasso.loggingEnabled) {
                log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + MEMORY);
            }
            if (callback != null) {
                callback.onSuccess();
            }
            return;
        }
    }

    // 设置默认图
    if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable());
    }
    // 创建 ImageViewAction 对象，后面会用到
    Action action =
        new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,
            errorDrawable, requestKey, tag, callback, noFade);

    /* 提交请求，Picasso 内部维护了一个 Map(Object, Action)
     * 提交时做判断，如果当前 Object 已经在任务队列里了。判断当前任务与之前的任务是否相同，
     * 如果不相同则取消之前的任务并将新的 key-value 加入到 Map。
     * 最后提交到下一步:Dispatcher 的 performSubmit 方法处理
     */
    picasso.enqueueAndSubmit(action);
}
</pre>
                            </li>
                            <li><code>Dispatcher.performSubmit()</code> -- 选择合适的 RequestHandler 来创建
                                BitmapHunter，最后提交任务到线程池
                                <pre class="brush: java;">
void performSubmit(Action action, boolean dismissFailed) {
    if (pausedTags.contains(action.getTag())) {
        pausedActions.put(action.getTarget(), action);
        if (action.getPicasso().loggingEnabled) {
        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),
            "because tag '" + action.getTag() + "' is paused");
        }
        return;
    }
    /* BitmapHunter 是一个 Runnable 的子类，用来进行 Bitmap 的获取(网络，硬盘，内存等)，处理(角度，大小等)
    * 然后执行分发器（dispatcher）的回调处理
    */
    BitmapHunter hunter = hunterMap.get(action.getKey());
    if (hunter != null) {
        hunter.attach(action);
        return;
    }

    if (service.isShutdown()) {
        if (action.getPicasso().loggingEnabled) {
            log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), "because shut down");
        }
        return;
    }
    // 根据不同的加载路径，选择合适的 RequestHandler 来创建 BitmapHunter
    hunter = forRequest(action.getPicasso(), this, cache, stats, action);
    // 提交任务到线程池，提交到线程池后，下一步会执行 BitmapHunter 的 run 方法
    hunter.future = service.submit(hunter);
    // 将 runnable 缓存在 map 集合中
    hunterMap.put(action.getKey(), hunter);
    if (dismissFailed) {
        failedActions.remove(action.getTarget());
    }

    if (action.getPicasso().loggingEnabled) {
        log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());
    }
}

</pre>
                            </li>
                            <li><code>BitmapHunter.forRequest()</code> -- 使用合适的 RequestHandler
                                来构建合适的 BitmapHunter。Picasso 类有一个成员保存了所有的
                                RequestHandler，并在初始化的时候添加。<code>List&lt;RequestHandler>
                                    requestHandlers</code>
                                <pre class="brush: java;">
static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,
      Action action) {
    Request request = action.getRequest();
    // Picasso 中默认保存了一个集合，里面存储了每一类图片的加载，判断和处理逻辑 ，比如网络图片，资源图片，硬盘图片等
    List&lt;RequestHandler> requestHandlers = picasso.getRequestHandlers();

    for (int i = 0, count = requestHandlers.size(); i < count; i++) {
        RequestHandler requestHandler = requestHandlers.get(i);
        /* 通过 request 中 uri 的 scheme 来判断该使用哪一个 RequestHandler，
         * 最终 BitmapHunter.hunt() 方法中要使用这个 RequestHandler.load() 方法来加载图片
         */
        if (requestHandler.canHandleRequest(request)) {
            return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);
        }
    }

    return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);
}
                            </pre>
                            </li>
                            <li><code>BitmapHunter.run()</code> -- BitmapHunter 实现 Runnable
                                的接口。也是从这里开始进入子线程执行。
                                <pre class="brush: java;">
@Override
public void run() {
    try {
        updateThreadName(data);

        if (picasso.loggingEnabled) {
            log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this));
        }
        // ============== hunt方法才是重点: Bitmap 的获取 ========
        result = hunt();
        // 得到 bitmap 后，执行 Dispater 中的方法，Dispater 这个时候又准备切换为主线程了
        if (result == null) {
            dispatcher.dispatchFailed(this);
        } else {
            dispatcher.dispatchComplete(this); // 成功后直接使用这个方法把数据分发给 DispatcherThread
        }
    } catch (Downloader.ResponseException e) {
        if (!e.localCacheOnly || e.responseCode != 504) {
            exception = e;
        }
        dispatcher.dispatchFailed(this);
    } catch (NetworkRequestHandler.ContentLengthException e) {
        exception = e;
        dispatcher.dispatchRetry(this);
    } catch (IOException e) {   // 重试
        exception = e;
        dispatcher.dispatchRetry(this);
    } catch (OutOfMemoryError e) {  // OOM 异常的处理
        StringWriter writer = new StringWriter();
        stats.createSnapshot().dump(new PrintWriter(writer));
        exception = new RuntimeException(writer.toString(), e);
        dispatcher.dispatchFailed(this);
    } catch (Exception e) {
        exception = e;
        dispatcher.dispatchFailed(this);
    } finally {
        Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);
    }
}
</pre>
                            </li>
                            <li><code>BitmapHunter.hunt()</code> -- 重点：Bitmap
                                的获取，包括获取途径内存，硬盘，网络的判断以及加载
                                <pre class="brush: java;">
Bitmap hunt() throws IOException {
    Bitmap bitmap = null;
    // 是否从内存读取
    if (shouldReadFromMemoryCache(memoryPolicy)) {
        bitmap = cache.get(key);
        if (bitmap != null) {
            // 发送一个内存缓存中查找成功的消息
            stats.dispatchCacheHit();
            loadedFrom = MEMORY;
            if (picasso.loggingEnabled) {
                log(OWNER_HUNTER, VERB_DECODED, data.logId(), "from cache");
            }
            return bitmap;
        }
    }

    // 如果重试次数为 0 则走本地硬盘，否则从网络获取
    data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;
    /* 根据重试的次数和不同的 RequestHandler 的子类来实现不同来源图片的加载,资源文件，硬盘图片又或者网络图片
     * 这个 requestHandler 具体实例在 BitmapHunter.forRequest() 方法中确定
     */
    RequestHandler.Result result = requestHandler.load(data, networkPolicy);
    if (result != null) {
        loadedFrom = result.getLoadedFrom();// 获取加载途径（内存，硬盘，网络）
        exifRotation = result.getExifOrientation();

        bitmap = result.getBitmap();

        // 返回的 resuslt 中包括 bitmap 和 inputstream，如果 bitmap 为 null 则需要从 stream 中转换
        if (bitmap == null) {
            InputStream is = result.getStream();
            try {
                bitmap = decodeStream(is, data);
            } finally {
                Utils.closeQuietly(is);
            }
        }
    }

    if (bitmap != null) {
        if (picasso.loggingEnabled) {
            log(OWNER_HUNTER, VERB_DECODED, data.logId());
        }
        // 修改 stats 中记录的图片的个数和占用的内存总大小以及平均内存占用量
        stats.dispatchBitmapDecoded(bitmap);
        // 图片是否需要旋转或者其他的操作处理
        if (data.needsTransformation() || exifRotation != 0) {
            synchronized (DECODE_LOCK) {
                if (data.needsMatrixTransform() || exifRotation != 0) {
                    bitmap = transformResult(data, bitmap, exifRotation);
                    if (picasso.loggingEnabled) {
                        log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());
                    }
                }
                // 自定义的图片处理
                if (data.hasCustomTransformations()) {
                    bitmap = applyCustomTransformations(data.transformations, bitmap);
                    if (picasso.loggingEnabled) {
                        log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(),
                                    "from custom transformations");
                    }
                }
            }
            if (bitmap != null) {
                stats.dispatchBitmapTransformed(bitmap);
            }
        }
    }
    return bitmap;
}
</pre>

                            </li>
                            <li>
                                <code>NetworkRequestHandler.load(Request request, int
                                    networkPolicy)</code> -- 以 NetworkRequestHandler 为例：
                                <pre class="brush: java;">
@Override
public Result load(Request request, int networkPolicy) throws IOException {
    /* 如果我们使用了 OkHttpClient，那么这个 downloader 就是 OkHttpDownloader 的实例；
     * 否则就是 UrlConnectionDownloader 的实例。
     */
    Response response = downloader.load(request.uri, request.networkPolicy);
    if (response == null) {
        return null;
    }

    Picasso.LoadedFrom loadedFrom = response.cached ? DISK : NETWORK;

    Bitmap bitmap = response.getBitmap();
    if (bitmap != null) {
        return new Result(bitmap, loadedFrom);
    }

    InputStream is = response.getInputStream();
    if (is == null) {
        return null;
    }

    if (loadedFrom == DISK && response.getContentLength() == 0) {
        Utils.closeQuietly(is);
        throw new ContentLengthException("Received response with 0 content-length header.");
    }
    if (loadedFrom == NETWORK && response.getContentLength() > 0) {
        stats.dispatchDownloadFinished(response.getContentLength());
    }
    return new Result(is, loadedFrom);
  }
                                </pre>
                            </li>
                            <li>
                                假设使用了 OkHttpClient，来看 <code>OkHttpDownloader.load()</code>方法：
                                <pre class="brush: java;">
@Override
public Response load(Uri uri, int networkPolicy) throws IOException {
    CacheControl cacheControl = null;
    if (networkPolicy != 0) {
        // 只走本地缓存
        if (NetworkPolicy.isOfflineOnly(networkPolicy)) {
            cacheControl = CacheControl.FORCE_CACHE;
        } else { // 自定义缓存策略
            CacheControl.Builder builder = new CacheControl.Builder();
            // 不从硬盘读
            if (!NetworkPolicy.shouldReadFromDiskCache(networkPolicy)) {
                builder.noCache();
            }
            // 不写入硬盘
            if (!NetworkPolicy.shouldWriteToDiskCache(networkPolicy)) {
                builder.noStore();
            }
            cacheControl = builder.build();
        }
    }

    Request.Builder builder = new Request.Builder().url(uri.toString());
    if (cacheControl != null) {
        builder.cacheControl(cacheControl);
    }

     // 调用 OkHttp 来执行 Bitmap 的下载任务
    com.squareup.okhttp.Response response = client.newCall(builder.build()).execute();
    int responseCode = response.code();
    if (responseCode >= 300) {
        response.body().close();
        throw new ResponseException(responseCode + " " + response.message(), networkPolicy,
                    responseCode);
    }

    boolean fromCache = response.cacheResponse() != null;

    ResponseBody responseBody = response.body();
    return new Response(responseBody.byteStream(), fromCache, responseBody.contentLength());
}
                                </pre>
                            </li>
                            <li><code>Picasso.complete()</code> 最终 BitmapHunter 被转发到这个方法了：
                                <pre class="brush: java;">
void complete(BitmapHunter hunter) {
    Action single = hunter.getAction();
    List&lt;Action> joined = hunter.getActions();

    boolean hasMultiple = joined != null && !joined.isEmpty();
    boolean shouldDeliver = single != null || hasMultiple;

    if (!shouldDeliver) {
        return;
    }

    Uri uri = hunter.getData().uri;
    Exception exception = hunter.getException();
    Bitmap result = hunter.getResult();
    LoadedFrom from = hunter.getLoadedFrom();

    if (single != null) {
        deliverAction(result, from, single);
    }

    if (hasMultiple) {
        //noinspection ForLoopReplaceableByForEach
        for (int i = 0, n = joined.size(); i < n; i++) {
            Action join = joined.get(i);
            deliverAction(result, from, join);
        }
    }

    if (listener != null && exception != null) {
        listener.onImageLoadFailed(this, uri, exception);
    }
}

private void deliverAction(Bitmap result, LoadedFrom from, Action action) {
    if (action.isCancelled()) {
        return;
    }
    if (!action.willReplay()) {
        targetToAction.remove(action.getTarget());
    }
    if (result != null) {
        if (from == null) {
            throw new AssertionError("LoadedFrom cannot be null.");
        }
        // 这里的 action 就是前面提到的 ImageViewAction，其他还有 RemoteViewsAction，TargetAction 等
        action.complete(result, from);
        if (loggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), "from " + from);
        }
    } else {
        action.error();
        if (loggingEnabled) {
            log(OWNER_MAIN, VERB_ERRORED, action.request.logId());
        }
    }
  }
</pre>
                            </li>
                            <li><code>ImageViewAction.complete()</code> 其他还有
                                RemoteViewsAction，TargetAction 等，最后来看下 ImageViewAction 的 <code>complete()</code>
                                方法。
                                <pre class="brush: java;">
@Override
public void complete(Bitmap result, Picasso.LoadedFrom from) {
    if (result == null) {
      throw new AssertionError(
          String.format("Attempted to complete action with no result!\n%s", this));
    }

    ImageView target = this.target.get();
    if (target == null) {
        return;
    }

    Context context = picasso.context;
    // 是否展示来源的标签，默认不展示。(最前面的打开调试模式就是它)
    boolean indicatorsEnabled = picasso.indicatorsEnabled;
    // 调用此方法将 Bitmap 设置到 ImageView
    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);

    if (callback != null) {
        callback.onSuccess();
    }
}

// PicassoDrawable 中 setBitmap 方法的实现
static void setBitmap(ImageView target, Context context, Bitmap bitmap,
      Picasso.LoadedFrom loadedFrom, boolean noFade, boolean debugging) {
    Drawable placeholder = target.getDrawable();
    if (placeholder instanceof AnimationDrawable) {
        ((AnimationDrawable) placeholder).stop();
    }
    // 最终扔到 ImageView 上现实的的是 PicassoDrawable
    PicassoDrawable drawable =
        new PicassoDrawable(context, bitmap, placeholder, loadedFrom, noFade, debugging);
    target.setImageDrawable(drawable);
}
                                </pre>
                            </li>
                        </ol>
                    </div>

                    <div class="sub-item">
                        <p><b>Picasso 内存优化和实例</b></p>
                        <ul>
                            <li><p><b>内存优化</b> -- 图片裁剪</p>
                                <pre class="brush: java;">
Picasso.with(context)
    .load(url)
    .resize(dp2px(250),dp2px(250))      // 在列表页尽量使用裁剪后的图片
    .centerCrop()
    .into(imageView);
</pre>
                            </li>
                            <li><p><b>内存优化</b> -- 查看大图放弃 Memory Cache</p>
                                <pre class="brush: java;">
// 查看大图时放弃使用内存缓存，图片从网络下载完成后会缓存到磁盘中，加载会从磁盘中加载
Picasso.with(context)
    .load(url)
    .memoryPolicy(NO_CACHE, NO_STORE)   // NO_CACHE: 加载时不在在内存缓存查找，NO_STORE: 加载完不缓存在内存
    .into(imageView);
</pre>
                            </li>
                            <li><p><b>内存优化</b> -- 重写 ImageView.onDetachedFromWindow() 方法，去掉 Drawable
                                引用，能加快内存的回收。</p>
                                <pre class="brush: java;">
public class RecyclerImageView extends ImageView {
    ...

    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        setImageDrawable(null);
    }
}
</pre>
                            </li>
                            <li><p><b>内存优化</b> -- 新进程中查看大图，在新进程中打开 Activity 成为比较取巧的避免 OOM 的方式。</p>
                                <pre class="brush: java;">
&lt;activity android:name=".LargeImageActivity" android:process=":picture" />
</pre>
                            </li>
                            <li><p><b>内存优化</b> -- 对于不透明的图片可以使用 RGB_565 来优化内存。</p>
                                <pre class="brush: java;">
Picasso.with( imageView.getContext() )
    .load(url)
    .config(Bitmap.Config.RGB_565)
    .into(imageView);
</pre>
                            </li>
                            <li><p><b>Bitmap 应用转换</b> -- 自定义 Transformation，实现图片的转换。</p>
                                <pre class="brush: java;">
GreyTransformation transfrom = new GreyTransformation(url);
Picasso.with(context).load(url).transform(transfrom).into(mImageView);

/** 将 Bitmap 转换为灰度模式 */
class GreyTransformation implements Transformation {
    private String key;

    public GreyTransformation(String key) {
        this.key = key;
    }

    @Override
    public Bitmap transform(Bitmap source) {

        int width = source.getWidth();
        int height = source.getHeight();

        Bitmap faceIconGreyBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);

        Canvas canvas = new Canvas(faceIconGreyBitmap);
        Paint paint = new Paint();
        ColorMatrix colorMatrix = new ColorMatrix();
        colorMatrix.setSaturation(0);   // 设置矩阵以影响颜色的饱和度， 参见: ColorMatrix
        ColorMatrixColorFilter colorMatrixFilter = new ColorMatrixColorFilter(colorMatrix);
        paint.setColorFilter(colorMatrixFilter);
        canvas.drawBitmap(source, 0, 0, paint);

        source.recycle();   // 别忘记回收这个旧的 Bitmap

        return faceIconGreyBitmap;
    }

    @Override
    public String key() {
        return key;
    }
}
</pre>
                            </li>
                            <li><p><b>使用第三方的 Transformation</b> -- <a
                                    href="https://github.com/wasabeef/picasso-transformations">picasso-transformations</a>
                                是一个 Picasso 图片转换的库，其实就是对 Bitmap 进行变化操作，因此可以同时有多个 tranform 方法进行变换操作。
                            </p>
                                <div class="row">
                                    <div class="col-md-8"><pre class="brush: java; gutter: false;">
/** 引入 picasso-transformations, GPUImage 看需要引入 */
compile 'jp.wasabeef:picasso-transformations:2.2.1'

1.遮盖变换 -- MaskTransformation
context - 需要从 Drawable 目录读取一张用于遮盖的图片
maskResId - 图片 ID

2.裁剪变换 -- CropTransformation，有多个构造方法，比如 600 * 800 图片：
(width, height) - (300, 400) 展示图片中间位置：(150,200) - (450, 600)
(left, top, width, height) - 指定左上角和宽高

GravityHorizontal - 指定横向区域，有三个值：LEFT, CENTER, RIGHT
GravityVertical - 指定纵向区域，有三个值：TOP, CENTER, BOTTOM
(width, height, gravityHorizontal, gravityVertical) - 裁剪指定宽高的
    左上，左中，左下，中上，中中，中下，右上，右中，右下 区域
(width, height, aspectRatio, gravityHorizontal, gravityVertical) -
aspectRatio - 为横纵比。如果设置了宽度，那么高度无意义，根据纵横比计算高度：
if (mWidth != 0) {
    mHeight = (int) ((float) mWidth / aspectRatio);
} else {
    if (mHeight != 0) {
        mWidth = (int) ((float) mHeight * aspectRatio);
    }
}

3.正方形变换 -- CropSquareTransformation
比如 600 * 800 的图片，展示区域为：(0, 100) - (600, 700)
比如 400 * 300 的图片，展示区域为：(50, 0) - (350, 0)

4.圆形变换 -- CropCircleTransformation, 展示区域为在正方形内画圆

5.颜色变换 -- ColorFilterTransformation, 这个要参照 PorterDuffColorFilter

6.灰度变换 -- GrayscaleTransformation，灰度模式

7.圆角变换 -- RoundedCornersTransformation，有两个构造函数
(int radius, int margin) - 指定圆角半径, magin: 图片到 View 边界的间距
(int radius, int margin, CornerType cornerType) - 指定要变换的角
CornerType - 为内部枚举类型，用于指定要变换的角

8.模糊变换 -- BlurTransformation，最多可以有三个参数
context - RSBlur.blur() 用到
radius - 默认为 25, 值越大越模糊
sampling - 默认为 1, 可以理解为缩小倍数

/** 基于 GPU 的图像处理库，提供各种各样的图像处理滤镜，
 * 并且支持照相机和摄像机的实时滤镜。下面的一些变换需要
 */
compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1'

/** 下面的变换要 GPUImage 库的支持，具体效果请看 GPUImage 库 */
ToonFilterTransformation, SepiaFilterTransformation
ContrastFilterTransformation, InvertFilterTransformation
PixelationFilterTransformation, SketchFilterTransformation
SwirlFilterTransformation, BrightnessFilterTransformation
KuwaharaFilterTransformation, VignetteFilterTransformation
</pre>
                                    </div>
                                    <div class="col-md-4"><img
                                            src="images/picasso-transformations.gif"
                                            class="img-responsive"></div>
                                </div>
                            </li>
                            <li><p><b>封装 GPUImage 的 Transformation</b> -- GPUImage 是 iOS 下一个开源的基于
                                GPU 的图像处理库，提供各种各样的图像处理滤镜，并且支持照相机和摄像机的实时滤镜。</p>
                                <p><a href="https://github.com/CyberAgent/android-gpuimage"
                                      target="_blank">GPUImage for Android</a> 是它在 Android
                                    下的实现，同样也是开源的。其中提供了几十种常见的图片滤镜 API，且其机制是基于 GPU
                                    渲染，处理速度相应也比较快，并且支持照相机和摄像机的实时滤镜。</p>
                                <pre class="brush: java;">
compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1'

/** 使用的时候传入相应的 GPUImageFilter */
Picasso.with(this)
    .load(url)
    .transform(new GPUImageTransformation(this, new GPUImageSobelEdgeDetection()))
    .into(text);

public class GPUImageTransformation implements Transformation {
    /**
     * GPUImageFilter 的子类：
     * GPUImageFilterGroup -- 也是 GPUImageFilter 的子类，可以组合多个效果
     * GPUImage3x3ConvolutionFilter -- 3x3卷积，高亮大色块变黑，加亮边缘、线条等
     * GPUImage3x3TextureSamplingFilter -- 3x3卷积
     * GPUImageAddBlendFilter -- 通常用于创建两个图像之间的动画变亮模糊效果
     * GPUImageAlphaBlendFilter -- 透明混合,通常用于在背景上应用前景的透明度
     * GPUImageBilateralFilter -- 双边模糊
     * GPUImageBoxBlurFilter -- 盒状模糊
     * GPUImageBrightnessFilter -- 亮度的调整
     * GPUImageBulgeDistortionFilter -- 凸起失真，鱼眼效果
     * GPUImageCGAColorspaceFilter -- CGA 色彩滤镜，形成黑、浅蓝、紫色块的画面
     * GPUImageChromaKeyBlendFilter -- 色度键混合
     * GPUImageColorBalanceFilter -- 色彩平衡
     * GPUImageColorBlendFilter -- 颜色混合
     * GPUImageColorBurnBlendFilter -- 色彩加深混合
     * GPUImageColorDodgeBlendFilter -- 色彩减淡混合
     * GPUImageColorInvertFilter -- 颜色倒置
     * GPUImageColorMatrixFilter -- 色彩矩阵
     * GPUImageContrastFilter -- 差异
     * GPUImageCrosshatchFilter -- 交叉线阴影，形成黑白网状画面
     * GPUImageDarkenBlendFilter -- 加深混合,通常用于重叠类型
     * GPUImageDifferenceBlendFilter -- 差异混合,通常用于创建更多变动的颜色
     * GPUImageDilationFilter -- 扩展边缘模糊，变黑白
     * GPUImageDirectionalSobelEdgeDetectionFilter -- 定向边缘检测
     * GPUImageDissolveBlendFilter -- 溶解
     * GPUImageDivideBlendFilter -- 通常用于创建两个图像之间的动画变暗模糊效果
     * GPUImageEmbossFilter -- 浮雕效果，带有点 3D 的感觉
     * GPUImageExclusionBlendFilter -- 排除混合
     * GPUImageExposureFilter -- 曝光
     * GPUImageFalseColorFilter -- 使用图像的亮度在两个用户指定的颜色之间混合
     * GPUImageGammaFilter -- 调整图像的灰度系数
     * GPUImageGaussianBlurFilter -- 高斯模糊
     * GPUImageGlassSphereFilter -- 水晶球效果
     * GPUImageGrayscaleFilter -- 灰度滤镜
     * GPUImageHalftoneFilter -- 点染,图像黑白化，由黑点构成原图的大致图形
     * GPUImageHardLightBlendFilter -- 强光混合,通常用于创建阴影效果
     * GPUImageHazeFilter -- 朦胧加暗
     * GPUImageHighlightShadowFilter -- 调整图像的阴影和高光
     * GPUImageHueBlendFilter -- 应用两个图像的色调混合
     * GPUImageHueFilter -- 调整图像的色调
     * GPUImageKuwaharaFilter -- 桑原滤波,水粉画的模糊效果；处理时间比较长，慎用
     * GPUImageLaplacianFilter -- 拉普拉斯算子
     * GPUImageLevelsFilter -- Photoshop 级别调整
     * GPUImageLightenBlendFilter -- 减淡混合,通常用于重叠类型
     * GPUImageLinearBurnBlendFilter -- 线性刻录混合
     * GPUImageLookupFilter -- 使用 RGB 颜色查找图像重新映射图像中的颜色
     * GPUImageLuminosityBlendFilter -- 亮度混合
     * GPUImageMixBlendFilter -- 调和混合
     * GPUImageMonochromeFilter -- 根据每个像素的亮度将图像转换为单色版本
     * GPUImageMultiplyBlendFilter -- 通常用于创建阴影和深度效果
     * GPUImageNonMaximumSuppressionFilter -- 非最大抑制，只显示亮度最高的像素，其他为黑
     * GPUImageNormalBlendFilter -- 正常
     * GPUImageOpacityFilter -- Alpha 通道调节
     * GPUImageOverlayBlendFilter -- 叠加,通常用于创建阴影效果
     * GPUImagePixelationFilter -- 象素化
     * GPUImagePosterizeFilter -- 色调分离，形成噪点效果
     * GPUImageRGBDilationFilter -- RGB扩展边缘模糊，有色彩
     * GPUImageRGBFilter -- 调整图像的每个 RGB 通道
     * GPUImageSaturationBlendFilter -- 饱和度混合
     * GPUImageSaturationFilter -- 饱和度
     * GPUImageScreenBlendFilter -- 屏幕包裹,通常用于创建亮点和镜头眩光
     * GPUImageSepiaFilter -- 简单的棕褐色调滤波器
     * GPUImageSharpenFilter -- 锐化
     * GPUImageSketchFilter -- 素描
     * GPUImageSmoothToonFilter -- 相比上面的效果更细腻，上面是粗旷的画
     * GPUImageSobelThresholdFilter -- Sobel 阈值
     * GPUImageSoftLightBlendFilter -- 柔光混合
     * GPUImageSourceOverBlendFilter -- 源混合
     * GPUImageSphereRefractionFilter -- 球形折射，图形倒立
     * GPUImageSubtractBlendFilter -- 差值混合,通常用于创建两个图像之间的动画变暗模糊效果
     * GPUImageSwirlFilter -- 漩涡，中间形成卷曲的画面
     * GPUImageThresholdEdgeDetection -- 阈值边缘检测
     * GPUImageToneCurveFilter -- 颜色通道的样条曲线调整图像的颜色
     * GPUImageToonFilter -- 卡通效果（黑色粗线描边）
     * GPUImageTransformFilter -- 形状变化
     * GPUImageTwoInputFilter -- 双输入
     * GPUImageTwoPassFilter -- 双通道处理
     * GPUImageTwoPassTextureSamplingFilter
     * GPUImageVignetteFilter -- 晕影，形成黑色圆形边缘，突出中间图像的效果
     * GPUImageWeakPixelInclusionFilter -- 弱像素包含
     * GPUImageWhiteBalanceFilter -- 白平衡
     */

    private Context context;
    private GPUImageFilter filter;

    public GPUImageTransformation(Context context, GPUImageFilter filter){
        this.context = context;
        this.filter = filter;
    }

    @Override
    public Bitmap transform(Bitmap source) {
        Bitmap target = source.copy(Bitmap.Config.ARGB_8888, true);

        GPUImage gpuImage = new GPUImage(context);
        gpuImage.setImage(target);
        gpuImage.setFilter(filter);

        source.recycle();
        return gpuImage.getBitmapWithFilterApplied();
    }

    @Override
    public String key() {
        return "GPUImage";
    }
}
</pre>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="image-Glide"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Glide</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <p>Glide 是一个 Android
                            上的图片加载和缓存库，它不仅能实现平滑的图片列表滚动效果，还支持远程图片的获取、大小调整和展示，并且可以加载 Gif
                            动态图，可谓功能强大。Glide 的集成离不开 v4 包，所以必须添加 support 包。</p>
                        <div class="row">
                            <div class="col-md-4">
                                <p>
                                    项目源码 --
                                    <a href="https://github.com/bumptech/glide" target="_blank">
                                        Glide</a><br>
                                    项目 JAR --
                                    <a href="lib/glide-3.7.0.jar">glide-3.7.0.jar</a>
                                </p>
                                <p>Glide 模块分为</p>
                                <ul>
                                    <li>RequestManager(请求管理器)</li>
                                    <li>Engine(数据获取引擎)</li>
                                    <li>Fetcher(数据获取器)</li>
                                    <li>MemoryCache(内存缓存)</li>
                                    <li>DiskLRUCache(SD 缓存)</li>
                                    <li>Transformation(图片处理)</li>
                                    <li>Encoder(本地缓存存储)</li>
                                    <li>Registry(图片类型及解析器)</li>
                                    <li>Target(目标)</li>
                                </ul>
                                <p>简单的讲就是 Glide 收到加载及显示资源的任务，创建 Request 并将它交给
                                    RequestManager，Request 启动 Engine 去数据源获取资源(通过 Fetcher )，获取到后
                                    Transformation 处理后交给 Target。</p>
                            </div>
                            <div class="col-md-8">
                                <img src="images/overall-design-glide.jpg"
                                     class="img-responsive">
                            </div>
                        </div>

                        <p>Glide 如同 ImageLoader 一样，也是可以配置一些属性的，Glide 可以在 GlideModel
                            中统一配置其属性。</p>
                        <pre class="brush: java;">
// GlideModel 可以在 AndroidManifest.xml 文件中注册，以便 Glide 能够找到你的 Module
&lt;meta-data
	android:name="xx.yy.GlideModelConfig"
	android:value="GlideModule" />

public class GlideModelConfig implements GlideModule {

	int diskSize = 1024 * 1024 * 100;
	// 取1/8最大内存作为最大缓存
	int memorySize = (int) (Runtime.getRuntime().maxMemory()) / 8;

	@Override
	public void applyOptions(Context context, GlideBuilder builder) {
		// 定义缓存大小和位置
		builder.setDiskCache(new InternalCacheDiskCacheFactory(context,
				diskSize)); // 内存中
		builder.setDiskCache(new ExternalCacheDiskCacheFactory(context,
				"cache", diskSize)); // sd卡中

		// 默认内存和图片池大小
		MemorySizeCalculator calculator = new MemorySizeCalculator(context);
		// 默认内存大小
		int defaultMemoryCacheSize = calculator.getMemoryCacheSize();
		// 默认图片池大小
		int defaultBitmapPoolSize = calculator.getBitmapPoolSize();
		// 该两句无需设置，是默认的
		builder.setMemoryCache(new LruResourceCache(defaultMemoryCacheSize));
		builder.setBitmapPool(new LruBitmapPool(defaultBitmapPoolSize));

		// 自定义内存和图片池大小
		builder.setMemoryCache(new LruResourceCache(memorySize));
		builder.setBitmapPool(new LruBitmapPool(memorySize));

		// 定义图片格式
		builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);
		builder.setDecodeFormat(DecodeFormat.PREFER_RGB_565); // 默认
	}

	@Override
	public void registerComponents(Context context, Glide glide) {
	}
}
</pre>
                        <p>Glide 的常用方法:</p>
                        <pre class="brush: java;">
// 1.加载网络图片
Glide.with(this).load(url).into(imageView);

// 2.加载本地图片
File file = new File(getExternalCacheDir() + "/image.jpg");
Glide.with(this).load(file).into(imageView);

// 3.加载应用资源
int resource = R.drawable.image;
Glide.with(this).load(resource).into(imageView);

// 4.加载二进制流
byte[] image = getImageBytes();
Glide.with(this).load(image).into(imageView);

// 5.加载Uri对象
Uri imageUri = getImageUri();
Glide.with(this).load(imageUri).into(imageView);

// 6.加载占位图
Glide.with(this).placeholder(R.drawable.loading);

// 7.加载错误图片
Glide.with(this).error(R.drawable.error);

// 8.禁用缓存
/**
 * DiskCacheStrategy.ALL：两个都缓存
 * DiskCacheStrategy.NONE：不缓存 
 * DiskCacheStrategy.SOURCE：缓存原始图片 
 * DiskCacheStrategy.RESULT：缓存压缩过的结果图片
 */
Glide.with(this).diskCacheStrategy(DiskCacheStrategy.NONE);

// 9.只允许加载静态图片, Glide 支持直接加载 Gif, asBitmap() 方法不需要Glide去帮我们自动进行图片格式的判断
Glide.with(this).asBitmap();

// 10.指定图片大小
Glide.with(this).override(100, 100);

// 11.显示动画, 这个动画只在初次加载出来时使用，已经加载过了，下载再从缓存中取是不会动画的。
Glide.with(this).animate(Animator animator);// 或者int animationId 
Glide.with(this).dontAnimate();// 去除动画

// 12.图片拉伸
// 长的一边撑满
Glide.with(this).centerCrop();
// 短的一边撑满
Glide.with(this).fitCenter();

// 13.转换器 -- 提供各式各样的Api可以将图片转为各种形状，例如圆形，圆角型等等
/**
 * glide-transformations -- 一个基于Glide的transformation库，拥有裁剪，着色，模糊，滤镜等多种转换效果
 * url -- https://github.com/wasabeef/glide-transformations
 */
// 单独转换器效果（毛玻璃为例）
Glide.with(this).load(R.mipmap.login)
	.bitmapTransform(new BlurTransformation(this, 20))
	.into(imageView);
// 复合转换器效果(毛玻璃加图角)
Glide.with(this).load(R.mipmap.login)
	.bitmapTransform(new BlurTransformation(this, 20), 
		new CropCircleTransformation(this))
	.into(imageView);

// 14.缓存的动态清理
Glide.get(this).clearDiskCache();		// 清理磁盘缓存 需要在子线程中执行
Glide.get(this).clearMemory();			// 清理内存缓存  可以在UI主线程中进行

// 15.暂停／恢复加载, GirdView, ListView 加载图片, 而当我们快速滑动 GridView，ListView，我们希望能停止图片的加载
Glide.with(this).pauseRequests();		// 停止图片的加载
Glide.with(this).resumeRequests();		// 恢复加载
</pre>
                    </div>

                </div>
            </div>
            <!-- item over -->


            <!-- item start -->
            <a class="offset" id="other-RxJava"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">RxJava / RxAndroid</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <p><a href="https://github.com/ReactiveX/RxJava">RxJava / RxAndroid</a> 是一个在
                            Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库，主要是一个实现观察者模式和异步操作的库。</p>
                        <p>RxJava 中最值得称道的地方是线程调度器(Scheduler)，实现了简洁明了的异步操作。</p>
                        <p>一般来说 Observable 生成发射数据流，以及 Operators 加工数据流都是在后台线程中进行，而 Observer
                            在前台线程中接受并相应数据。</p>
                        <pre class="brush: java;">
compile "io.reactivex.rxjava2:rxjava:2.1.10"
compile 'io.reactivex.rxjava2:rxandroid:2.0.2'</pre>
                        <p>我们一般写的程序统称为命令式程序，是以流程为核心的，每一行代码实际上都是机器实际上要执行的指令。而 Rxjava
                            这样的编程风格，称为函数响应式编程。函数响应式编程是以数据流为核心，处理数据的输入，处理以及输出的。</p>
                        <p>
                            响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</p>
                    </div>

                    <div class="sub-item">
                        <p><b>观察者模式</b></p>
                        <p>RxJava 以观察者模式为骨架，RxJava2 中出现了两种观察者模式：</p>
                        <ul>
                            <li><p>Observable ( 被观察者 ) / Observer ( 观察者 ) -- Observable 用于订阅
                                Observer，不再支持背压；</p></li>
                            <li>
                                <p>Flowable （被观察者）/ Subscriber （观察者） -- Flowable 用于订阅 Subscriber ，
                                    是支持背压。</p>
                            </li>
                        </ul>
                        <p class="alert alert-success">
                            背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。</p>
                        <p>观察者模式使用步骤：</p>
                        <ul>
                            <li><p>构建一个被观察者；</p></li>
                            <li><p>构建一个观察者；</p></li>
                            <li><p>建立观察者和被观察者的订阅关系。</p></li>
                        </ul>
                        <p><b>ObservableEmitter</b> -- Emitter 是发射器的意思，是用来发出事件的，可以发出三种类型的事件，通过调用
                            emitter 的 onNext(T value)、onComplete() 和 onError(Throwable error)
                            就可以分别发出 next 事件、complete 事件和 error 事件。</p>
                        <p><b>Disposable</b> -- 字面意思是一次性用品，用完即可丢弃的。RxJava 中可以把它理解成被观察者和观察者之间的一个机关,
                            当调用它的 dispose() 方法时, 观察者收不到事件。</p>

                        <pre class="brush: java;">
/** 先来看代码输出:
 * subscribe -> onNext:1 -> onNext:2 -> onNext:3 -> onComplete;
 * 在 subscribe 中发送 onComplete 或 onError 后，被观察者继续发送事件，但观察者不会再接收事件；
 * 在 subscribe 中不能同时调用 onComplete 和 onError，这两个时间必须互斥;
 * 在 Observer 中调用 mDisposable.dispose() 方法，观察者也不会再接收事件，主要用于线程调度。
 */
// 1. 初始化 Observerable
Observable&lt;Integer> observable = Observable.create(new ObservableOnSubscribe&lt;Integer>() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer> emitter) throws Exception {
        System.out.println("subscribe");
        emitter.onNext(1);
        emitter.onNext(2);
        emitter.onNext(3);

        emitter.onComplete();// Observer 不会调用 onNext(4)

        emitter.onNext(4);
    }
});

// 2. 初始化 Observer
Observer&lt;Integer> observer = new Observer&lt;Integer>() {
    private Disposable mDisposable;

    @Override
    public void onSubscribe(Disposable d) {
        mDisposable = d;
    }

    @Override
    public void onNext(Integer integer) {
        System.out.println("onNext:" + integer);
        if (2 == integer) {
            // mDisposable.dispose(); // 可以打断，不会调用 onNext(3)
        }
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {
        System.out.println("onComplete");
    }
};

// 3. 建立订阅关系
observable.subscribe(observer);
</pre>
                    </div>

                    <div class="sub-item">
                        <p><b>操作符</b></p>
                        <p>操作符按照其作用具体可分为以下几类：</p>
                        <ul>
                            <li><p>创建：创建一个可观察对象Observable并发射数据</p>
                                <pre class="brush: java;">
create：基础创建操作符
just：创建一个 Observable，可接受一个或多个参数，将每个参数逐一发送
fromArray：创建一个 Observable，接受一个数组，并将数组中的数据逐一发送
fromIterable：创建一个 Observable，接受一个可迭代对象，并将可迭代对象中的数据逐一发送
range：创建一个 Observable，发送一个范围内的整数，Observable.range(1,10) 从 1 开始以步长 1 递增发送 10 个数据
                                </pre>
                            </li>
                            <li><p>过滤：从Observable发射的数据中取出特定的值</p>
                                <pre class="brush: java;">
filter：filter使用Predicate 函数接口传入条件值，来判断Observable发射的每一个值是否满足这个条件，
        如果满足，则继续向下传递，如果不满足，则过滤掉。
distinct：过滤掉重复的数据项，过滤规则为：只允许还没有发射过的数据项通过。
skip：接受一个 long 型参数 count ，代表跳过 count 个数目开始接收。
                                </pre>
                            </li>
                            <li><p>变换：对Observable发射的数据执行变换操作</p>
                                <pre class="brush: java;">
map：对 Observable 发射的每一项数据应用一个函数，执行变换操作
flatMap：将一个发射数据的 Observable 变换为多个 Observable，然后将多个 Observable 发射的数据合
        并到一个 Observable 中进行发射
concatMap：同 flatMap, 它保证顺序
                                </pre>
                            </li>
                            <li><p>组合：组合多个 Observable,例如：{1,2,3}+{4,5,6}-->{1,2,3,4,5,6}</p>
                                <pre class="brush: java;">
merge / mergeWith：合并多个 Observable 发射的数据，可能会让 Observable 发射的数据交错。
concat / concatWith：同 mergeWith 一样，用以合并多个 Observable 发射的数据，但是 concatWith 不会让
                                    Observable 发射的数据交错。
                                </pre>
                            </li>
                            <li><p>聚合：聚合多个 Observable，例如：{1,2,3}+{4,5,6}-->{[1,4],[2,5],[3,6]}</p>
                                <pre class="brush: java;">
zip / zipWith：将多个 Obversable 发射的数据，通过一个函数 BiFunction对对应位置的数据处理后放到一个新的
        Observable 中发射，所发射的数据个数与最少的 Observabel 中的一样多。
buffer：接受两个参数，buffer(count,skip)，作用是将 Observable 中的数据按 skip (步长) 分成最大不超过
        count 的 buffer，然后生成一个 Observable。
                                </pre>
                            </li>
                        </ul>
                        <p>先来看一段代码，应用了很多操作符：</p>
                        <pre class="brush: java;">
Integer nums1[] = new Integer[]{5, 6, 7, 8, 9};
Integer nums2[] = new Integer[]{3, 4, 5, 6};
String names[] = new String[]{"红娃", "橙娃", "黄娃", "绿娃", "青娃", "蓝娃", "紫娃"};
Observable.just(nums1)
    .flatMap(new Function&lt;Integer[], Observable&lt;Integer>>() {
        @Override
        public Observable&lt;Integer> apply(@NonNull Integer[] integers) throws Exception {
            return Observable.fromArray(integers);
        }
    })
    .mergeWith(Observable.fromArray(nums2))
    .concatWith(Observable.just(1, 2))
    .distinct()
    .filter(new Predicate&lt;Integer>() {
        @Override
        public boolean test(@NonNull Integer integer) throws Exception {
            return integer < 5;
        }
    })
    .map(new Function&lt;Integer, String>() {
        @Override
        public String apply(@NonNull Integer integer) throws Exception {
            return integer + ":";
        }
    })
    .zipWith(Observable.fromArray(names), new BiFunction&lt;String, String, String>() {
        @Override
        public String apply(@NonNull String s, @NonNull String s2) throws Exception {
            return s + s2;
        }
    })
    .subscribe(new Consumer&lt;String>() {
        @Override
        public void accept(@NonNull String s) throws Exception {
            System.out.println(s);
        }
    });
</pre>
                        <ol>
                            <li>
                                <p><code>create</code> -- 用于产生一个 Obserable 被观察者对象。</p></li>
                            <li><p><code>map</code> -- 对发射时间发送的每一个事件应用一个函数。</p>
                                <pre class="brush: java;">
/** Observer 接收到的值是 map 的 apply 方法处理后的返回值 */
Observable.create(new ObservableOnSubscribe&lt;Integer>() {
        @Override
        public void subscribe(ObservableEmitter&lt;Integer> emitter) throws Exception {
            emitter.onNext(1);
            emitter.onNext(2);
        }
    }).map(new Function&lt;Integer, String>() { // 处理 onNext 参数，再传给 Observer
        @Override
        public String apply(Integer integer) throws Exception {
            return "Value is " + integer;
        }
    }).subscribe(new Consumer&lt;String>() {    // Consumer 只关心 onNext 方法
        @Override
        public void accept(String s) throws Exception {
            log(s);
        }
    });
</pre>
                            </li>
                            <li><p><code>zip</code> -- 合并事件， 最终配对出的 Observable 发射事件数目只和少的那个相同。</p>
                                <pre class="brush: java;">
/** 只会输出 A1 和 B2 */
Observable.zip(Observable.create(new ObservableOnSubscribe&lt;String>() {
        @Override
        public void subscribe(ObservableEmitter&lt;String> emitter) throws Exception {
            emitter.onNext("A");
            emitter.onNext("B");
        }
    }), Observable.create(new ObservableOnSubscribe&lt;Integer>() {
        @Override
        public void subscribe(ObservableEmitter&lt;Integer> emitter) throws Exception {
            emitter.onNext(1);
            emitter.onNext(2);
            emitter.onNext(3);
        }
    }), new BiFunction&lt;String, Integer, String>() {
        @Override
        public String apply(String s, Integer i) throws Exception {
            return s + i;
        }
    }).subscribe(new Consumer&lt;String>() {
        @Override
        public void accept(String s) throws Exception {
            log(s);
        }
    });
</pre>
                            </li>
                            <li><p><code>concat</code> -- 对于单一的把两个发射器连接成一个发射器。</p>
                                <pre class="brush: java;">
/** 输出为 A B 1 2 3 */
Observable.concat(Observable.just("A", "B"), Observable.just("1", "2", "3"))
    .subscribe(new Consumer&lt;String>() {
        @Override
        public void accept(String s) throws Exception {
            log(s);
        }
    });
</pre>
                            </li>
                            <li><p><code>flatMap</code> -- 把一个发射器 Observable 通过某种方法转换为多个
                                Observables，然后再把这些分散的 Observables 装进一个单一的发射器
                                Observable。但有个需要注意的是，flatMap 并不能保证事件的顺序，如果要保证顺序，使用 concatMap。</p>
                                <pre class="brush: java;">
/** 输出为: (A1) (A2) (B1) (B2) */
Observable.create(new ObservableOnSubscribe&lt;String>() {
        @Override
        public void subscribe(ObservableEmitter&lt;String> e) throws Exception {
            e.onNext("A");
            e.onNext("B");
        }
    }).flatMap(new Function&lt;String, ObservableSource&lt;String>>() {
        @Override
        public ObservableSource&lt;String> apply(String integer) throws Exception {
            List&lt;String> list = new ArrayList<>();
            for (int i = 1; i < 3; i++) {
                list.add("(" + integer + i + ")");
            }
            return Observable.fromIterable(list);
        }
    }).subscribe(new Consumer&lt;String>() {
        @Override
        public void accept(String s) throws Exception {
            log(s);
        }
    });
</pre>
                            </li>
                            <li>
                                <p><code>concatMap</code> -- concatMap 与 flatMap 的唯一区别就是 concatMap
                                    保证了顺序。</p></li>
                            <li><p><code>distinct</code> -- 就是简单的去重。</p>
                                <pre class="brush: java;">
/** 输出为: 1 2 3 */
Observable.just(1, 2, 1, 3, 2)
    .distinct()
    .subscribe(new Consumer&lt;Integer>() {
        @Override
        public void accept(Integer s) throws Exception {
            log(s);
        }
    });
</pre>
                            </li>
                            <li><p><code>filter</code> -- 可以接受一个参数，让其过滤掉不符合我们条件的值</p>
                                <pre class="brush: java;">
/** 输出为: 2 4 */
Observable.just(1, 2, 3, 4, 5)
    .filter(new Predicate&lt;Integer>() {
        @Override
        public boolean test(Integer integer) throws Exception {
            return integer % 2 == 0;
        }
    })
    .subscribe(new Consumer&lt;Integer>() {
        @Override
        public void accept(Integer s) throws Exception {
            log(s);
        }
    });
</pre>
                            </li>
                            <li><p><code>buffer</code> -- 操作符接受两个参数，buffer(count,skip)，作用是将
                                Observable 中的数据按 skip (步长) 分成最大不超过 count 的 buffer ，然后生成一个
                                Observable。</p>
                                <pre class="brush: java;">
/** count 为 4, skip 一直取到 skip >= items.size
 * 第一次：skip = 0 -- [1, 2, 3, 4]
 * 第二次：skip = 2 -- [3, 4, 5, 6]
 * 第三次：skip = 4 -- [5, 6]
 */
Observable.just(1, 2, 3, 4, 5, 6)
    .buffer(4, 2)
    .subscribe(new Consumer&lt;List&lt;Integer>>() {
        @Override
        public void accept(List&lt;Integer> s) throws Exception {
            log(s);
        }
    });
</pre>
                            </li>
                            <li><p><code>timer</code> -- 相当于一个定时任务。发送一个 0，timer 和 interval 均默认在新线程。</p>
                                <pre class="brush: java;">
Observable.timer(1, TimeUnit.SECONDS)
    .observeOn(AndroidSchedulers.mainThread())      // 切换到主线程
    .subscribe(new Consumer&lt;Long>() {
        @Override
        public void accept(Long aLong) throws Exception {
            AppUtil.logDebug("=========" + Thread.currentThread().getName());
        }
    });

/** 延时 1s 执行一个网络逻辑 */
Observable.timer(1, TimeUnit.SECONDS)
    .map(new Function&lt;Long, String>() {
        @Override
        public String apply(Long aLong) throws Exception {
            return OkHttpUtil.getInstance().syncGettring("url");
        }
    }).observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Consumer&lt;String>() {
        @Override
        public void accept(String s) throws Exception {
            AppUtil.logDebug(s);
        }
    });
</pre>
                            </li>
                            <li><p><code>interval</code> --
                                用于间隔时间执行某个操作，其接受三个参数，分别是第一次发送延迟，间隔时间，时间单位。</p>
                                <pre class="brush: java;">
/** 第一次延时 0s, 每隔 3s 执行一个网络逻辑 */
Observable.interval(0, 3, TimeUnit.SECONDS)
    .map(new Functiom&lt;Long, String>() {
        @Override
        public String apply(Long aLong) throws Exception {
             return OkHttpUtil.getInstance().syncGettring(url);
        }
    }).observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Consumer&lt;String>() {
        @Override
        public void accept(String s) throws Exception {
            AppUtil.logDebug("===" + s);
        }
    });
</pre>
                            </li>
                            <li><p><code>doOnNext</code> -- 让订阅者在接收到数据之前执行一些操作。</p>
                                <pre class="brush: java;">
Observable.just(1, 2, 3).doOnNext(new Consumer&lt;Integer>() {
        @Override
        public void accept(Integer integer) throws Exception {
            log("doOnNext:" + integer);
        }
    }).subscribe(new Consumer&lt;Integer>() {
        @Override
        public void accept(Integer integer) throws Exception {
            log(integer);
        }
    });
</pre>
                            </li>
                            <li><p><code>skip</code> -- 接受一个 long 型参数 count ，代表跳过 count 个数目开始接收。</p>
                                <pre class="brush: java;">
/** 输出为: 2 3 */
Observable.just(1, 2, 3)
    .skip(1)
    .subscribe(new Consumer&lt;Integer>() {
        @Override
        public void accept(Integer integer) throws Exception {
            log(integer);
        }
    });
</pre>
                            </li>
                            <li><p><code>take</code> -- 接受一个 long 型参数 count ，代表至多接收 count 个数据。</p>
                                <pre class="brush: java;">
/** 输出为: 1 2 */
Observable.just(1, 2, 3)
    .take(2)
    .subscribe(new Consumer&lt;Integer>() {
        @Override
        public void accept(Integer integer) throws Exception {
            log(integer);
        }
    });
</pre>
                            </li>
                            <li><p><code>just</code> -- 一个简单的发射器依次调用 onNext() 方法。</p></li>
                            <li><p><code>debounce</code> -- 去除发送频率过快的项。比如在 Android
                                中应用手势事件时可能不需要这么多的时间时候可用。</p>
                                <pre class="brush: java;">
/** 去除发送间隔时间小于 500 毫秒的发射事件，所以 1 和 3 被去掉了 */
Observable.create(new ObservableOnSubscribe&lt;Integer>() {
        @Override
        public void subscribe(@NonNull ObservableEmitter&lt;Integer> emitter) throws Exception {
            emitter.onNext(1); // skip
            Thread.sleep(400);
            emitter.onNext(2); // deliver
            Thread.sleep(505);
            emitter.onNext(3); // skip
            Thread.sleep(100);
            emitter.onNext(4); // deliver
            Thread.sleep(605);
            emitter.onNext(5); // deliver
            Thread.sleep(510);
            emitter.onComplete();
        }
    }).debounce(500, TimeUnit.MILLISECONDS)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Consumer&lt;Integer>() {
        @Override
        public void accept(@NonNull Integer integer) throws Exception {
            Log.e(TAG, "debounce :" + integer + "\n");
        }
    });
</pre>
                            </li>
                            <li><p><code>defer</code> -- 每次订阅都会创建一个新的 Observable，并且如果没有被订阅，就不会产生新的
                                Observable。</p>
                                <pre class="brush: java;">
Observable&lt;Integer> observable = Observable.defer(new Callable&lt;ObservableSource&lt;Integer>>() {
        @Override
        public ObservableSource&lt;Integer> call() throws Exception {
            return Observable.just(1, 2, 3);
        }
    });
    observable.subscribe(new Consumer&lt;Integer>() {
        @Override
        public void accept(Integer integer) throws Exception {
            log(integer);
        }
    });
</pre>
                            </li>
                            <li><p><code>last</code> -- 取出可观察到的最后一个值，或者是满足某些条件的最后一项。</p>
                                <pre class="brush: java;">
/** 输出为: 3 */
Observable.just(1, 2, 3)
    .last(-1) // 如果失败，使用默认 -1
    .subscribe(new Consumer&lt;Integer>() {
        @Override
        public void accept(Integer integer) throws Exception {
            log(integer);
        }
    });
</pre>
                            </li>
                            <li><p><code>merge</code> -- 把多个 Observable 结合起来，接受可变参数，也支持迭代器集合。注意它和
                                concat 的区别在于，不用等到 发射器 A 发送完所有的事件再进行发射器 B 的发送。</p>
                                <pre class="brush: java;">
Observable.merge(Observable.just(1, 2), Observable.just(3, 4, 5))
    .subscribe(new Consumer&lt;Integer>() {
        @Override
        public void accept(Integer integer) throws Exception {

        }
    });
</pre>
                            </li>
                            <li><p><code>reduce</code> -- 每次用一个方法处理一个值，可以有一个 seed 作为初始值。</p>
                                <pre class="brush: java;">
Observable.just(1, 2, 3, 4, 5)
    .reduce(new BiFunction&lt;Integer, Integer, Integer>() {
        @Override
        public Integer apply(Integer integer, Integer integer2) throws Exception {
            return integer * integer2;
        }
    }).subscribe(new Consumer&lt;Integer>() {       // 这个参数不能是 new Observer&lt;Integer>() {...}
        @Override
        public void accept(Integer integer) throws Exception {
            log(integer);
        }
    });
</pre>
                            </li>
                            <li><p><code>scan</code> -- 作用和上面的 reduce 一致，唯一区别是 reduce 是个只追求结果的坏人，而
                                scan 会始终如一地把每一个步骤都输出。</p>
                                <pre class="brush: java;">
Observable.just(1, 2, 3, 4, 5)
    .scan(new BiFunction&lt;Integer, Integer, Integer>() {
        @Override
        public Integer apply(Integer integer, Integer integer2) throws Exception {
            return integer * integer2;
        }
    }).subscribe(new Observer&lt;Integer>() {...}      // 这个参数可以关注步骤
</pre>
                            </li>
                            <li><p><code>window</code> -- 按照实际划分窗口，将数据发送给不同的 Observable。</p>
                                <pre class="brush: java;">
Observable longObservable = Observable.create(new ObservableOnSubscribe&lt;Long>() {
    @Override
    public void subscribe(ObservableEmitter&lt;Long> emitter) throws Exception {

    }
});

Observable.interval(1, TimeUnit.SECONDS) // 间隔一秒发一次
    .take(15) // 最多接收 15 个
    .window(3, TimeUnit.SECONDS)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Consumer&lt;Observable&lt;Long>>() {
        @Override
        public void accept(@NonNull Observable&lt;Long> longObservable) {
            longObservable.subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeOn(Schedulers.io())
                .subscribe(new Consumer&lt;Long>() {
                    @Override
                    public void accept(Long aLong) throws Exception {
                        log(aLong);
                    }
                });
        }
    });
</pre>
                            </li>

                        </ol>
                    </div>

                    <div class="sub-item">
                        <p><b>线程切换(异步操作)</b></p>
                        <p>线程切换由下面两个方法指定：</p>
                        <ul>
                            <li><p><code>subscribeOn</code> -- 用于指定 subscribe()
                                时所发生的线程，从源码角度可以看出，内部线程调度是通过 ObservableSubscribeOn 来实现的；</p></li>
                            <li><p><code>observeOn</code> -- 用于指定下游 Observer 回调发生的线程。</p></li>
                        </ul>
                        <p>线程切换需要注意的:</p>
                        <ul>
                            <li><p>简单地说，subscribeOn() 指定的就是发射事件的线程，observerOn() 指定的就是订阅者接收事件的线程；</p>
                            </li>
                            <li><p>多次指定发射事件的线程只有第一次指定的有效，也就是说多次调用 subscribeOn()
                                只有第一次的有效，其余的会被忽略；</p></li>
                            <li><p>多次指定订阅者接收线程是可以的，也就是说每调用一次 observerOn()，下游的线程就会切换一次；</p></li>
                            <li><p>subscribeOn() 和 subscribeOn()
                                写的位置不一样，加工方法运行的线程也不一样，一些方法默认执行的线程可能在子线程，具体看说明。</p></li>
                        </ul>
                        <p>RxJava 中，已经内置了很多线程选项供我们选择，而 RxJava 内部使用的是线程池来维护这些线程，所以效率也比较高。例如有：</p>
                        <ul>
                            <li>
                                <code>Schedulers.io()</code> 代表 io 操作的线程, 通常用于网络,读写文件等 io 密集型的操作；
                            </li>
                            <li>
                                <code>Schedulers.computation()</code> 代表 CPU 计算密集型的操作, 例如需要大量计算的操作；
                            </li>
                            <li>
                                <code>Schedulers.newThread()</code> 代表一个常规的新线程，不是用线程池，因此效率不高；
                            </li>
                            <li>
                                <code>AndroidSchedulers.mainThread()</code> 代表 Android 的主线程(这个的
                                RxAndroid 中才有)。
                            </li>
                        </ul>
                        <pre class="brush: java;">
/** RxJava 默认运行在当前线程中。
 * 如果当前线程是子线程，则 RxJava 运行在子线程；同样，当前线程是主线程，则 RxJava 运行在主线程
 */
Observable.create(...).map(...).subscribe(...);
new Thread(new Runnable() {
    @Override public void run() {
        Observable.create(...).map(...).subscribe(...);
    }
}).start();

/** 运行的线程分为三个方面：事件产生，事件加工，事件消费
 * 1.事件产生的线程由 subscribeOn 指定，如果只指定了 subscribeOn，那么 事件加工和事件消费 都和事件产生同一个线程;
 * 2.事件消费的线程由 observeOn 指定，如果只指定了 observeOn，那么事件产生在当前线程线程，事件加工的线程要看是在
 *      observeOn 前调用还是后调用，observeOn 影响的是后面的方法;
 * 3.多次调用 observeOn 方法，事件加工和时间消费的方法所在线程会多次切换；
 * 4.注意 Observer 的 onSubscribe 方法总是在当前线程运行的。
 */
Observable.create(...)                  // io 线程
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .map(...)                           // 主线程
    .subscribe(...);                    // 主线程

Observable.create(...)                  // io 线程
    .map(...)                           // io 线程
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(...);                    // 主线程

Observable.create(...)                  // io 线程
    .map(...)                           // io 线程
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .doOnNext(...)                      // 主线程
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(...);                    // 主线程
                            </pre>
                    </div>

                    <div class="sub-item">
                        <p><b>Flowable 背压支持</b></p>
                        <p class="alert alert-success">
                            背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。</p>
                        <p>Flowable 是为了解决背压问题，而在 Observable 的基础上优化后的产物，与 Observable
                            不是同一组观察者模式下的成员，Flowable 是 Publisher 与 Subscriber 这一组观察者模式中 Publisher
                            的典型实现，Observable 是 ObservableSource / Observer 这一组观察者模式中
                            ObservableSource 的典型实现；
                            所以在使用 Flowable 的时候，可观察对象不再是 Observable，而是 Flowable；观察者不再是 Observer，而是
                            Subscriber。Flowable 与 Subscriber 之间依然通过 subscribe() 进行关联。
                        </p>
                        <p>由于基于 Flowable 发射的数据流，以及对数据加工处理的各操作符都添加了背压支持，附加了额外的逻辑，其运行效率要比 Observable
                            低得多。
                            因为只有上下游运行在各自的线程中，且上游发射数据速度大于下游接收处理数据的速度时，才会产生背压问题。</p>
                        <pre class="brush: java;">
/** 使用 Observable 产生的背压问题：
 * 上游发送数据速度远大于下游接收数据的速度，造成上下游流速不均，导致数据累计，最后引起内存溢出。 */
Observable.create(new ObservableOnSubscribe&lt;Integer>() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer> emitter) throws Exception {
        int i = 0;
        while (true) {
            i++;
            emitter.onNext(i);
        }
    }
    }).observeOn(Schedulers.newThread())
    .subscribe(new Consumer&lt;Integer>() {
        @Override
        public void accept(Integer integer) throws Exception {
            Thread.sleep(5000);
            log(integer);
        }
    });
</pre>
                        <p>Flowable 的使用：</p>
                        <ol>
                            <li><p>create 方法中多了一个 BackpressureStrategy 类型的参数；</p></li>
                            <li><p>onSubscribe 回调的参数不是 Disposable 而是Subscription；</p></li>
                            <li><p>Flowable 发射数据时，使用的发射器是 FlowableEmitter 而不是 ObservableEmitter。</p>
                            </li>
                        </ol>
                        <p>Flowable 的异步缓存池不同于 Observable，Observable 的异步缓存池没有大小限制，可以无限制向里添加数据，直至
                            OOM,而 Flowable 的异步缓存池有个固定容量，其大小为 128。</p>
                        <p>BackpressureStrategy 的作用便是用来设置 Flowable 通过异步缓存池存储数据的策略。</p>
                        <pre class="brush: java;">
/** BackpressureStrategy 枚举类型:
 * ERROR -- 如果放入Flowable的异步缓存池中的数据超限了，则会抛出MissingBackpressureException异常。
 * DROP -- 如果Flowable的异步缓存池满了，会丢掉将要放入缓存池中的数据。
 * LATEST -- 与 Drop 策略一样，如果缓存池满了，会丢掉将要放入缓存池中的数据，不同的是，不管缓存池的状态如何，
                 LATEST 都会将最后一条数据强行放入缓存池中。
 * BUFFER -- Flowable 的异步缓存池同 Observable 的一样，没有固定大小，可以无限制向里添加数据，不会抛出
                 MissingBackpressureException 异常，但会导致 OOM。
 * MISSING -- 通过 Create 方法创建的 Flowable 没有指定背压策略，不会对通过 OnNext 发射的数据做缓存或丢弃处理，
                 需要下游通过背压操作符（onBackpressureBuffer()/onBackpressureDrop()/onBackpressureLatest()）
                 指定背压策略。
 */
Flowable.create(new FlowableOnSubscribe&lt;Integer>() {
        @Override
        public void subscribe(FlowableEmitter&lt;Integer> emitter) throws Exception {
            // 如果在这里发送 129 条数据，会触发异步缓存池存储数据的策略
        }
    }, BackpressureStrategy.BUFFER).subscribe(new Subscriber&lt;Integer>() {
        @Override
        public void onSubscribe(Subscription s) {
            // 这行代码可以指定接收的最大数量
            s.request(Integer.MAX_VALUE);
        }

        @Override
        public void onNext(Integer integer) {
            log(integer);
        }

        @Override
        public void onError(Throwable t) {}

        @Override
        public void onComplete() {}
    });
                            </pre>
                    </div>

                    <div class="sub-item">
                        <p><b>Single, Completable, Maybe -- 简化版的 Observable</b></p>
                        <ul>
                            <li><p><code>Single</code> --
                                只发射一条单一的数据，或者一条异常通知，不能发射完成通知，其中数据与通知只能发射一个。</p>
                                <pre class="brush: java;">
 Single.create(new SingleOnSubscribe&lt;String>() {
        @Override
        public void subscribe(SingleEmitter&lt;String> emitter) throws Exception {
            // onSuccess 和 onError 只能调用一个
            emitter.onSuccess("success");
            // emitter.onError("error");
        }
    }).subscribe(new SingleObserver&lt;String>() {
        @Override
        public void onSubscribe(Disposable d) {}

        @Override
        public void onSuccess(String s) {}

        @Override
        public void onError(Throwable e) {}
    });
</pre>
                            </li>
                            <li><p><code>Completable</code> --
                                只发射一条完成通知，或者一条异常通知，不能发射数据，其中完成通知与异常通知只能发射一个。</p>
                                <pre class="brush: java;">
Completable.create(new CompletableOnSubscribe() {
        @Override
        public void subscribe(CompletableEmitter emitter) throws Exception {
            // onComplete 和 onError 只能调用一个
            emitter.onComplete();
            // emitter.onError(new Exception("error"));
        }
    }).subscribe(new CompletableObserver() {
        @Override
        public void onSubscribe(Disposable d) {}

        @Override
        public void onComplete() {}

        @Override
        public void onError(Throwable e) {}
    });
</pre>
                            </li>
                            <li><p><code>Maybe</code> --
                                可发射一条单一的数据，以及发射一条完成通知，或者一条异常通知，其中完成通知和异常通知只能发射一个，发射数据只能在发射完成通知或者异常通知之前，否则发射数据无效。
                            </p>
                                <pre class="brush: java;">
Maybe.create(new MaybeOnSubscribe&lt;String>() {
        @Override
        public void subscribe(MaybeEmitter&lt;String> emitter) throws Exception {
            emitter.onSuccess("msg");
            emitter.onComplete();
        }
    }).subscribe(new MaybeObserver&lt;String>() {
        @Override
        public void onSubscribe(Disposable d) {}

        @Override
        public void onSuccess(String o) {}

        @Override
        public void onError(Throwable e) {}

        @Override
        public void onComplete() {}
    });
</pre>
                            </li>
                        </ul>
                    </div>

                    <div class="sub-item">
                        <p><a href="https://github.com/ReactiveX/RxAndroid" target="_blank">RxAndroid</a>
                            -- 是 RxJava 在 Android 上的一个扩展。</p>
                        <pre class="brush: java;">
compile 'io.reactivex.rxjava2:rxandroid:2.0.2'

/** 1.主线程中调度 */
Observable.just("one", "two", "three", "four", "five")
    .subscribeOn(Schedulers.newThread())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(...);

/** 2.指定的 Looper 中调度 */
Looper backgroundLooper = ...
Observable.just("one", "two", "three", "four", "five")
    .observeOn(AndroidSchedulers.from(backgroundLooper))
    .subscribe(...);
                            </pre>
                    </div>

                    <div class="sub-item">
                        <p><b>RxJava / RxAndroid</b> 使用 examples：</p>
                        <ol>
                            <li><p>简单的网络请求:</p>
                                <pre class="brush: java;">
/** 简单的网络请求
 * 1.通过 Observable.create() 方法，调用 OkHttp 网络请求；
 * 2.通过 map 操作符集合 gson，将 Response 转换为 bean 类；
 * 3.通过 doOnNext() 方法，解析 bean 中的数据，并进行数据库存储等操作；
 * 4.调度线程，在子线程中进行耗时操作任务，在主线程中更新 UI ；
 * 5.通过 subscribe()，根据请求成功或者失败来更新 UI 。
 */
Observable.create(new ObservableOnSubscribe&lt;Response>() {
        @Override
        public void subscribe(@NonNull ObservableEmitter&lt;Response> e) throws Exception {
            // 工作线程，执行请求
            Request.Builder builder = new Request.Builder().url(url).get();
            Request request = builder.build();
            Call call = new OkHttpClient().newCall(request);
            Response response = call.execute();
            e.onNext(response);
        }
    }).map(new Function&lt;Response, MobileAddress>() {
        @Override
        public MobileAddress apply(@NonNull Response response) throws Exception {
            // 工作线程，转换数据
            if (response.isSuccessful()) {
                ResponseBody body = response.body();
                if (body != null) {
                    return new Gson().fromJson(body.string(), MobileAddress.class);
                }
            } return null;
        }
    }).observeOn(AndroidSchedulers.mainThread()) // 让 doOnNext 方法执行在主线程
    .doOnNext(new Consumer&lt;MobileAddress>() {
        @Override
        public void accept(@NonNull MobileAddress s) throws Exception {
            // 主线程，可以对数据执行保存等操作
        }
    }).subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread()) // 让下面的两个方法执行在主线程
    .subscribe(new Consumer&lt;MobileAddress>() {
        @Override public void accept(@NonNull MobileAddress data) throws Exception {
            // 主线程，获取成功，更新 UI
        }
    }, new Consumer&lt;Throwable>() {
        @Override
        public void accept(@NonNull Throwable throwable) throws Exception {
            // 主线程，获取失败，更新 UI
        }
    });
</pre>
                            </li>
                            <li><p>先读取缓存，如果缓存没数据再通过网络请求获取数据:</p>
                                <pre class="brush: java;">
/** concat 可以做到不交错的发射两个甚至多个 Observable 的发射事件，并且只有前一个 Observable 终止(onComplete())
 * 后才会定义下一个 Observable。利用这个特性，我们就可以先读取缓存数据，倘若获取到的缓存数据不是我们想要的，再调用
 * onComplete() 以执行获取网络数据的 Observable，如果缓存数据能应我们所需，则直接调用 onNext() ，防止过度的
 * 网络请求，浪费用户的流量。
 */
// 1.本地 Observable
Observable&lt;FoodList> cache = Observable.create(new ObservableOnSubscribe&lt;FoodList>() {
        @Override
        public void subscribe(@NonNull ObservableEmitter&lt;FoodList> e) throws Exception {
            // 工作线程，尝试读取本地数据
            FoodList data = CacheManager.getInstance().getFoodListData();
            // 在操作符 concat 中，只有调用 onComplete 之后才会执行下一个 Observable
            if (data != null) { // 如果缓存数据不为空，则直接读取缓存数据，而不读取网络数据
                isFromNet = false;
                e.onNext(data);
            } else {
                isFromNet = true;
                e.onComplete();
            }
        }
    });

// 2.网络 Observable, 这里使用 Rx2AndroidNetworking 来获取网络请求，这个库是对 RxJava 的封装
Observable&lt;FoodList> network = Rx2AndroidNetworking.get("http://www.tngou.net/api/food/list")
    .addQueryParameter("rows", 10 + "")
    .build()
    .getObjectObservable(FoodList.class);

// 3.使用 concat 操作符连接成一个发射器， 两个 Observable 的泛型应当保持一致
Observable.concat(cache, network)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Consumer&lt;FoodList>() {
        @Override
        public void accept(@NonNull FoodList tngouBeen) throws Exception {
            // 获取成功，更新 UI，isFromNet 是成员变量，可以判断数据来源本地还是网络
            if (isFromNet) {

            }

        }
    }, new Consumer&lt;Throwable>() {
        @Override
        public void accept(@NonNull Throwable throwable) throws Exception {
            // 获取失败，更新 UI
        }
    });
</pre>
                            </li>
                            <li><p>多个网络请求依次依赖:</p>
                                <pre class="brush: java;">
/** flatMap 操作符可以将一个发射数据的 Observable 变换为多个 Observables ，然后将它们发射的数据合并后
 * 放到一个单独的 Observable
 * 例如用户注册成功后需要自动登录，我们只需要先通过注册接口注册用户信息，注册成功后马上调用登录接口进行自动登录即可。
 */
Rx2AndroidNetworking.get("http://www.tngou.net/api/food/list")
    .addQueryParameter("rows", 1 + "")
    .build()
    .getObjectObservable(FoodList.class) // 发起获取食品列表的请求，并解析到FootList
    .subscribeOn(Schedulers.io()) // 在io线程进行网络请求
    .observeOn(AndroidSchedulers.mainThread()) // 在主线程处理获取食品列表的请求结果
    .doOnNext(new Consumer&lt;FoodList>() {
        @Override
        public void accept(@NonNull FoodList foodList) throws Exception {
            // 主线程，先根据获取食品列表的响应结果做一些操作
        }
    }).observeOn(Schedulers.io()) // 回到 io 线程去处理获取食品详情的请求
    .flatMap(new Function&lt;FoodList, ObservableSource&lt;FoodDetail>>() {
        @Override
        public ObservableSource&lt;FoodDetail> apply(@NonNull FoodList foodList) throws Exception {
            if (foodList != null && foodList.getTngou() != null && foodList.getTngou().size() > 0) {
                return Rx2AndroidNetworking.post("http://www.tngou.net/api/food/show")
                        .addBodyParameter("id", foodList.getTngou().get(0).getId() + "")
                        .build()
                        .getObjectObservable(FoodDetail.class);
            }
            return null;
        }
    }).observeOn(AndroidSchedulers.mainThread()).subscribe(new Consumer&lt;FoodDetail>() {
        @Override
        public void accept(@NonNull FoodDetail foodDetail) throws Exception {
            // 主线程，获取成功，更新 UI
        }
    }, new Consumer&lt;Throwable>() {
        @Override
        public void accept(@NonNull Throwable throwable) throws Exception {
            // 主线程，获取失败，更新 UI
        }
    });
</pre>
                            </li>
                            <li><p>结合多个接口的数据更新 UI:</p>
                                <pre class="brush: java;">
/** zip 操作符可以将多个 Observable 的数据结合为一个数据源再发射出去。
 * 在实际应用中，我们极有可能会在一个页面显示的数据来源于多个接口
 */
Observable&lt;MobileAddress> observable1 = Rx2AndroidNetworking.get(url)
    .build()
    .getObjectObservable(MobileAddress.class);

Observable&lt;CategoryResult> observable2 = Network.getGankApi()
    .getCategoryData("Android", 1, 1);

Observable.zip(observable1, observable2, new BiFunction&lt;MobileAddress, CategoryResult, String>() {
        @Override
        public String apply(@NonNull MobileAddress mobileAddress,
                             @NonNull CategoryResult categoryResult) throws Exception {
            // 结合为一个数据源
            return mobileAddress.getResult()  + categoryResult.getResult();
        }
    }).subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Consumer&lt;String>() {
        @Override
        public void accept(@NonNull String s) throws Exception {
            // 主线程，获取成功，更新 UI
        }
    }, new Consumer&lt;Throwable>() {
        @Override
        public void accept(@NonNull Throwable throwable) throws Exception {
            // 主线程，获取失败，更新 UI
        }
    });
</pre>
                            </li>
                        </ol>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="other-DBFlow"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">DBFlow</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <p><a href="https://github.com/Raizlabs/DBFlow" target="_blank">DBFlow</a>
                            是一个基于 注解处理器(AnnotationProcessing)的强大、健壮同时又简单的 ORM 框架。</p>
                        <p>
                            <a href="https://yumenokanata.gitbooks.io/dbflow-tutorials/content/index.html"
                               target="_blank">官方文档中文译文</a> -- <b>注意： 这个版本不是本文使用的版本，文中的 android-apt 已经不需要，直接使用
                            annotationProcessor。另外，文中的一些 API 也不再使用了。</b></p>
                        <ul>
                            <li><p><strong>扩展性</strong>： ORM 所需的数据类只需要实现<code>Model</code>接口即可，而不需要必须继承一个类，同时为了方便，我们还是推荐继承<code>BaseModel</code>，这是<code>Model</code>接口的一个标准实现。这样你既可以通过继承一个来自其他包的非<code>Model</code>类来生成你的数据库表，也可以通过继承一个<code>Model</code>类并通过添加<code>@Column</code>注解的属性向表中自由添加列。这一切都是为了方便你的使用。</p></li>
                            <li><p><strong>速度</strong>：DBFlow 基于 AnnotationProcessing(注解处理器），通过编译期代码生成，运行时对性能是零损耗的。通过模板来为你维护生成的代码。通过缓存和尽可能地重用对象，我们得到了比原生 SQLite 更快的速度。同时我们还支持懒加载（lazy-loading），比如对于<code>@ForeignKey</code>和<code>@OneToMany</code>，这使得我们有着更高效得查询效率。</p></li>
                            <li><p><strong>SQLite 查询流(SQLite Query Flow)</strong>： DBFlow 的查询语法尽可能地和 SQL 语句相似，使您能更快上手。</p></li>
                            <li><p><strong>开源</strong>： 整个 DBFlow 库都是开源的，而且也非常欢迎大家来为这个库贡献自己的力量。</p></li>
                            <li><p><strong>Robust</strong>： 支持<code>Trigger</code>,<code>ModelView</code>,<code>Index</code>,<code>Migration</code>,所有的数据库操作都在同一个线程（线程安全），还有其他特性。</p></li>
                            <li><p><strong>多数据库、多表单</strong>： 无缝支持多数据库文件。</p></li>
                            <li><p><strong>基于 SQLite</strong>： SQLite 是世界上使用最广泛的数据库引擎，基于 SQLite 的 DBFlow 使你不需要被限制在某些平台上。</p></li>
                        </ul>
                        <pre class="brush: java;">
// DBFlow 库未发布在 MavenCenter 或 jCenter，在 jitpack.io 上
repositories {
    maven { url "https://www.jitpack.io" }
}

def dbflow_version = "4.2.4"

annotationProcessor "com.github.Raizlabs.DBFlow:dbflow-processor:${dbflow_version}"
compile "com.github.Raizlabs.DBFlow:dbflow-core:${dbflow_version}"
compile "com.github.Raizlabs.DBFlow:dbflow:${dbflow_version}"

// DBFlow 可以配合 RxJava2 使用，如果需要，可以引入 DBFlow RXJava2 支持
compile "com.github.Raizlabs.DBFlow:dbflow-rx2:${dbflow_version}"

// 在 Application 中初始化
FlowManager.init(this);
</pre>
                    </div>

                    <div class="sub-item">
                        <p><b>DBFlow 使用</b></p>
                        <ul>
                            <li><p>简单的增，删，改，查</p>
                            <pre class="brush: java;">
/** 1.创建数据库，指定 DB 的名字和版本 */
@Database(name = DBFlowDatabase.NAME, version = DBFlowDatabase.VERSION)
public class DBFlowDatabase {
    // 数据库名称
    public static final String NAME = "DBFlowDatabase";
    // 数据库版本号
    public static final int VERSION = 1;
}

/** 2.创建表，指定所在 DB，表名和字段
 * 表名可以不指定，根据类名自动生成，默认生成为：类名_Table
 * 可以实现 Model 接口，推荐继承 BaseModel 类
 */
@Table(database = DBFlowDatabase.class)
public class Book extends BaseModel {
    // 自增 ID
    @PrimaryKey(autoincrement = true)
    public Long id;

    @Column
    public String name;

    @Column
    public String subject;
}

/** 3.数据操作 -- 增，删，改，查 */
Book book = new Book();
book.name = "Linux Kernel";
book.subject = "Compute";
book.save();        // 插入数据

book = new Book();
book.name = "Android Developer";
book.subject = "Computer";
book.save();        // 插入数据

// 查询全部数据
List&lt;Book> books = SQLite.select().from(Book.class).queryList();
for (Book item: books) {
    AppUtil.logDebug(item.id + ":" + item.name + ":" + item.subject);
}

// 查询 id = 1 的 Book, Book_Table 为自动生成的类, 必须先 'Make Project' 生成这个类
Book query = SQLite.select().from(Book.class).where(Book_Table.id.eq(1L)).querySingle();
if(null != query) {
    AppUtil.logDebug("id = 1:" + query.id + ":" + query.name + ":" + query.subject);

    query.subject = "Tools";
    query.update();     // 更新数据

    books = SQLite.select().from(Book.class).queryList();
    for (Book item: books) {
        AppUtil.logDebug("after update:" + item.id + ":" + item.name + ":" + item.subject);
    }

    query.delete();     // 删除数据

    books = SQLite.select().from(Book.class).queryList();
    for (Book item: books) {
        AppUtil.logDebug("after delete:" + item.id + ":" + item.name + ":" + item.subject);
    }
}
</pre>
                            </li>
                            <li><p>数据库中查找数据</p>
                                <pre class="brush: java;">
// 查询列表
SQLite.select().from(SomeTable.class).queryList();
SQLite.select().from(SomeTable.class).where(conditions).queryList();

// 查询单个数据
SQLite.select().from(SomeTable.class).querySingle();
SQLite.select().from(SomeTable.class).where(conditions).querySingle();

// 异步操作
SQLite.select().from(Menu.class).async().queryListResultCallback(
                                    new QueryTransaction.QueryResultListCallback&lt;Menu>() {
    @Override
    public void onListQueryResult(QueryTransaction transaction, @NonNull List&lt;Menu> tResult) {

    }
});

// Query a Table List and Cursor List
SQLite.select().from(SomeTable.class).where(conditions).queryTableList();
SQLite.select().from(SomeTable.class).where(conditions).queryCursorList();

// SELECT methods
SQLite.select().distinct().from(table).queryList();
SQLite.select().from(table).queryList();
SQLite.select(Method.avg(SomeTable_Table.salary)).from(SomeTable.class).queryList();
SQLite.select(Method.max(SomeTable_Table.salary)).from(SomeTable.class).queryList();

// Oeder By: true 为'ASC'正序, false 为'DESC'反序
SQLite.select().from(table).where().orderBy(Customer_Table.customer_id, true).queryList();

// LIMIT + OFFSET (分页)
SQLite.select().from(table).limit(3).offset(2).queryList();
                                </pre>
                            </li>
                            <li><p>事务处理, 当数据太多时，应该使用事务处理</p>
                            <pre class="brush: java;">
ArrayList&lt;User> users = new ArrayList<>();

FlowManager.getDatabase(AppDatabase.class)
    .beginTransactionAsync(new ProcessModelTransaction.Builder<>(
    new ProcessModelTransaction.ProcessModel&lt;User>() {
        @Override
        public void processModel(User user) {
            // do work here -- i.e. user.delete() or user.update()
            user.save();
        }
    }).addAll(users).build())  // add elements (can also handle multiple)
    .error(new Transaction.Error() {
        @Override
        public void onError(Transaction transaction, Throwable error) {

        }
    })
    .success(new Transaction.Success() {
        @Override
        public void onSuccess(Transaction transaction) {

        }
    }).build().execute();
</pre>
                            </li>
                            <li><p>结合 RxJava2 使用</p>
                            <pre class="brush: java;">


RXSQLite.rx(SQLite.select().from(Book.class))
    .queryList()
    .subscribe(new Consumer&lt;List&lt;Book>>() {
        @Override
        public void accept(List&lt;Book> books) throws Exception {

        }
    });
</pre>
                            </li>
                        </ul>
                    </div>


                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="other-EventBus"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">EventBus</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <p>
                            官网地址 --
                            <a href="http://greenrobot.org/eventbus/" target="_blank">EventBus</a>
                            &nbsp;&nbsp;GitHub 地址 --
                            <a href="https://github.com/greenrobot/EventBus" target="_blank">EventBus</a>
                            &nbsp;&nbsp;JAR 包 --
                            <a href="lib/eventbus-3.0.0.jar">EventBus-3.0.0.jar</a>
                        </p>
                        <p>EventBus 是一款针对 Android 优化的发布/订阅事件总线。主要功能是替代 Intent,
                            Handler, BroadCast 在 Fragment，
                            Activity，Service，线程之间传递消息。优点是开销小，代码更优雅。以及将发送者和接收者解耦。</p>
                        <p>EventBus
                            是一个消息总线，以观察者模式实现，用于简化程序的组件、线程通信，可以轻易切换线程、开辟线程。EventBus3.0
                            跟先前版本的区别在于加入了 annotation @Subscribe，取代了以前约定命名的方式。</p>
                        <p width="100%">
                            <img style="height: 180px;"
                                 src="images/EventBus-Publish-Subscribe.png"
                                 class="img-responsive center-block">
                        </p>
                    </div>

                    <div class="sub-item">
                        <h5 class="text-primary">EventBus 使用三部曲</h5>
                        <ol type="I">
                            <li>
                                定义事件
                                <pre class="brush: java;">
public class MessageEvent {
	public final String message;

    public MessageEvent(String message) {
        this.message = message;
    }
}
</pre>
                            </li>
                            <li>
                                准备订阅者
                                <pre class="brush: java;">
//** EventBus 使用 @Subscribe 注解来标识接收消息的方法, 注意 EventBus 根据参数来确定消息接收的方法 */
@Subscribe
public void onMessageEvent(MessageEvent event){
	Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show();
}

@Subscribe
public void handleSomethingElse(SomeOtherEvent event){
    doSomethingWith(event);
}

//** 在适当的生命周期中注册和反注册EventBus */
@Override
public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
}

@Override
public void onStop() {
   EventBus.getDefault().unregister(this);
    super.onStop();
}
</pre>
                            </li>
                            <li>
                                发送事件
                                <pre class="brush: java;">
//** 消息发送根据接收方法参数类型来确定接收方法 */
EventBus.getDefault().post(new MessageEvent("Hello everyone!"));

//** 此方法就调用上面的　handleSomethingElse 方法 */
EventBus.getDefault().post(new SomeOtherEvent("Hello everyone!"));
</pre>
                            </li>
                        </ol>
                    </div>


                    <div class="sub-item">
                        <h5 class="text-primary">ThreadMode</h5>
                        <p>EventBus 可以很简单的实现线程间的切换，包括后台线程、UI线程、异步线程。</p>
                        <ul>
                            <li>
                                <b>ThreadMode.POSTING</b> -- 默认调用方式，在调用 post
                                方法的线程执行，避免了线程切换，性能开销最少
                                <pre class="brush: java;">
@Subscribe(threadMode = ThreadMode.POSTING)
public void onMessage(MessageEvent event) {
    log(event.message);
}
</pre>
                            </li>
                            <li>
                                <b>ThreadMode.MAIN</b> -- 在 Anroid UI 线程中执行, 这种模式可以用来替代主线程中的
                                Handler 更新 UI 等操作
                                <pre class="brush: java;">
@Subscribe(threadMode = ThreadMode.MAIN)
public void onMessage(MessageEvent event) {
    textField.setText(event.message);
}
</pre>
                            </li>
                            <li>
                                <b>ThreadMode.BACKGROUND</b> -- 如果调用 post 方法的线程不是主线程，则直接在该线程执行;
                                如果是主线程，则切换到后台单例线程，多个方法公用同个后台线程，按顺序执行，避免耗时操作
                                <pre class="brush: java;">
@Subscribe(threadMode = ThreadMode.BACKGROUND)
public void onMessage(MessageEvent event){
    saveToDisk(event.message);
}
</pre>
                            </li>
                            <li>
                                <b>ThreadMode.ASYNC</b> -- 开辟新独立线程，用来执行耗时操作，例如网络访问。EventBus
                                内部使用了线程池，但是要尽量避免大量长时间运行的异步线程，限制并发线程数量, 可以通过 EventBusBuilder
                                修改，默认使用 Executors.newCachedThreadPool()
                                <pre class="brush: java;">
@Subscribe(threadMode = ThreadMode.ASYNC)
public void onMessage(MessageEvent event){
    backend.send(event.message);
}
</pre>
                            </li>
                        </ul>
                        <p>
                            <b>实例验证 ThreadMode 的 ４ 种模式</b>
                        </p>
                        <pre class="brush: java;">
// 默认为 @Subscribe(threadMode = ThreadMode.POSTING) 
@Subscribe
public void onEventPosting(FirstEvent event) {
	System.out.println("onEventPosting==" + Thread.currentThread().getId()
			+ "==" + event.getMsg());
}

// 此方法验证高优先级订阅者先收到消息
@Subscribe(priority = 1)
public void onEventPostingHighPriority(FirstEvent event) {
	System.out.println("onEventPostingHighPriority=="
			+ Thread.currentThread().getId() + "==" + event.getMsg());
}

// 此方法总是在 UI 线程中运行
@Subscribe(threadMode = ThreadMode.MAIN)
public void onEventMain(FirstEvent event) {
	System.out.println("onEventMain==" + Thread.currentThread().getId()
			+ "==" + event.getMsg());
}

// 此方法总是在非 UI 线程中运行
@Subscribe(threadMode = ThreadMode.BACKGROUND)
public void onEventBackGround(FirstEvent event) {
	System.out.println("onEventBackGround=="
			+ Thread.currentThread().getId() + "==" + event.getMsg());
}

// 此方法总是在新线程中运行
@Subscribe(threadMode = ThreadMode.ASYNC)
public void onEventAsync(FirstEvent event) {
	System.out.println("onEventAsync==" + Thread.currentThread().getId()
			+ "==" + event.getMsg());
}

public void execute() {
	// 1.在主线程中发送一条消息
	EventBus.getDefault().post(new FirstEvent("主线程中发送的消息!"));
	/** 输出:
	 * onEventPostingHighPriority==1==主出线程中发送的消息!
	 * onEventPosting==1==主线程中发送的消息!
	 * onEventAsync==4565==主线程中发送的消息!
	 * onEventMain==1==主线程中发送的消息!
	 * onEventBackGround==4566==主线程中发送的消息!
	 */
	
	// 2.在子线程中发送一条消息
	new Thread(new Runnable() {
		@Override
		public void run() {
			EventBus.getDefault().post(new FirstEvent("子线程中发送的消息!"));
		}
	}).start();
	/** 输出:
	 * onEventPostingHighPriority==4813==子线程中发送的消息!
	 * onEventAsync==4811==子线程中发送的消息!
	 * onEventBackGround==4813==子线程中发送的消息!
	 * onEventPosting==4813==子线程中发送的消息!
	 * onEventMain==1==子线程中发送的消息!
	 */
}
</pre>
                    </div>

                    <div class="sub-item">
                        <h5 class="text-primary">配置 EventBusBuilder</h5>
                        <p>EventBus 提供了很多配置，一般的情况下我们可以不用配置。但是，如果你有一些其他要求,
                            比如控制日志在开发的时候输出, 发布的时候不输出，在开发的时候错误崩溃，而发布的时候不崩溃...等情况。</p>
                        <pre class="brush: java;">
//** EventBus 提供了一个默认的实现，但不是单例。*/
EventBus eventBus = new EventBus();
// 下面这一条的效果是完全一样的
EventBus eventBus = EventBus.builder().build();
// 修改默认实现的配置，记住，必须在第一次 EventBus.getDefault() 之前配置，且只能设置一次。建议在 application 中调用
EventBus.builder().throwSubscriberException(BuildConfig.DEBUG).installDefaultEventBus();
</pre>
                    </div>

                    <div class="sub-item">
                        <h5 class="text-primary">StickyEvent</h5>
                        <p>StickyEvent
                            在内存中保存最新的消息，取消原有消息，执行最新消息，只有在注册后才会执行，如果没有注册，消息会一直保留来内存中。</p>
                        <pre class="brush: java;">
// 在注册之前发送消息
EventBus.getDefault().postSticky(new MessageEvent("Hello everyone!"));

@Override
public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
}

// 在onStart调用register后，执行消息
@Subscribe(sticky = true, threadMode = ThreadMode.MAIN)
public void onEvent(MessageEvent event) {
    // UI updates must run on MainThread
    textField.setText(event.message);
}

@Override
public void onStop() {
    EventBus.getDefault().unregister(this);
    super.onStop();
}
</pre>
                    </div>

                    <div class="sub-item">
                        <h5 class="text-primary">事件优先级和事件中止</h5>
                        <p>EventBus 发送的消息，所有的订阅者都能收到。EventBus 提供了 priority
                            来设置事件订阅者接收消息的顺序，级别越高的，先收到消息。</p>
                        <div class="alert alert-warning">注意：优先级不会影响不同线程模式下的订阅者接收事件的顺序。</div>
                        <pre class="brush: java;">
@Subscribe(priority = 1);
public void onEvent(MessageEvent event) {
	log(event.message);
}
</pre>
                        <p>EventBus 在事件传递过程中，能够中止事件传递，后续事件不在调用。</p>
                        <div class="alert alert-warning">事件取消仅限于
                            ThreadMode.PostThread 下才可以使用。
                        </div>
                        <pre class="brush: java;">
@Subscribe
public void onEvent(MessageEvent event){
    …
    EventBus.getDefault().cancelEventDelivery(event) ;
}
</pre>
                    </div>

                    <div class="sub-item">
                        <h5 class="text-primary">EventBus3.0 性能优化之添加索引</h5>
                        <p>EventBus 使用了 annotation，默认在编译时生成代码，生成索引，添加 index
                            后会在编译时运行，自动生成相应代码。</p>
                        <div class="alert alert-warning">由于 apt 的限制，匿名内部类中的
                            annotation 不会被识别，会自动降级在运行时反射，此时，效率会降低
                        </div>
                        <p>解决方法:</p>
                        <ol>
                            <li>
                                为要在编译时生成索引文件，在 build.grade 文件中添加如下代码:
                                <pre class="brush: groovy;">
buildscript {
    dependencies {
        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
    }
}
apply plugin: 'com.neenbedankt.android-apt'
dependencies {
    compile 'org.greenrobot:eventbus:3.0.0'
    apt 'org.greenrobot:eventbus-annotation-processor:3.0.1'
}
apt {
    arguments {
    	// 这个名字可以随便写，意思是要在编译时生成使用这个类名的索引文件，所以不能与已有的类冲突
        eventBusIndex "xx.yy.MyEventBusIndex"
    }
}
</pre>
                            </li>

                            <li>
                                上面的步骤生成了
                                <code>MyEventBusIndex.class</code>
                                这个类，配置 EventBus 使用这个索引:
                                <pre class="brush: java;">
EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();
</pre>
                            </li>
                            </ul>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="other-ButterKnife"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">ButterKnife</h3>
                </div>
                <div class="panel-body">
                    <p>Butter Knife，专门为 Android View 设计的绑定注解，专业解决各种 <code>findViewById</code> 和 <code>OnClickListener</code>。项目主页为：<a
                            href="http://jakewharton.github.io/butterknife/">http://jakewharton.github.io/butterknife/</a>
                    </p>
                    <pre class="brush: java;">
// 引入 butterknife，还需要 butterknife 的注解处理器
compile 'com.jakewharton:butterknife:8.4.0'
annotationProcessor 'com.jakewharton:butterknife-compiler:8.4.0'

class ExampleActivity extends Activity {
    // 绑定 View
    @BindView(R.id.title) TextView title;
    @BindView(R.id.subtitle) TextView subtitle;
    @BindView(R.id.footer) TextView footer;

    // 绑定资源
    @BindString(R.string.title) String title;
    @BindDrawable(R.drawable.graphic) Drawable graphic;
    @BindColor(R.color.red) int red; // int or ColorStateList field
    @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field


    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.simple_activity);
        ButterKnife.bind(this);     // Activity 中初始化 ButterKnife
    }

    @OnClick(R.id.button)           // onClick 事件
    public void onClick(View v) {}

    @OnClick({R.id.btn1, R.id.btn2})    // 多个 View 的 onClick 事件
    public void onClick(View v) {}
}

public class FancyFragment extends Fragment {
    @BindView(R.id.button1) Button button1;
    @BindView(R.id.button2) Button button2;

    @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, 
								Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fancy_fragment, container, false);
        ButterKnife.bind(this, view);   // Fragment 中初始化

        return view;
    }
}
</pre>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="libs-"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">...</h3>
                </div>
                <div class="panel-body"></div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="libs-"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">...</h3>
                </div>
                <div class="panel-body"></div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="libs-"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">...</h3>
                </div>
                <div class="panel-body"></div>
            </div>
            <!-- item over -->

        </div>
    </div>
</div>

<div class="btn-group-vertical bottom-button">
    <a href="#" type="button"
       class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
        <span class="caret"></span>
    </a>
    <a href="#" type="button"
       class="btn btn-default dropdown-toggle btn-primary"
       data-toggle="dropup"> TOP </a>
    <a href="docs/reference/index.html" type="button"
       class="btn btn-default dropdown-toggle btn-primary" target="_blank"
       data-toggle="dropup"> DOCS </a>
    <a href="docs/guide/index.html" type="button"
       class="btn btn-default dropdown-toggle btn-primary" target="_blank"
       data-toggle="dropup"> GUIDE </a>
</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="../support/jquery/jquery-3.1.1.min.js"></script>
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../support/bootstrap/js/bootstrap.min.js"></script>
<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
<script src="../support/syntaxhighlighter/scripts/shBrushGroovy.js"></script>
<script src="res/menu.js"></script>
<script src="../commons/js/common.js"></script>
</body>
</html>
