<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport"
          content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="keywords" content="key1, key2"/>
    <meta name="description" content=””>
    <meta name="author" content="nate">
    <meta name="author" content="nate &lt;jiwanger@126.com&gt;">
    <link href="images/favicon.ico" rel="bookmark" type="image/x-icon"/>
    <link href="images/favicon.ico" rel="icon" type="image/x-icon"/>
    <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
    <title>NATE--笔记--DRAWABLE</title>
    <!-- Bootstrap -->
    <link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
          rel="stylesheet">
    <!--
    <link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
    -->
    <link type="text/css" rel="stylesheet"
          href="../support/syntaxhighlighter/styles/shCoreDefault.css"/>
    <link href="../commons/css/common.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<!-- nav start -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse"
                    data-target="#bs-example-navbar-collapse-1">
                <span class="icon-bar"></span> <span class="icon-bar"></span> <span
                    class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../index.html">
                <img src="../commons/images/icon.png">
            </a>
        </div>

        <div class="collapse navbar-collapse"
             id="bs-example-navbar-collapse-1">
            <ul id="my-nav" class="nav navbar-nav">

            </ul>
        </div>
    </div>
</nav>
<!-- nav end -->


<div class="container">
    <div class="row">
        <!-- left-menu start -->
        <div class="col-md-3">
            <div class="panel panel-default"
                   id="left_menu_modify">
                <div class="panel-heading">
                    <h3 class="panel-title">DRAWABLE</h3>
                </div>
                <div class="list-group">
                    <a href="#" class="list-group-item">Drawable 简介</a>
                    <a href="#drawable-Drawable" class="list-group-item">
                        Drawable 类
                    </a>
                    <a href="#drawable-custom" class="list-group-item">
                        自定义 Drawable
                    </a>
                    <a href="#drawable-dir" class="list-group-item">
                        <code>drawable</code>
                        目录
                    </a>
                    <a class="list-group-item active dropup" data-toggle="collapse"
                       data-parent="#accordion" href="#drawable-sub"
                       aria-expanded="true">
                        Drawable 子类<span class="caret pull-right"
                                         style="margin-top: 5px;"></span>
                    </a>
                    <div id="drawable-sub" class="panel-collapse collapse in"
                         role="tabpanel">
                        <a href="#BitmapDrawable" class="list-group-item">BitmapDrawable</a>
                        <a href="#ColorDrawable" class="list-group-item">ColorDrawable</a>
                        <a href="#ShapeDrawable" class="list-group-item">ShapeDrawable 及子类</a>
                        <a href="#GradientDrawable" class="list-group-item">GradientDrawable</a>
                        <a href="#NinePatchDrawable" class="list-group-item">NinePatchDrawable</a>
                        <a href="#PictureDrawable" class="list-group-item">PictureDrawable</a>

                        <a href="#LayerDrawable" class="list-group-item">LayerDrawable 及子类</a>
                        <a href="#DrawableWrapper" class="list-group-item">DrawableWrapper 及子类</a>
                        <a href="#DrawableContainer" class="list-group-item">DrawableContainer 及子类</a>

                        <a href="#VectorDrawable" class="list-group-item">VectorDrawable</a>
                        <a href="#AnimatedVectorDrawable" class="list-group-item">AnimatedVectorDrawable</a>
                    </div>
                    <a href="#java-class-loader" class="list-group-item">...</a>
                </div>
            </div>
        </div>
        <!-- left-menu over -->
    </div>
</div>


<div class="container" style="margin-top: 70px;">
    <div class="row">
        <div class="col-md-9 col-md-push-3" style="float: left;">
            <!-- item start -->
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Drawable 简介</h3>
                </div>
                <div class="panel-body">
                    <p><a href="docs/reference/android/graphics/drawable/Drawable.html"
                          target="_blank">Drawable</a> 一般抽象为“能被绘制的东西”。相比于 View，并不需要去考虑
                        measure、layout，仅仅只要去考虑如何 draw（canavs）。</p>
                    <h5 class="text-primary">Drawable 的用法：</h5>
                    <ul>
                        <li>
                            <p>
                                <b>自定义Drawable</b> -- 相比View来说，Drawable
                                属于轻量级的、使用也很简单。以后自定义实现一个效果的时候，可以改变 View first 的思想，尝试下 Drawable
                                first。
                            </p>
                        </li>
                        <li>
                            <p>
                                <b>自定义状态</b> -- 相信大家对于State Drawable都不陌生，但是有没有尝试过去自定义一个状态呢？
                            </p>
                        </li>

                        <li>
                            <p>
                                <b>UI Perfermance</b> -- 利用 Drawable 提升我们的 UI Perfermance， 如何利用
                                Drawable 去提升我们的UI的性能。
                            </p>
                        </li>
                    </ul>
                    <p>一般情况下，除了直接使用放在 drawable 下的图片，其实的 Drawable 的用法都和 xml
                        相关，我们可以使用 shape、layer-list 等标签绘制一些背景，还可以通过 selector 标签定义 View
                        的状态的效果等。当然了基本每个标签都对应于一个真正的实体类，关系如下：</p>
                    <p>
                        <img src="res/drawable_type.png"
                             class="img-responsive center-block">
                    </p>


                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="drawable-Drawable"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">Drawable 类</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
						<pre class="brush: java;">
java.lang.Object
	android.graphics.drawable.Drawable

public abstract class Drawable {
	/** 内部类 */
	public static interface Drawable.Callback {
		// 自身需要重绘时的处理逻辑
		public void invalidateDrawable(Drawable who);
		// 下面两个主要用于动画处理
		public void scheduleDrawable(Drawable who, Runnable what, long when);
		public void unscheduleDrawable(Drawable who, Runnable what);
	}

    /**  */
	public static abstract class ConstantState {
		public boolean canApplyTheme();
		public abstract int getChangingConfigurations();
		public Drawable newDrawable(Resources res);
		public abstract Drawable newDrawable();
		public Drawable newDrawable(Resources res, Resources.Theme theme);
	}
}
</pre>
                        <p>
                            图形图像的绘制需要在画布上进行操作和处理，但是绘制需要了解很多细节以及可能要进行一些复杂的处理，这样就会增加学习和使用的成本，因此系统提供了一个被称之为 <a href="docs/reference/android/graphics/drawable/Drawable.html">Drawable</a> 的类来进行绘制处理。</p>
                        <p>通过 <a href="docs/reference/android/graphics/drawable/Drawable.html">Drawable</a> 类可以减少我们的绘制工作和使用成本，同时系统也提供了众多的 <a href="docs/reference/android/graphics/drawable/Drawable.html">Drawable</a> 的派生类比如单色、图形、位图、裁剪、动画等等来完成一些常见的绘制需求。<a href="docs/reference/android/graphics/drawable/Drawable.html">Drawable</a> 是一个抽象的可绘制类。</p>
                        <p><a href="docs/reference/android/graphics/drawable/Drawable.html">Drawable</a> 类主要是提供了一个可绘制的区域 bound 属性以及一个 draw 成员函数，不同的派生类通过重载 draw 函数的实现而产生不同的绘制结果。</p>
                        <p><a href="docs/reference/android/graphics/drawable/Drawable.html">Drawable</a> 解析使用了一个 <code>@hide</code> 类：<code>DrawableInflater</code>，支持以下标签：</p>
                        <pre class="brush: java;">
private Drawable inflateFromTag(@NonNull String name) {
    switch (name) {
        case "selector":
            return new StateListDrawable();
        case "animated-selector":
            return new AnimatedStateListDrawable();
        case "level-list":
            return new LevelListDrawable();
        case "layer-list":
            return new LayerDrawable();
        case "transition":
            return new TransitionDrawable();
        case "ripple":
            return new RippleDrawable();
        case "adaptive-icon":
            return new AdaptiveIconDrawable();
        case "color":
            return new ColorDrawable();
        case "shape":
            return new GradientDrawable();
        case "vector":
            return new VectorDrawable();
        case "animated-vector":
            return new AnimatedVectorDrawable();
        case "scale":
            return new ScaleDrawable();
        case "clip":
            return new ClipDrawable();
        case "rotate":
            return new RotateDrawable();
        case "animated-rotate":
            return new AnimatedRotateDrawable();
        case "animation-list":
            return new AnimationDrawable();
        case "inset":
            return new InsetDrawable();
        case "bitmap":
            return new BitmapDrawable();
        case "nine-patch":
            return new NinePatchDrawable();
        default:
            return null;
    }
}

                        </pre>
                    </div>

                    <div class="sub-item">
                        <p>
                            <a href="docs/reference/android/graphics/drawable/Drawable.html">Drawable</a>
                            常用方法：</p>
                        <ol type="I">
                            <li>
                                Drawable 抽象方法:
                                <ol>
                                    <li><p><code>abstract void draw(Canvas canvas)</code> -- 实际的绘制方法
                                    </p></li>
                                    <li><p><code>abstract void setAlpha(int alpha)</code> --
                                        设置绘制内容的透明度</p></li>
                                    <li><p><code>abstract int getOpacity()</code> --
                                        需要获取不透明度状态，函数的返回有三个可选值：</p>
                                        <pre class="brush: java;">
PixelFormat.OPAQUE：不透明
PixelFormat.TRANSPARENT：透明
PixelFormat.TRANSLUCENT：半透明
</pre>
                                    </li>
                                    <li><p><code>abstract void setColorFilter(ColorFilter
                                        colorFilter)</code> -- 设置滤镜效果，参见：<a
                                            href="graphics.html#graphics-ColorFilter">ColorFilter</a>
                                    </p></li>
                                </ol>
                            </li>
                            <li>
                                Drawable 静态创建方法:
                                <ol start="5">
                                    <li><p><code>static Drawable createFromPath(String pathName)</code> -- 从文件创建 Drawable，实际调用了 <code>BitmapFactory.decodeFile(pathName);</code>, 再从 Bitmap 创建 BitmapDrawable</p></li>
                                    <li><p><code>static Drawable createFromStream(InputStream is, String srcName)</code> -- 从 InputStream 创建 Drawable，实际调用了 <code>BitmapFactory.decodeResourceStream(res, value, is, pad, opts);</code>, 再从 Bitmap 创建 BitmapDrawable</p></li>
                                    <li><p><code>static Drawable createFromResourceStream(Resources res, TypedValue value, InputStream is, String srcName)</code> -- 同上</p></li>
                                    <li><p><code>static Drawable createFromResourceStream(Resources res, TypedValue value, InputStream is, String srcName, BitmapFactory.Options opts)</code> -- 同上</p></li>
                                    <li><p><code>static Drawable createFromXml(Resources r, XmlPullParser parser)</code> -- 从 xml 文件中创建 Drawable</p></li>
                                    <li><p><code>static Drawable createFromXml(Resources r, XmlPullParser parser, Resources.Theme theme)</code> -- 从 xml 文件中创建 Drawable</p></li>
                                    <li><p><code>static Drawable createFromXmlInner(Resources r, XmlPullParser parser, AttributeSet attrs, Resources.Theme theme)</code> -- 从 xml 文件中创建 Drawable</p></li>
                                    <li><p><code>static Drawable createFromXmlInner(Resources r, XmlPullParser parser, AttributeSet attrs)</code> -- 从 xml 文件中创建 Drawable</p></li>
                                </ol>
                            </li>
                            <li>
                                Drawable 常用方法:
                                <ol start="13">
                                    <li><p><code>void setBounds(Rect bounds)</code> -- 设置边界信息</p></li>
                                    <li><p><code>void setBounds(int left, int top, int right, int bottom)</code> -- 同上</p></li>
                                    <li><p><code>final Rect getBounds()</code> -- 获取边界信息</p></li>
                                    <li><p><code>final Rect copyBounds()</code> -- 复制边界信息</p></li>
                                    <li><p><code>final void copyBounds(Rect bounds)</code> -- 同上</p></li>
                                    <li><p><code>Rect getDirtyBounds()</code> -- API 21 添加，默认返回同 getBounds</p></li>
                                    <li><p><code>void getHotspotBounds(Rect outRect)</code> -- 将 outRect 边界设置为 getBounds 的值</p></li>
                                    <li><p><code>void setHotspotBounds(int left, int top, int right, int bottom)</code> -- Drawable 并未实现，看子类的实现</p></li>
                                    <li><p><code>void setHotspot(float x, float y)</code> -- Drawable 并未实现，看子类的实现</p></li>
                                    <li><p><code>protected void onBoundsChange(Rect bounds)</code> -- 调用 <code>setBounds</code> 方法会触发此方法回调。在 <code>draw</code> 方法调用前，布局文件将会传入 View 的边界信息，同样会触发此方法。</p></li>

                                    <li><p><code>final boolean setLevel(int level)</code> -- 设置显示的级别，以便进行一些绘制时的区间和条件控制</p></li>
                                    <li><p><code>final int getLevel()</code> -- 获取显示的级别</p></li>
                                    <li><p><code>protected boolean onLevelChange(int level)</code> -- 调用 <code>setLevel</code> 方法会触发此方法回调</p></li>

                                    <li><p><code>boolean setState(int[] stateSet)</code> -- 设置状态信息</p></li>
                                    <li><p><code>int[] getState()</code> -- 获取状态信息</p></li>
                                    <li><p><code>boolean isStateful()</code> -- 指示是否可改变状态，默认返回 false, StateListDrawable 返回 true</p></li>
                                    <li><p><code>void jumpToCurrentState()</code> -- 跳转到当前状态</p></li>
                                    <li><p><code>protected boolean onStateChange(int[] state)</code> -- 调用 <code>setState</code> 方法会触发此方法回调</p></li>

                                    <li><p><code>void setColorFilter(int color, PorterDuff.Mode mode)</code> -- 使用 PorterDuff 来设置颜色过滤器</p></li>
                                    <li><p><code>ColorFilter getColorFilter()</code> -- 获取颜色过滤器</p></li>
                                    <li><p><code>void clearColorFilter()</code> -- 清除颜色过滤器</p></li>

                                    <li><p><code>int getIntrinsicHeight()</code> -- 看子类实现，获取绘制对象的实际高度；如果 ImageView 的高度为 <code>wrap_content</code>，将会读取这个值为高度</p></li>
                                    <li><p><code>int getIntrinsicWidth()</code> -- 看子类实现，获取绘制对象的实际宽度；如果 ImageView 的宽度为 <code>wrap_content</code>，将会读取这个值为宽度</p></li>
                                    <li><p><code>int getMinimumHeight()</code> -- 看子类实现，获取绘制对象的最小高度</p></li>
                                    <li><p><code>int getMinimumWidth()</code> -- 看子类实现，获取绘制对象的最小宽度</p></li>
                                    <li><p><code>boolean getPadding(Rect padding)</code> -- 看子类实现，获取填充值</p></li>
                                    <li><p><code>void getOutline(Outline outline)</code> -- 设置为 getBounds() 和 setAlpha(0)</p></li>

                                    <li><p><code>void inflate(Resources r, XmlPullParser parser, AttributeSet attrs)</code> -- 将 parser 的数据解析到 attrs 中</p></li>
                                    <li><p><code>void inflate(Resources r, XmlPullParser parser, AttributeSet attrs, Resources.Theme theme)</code> -- 同上</p></li>

                                    <li><p><code>void setAutoMirrored(boolean mirrored)</code> -- 设置自动镜像，看子类实现</p></li>
                                    <li><p><code>boolean isAutoMirrored()</code> -- 是否自动镜像</p></li>

                                    <li><p><code>final boolean isVisible()</code> -- 返回绘制的内容是否可见</p></li>
                                    <li><p><code>boolean setVisible(boolean visible, boolean restart) </code> -- 设置绘制的内容是否可见</p></li>
                                    <li><p><code>Drawable getCurrent()</code> -- 获取当前的可绘制对象，这个主要是针对有动画的可绘制对象</p></li>

                                    <li><p><code>Drawable.Callback getCallback()</code> -- 获取 Drawable.Callback</p></li>
                                    <li><p><code>final void setCallback(Drawable.Callback cb)</code> -- 委托给外部实现 Drawable.Callback 类进行处理</p></li>
                                    <li><p><code>void invalidateSelf()</code> -- 刷新本身</p></li>
                                    <li><p><code>void scheduleSelf(Runnable what, long when)</code> -- 主要用于动画处理</p></li>
                                    <li><p><code>void unscheduleSelf(Runnable what)</code> -- 主要用于动画处理</p></li>

                                    <li><p><code>Drawable.ConstantState getConstantState()</code> -- 对于有些可绘制对象可以共享其中的资源而不需要有多个副本，因此可以通过如下方法来得到一个内部的保存的常量状态</p></li>
                                    <li><p><code>Drawable mutate()</code> -- 要单独制作一份不共享的可绘制对象</p></li>

                                    <li><p><code>void setChangingConfigurations(int configs)</code> -- 这个 configs 参数由 <code>ActivityInfo</code> 定义</p></li>
                                    <li><p><code>int getChangingConfigurations()</code> -- 获取值</p></li>

                                    <li><p><code>final boolean setLayoutDirection(int layoutDirection)</code> -- 设置布局方向，API 23 添加。从左到右或从右到左(<code>View.LAYOUT_DIRECTION_LTR</code> 或者 <code>View.LAYOUT_DIRECTION_RTL</code>)</p></li>
                                    <li><p><code>int getLayoutDirection()</code> -- 获取布局方向，API 23 添加</p></li>
                                    <li><p><code>boolean onLayoutDirectionChanged(int layoutDirection)</code> -- 调用 setLayoutDirection 时回调，API 23 添加</p></li>

                                    <li><p><code>Region getTransparentRegion()</code> -- Region 用来指定区域和区域间的组合方式，参见：<a href="graphics.html#graphics-Region">Region</a></p></li>
                                    <li><p><code>void setTint(int tintColor)</code> -- 将混合在一起的色彩在屏幕上绘制，和 ColorFilter 差不多</p></li>
                                    <li><p><code>void setTintList(ColorStateList tint)</code> -- 同上</p></li>
                                    <li><p><code>void setTintMode(PorterDuff.Mode tintMode)</code> -- 同上</p></li>

                                    <li><p><code>static int resolveOpacity(int op1, int op2)</code> -- 从 op1 和 op2 的值返回一个恰当值，具体看实现</p></li>

                                    <li><p><code>void applyTheme(Resources.Theme t)</code> -- 看子类实现，API 21 添加，应用主题</p></li>
                                    <li><p><code>boolean canApplyTheme()</code> -- API 21 添加，是否可应用主题，默认返回 false</p></li>

                                    <li><p><code>boolean isFilterBitmap()</code> -- API 23 添加，默认返回 false</p></li>
                                    <li><p><code>void setFilterBitmap(boolean filter)</code> -- 默认未实现，看子类实现</p></li>

                                    <li><p><code>void setDither(boolean dither)</code> -- API 23 后不再使用</p></li>
                                </ol>
                            </li>
                        </ol>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="drawable-custom"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">自定义 Drawable</h3>
                </div>
                <div class="panel-body">
                    <p>自定义圆角　Drawable:</p>
                    <ul>
                        <li><p><code>public void draw(Canvas canvas)</code> -- <b>必须实现</b>，使用 Canvas
                            绘制图形</p></li>
                        <li><p><code>public void setColorFilter(ColorFilter cf)</code> --
                            <b>必须实现</b>，指定一个色彩过滤器</p></li>
                        <li><p><code>public void setAlpha(int alpha)</code> -- <b>必须实现</b>，设置 alpha
                            值</p></li>
                        <li><p><code>public int getOpacity()</code> -- <b>必须实现</b>，返回不透明度/透明度。</p>
                        </li>
                        <li><p><code>public void setBounds(int left, int top, int right, int
                            bottom)</code> -- 设置绘制的范围</p></li>
                        <li><p><code>public int getIntrinsicWidth()</code> -- View 使用 wrap_content
                            的时候，提供一下宽度尺寸</p></li>
                        <li><p><code>public int getIntrinsicHeight()</code> --
                            View　使用　wrap_content　的时候，提供一下高度尺寸</p></li>
                    </ul>

                    <pre class="brush: xml;">
&lt;!-- API 24 可以将自定义的 Drawable 写在 res/drawble 下的文件中 -->
&lt;com.myapp.MyCustomDrawable xmlns:android="http://schemas.android.com/apk/res/android"
                            android:color="#ffff0000" />
&lt;!-- 或者这样写 -->
&lt;drawable xmlns:android="http://schemas.android.com/apk/res/android"
          class="com.myapp.MyTopLevelClass$InnerCustomDrawable"
          android:color="#ffff0000" />
</pre>
                    <pre class="brush: java;">
package com.lesson1234.myapplication;

import android.graphics.Bitmap;
import android.graphics.BitmapShader;
import android.graphics.Canvas;
import android.graphics.ColorFilter;
import android.graphics.Paint;
import android.graphics.PixelFormat;
import android.graphics.RectF;
import android.graphics.Shader;
import android.graphics.drawable.Drawable;

public class CircleConerDrawable extends Drawable {
    private Paint mPaint;
    private Bitmap mBitmap;

    private RectF rectF;

    public CircleConerDrawable(Bitmap bitmap) {
        mBitmap = bitmap;
        BitmapShader bitmapShader = new BitmapShader(bitmap, Shader.TileMode.CLAMP,
                Shader.TileMode.CLAMP);
        mPaint = new Paint();
        mPaint.setAntiAlias(true);
        mPaint.setShader(bitmapShader);
    }

    @Override
    public void setBounds(int left, int top, int right, int bottom) {
        super.setBounds(left, top, right, bottom);
        rectF = new RectF(left, top, right, bottom);
    }

    @Override
    public void draw(Canvas canvas) {
        canvas.drawRoundRect(rectF, 30, 30, mPaint);
    }

    @Override
    public int getIntrinsicWidth() {
        return mBitmap.getWidth();
    }

    @Override
    public int getIntrinsicHeight() {
        return mBitmap.getHeight();
    }

    @Override
    public void setAlpha(int alpha) {
        mPaint.setAlpha(alpha);
    }

    @Override
    public void setColorFilter(ColorFilter cf) {
        mPaint.setColorFilter(cf);
    }

    @Override
    public int getOpacity() {
        return PixelFormat.TRANSLUCENT;
    }
}
</pre>
                    <p>使用这个 CircleConerDrawable:</p>
                    <pre class="brush: xml;">
Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bjx);
Drawable dw = new CircleConerDrawable(bitmap);
mImageview.setImageDrawable(dw);

                        <!-- XML　文件中使用 Drawable 类, API 24 -->
&lt;com.myapp.MyCustomDrawable
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:color="#ffff0000" />

                        <!-- 内部 Drawable 类, API 24 -->
&lt;drawable
    xmlns:android="http://schemas.android.com/apk/res/android"
    class="com.myapp.MyTopLevelClass$InnerCustomDrawable"
    android:color="#ffff0000" />
</pre>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="drawable-dir"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">
                        <code>drawable</code>
                        目录
                    </h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
                        <p>
                            <b>应用程序 ICON 尺寸表</b>
                        </p>
                        <table class="table table-bordered table-responsive">
                            <thead>
                            <tr>
                                <th>密度</th>
                                <th>建议尺寸</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>mipmap-mdpi</td>
                                <td>48 * 48</td>
                            </tr>
                            <tr>
                                <td>mipmap-hdpi</td>
                                <td>72 * 72</td>
                            </tr>
                            <tr>
                                <td>mipmap-xhdpi</td>
                                <td>96 * 96</td>
                            </tr>
                            <tr>
                                <td>mipmap-xxhdpi</td>
                                <td>144 * 144</td>
                            </tr>
                            <tr>
                                <td>mipmap-xxxhdpi</td>
                                <td>192 * 192</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="sub-item">
                        <p>
                            <b>DPI 与 drawable 目录对应表</b>
                        </p>
                        <table class="table table-bordered table-responsive">
                            <thead>
                            <tr>
                                <th>dpi范围</th>
                                <th>目录</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>0dpi ~ 120dpi</td>
                                <td>drawable-ldpi</td>
                            </tr>
                            <tr>
                                <td>120dpi ~ 160dpi</td>
                                <td>drawable-mdpi / drawable</td>
                            </tr>
                            <tr>
                                <td>160dpi ~ 240dpi</td>
                                <td>drawable-hdpi</td>
                            </tr>
                            <tr>
                                <td>240dpi ~ 320dpi</td>
                                <td>drawable-xhdpi</td>
                            </tr>
                            <tr>
                                <td>320dpi ~ 480dpi</td>
                                <td>drawable-xxhdpi</td>
                            </tr>
                            <tr>
                                <td>480dpi ~ 640dpi</td>
                                <td>drawable-xxxhdpi</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="sub-item">
                        <p>
                            <b>Android 从 drawable 目录下寻找图片的规则(假设屏幕为: xxhdpi)：</b>
                        </p>
                        <ul>
                            <li>
                                <p>
                                    1. 从设备 DPI 适配的对应 drawable 目录下寻找(因为设备为 xxhdpi, 对应目录为
                                    <code>drawable-xxhdpi</code>
                                    )；
                                </p>
                            </li>
                            <li>
                                <p>
                                    2. 从更高 DPI 的对应 drawable 目录下寻找(
                                    <code>drawable-xxxhdpi</code>
                                    )；
                                </p>
                            </li>
                            <li>
                                <p>
                                    3. 从无 DPI 的对应 drawable 目录下寻找(
                                    <code>drawable-nodpi</code>
                                    )；
                                </p>
                            </li>
                            <li>
                                <p>
                                    4. 从相对低 DPI 的对应 drawable 目录下寻找(
                                    <code>drawable-xhpi</code>
                                    )。
                                </p>
                            </li>
                        </ul>
                        <p>
                            综上所述：假设屏幕为:
                            <code>xxhdpi</code>
                            ，那么系统寻找图片的顺序为：
                            <code>drawable-xxhdpi</code>
                            ->
                            <code>drawable-xxxhdpi</code>
                            ->
                            <code>drawable-nodpi</code>
                            ->
                            <code>drawable-xhdpi</code>
                            ->
                            <code>drawable-hdpi</code>
                            ->
                            <code>drawable-mdpi / drawable</code>
                            ->
                            <code>drawable-ldpi</code>
                        </p>
                        <p>
                            <b><code>drawable</code></b> 和 <b><code>mipmap</code>
                            目录对图片尺寸的影响</b>
                        </p>
                        <p>
                            当能在设备屏幕 DPI 对应的
                            <code>drawable</code>
                            目录下找到图片时，图片不会变形；当图片放置于比设备屏幕 DPI 低的目录下时，显示的图片会相应放大；当图片放置于比设备屏幕
                            DPI 高的目录下时，显示的图片会相应缩小；具体如下：
                        </p>
                        <p>
                            每一种密度的 DPI 范围都有一个最大值，这个最大值之间的比例就是图片会被系统自动放大的比例。 图片在不同的
                            <code>drawable</code>
                            目录下的缩放规则：
                        </p>
                        <ul>
                            <li>
                                <p>
                                    1. 图片原始像素：
                                    <code>270 : 480</code>
                                    ，图片位置：
                                    <code>drawable-xxhdpi</code>
                                    ，运行设备：
                                    <code>xxhdpi</code>
                                    ，图片不会变形。
                                </p>
                            </li>
                            <li>
                                <p>
                                    2. 将图片位置改变到：
                                    <code>drawable-xxxhdpi</code>
                                    ，其它情景不变，图片变小，从 DPI 与 drawable 目录对应表可以查到，缩放比例:
                                    <code>480 / 640 = 0.75</code>
                                    ，最终显示尺寸：
                                    <code>270 * 0.75 : 480 * 0.75</code>
                                </p>
                            <li>
                                <p>
                                    3. 将图片位置改变到：
                                    <code>drawable-xhdpi</code>
                                    ，其它情景不变，图片变大，从 DPI 与 drawable 目录对应表可以查到，缩放比例:
                                    <code>480 / 320 = 1.5</code>
                                    ，最终显示尺寸：
                                    <code>270 * 1.5 : 480 * 1.5</code>
                                </p>
                            <li>
                                <p>
                                    4. 将图片位置改变到：
                                    <code>drawable-hdpi</code>
                                    ，其它情景不变，图片变大，从 DPI 与 drawable 目录对应表可以查到，缩放比例:
                                    <code>480 / 240 = 2</code>
                                    ，最终显示尺寸：
                                    <code>270 * 2 : 480 * 2</code>
                                </p>
                        </ul>
                        <div class="alert alert-success" style="font-size: 14px;">
                            <p>
                                <b>说了这么多，图片应该怎么放最好呢？</b>
                            </p>
                            <p>根据 Android 的开发建议, 图片资源时尽量应该给每种密度的设备都准备一套。</p>
                            <p>
                                <b>如果只有一套图片，那么放在哪里比较合适呢？</b>
                            </p>
                            <p>
                                如果将一张图片放在低密度文件夹下，那么在高密度设备上显示图片时就会被自动放大；而如果将一张图片放在高密度文件夹下，那么在低密度设备上显示图片时就会被自动缩小。</p>
                            <p>原图片被缩小了之后显示并没有什么副作用，但一张原图片被放大了之后显示就意味着要占用更多的内存了。</p>
                            <p>
                                图片资源应该尽量放在高密度文件夹下，这样可以节省图片的内存开支，而 UI
                                在设计图片的时候也应该尽量面向高密度屏幕的设备来进行设计。<b>就目前来讲，最佳放置图片资源的文件夹就是 <code>drawable-xxhdpi</code></b>。那么有的朋友可能会问了，不是还有更高密度的
                                <code>drawable-xxxhdpi</code>
                                吗？干吗不放在这里？这是因为，市面上 480dpi 到 640dpi
                                的设备实在是太少了，如果针对这种级别的屏幕密度来设计图片，图片在不缩放的情况下本身就已经很大了，基本也起不到节省内存开支的作用了。
                            </p>
                        </div>
                    </div>

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="BitmapDrawable"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">BitmapDrawable</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
						<pre class="brush: java;">
java.lang.Object
	android.graphics.drawable.Drawable
		android.graphics.drawable.BitmapDrawable
		
public class BitmapDrawable extends Drawable {
    BitmapDrawable(Resources res, Bitmap bitmap)
    BitmapDrawable(Resources res, String filepath)
    BitmapDrawable(Resources res, InputStream is)
    BitmapDrawable()                                // API 4 过时
    BitmapDrawable(Bitmap bitmap)                   // API 4 过时
    BitmapDrawable(String filepath)                 // API 5 过时
    BitmapDrawable(InputStream is)                  // API 5 过时
    BitmapDrawable(Resources res)                   // API 18 过时
}
</pre>
                        <p><a href="docs/reference/android/graphics/drawable/BitmapDrawable.html" target="_blank">BitmapDrawable</a> 可在 <code>res/drawable</code> 下使用 XML 定义：</p>
                        <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;bitmap
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:src="@drawable/drawable_resource"
    android:antialias=["true" | "false"]        &lt;!-- 设置是否开启抗锯齿 -->
    &lt;!-- 设置是否抖动，图片与屏幕的像素配置不同时会用到，比如图片是 ARGB 8888 的，而屏幕是 RGB565 -->
    android:dither=["true" | "false"]
    &lt;!-- 过时，设置是否允许对图片进行滤波，对图片进行收缩或者延展使用滤波可以获得平滑的外观效果 -->
    android:filter=["true" | "false"]
    android:autoMirrored="true|false" &lt;!-- 布局方向为RTL（右到左）时自动镜像 -->
    &lt;!-- 重力方向, 多个取值可以用 | 分隔
        top 图片放于容器顶部，不改变图片大小
        bottom 图片放于容器底部，不改变图片大小
        left 图片放于容器左边，不改变图片大小
        right 图片放于容器右边，不改变图片大小
        center 图片放于容器中心位置，包括水平和垂直方向，不改变图片大小
        fill 拉伸整张图片以填满容器的整个高度和宽度，默认值
        center_vertical 图片放于容器垂直方向的中心位置，不改变图片大小
        center_horizontal 图片放于容器水平方向的中心位置，不改变图片大小
        fill_vertical 在垂直方向上拉伸图片以填满容器的整个高度
        fill_horizontal 在水平方向上拉伸图片以填满容器的整个宽度
        clip_vertical 裁剪基于垂直方向的gravity，设置top时会裁剪底部，设置bottom时会裁剪顶部，其他同时裁剪顶部和底部
        clip_horizontal 裁剪基于水平方向的gravity，设置left时会裁剪右侧，设置right时会裁剪左侧，其他同时裁剪左右两侧
    -->
    android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" |
                      "fill_vertical" | "center_horizontal" | "fill_horizontal" |
                      "center" | "fill" | "clip_vertical" | "clip_horizontal"]

    android:mipMap=["true" | "false"]
    android:alpha="0-255"
    android:tint="@color/colorPrimary"  &lt;!-- 图形混合 -->
    android:tintMode="src_over|src_in|src_atop|screen|add|multiply" &lt;-- 混合模式 -->
                            <!-- 平铺模式, tileMode 启用，gravity 将失效。比如用于 background 属性时有用。
                              disable 不做任何平铺，默认设置
                              repeat 图片重复铺满
                              mirror 使用交替镜像的方式重复图片的绘制
                              clamp 复制图片边缘的颜色来填充容器剩下的空白部分
                            -->
    android:tileMode=["disabled" | "clamp" | "repeat" | "mirror"]
                            <!-- 下面两个属性 api 21 才有用 -->
    android:tileModeX=["disabled" | "clamp" | "repeat" | "mirror"]
    android:tileModeY=["disabled" | "clamp" | "repeat" | "mirror"] />
                        </pre>
                        <p><a href="docs/reference/android/graphics/drawable/BitmapDrawable.htmltarget="_blank">BitmapDrawable</a> 为位图可绘制类。在构造时指定一个 Bitmap 对象或者一个位图文件。位图显示时需要指定：<b>像素和设备尺寸的映射</b>，<b>显示的位置</b>，<b>显示模式</b>三种属性。</p>
                        <ol>
                            <li><p><b>像素和设备尺寸的映射: </b>位图里面的像素是一个抽象的概念他没有具体的物理尺寸，而设备的像素则是物理的，他有大小。因此需要有一个方法来指定位图像素转化为物理像素的映射关系，这样位图的像素才可以真正的显示在设备上。下面就是提供的三种映射设置方法：</p>
                            <pre class="brush: java;">
// 画布上的密度比值
public void setTargetDensity(Canvas canvas)
// 当前屏幕的密度比值
public void setTargetDensity(DisplayMetrics metrics)
//指定密度比值，注意这里的密度是 DisplayMetrics 中的 DENSITY_XXX。
public void setTargetDensity(int density)
                            </pre></li>
                            <li><p><b>显示的位置: </b>为位图指定绘制到画布上的位置以及缩放到区域的方式：</p>
                                <pre class="brush: java;">
// 这里的 android.view.Gravity 参考值。比如显示在左上角，比如拉伸显示在整个画布中等等
public void setGravity(int gravity)
                            </pre></li>
                            <li><p><b>显示模式: </b>图片的默认显示是一张图片进行拉伸，你可以设置平铺的方式。如果设置了这种模式则图像是平铺显示在画布上的：</p>
                                <pre class="brush: java;">
public final void setTileModeY(Shader.TileMode mode)
public void setTileModeX(Shader.TileMode mode)
</pre></li>
                        </ol>
                    </div>

                    <div class="sub-item">
                    <ol type="I">
                        <li>
                            <p>构造方法</p>
                            <ol>
                                <li><p><code>BitmapDrawable(Resources res, Bitmap bitmap)</code> -- 从 Bitmap 构造</p></li>
                                <li><p><code>BitmapDrawable(Resources res, String filepath)</code> -- 从文件构造</p></li>
                                <li><p><code>BitmapDrawable(Resources res, InputStream is)</code> -- 从输入流构造</p></li>
                            </ol>
                        </li>
                        <li>
                            <p>常用方法</p>
                            <ol start="4">
                                <li><p><code>final Bitmap getBitmap()</code> -- 获取 Bitmap</p></li>
                                <li><p><code>final Paint getPaint()</code> -- 获取 Paint</p></li>
                                <li><p><code>void setTargetDensity(int density)</code> -- 画布上的密度比值</p></li>
                                <li><p><code>void setTargetDensity(DisplayMetrics metrics)</code> -- 当前屏幕的密度比值</p></li>
                                <li><p><code>void setTargetDensity(int density)</code> -- 指定密度比值, DisplayMetrics 中的 DENSITY_XXX。</p></li>
                                <li><p><code>int getIntrinsicHeight()</code> -- 获取高度</p></li>
                                <li><p><code>int getIntrinsicWidth()</code> -- 获取宽度</p></li>

                                <li class="group"><p><code>Shader.TileMode getTileModeX()</code> -- X 平铺方式</p></li>
                                <li><p><code>Shader.TileMode getTileModeY()</code> -- Y 平铺方式</p></li>
                                <li><p><code>void setTileModeX(Shader.TileMode mode)</code> -- X 平铺方式</p></li>
                                <li><p><code>final void setTileModeY(Shader.TileMode mode) </code> -- Y 平铺方式</p></li>
                                <li><p><code>void setTileModeXY(Shader.TileMode xmode, Shader.TileMode ymode)</code> -- XY 平铺方式</p></li>

                                <li class="group"><p><code>int getGravity()</code> -- 位置</p></li>
                                <li><p><code>void setGravity(int gravity)</code> -- 位置</p></li>
                                <li><p><code>ColorFilter getColorFilter()</code> -- 颜色过滤</p></li>
                                <li><p><code>void setColorFilter(ColorFilter colorFilter)</code> -- 颜色过滤</p></li>
                                <li><p><code>final Drawable.ConstantState getConstantState()</code> -- 状态</p></li>
                                <li><p><code>boolean isStateful()</code> -- 状态</p></li>
                                <li><p><code>boolean hasAntiAlias()</code> -- 抗锯齿</p></li>
                                <li><p><code>void setAntiAlias(boolean aa) </code> -- 抗锯齿</p></li>
                                <li><p><code>void setAlpha(int alpha)</code> -- 透明度</p></li>
                                <li><p><code> int getAlpha()</code> -- 透明度</p></li>
                                <li><p><code>final boolean isAutoMirrored()</code> -- 布局方向为RTL（右到左）时自动镜像</p></li>
                                <li><p><code>void setAutoMirrored(boolean mirrored)</code> -- 布局方向为RTL（右到左）时自动镜像</p></li>
                                <li><p><code>void setTintList(ColorStateList tint)</code> -- 图形混合</p></li>
                                <li><p><code>void setTintMode(PorterDuff.Mode tintMode)</code> -- 图形混合模式</p></li>

                                <li class="group"><p><code>protected void onBoundsChange(Rect bounds)</code> -- 边界改变</p></li>
                                <li><p><code>protected boolean onStateChange(int[] stateSet)</code> -- 状态改变</p></li>
                            </ol>
                        </li>
                    </ol>
                </div>

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="ColorDrawable"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">ColorDrawable</h3>
                </div>
                <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
	android.graphics.drawable.Drawable
		android.graphics.drawable.ColorDrawable
		
public class ColorDrawable extends Drawable {
    public ColorDrawable() {}
    public ColorDrawable(int color) {}

    protected boolean onStateChange(int[] stateSet) {}
}
</pre>
                    <p><a href="docs/reference/android/graphics/drawable/ColorDrawable.html" target="_blank">ColorDrawable</a> 很简单，用一个颜色生成一个 Drawable, 一般用于设置背景。</p>
                    <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;color android:color="@color/colorAccent"
       xmlns:android="http://schemas.android.com/apk/res/android" />

&lt;!-- 在一些情况，能直接将一个颜色当作 Drawable 使用，比如： -->
&lt;selector xmlns:android="http://schemas.android.com/apk/res/android">
    &lt;item android:drawable="@drawable/bg_active" android:state_pressed="true" />
    &lt;item android:drawable="@color/colorAccent" />  &lt;!-- 这里的值为 color 类型，会自动转化为 Drawable -->
&lt;/selector>
                    </pre>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="ShapeDrawable"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">ShapeDrawable 及子类</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
						<pre class="brush: java;">
java.lang.Object
	android.graphics.drawable.Drawable
		android.graphics.drawable.ShapeDrawable
		
public class ShapeDrawable extends Drawable {
    public static abstract class ShaderFactory {
        public abstract Shader resize(int width, int height);
    }

    public ShapeDrawable() {}
    public ShapeDrawable(Shape shape) {}

    protected void onBoundsChange(Rect bounds) {}
    protected boolean onStateChange(int[] stateSet) {}
}
</pre>
                <p><a href="docs/reference/android/graphics/drawable/ShapeDrawable.html" target="_blank">ShapeDrawable</a> 使用图形生成一个 Drawable, 有一个子类: <a href="docs/reference/android/graphics/drawable/PaintDrawable.html" target="_blank">PaintDrawable</a></p>
                        <p><b>下面的 XML 代码最总转化得到的是一个 <code>GradientDrawable</code>，官方文档也是这样写的，<code>ShapeDrawable</code> 只能通过代码的方式实现。</b></p>
                    <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"
    &lt;!-- 图形类型，android.graphics.drawable.shapes 包下,分别为： 矩形 | 椭圆形 | 线 | 环形-->
    android:shape="rectangle | oval | line | ring"
    android:tint=""         &lt;!-- 参照 Drawable -->
    android:tintMode=""     &lt;!-- 参照 Drawable -->
    android:visible="true|false"    &lt;!-- 可见性 -->
    &lt;!-- 以下属性只有在 shape="ring" 才有效 -->
    android:innerRadius="" &lt;!-- 内环的半径 -->
    android:innerRadiusRatio="" &lt;!-- 以环的宽度比率来表示内环的半径 -->
    android:useLevel="true|false"
    android:thickness=""    &lt;!-- 环的厚度，是一个尺寸值或尺寸的资源 -->
    android:thicknessRatio="" > &lt;!-- 环的厚度的比例 -->

    &lt;solid android:color="@color/colorAccent" /> &lt;!-- 实心，单一颜色填充 -->
    &lt;stroke          &lt;!-- 空心，也可以叫边框，可以使用虚线 -->
        android:width=""    &lt;!-- 粗细 -->
        android:color=""    &lt;!-- 颜色 -->
        android:dashGap=""  &lt;!-- 实线的间隔长度 -->
        android:dashWidth="" />  &lt;!-- 实线的长度 -->

    &lt;corners         &lt;!-- 圆角 -->
        android:radius=""           &lt;!-- 圆角的半径 -->
        android:topLeftRadius=""    &lt;!-- 左上圆角的半径 -->
        android:topRightRadius=""   &lt;!-- 右上圆角的半径 -->
        android:bottomLeftRadius="" &lt;!-- 左下圆角的半径 -->
        android:bottomRightRadius="" />     &lt;!-- 右下圆角的半径 -->

    &lt;gradient                &lt;!-- 此标签对应 android.graphics.Shader 的子类 -->
       android:type="sweep|radial|linear"&lt;!-- 扫描|径向|线性, SweepGradient|RadialGradient|LinearGradient -->
        &lt;!-- 渐变的角度。 0 代表从左到右。90 代表下到上。必须是45的倍数, 对应为 GradientDrawable.Orientation -->
        android:angle=""
        android:startColor=""   &lt;!-- 开始颜色值 -->
        android:endColor=""     &lt;!-- 结束的颜色值 -->
        android:centerColor=""  &lt;!-- 中间色 -->
        android:centerX=""      &lt;!-- 渐变中心的相对X坐标，在0到1.0之间 -->
        android:centerY=""      &lt;!-- 渐变中心的相对Y坐标，在0到1.0之间 -->
        android:gradientRadius=""   &lt;!-- 渐变的半径。只有在 android:type="radial"才使用 -->
        android:useLevel="true|false" /> &lt;!-- 如果在 LevelListDrawable 中使用，则为 true -->

    &lt;padding                 &lt;!-- 内容与视图边界的距离 -->
        android:left=""         &lt;!-- 左边填充距离 -->
        android:top=""          &lt;!-- 顶部填充距离 -->
        android:right=""        &lt;!-- 右边填充距离 -->
        android:bottom="" />    &lt;!-- 底部填充距离 -->

    &lt;!-- shape 的大小 -->
    &lt;size android:width="" android:height="" />

&lt;/shape>
</pre>
                    </div>

                    <div class="sub-item">
                        <p><a href="docs/reference/android/graphics/drawable/ShapeDrawable.html" target="_blank">ShapeDrawable</a> 重要 API:</p>
                        <ol>
                            <li><p><code>Paint getPaint()</code> -- 获取用于绘制的 Paint</p></li>
                            <li><p><code>ShapeDrawable.ShaderFactory getShaderFactory()</code> -- 获取 ShaderFactory</p></li>
                            <li><p><code>void setShaderFactory(ShapeDrawable.ShaderFactory fact)</code> -- 设置 ShaderFactory</p></li>
                            <li><p><code>Shape getShape()</code> -- 获取图形</p></li>
                            <li><p><code>void setShape(Shape s)</code> -- 设置图形</p></li>
                            <li><p><code>void setIntrinsicHeight(int height)</code> -- 设置高度</p></li>
                            <li><p><code>void setIntrinsicWidth(int width)</code> -- 设置宽度</p></li>
                            <li><p><code>void setPadding(Rect padding)</code> -- 设置填充</p></li>
                            <li><p><code>void setPadding(int left, int top, int right, int bottom)</code> -- 设置填充</p></li>
                            <li><p><code>boolean getPadding(Rect padding)</code> -- 获取填充</p>
                            <li><p><code>void inflate(Resources r, XmlPullParser parser, AttributeSet attrs, Resources.Theme theme)</code> -- 从 XML 加载属性</p></li>
                        </ol>
                    </div>

                    <div class="sub-item">
                        <p><a href="docs/reference/android/graphics/drawable/ShapeDrawable.html" target="_blank">ShapeDrawable</a> 子类和相关类:</p>
                        <ul>
                            <li><p><a href="docs/reference/android/graphics/drawable/PaintDrawable.html" target="_blank">PaintDrawable</a> 使用给定的 Paint 绘制边界，可以使用圆角。</p>
                                <pre class="brush: java;">
java.lang.Object
    android.graphics.drawable.Drawable
  	    android.graphics.drawable.ShapeDrawable
  	  	    android.graphics.drawable.PaintDrawable

public class PaintDrawable extends ShapeDrawable {
    public PaintDrawable() {}
    public PaintDrawable(int color) {}

    public void setCornerRadii(float[] radii) {}
    public void setCornerRadius(float radius) {}
}

                            </pre>
                            </li>
                            <li><p><a href="docs/reference/android/graphics/drawable/shapes/package-summary.html" target="_blank">android.graphics.drawable.shapes</a> 包下的类，可以指定图形：</p>
                            <pre class="brush: java;">
java.lang.Object
    android.graphics.drawable.shapes.Shape
        ├── PathShape
        └── RectShape
            ├── ArcShape
            ├── OvalShape
            └── RoundRectShape

public abstract class Shape implements Cloneable {
    abstract void draw(Canvas canvas, Paint paint);
    final float getHeight() {}
    void getOutline(Outline outline) {}
    final float getWidth() {}
    boolean hasAlpha() {}
    final void resize(float width, float height) {}
    Shape clone() {}

    protected void onResize(float width, float height) {}
}

public class PathShape extends Shape {
    public PathShape(Path path, float stdWidth, float stdHeight) {}
}

public class RectShape extents Shape {
    final RectF rect() {}
}

public class ArcShape extents RectShape {
    public ArcShape(float startAngle, float sweepAngle) {}
}

public class RoundRectShape extents RectShape {
    public RoundRectShape(float[] outerRadii, RectF inset, float[] innerRadii) {}
}
</pre>
                            </li>
                        </ul>
                    </div>

                    <div class="sub-item">
                        <p><b>ShapeDrawable / GradientDrawable 实例，硬件加速可能会有影响</b></p>

                        <div class="row">
                            <div class="col-md-8">
                                <p><b>1. 实线</b></p>
                            <pre class="brush: xml; gutter: false;">
&lt;shape android:shape="line"
    xmlns:android="http://schemas.android.com/apk/res/android">
    &lt;stroke android:width="2dp" android:color="@color/colorAccent" />
&lt;/shape>
                            </pre>

                                <p><b>2. 虚线</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape android:shape="line" android:useLevel="true"
    xmlns:android="http://schemas.android.com/apk/res/android">
    &lt;stroke android:width="2dp" android:color="#FF4081"
        android:dashWidth="10dp" android:dashGap="5dp"/>
&lt;/shape>

                            </pre>

                                <p><b>3. 实线边框无填充</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle" android:useLevel="true">
    &lt;stroke android:width="2dp" android:color="#ffff0000" />
&lt;/shape>

                            </pre>

                                <p><b>4. 虚线边框无填充</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle" android:useLevel="true">
    &lt;stroke android:width="2dp" android:color="#ffff0000"
        android:dashWidth="10dp" android:dashGap="2dp"/>
&lt;/shape>
                            </pre>
                            </div>
                            <div class="col-md-4"><img src="images/shape-gradient.png" class="img-responsive"></div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <p><b>5. 实线边框有填充</b></p>
                                <pre class="brush: xml;gutter: false;" >
&lt;shape xmlns:android="..."
       android:shape="rectangle"
       android:useLevel="true" />
    &lt;stroke android:width="2dp"
        android:color="#ffff0000" />
    &lt;solid android:color="..." />
&lt;/shape>
                            </pre>
                            </div>
                            <div class="col-md-6" style="padding: 0px;">
                                <p><b>6. 虚线边框有填充</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape xmlns:android="..."
    android:shape="rectangle" android:useLevel="true"
    &lt;stroke
        android:width="2dp" android:color="#ffff0000"
        android:dashWidth="10dp" android:dashGap="2dp"/>
    &lt;solid android:color="..." />
&lt;/shape>
                            </pre>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <p><b>7. 圆角边框无填充</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape xmlns:android="..."
    android:shape="rectangle"
    android:useLevel="true">
    &lt;stroke android:width="2dp"
        android:color="#ffff0000" />
    &lt;corners android:radius="5dp" />
&lt;/shape>
                            </pre>
                            </div>
                            <div class="col-md-6" style="padding: 0px;">
                                <p><b>8. 圆角虚线边框无填充</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape xmlns:android="..."
    android:shape="rectangle"
    android:useLevel="true">
    &lt;stroke android:width="2dp" android:color="#ffff0000"
        android:dashWidth="10dp" android:dashGap="2dp"/>
    &lt;corners android:radius="5dp" />
&lt;/shape>
                            </pre>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <p><b>9. 圆角填充无边框</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape xmlns:android="..."
    android:shape="rectangle"
    android:useLevel="true">

    &lt;solid
        android:width="2dp"
        android:color="..." />

    &lt;corners android:radius="5dp" />

&lt;/shape>
                            </pre>
                            </div>
                            <div class="col-md-6" style="padding: 0px;">
                                <p><b>10. 半圆弧圆角填充无边框</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape xmlns:android="..."
    android:shape="rectangle" android:useLevel="true">
    <!-- 需要注意的是: 如果 View 的高度为 wrap_content, 将以
        这个高度为 View 的高度； 如果 View 的高度为固定值， 那么
        这个半圆角的高度和圆角半径会等比缩放，结果还是半圆角。 -->
    &lt;size android:height="40dp" />
    <!-- radius 为 大于高度的一半 -->
    &lt;corners android:radius="20dp" />
    &lt;solid android:width="2dp"
        android:color="@android:color/holo_blue_light" />
&lt;/shape>
                            </pre>
                            </div>
                        </div>

                        <div class="row">
                            <div class="col-md-6">
                                <p><b>11. 上部圆角填充无边框</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape xmlns:android="..."
    android:shape="rectangle"
    android:useLevel="true">
    &lt;solid
        android:width="2dp"
        android:color="..." />
    &lt;corners android:topLeftRadius="5dp"
        android:topRightRadius="5dp" />
&lt;/shape>
                            </pre>
                            </div>
                            <div class="col-md-6" style="padding: 0px;">
                                <p><b>12. 下部圆角填充无边框</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape xmlns:android="..."
    android:shape="rectangle" android:useLevel="true">
    &lt;solid
        android:width="2dp"
        android:color="@android:color/holo_blue_light" />
    &lt;corners
        android:bottomLeftRadius="5dp"
        android:bottomRightRadius="5dp" />
&lt;/shape>
                            </pre>
                            </div>
                        </div>

                        <div class="row">
                            <div class="col-md-6">
                                <p><b>13. 圆形填充边框渐变(最后 6 个图形相似，左下)</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape xmlns:android="..."
    android:shape="rectangle" android:useLevel="true">
<!-- 需要注意的是: 如果 View 的高度为 wrap_content, 将以这
    个高度为 View 的高度； 如果 View 的高度为固定值，那个这
    个圆的高度和圆角半径会等比缩放，结构还是圆。 -->
    &lt;size android:height="40dp"
        android:width="40dp"/>
    <!-- radius 为 大于宽度和高度的一半 -->
    &lt;corners android:radius="20dp" />
    &lt;stroke android:width="1dp" android:color="..."/>
    &lt;solid android:color="..." />
    &lt;gradient
        android:centerX="0.5" android:centerY="0.5"
        android:startColor="..."
        android:endColor="@color/colorAccent"
        android:gradientRadius="30dp"
        android:type="radial" />
&lt;/shape>
                            </pre>
                            </div>
                            <div class="col-md-6" style="padding: 0px;">
                                <p><b>14. 上下两边半圆弧填充(最后 6 个图形相似，右下)</b></p>
                                <pre class="brush: xml;gutter: false;">
&lt;shape xmlns:android="..."
    android:shape="rectangle" android:useLevel="true">
    <!-- 同上面的圆形背景填充，只是宽高比变了。 -->
    &lt;size android:height="40dp
        android:width="20dp" />
    <!-- radius 为 大于宽度和高度的一半 -->
    &lt;corners android:radius="20dp" />
    &lt;stroke android:width="1dp"
        android:color="..." />
    &lt;solid android:color="..." />
    &lt;gradient
        android:centerX="0.5"
        android:centerY="0.5"
        android:startColor="@android:color/holo_blue_dark"
        android:endColor="@color/colorAccent"
        android:gradientRadius="30dp"
        android:type="radial" />
&lt;/shape>
                            </pre>
                            </div>
                        </div>


                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="GradientDrawable"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">GradientDrawable</h3>
                </div>
                <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
	android.graphics.drawable.Drawable
		android.graphics.drawable.GradientDrawable

public class GradientDrawable extends Drawable {
    // 渐变方向，45度角的倍数，一个 360 / 45 = 8 个
    public enum Orientation {
        TOP_BOTTOM, // 上下，默认
        BOTTOM_TOP, // 下上
        LEFT_RIGHT, // 左右
        RIGHT_LEFT, // 右左
        TR_BL,      // 右上 -- 左下
        BR_TL,      // 右下 -- 左上
        BL_TR,      // 左下 -- 右上
        TL_BR       // 左上 -- 右下
    }

    public GradientDrawable() {}
    public GradientDrawable(GradientDrawable.Orientation orientation, int[] colors) {}
}
</pre>
                    <p><a href="docs/reference/android/graphics/drawable/GradientDrawable.html" target="_blank">GradientDrawable</a> 同样使用 <code>shape</code> 标签定义，同样使用 <code>ShapeDrawabe</code> 里面的属性。比较奇葩的是 <a href="#ShapeDrawable">ShapeDrawable</a> 的 <code>XML</code> 标签转转完成后得到的类型是 <code>GradientDrawable</code>。</p>
                    <ol>
                        <li><p><code>void setCornerRadii(float[] radii)</code> -- 数组长度为 8，分为 4 对，分别指定 4 个角的 x 和 y 长度。顺序为  top-left, top-right, bottom-right, bottom-left。指定图形为矩形才适用。</p></li>
                        <li><p><code>float[] getCornerRadii()</code> -- 获取圆角设置数组</p></li>
                        <li><p><code>void setCornerRadius(float radius)</code> -- 设置统一的圆角半径</p></li>
                        <li><p><code>float getCornerRadius()</code> -- 获取统一的圆角半径</p></li>
                        <li><p><code>void setGradientCenter(float x, float y)</code> -- 设置渐变中心</p></li>
                        <li><p><code>float getGradientCenterX()</code> -- 获取渐变中心 X</p></li>
                        <li><p><code>float getGradientCenterY()</code> -- 获取渐变中心 Y</p></li>
                        <li><p><code>void setGradientRadius(float gradientRadius)</code> -- 设置渐变半径</p></li>
                        <li><p><code>float getGradientRadius()</code> -- 获取渐变半径</p></li>
                        <li><p><code>void setGradientType(int gradient)</code> -- 设置渐变类型， LINEAR_GRADIENT， RADIAL_GRADIENT， SWEEP_GRADIENT</p></li>
                        <li><p><code>int getGradientType()</code> -- 获取渐变类型</p></li>
                        <li><p><code>void setOrientation(GradientDrawable.Orientation orientation)</code> -- 设置渐变方向，对应 XML 为 <code>angle</code></p></li>
                        <li><p><code>GradientDrawable.Orientation getOrientation()</code> -- 获取渐变方向</p></li>
                        <li><p><code>void setShape(int shape)</code> -- 指定绘制形状，LINE, OVAL, RECTANGLE, RING</p></li>
                        <li><p><code>int getShape()</code> -- 获取绘制形状</p></li>
                        <li><p><code>void setSize(int width, int height)</code> -- 设置大小</p></li>
                        <li><p><code>void setColors(int[] colors)</code> -- 设置渐变数组</p></li>
                        <li><p><code>int[] getColors()</code> -- 获取渐变数组</p></li>
                    </ol>

                    <p><b>使用 <code>XML</code> 实现 <a href="docs/reference/android/graphics/drawable/GradientDrawable.html" target="_blank">GradientDrawable</a> 同 <a href="#ShapeDrawable">ShapeDrawable</a> 是一样的，现在使用 <code>Java</code> 代码实现：</b></p>
                    <pre class="brush: java;">
/** 效果图参见 ShapeDrawable， 更多的效果参见 API 文档 */

/** 1. 实线边框 */
public Drawable createSolideBorderDrawable() {
    GradientDrawable drawable = new GradientDrawable();
    // 默认为 RECTANGLE
    drawable.setShape(GradientDrawable.RECTANGLE);

    // 实现边框
    int width = Tools.dip2px(this, 1);
    int color = getResources().getColor(R.color.colorAccent);
    drawable.setStroke(width, color);

    return drawable;
}

/** 2. 虚线边框 */
public Drawable createDashStokeDrawable() {
    GradientDrawable drawable = new GradientDrawable();
    // 虚线边框
    int width = Tools.dip2px(this, 1);
    int color = getResources().getColor(R.color.colorAccent);
    int dashWidth = Tools.dip2px(this, 10);
    int dashGap = Tools.dip2px(this, 2);
    drawable.setStroke(width, color, dashWidth, dashGap);

    return drawable;
}

/** 3. 实心填充 */
public Drawable createSolideDrawable() {
    GradientDrawable drawable = new GradientDrawable();

    // 填充
    int solid_color = getResources().getColor(android.R.color.holo_blue_light);
    drawable.setColor(solid_color);

    return drawable;
}

/** 4. 统一圆角 */
public Drawable createCornerDrawable() {
    GradientDrawable drawable = new GradientDrawable();

    // 颜色填充
    int solid_color = getResources().getColor(android.R.color.holo_blue_light);
    drawable.setColor(solid_color);

    // 4个角为统一圆角
    int corner = Tools.dip2px(this, 5);
    drawable.setCornerRadius(corner);

    return drawable;
}

/** 5. 分别设置 4 个圆角 */
public Drawable createDiffCornerDrawable() {
    GradientDrawable drawable = new GradientDrawable();

    // 颜色填充
    int solid_color = getResources().getColor(android.R.color.holo_blue_light);
    drawable.setColor(solid_color);

    /** 分别设置 4 个， 圆角数组长度为 8，分为 4 对，分别指定 4 个角的 x 和 y 长度。
     * 顺序为 top-left, top-right, bottom-right, bottom-left。指定图形为矩形才适用。
     */
    float[] corners = {30, 10, 30, 10, 0, 0, 0, 0, 0};
    drawable.setCornerRadii(corners);
    return drawable;
}

/** 6. 渐变 */
public Drawable createGradientDrawable() {
    GradientDrawable drawable = new GradientDrawable();

    // 渐变, 默认为 LINEAR_GRADIENT
    drawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);
    // 设置渐变方向，默认为 TOP_BOTTOM
    drawable.setOrientation(GradientDrawable.Orientation.TOP_BOTTOM);
    drawable.setGradientCenter(0.5f, 0.5f);
    int start = getResources().getColor(android.R.color.holo_blue_dark);
    int end = getResources().getColor(R.color.colorAccent);
    // 颜色数组长度至少为 2 才有渐变效果，可以有多个，第一个为 start, 最后一个为 end
    int[] colors = {start, end};
    drawable.setColors(colors);

    return drawable;
}
                    </pre>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="NinePatchDrawable"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">NinePatchDrawable</h3>
                </div>
                <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
	android.graphics.drawable.Drawable
		android.graphics.drawable.NinePatchDrawable
		
public class NinePatchDrawable extends Drawable {
    // 使用 NinePatch 构造
    public NinePatchDrawable(Resources res, NinePatch patch) {}
    // 两个构造方法其实一样，后面的三个参数用于构造一个 NinePatch
    public NinePatchDrawable(Resources res, Bitmap bitmap, byte[] chunk, Rect padding, String srcName) {}
}
</pre>

                    <p><a href="docs/reference/android/graphics/drawable/NinePatchDrawable.html" target="_blank">NinePatchDrawable</a> 格式的图片在 android 环境下具有自适应调节大小的能力，可以实现 PNG 图片的部分拉伸。</p>
                    <p>一个 <code>.9.png</code> 图片是一个标准的 PNG 图像，它包括四个边各一个额外的 1 像素宽的边界(如果使用 png 制作，那么它的实际宽度和高度各要加上 2px，但是绘制的还是原来大小)。边界用于定义图像的可伸展区域和静态区域。</p>
                    <p>在 Android Studio 中使用 <code>.9.png</code> 图片：</p>
                    <ul>
                        <li><p><code>.9.png</code> 图片每个边都必须有黑线标记；</p></li>
                        <li><p><code>.9.png</code> 图片每个边只能一条黑线标记；</p></li>
                        <li><p><code>.9.png</code> 图片左侧和上方的黑线交叉的部分即可扩展区域，右侧和下方的黑线交叉的部分即内容显示区域；</p></li>
                        <li><p>另外，在 Android Studio 中要制作 <code>.9.png</code> 图片，只要将普通 PNG 图片复制到 <code>drawable</code>, 直接打开即可。</p></li>
                    </ul>
                    <p><b>扩展区域</b> 和 <b>内容显示区域</b> 的理解：</p>
                    <ul>
                        <li><p>扩展区域 -- 左边和上边标记的线为扩展区域。如果宽度伸缩，那么只是上边标线区域的位置进行伸缩；如果高度伸缩，那么只是左边标线区域的位置进行伸缩。</p></li>
                        <li><p>内容显示区域 -- 有点类似 padding 功能。当 <code>.9.png</code> 作为 TextView 背景时，文字显示的左上角(开始位置)始终为底部标线和右边标线相交的开始位置(矩形的左上角)，右下角(结束位置)始终为底部标线和右边标线相交的结束位置(矩形的右下角)，和是否伸缩无关。在绘制 <code>.9.png</code> 的时候已经确定，如果宽度或者高度不够，将不能显示完整文字。</p></li>
                    </ul>


                    <p><a href="docs/reference/android/graphics/drawable/NinePatchDrawable.html" target="_blank">NinePatchDrawable</a> 最重要的构造方法里面的 <a href="docs/reference/android/graphics/NinePatch.html" target="_blank">NinePatch</a> 类:</p>
                    <pre class="brush: java;">
java.lang.Object
    android.graphics.NinePatch

public class NinePatch {
    public NinePatch(Bitmap bitmap, byte[] chunk) {}
    public NinePatch(Bitmap bitmap, byte[] chunk, String srcName) {}
}
                    </pre>
                    <p>可以使用马甲让一个非 <code>.9.png</code> 图片进行局部拉升，但是测试过程其内容展示区域失效。</p>
                    <pre class="brush: java;">
/** 让一张非 .9.png 图片局部拉伸 */
Resources res = getResources();
// ninepatch 是一张 .9.png 图片
Bitmap bitmap = BitmapFactory.decodeResource(res, R.drawable.ninepatch);
// 得到 ninepatch 这张图片的 chunk，包含了拉伸位置信息
byte[] chunk = bitmap.getNinePatchChunk();

// nine 这张图片非 .9.png， 但是使用了 ninepatch 这张图片的 chunk 构建 NinePatch 对象
NinePatch ninePatch = new NinePatch(BitmapFactory.decodeResource(res, R.drawable.nine), chunk);
NinePatchDrawable drawable = new NinePatchDrawable(res, ninePatch);
view.setBackground(drawable);
                    </pre>

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="PictureDrawable"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">PictureDrawable</h3>
                </div>
                <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
	android.graphics.drawable.Drawable
		android.graphics.drawable.PictureDrawable
		
public class PictureDrawable extends Drawable {
    public PictureDrawable(Picture picture) {}
}
</pre>
                    <p><a href="docs/reference/android/graphics/drawable/PictureDrawable.html" target="_blank">PictureDrawable</a> 使用 Picture 进行绘制，要关闭硬件加速。</p>
                    <p><a href="graphics.html#graphics-Picture">Picture</a> 可以记录在 Canvas 上每个绘制操作(通过 beginRecording 返回的 Canvas)，然后回放每个绘图操作。同时也支持将 Picture 中的内容写到 Stream 中，并支持从 Stream 恢复 Picture。这些功能使用 Bitmap 也能实现。但 Picture 只是记录绘图操作而不是绘制后的像素结果，因此存储大小比同样大小的 Bitmap 要小得多。</p>
                    <ol>
                        <li><p><code><a href="docs/reference/android/graphics/Picture.html" target="_blank">Picture</a> getPicture()</code> -- 获取 Picture</p></li>
                        <li><p><code>void setPicture(<a href="docs/reference/android/graphics/Picture.html" target="_blank">Picture</a> picture)</code> -- 设置 Picture</p></li>
                    </ol>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="LayerDrawable"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">LayerDrawable</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
						<pre class="brush: java;">
java.lang.Object
	android.graphics.drawable.Drawable
		android.graphics.drawable.LayerDrawable
		
public class LayerDrawable extends Drawable implements Drawable.Callback {
    public LayerDrawable(Drawable[] layers) {}
}
</pre>
                    <p><a href="docs/reference/android/graphics/drawable/LayerDrawable.html" target="_blank">LayerDrawable</a> 以数组的顺序绘制的 Drawable，因此最大索引的元素将被绘制在顶部。有两个子类： <a href="docs/reference/android/graphics/drawable/RippleDrawable.html" target="_blank">RippleDrawable</a>, <a href="docs/reference/android/graphics/drawable/TransitionDrawable.html"  target="_blank">TransitionDrawable</a>。</p>
                    <pre class="brush: xml;">
&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"
    &lt;!-- 填充 -->
    android:paddingStart=""
    android:paddingTop=""
    android:paddingEnd=""
    android:paddingBottom=""
    android:paddingLeft=""
    android:paddingRight=""
    android:paddingMode="nest|stack" &lt;!-- 默认，将每个层嵌套在前一层的填充物中|在前一层上直接堆叠每个层 -->
    android:opacity="transparent|translucent|opaque"
    android:autoMirrored="">

    &lt;item
        android:id=""               &lt;!-- 标识 drawable -->
        android:drawable=""         &lt;!-- 必须 -->
        android:width=""
        android:height=""
        android:gravity="$Gravity"  &lt;!-- 重力方向 -->
        &lt;!-- 相当于 margin -->
        android:bottom=""
        android:top=""
        android:start=""
        android:end=""
        android:left=""
        android:right="">

        &lt;... />                  &lt;!-- 可以嵌入各种 drawable -->

    &lt;/item>

    &lt;item ... />
&lt;/layer-list>
                    </pre>
                </div>
                    <div class="sub-item">
                        <p><a href="docs/reference/android/graphics/drawable/LayerDrawable.html" target="_blank">LayerDrawable</a> API:</p>
                    <ol>
                        <li><p><code>int addLayer(Drawable dr)</code> -- 添加一个 Drawable，返回起索引</p></li>
                        <li><p><code>void setDrawable(int index, Drawable drawable)</code> -- 替换指定 INDEX 上的 Drawable</p></li>
                        <li><p><code>boolean setDrawableByLayerId(int id, Drawable drawable)</code>-- 替换指定 ID 的 Drawable</p></li>
                        <li><p><code>Drawable getDrawable(int index)</code> -- 返回指定 INDEX 的 Drawable</p></li>
                        <li><p><code>Drawable findDrawableByLayerId(int id)</code> -- 返回指定 ID 的 Drawable</p></li>
                        <li><p><code>int findIndexByLayerId(int id)</code> -- 返回指定 ID 的索引</p></li>
                        <li><p><code>int getId(int index)</code> -- 指定 INDEX 对应 Drawable 的 ID</p></li>
                        <li><p><code>void setId(int index, int id)</code> -- 指定 INDEX 对应 Drawable 的 ID</p></li>
                        <li><p><code>int getNumberOfLayers()</code> -- 获取数量</p></li>

                        <li class="group"><p><code>void setLayerSize(int index, int w, int h)</code> -- 指定 INDEX 对应 Drawable 的大小</p></li>
                        <li><p><code>int getLayerWidth(int index)</code> -- 指定 INDEX 对应 Drawable 的宽度</p></li>
                        <li><p><code>void setLayerWidth(int index, int w)</code> -- 指定 INDEX 对应 Drawable 的宽度</p></li>
                        <li><p><code>int getLayerHeight(int index)</code> -- 指定 INDEX 对应 Drawable 的高度</p></li>
                        <li><p><code>void setLayerHeight(int index, int h)</code> -- 指定 INDEX 对应 Drawable 的高度</p></li>

                        <li class="group"><p><code>void setPaddingMode(int mode)</code> -- 填充模式: 	PADDING_MODE_NEST(默认)， PADDING_MODE_STACK</p></li>
                        <li><p><code>int getPaddingMode()</code> -- 获取填充模式</p></li>
                        <li><p><code>int getStartPadding()</code> -- 起始填充(LTR, RTL)</p></li>
                        <li><p><code>int getTopPadding()</code> -- 顶部填充</p></li>
                        <li><p><code>int getBottomPadding()</code> -- 底部填充</p></li>
                        <li><p><code>int getEndPadding()</code> -- 结束填充(LTR, RTL)</p></li>
                        <li><p><code>int getLeftPadding()</code> -- 左侧填充</p></li>
                        <li><p><code>int getRightPadding()</code> -- 右侧填充</p></li>
                        <li><p><code>boolean getPadding(Rect padding)</code> -- 填充保存到 Rect 中</p></li>
                        <li><p><code>void setPadding(int left, int top, int right, int bottom)</code> -- 设置填充</p></li>
                        <li><p><code>void setPaddingRelative(int start, int top, int end, int bottom)</code> -- 在原始填充基础上相加</p></li>

                        <li class="group"><p><code>int getLayerInsetStart(int index)</code> -- 开始边距(LTR, RTL)</p></li>
                        <li><p><code>void setLayerInsetStart(int index, int s)</code> -- 开始边距(LTR, RTL)</p></li>
                        <li><p><code>int getLayerInsetBottom(int index)</code> -- 底部边距</p></li>
                        <li><p><code>void setLayerInsetBottom(int index, int b)</code> -- 底部边距</p></li>
                        <li><p><code>int getLayerInsetEnd(int index)</code> -- 结束边距(LTR, RTL)</p></li>
                        <li><p><code>void setLayerInsetEnd(int index, int e)</code> -- 结束边距(LTR, RTL)</p></li>
                        <li><p><code>int getLayerInsetTop(int index)</code> -- 顶部边距</p></li>
                        <li><p><code>void setLayerInsetTop(int index, int t)</code> -- 顶部边距</p></li>
                        <li><p><code>int getLayerInsetLeft(int index)</code> -- 左侧边距</p></li>
                        <li><p><code>void setLayerInsetLeft(int index, int l)</code> -- 左侧边距</p></li>
                        <li><p><code>int getLayerInsetRight(int index)</code> -- 右侧边距</p></li>
                        <li><p><code>void setLayerInsetRight(int index, int r)</code> -- 右侧边距</p></li>
                        <li><p><code>void setLayerInset(int index, int l, int t, int r, int b)</code> -- 设置边距</p></li>
                        <li><p><code>void setLayerInsetRelative(int index, int s, int t, int e, int b)</code> -- 设置相对于 INDEX 对应 Drawable 边距</p></li>

                        <li class="group"><p><code>int getLayerGravity(int index)</code> -- 指定 INDEX 对应 Drawable 的重力方向</p></li>
                        <li><p><code>void setLayerGravity(int index, int gravity)</code> -- 重力方向</p></li>
                        <li><p><code>boolean setVisible(boolean visible, boolean restart)</code> -- 可见性</p></li>

                        <li class="group"><p><code>boolean onLayoutDirectionChanged(int layoutDirection)</code> -- 横竖屏切换回调</p></li>
                        <li><p><code>void scheduleDrawable(Drawable who, Runnable what, long when)</code> -- ?</p></li>
                        <li><p><code>void unscheduleDrawable(Drawable who, Runnable what)</code> -- ?</p></li>

                        <li class="group"><p><code>void setHotspot(float x, float y)</code> -- 指定可绘制区域内的热点</p></li>
                        <li><p><code>void setHotspotBounds(int left, int top, int right, int bottom)</code> -- 设置热点限制的边界，如果它们与可绘制边界不同</p></li>
                        <li><p><code>void getHotspotBounds(Rect outRect)</code> -- 获取热区边界</p></li>
                    </ol>
                    </div>

                    <div class="sub-item">
                        <p><a href="docs/reference/android/graphics/drawable/LayerDrawable.html" target="_blank">LayerDrawable</a> 子类：</p>
                        <p><a href="docs/reference/android/graphics/drawable/RippleDrawable.html" target="_blank">RippleDrawable</a> -- 用于产生一个触发反馈效果，比如在 Button 上点击，会有一个水波纹效果。</p>
                        <pre class="brush: xml;">
&lt;ripple xmlns:android="http://schemas.android.com/apk/res/android"
        android:color="@color/colorAccent"
        android:radius="@dimen/dimen_20_dp">

        &lt;item
            android:id=""               &lt;!-- 标识 drawable -->
            android:drawable=""         &lt;!-- 必须 -->
            android:width=""
            android:height=""
            android:gravity="$Gravity"  &lt;!-- 重力方向 -->
            &lt;!-- 相当于 margin -->
            android:bottom=""
            android:top=""
            android:start=""
            android:end=""
            android:left=""
            android:right="">

            &lt;... />                  &lt;!-- 可以嵌入各种 drawable -->
        &lt;/item>

        &lt;item ... />
&lt;/ripple>
                        </pre>
                        <p><a href="docs/reference/android/graphics/drawable/TransitionDrawable.html" target="_blank">TransitionDrawable</a> -- 用于在两个 Drawable 之间平滑切换。构造方法接受的 Drawable 数组长度只能为 2。</p>
                        <ul>
                            <li><p><code>void startTransition(int durationMillis)</code> -- 切换到第二个 Drawable</p></li>
                            <li><p><code>void reverseTransition(int duration)</code> -- 恢复到第一个 Drawable</p></li>
                            <li><p><code>void resetTransition()</code> -- 恢复到第一个 Drawable</p></li>
                            <li><p><code>void setCrossFadeEnabled(boolean enabled)</code> -- 是否开启透明渐变，默认不开启</p></li>
                            <li><p><code>boolean isCrossFadeEnabled()</code> -- 是否开启了透明渐变</p></li>
                        </ul>
                        <pre class="brush: xml;">
&lt;transition xmlns:android="http://schemas.android.com/apk/res/android"
    &lt;!-- 填充 -->
    android:paddingStart=""
    android:paddingTop=""
    android:paddingEnd=""
    android:paddingBottom=""
    android:paddingLeft=""
    android:paddingRight=""
    android:paddingMode="nest|stack" &lt;!-- 默认，将每个层嵌套在前一层的填充物中|在前一层上直接堆叠每个层 -->
    android:opacity="transparent|translucent|opaque"
    android:autoMirrored="">

    &lt;item
        android:id=""               &lt;!-- 标识 drawable -->
        android:drawable=""         &lt;!-- 必须 -->
        android:width=""
        android:height=""
        android:gravity="$Gravity"  &lt;!-- 重力方向 -->
        &lt;!-- 相当于 margin -->
        android:bottom=""
        android:top=""
        android:start=""
        android:end=""
        android:left=""
        android:right="">

        &lt;... />                  &lt;!-- 可以嵌入各种 drawable -->

    &lt;/item>

    &lt;item ... />
&lt;/transition>
                        </pre>
                    </div>
                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="DrawableWrapper"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">DrawableWrapper 及子类</h3>
                </div>
                <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    android.graphics.drawable.Drawable
  	    android.graphics.drawable.DrawableWrapper

public abstract DrawableWrapper extends Drawable implements Drawable.Callback {
    public DrawableWrapper(Drawable dr) {}
}
</pre>
                    <p><a href="docs/reference/android/graphics/drawable/DrawableWrapper.html" target="_blank">DrawableWrapper</a> 有以下子类：<a href="docs/reference/android/graphics/drawable/ClipDrawable.html" target="_blank">ClipDrawable</a>, <a href="docs/reference/android/graphics/drawable/InsetDrawable.html" target="_blank">InsetDrawable</a>, <a href="docs/reference/android/graphics/drawable/RotateDrawable.html" target="_blank">RotateDrawable</a>, <a href="docs/reference/android/graphics/drawable/ScaleDrawable.html" target="_blank">ScaleDrawable</a></p>

                    <p><a href="docs/reference/android/graphics/drawable/ClipDrawable.html" target="_blank">ClipDrawable</a> -- 可以根据 level 裁剪不同的部分，以达到展示图片不同部分的效果。</p>
                    <pre class="brush: xml;">
&lt;clip xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable=""
    android:gravity="$Gravity"
    android:clipOrientation="vertical|horizontal" />
                </pre>
                    <div class="row">
                        <div class="col-md-9">
                            <pre class="brush: java;">
/** Gravity 要和 Orientation 生成 ClipDrawable */
public ClipDrawable newClipDrawable(int gravity, int orientation) {
    Drawable image = getResources().getDrawable(R.drawable.jpg_480x320);
    return new ClipDrawable(image, gravity, orientation);
}

// 调用每个 ClipDrawable 的 setLevel 方法
for (ImageView imageView : views) {
    imageView.getDrawable().setLevel(progress);
}

/** 构建不同的 ClipDrawable, Gravity 要和 Orientation 配套 */
views[0]...(newClipDrawable(Gravity.START, ClipDrawable.HORIZONTAL));
views[1]...(newClipDrawable(Gravity.TOP, ClipDrawable.VERTICAL));
views[2]...(newClipDrawable(Gravity.CENTER, ClipDrawable.HORIZONTAL));
views[3]...(newClipDrawable(Gravity.CENTER, ClipDrawable.VERTICAL));
views[4]...(newClipDrawable(Gravity.END, ClipDrawable.HORIZONTAL));
views[5]...(newClipDrawable(Gravity.BOTTOM, ClipDrawable.VERTICAL));
/** Gravity 和 Orientation 可以有多个 */
views[6]...(newClipDrawable(Gravity.START|Gravity.TOP,
    ClipDrawable.HORIZONTAL|ClipDrawable.VERTICAL));
views[7]...(newClipDrawable(Gravity.CENTER,
    ClipDrawable.HORIZONTAL|ClipDrawable.VERTICAL));
                            </pre>

                        </div>
                        <div class="col-md-3"><img src="images/ClipDrawable.gif" class="img-responsive"/></div>
                    </div>

                    <p><a href="docs/reference/android/graphics/drawable/InsetDrawable.html" target="_blank">InsetDrawable</a></p>
                    <pre class="brush: xml;">
&lt;inset xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable=""
    android:visible="true|false"
    android:inset=""
    android:insetLeft=""
    android:insetTop=""
    android:insetRight=""
    android:insetBottom="" />
                    </pre>
                    <p><a href="docs/reference/android/graphics/drawable/RotateDrawable.html" target="_blank">RotateDrawable</a></p>
                    <pre class="brush: xml;">
&lt;rotate xmlns:android="http://schemas.android.com/apk/res/android"
    android:visible="true|false"
    android:drawable=""
    android:pivotX=""
    android:pivotY=""
    android:fromDegrees=""
    android:toDegrees="" />
                    </pre>
                    <p><a href="docs/reference/android/graphics/drawable/ScaleDrawable.html" target="_blank">ScaleDrawable</a></p>
                    <pre class="brush: xml;">
&lt;scale xmlns:android="http://schemas.android.com/apk/res/android"
       android:drawable=""
       android:level=""
       android:scaleWidth=""
       android:scaleHeight=""
       android:scaleGravity="$Gravity"
       android:useIntrinsicSizeAsMinimum="true|false" />
                    </pre>

                </div>
            </div>
            <!-- item over -->

            <!-- item start -->
            <a class="offset" id="DrawableContainer"></a>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">DrawableContainer 及子类</h3>
                </div>
                <div class="panel-body">
                    <div class="sub-item">
						<pre class="brush: java;">
java.lang.Object
	android.graphics.drawable.Drawable
		android.graphics.drawable.DrawableContainer

public class DrawableContainer extends Drawable {}
</pre>
                    <p><a href="docs/reference/android/graphics/drawable/DrawableContainer.html" target="_blank">DrawableContainer</a> 有以下下子类：<a href="docs/reference/android/graphics/drawable/AnimationDrawable.html" target="_blank">AnimationDrawable</a>, <a href="docs/reference/android/graphics/drawable/LevelListDrawable.html" target="_blank">LevelListDrawable</a>, <a href="docs/reference/android/graphics/drawable/StateListDrawable.html" target="_blank">StateListDrawable</a>, <a href="docs/reference/android/graphics/drawable/AnimatedStateListDrawable.html" target="_blank">AnimatedStateListDrawable</a></p>

                    </div>

                    <div class="sub-item">
                            <pre class="brush: java;">
                                    java.lang.Object
                                        android.graphics.drawable.Drawable
                                            android.graphics.drawable.StateListDrawable
                                            
                                    public class StateListDrawable extends Drawable {}
                                    </pre>
                                                        <p class="alert alert-success">请记住，<b>状态列表中与对象当前状态匹配的第一个项目将被应用。</b>因此，如果列表中的第一个项目不包含下面的状态属性，那么它将每次都被应用，这就是为什么您的默认值应该始终保持不变。比如：将
                                                            <code>state_focused</code> 放置于 <code>state_pressed</code> 前，那么 <code>state_pressed</code>
                                                            将不会执行，因为它也是 <code>state_focused</code> 状态。</p>
                                                        <pre class="brush: xml">
                                    &lt;?xml version="1.0" encoding="utf-8"?>
                                    &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"
                                        android:constantSize=["true" | "false"]
                                        android:dither=["true" | "false"]
                                        android:variablePadding=["true" | "false"] >
                                        &lt;item
                                            android:drawable="@[package:]drawable/drawable_resource"
                                            android:state_pressed=["true" | "false"]
                                            android:state_focused=["true" | "false"]
                                            android:state_hovered=["true" | "false"]
                                            android:state_selected=["true" | "false"]
                                            android:state_checkable=["true" | "false"]
                                            android:state_checked=["true" | "false"]
                                            android:state_enabled=["true" | "false"]
                                            android:state_activated=["true" | "false"]
                                            android:state_window_focused=["true" | "false"] />
                                    &lt;/selector>
                                    </pre>
                    </div>

                    <div class="sub-item">

                    </div>
                </div>
            </div>
            <!-- item over -->

<!-- item start -->
<a class="offset" id="VectorDrawable"></a>
<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">VectorDrawable</h3>
    </div>
    <div class="panel-body">
            <pre class="brush: java;">
java.lang.Object
android.graphics.drawable.Drawable
android.graphics.drawable.VectorDrawable

public class VectorDrawable extends Drawable {}
</pre>
        <p><a href="docs/reference/android/graphics/drawable/VectorDrawable.html" target="_blank">VectorDrawable</a></p>
    </div>
</div>
<!-- item over -->


<!-- item start -->
<a class="offset" id="AnimatedVectorDrawable"></a>
<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">AnimatedVectorDrawable</h3>
    </div>
    <div class="panel-body">
            <pre class="brush: java;">
java.lang.Object
android.graphics.drawable.Drawable
android.graphics.drawable.AnimatedVectorDrawable

public class AnimatedVectorDrawable extends Drawable {}
</pre>
        <p><a href="docs/reference/android/graphics/drawable/AnimatedVectorDrawable.html" target="_blank">AnimatedVectorDrawable</a></p>
    </div>
</div>
<!-- item over -->

        </div>
    </div>
</div>

<div class="btn-group-vertical bottom-button">
    <a href="#" type="button"
       class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
        <span class="caret"></span>
    </a>
    <a href="#" type="button"
       class="btn btn-default dropdown-toggle btn-primary"
       data-toggle="dropup"> TOP </a>
    <a href="docs/reference/index.html" type="button"
       class="btn btn-default dropdown-toggle btn-primary" target="_blank"
       data-toggle="dropup"> DOCS </a>
    <a href="docs/guide/index.html" type="button"
       class="btn btn-default dropdown-toggle btn-primary" target="_blank"
       data-toggle="dropup"> GUIDE </a>
</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="../support/jquery/jquery-3.1.1.min.js"></script>
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../support/bootstrap/js/bootstrap.min.js"></script>
<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
<script src="../support/syntaxhighlighter/scripts/shBrushXml.js"></script>
<script src="res/menu.js"></script>
<script src="../commons/js/common.js"></script>
</body>
</html>
