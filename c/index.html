<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--C</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					style="position: fixed; top: 70px; width: 260px; height: 85%; overflow: auto; float: left;">
					<div class="panel-heading">
						<h3 class="panel-title">C</h3>
					</div>
					<div class="list-group">
						<a href="#" class="list-group-item">简介</a>
						<a href="#c-compile" class="list-group-item">C 语言程序编译过程</a>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#c-base-menu" aria-expanded="true">
							C 语言基础<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="c-base-menu" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#c-keyword" class="list-group-item">关键字</a>
							<a href="#c-type" class="list-group-item">数据类型</a>
							<a href="#c-converter" class="list-group-item">强制类型转换</a>
							<a href="#c-const" class="list-group-item">常量</a>
							<a href="#c-calculator" class="list-group-item">运算符</a>
							<a href="#c-ifelse" class="list-group-item">流程控制</a>
							<a href="#c-function" class="list-group-item">函数</a>
							<a href="#c-area" class="list-group-item">作用域规则</a>
							<a href="#c-array" class="list-group-item">数组</a>
							<a href="#c-header" class="list-group-item">头文件</a>
							<a href="#c-string" class="list-group-item">字符串</a>
							<a href="#c-struct" class="list-group-item">结构体</a>
							<a href="#c-share" class="list-group-item">共用体</a>
							<a href="#c-bit-area" class="list-group-item">位域</a>
							<a href="#c-error" class="list-group-item">错误处理</a>
							<a href="#c-variable-arg" class="list-group-item">可变参数</a>
							<a href="#c-memory" class="list-group-item">内存管理</a>
							<a href="#c-cmd" class="list-group-item">命令行参数</a>
						</div>
						<a href="#c-printf" class="list-group-item">格式化输出</a>
						<a href="#c-preprocessor" class="list-group-item">预处理器</a>
						<a href="#c-poiter" class="list-group-item">指针</a>
						<a href="#c-file" class="list-group-item">文件读写</a>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#c-lib" aria-expanded="true">
							C 标准库(89)<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="c-lib" class="panel-collapse collapse in" role="tabpanel">
							<a href="#c-lib-string" class="list-group-item">
								<code>string.h</code>
							</a>
							<a href="#c-lib-stdio" class="list-group-item">
								<code>stdio.h</code>
							</a>
							<a href="#c-lib-stdlib" class="list-group-item">
								<code>stdlib.h</code>
							</a>
							<a href="#c-lib-error" class="list-group-item">
								<code>errno.h</code>
							</a>
							<a href="#c-lib-math" class="list-group-item">
								<code>math.h</code>
							</a>
							<a href="#c-lib-time" class="list-group-item">
								<code>time.h</code>
							</a>
							<a href="#c-lib-assert" class="list-group-item">
								<code>assert.h</code>
							</a>
							<a href="#c-lib-ctype" class="list-group-item">
								<code>ctype.h</code>
							</a>
							<a href="#c-lib-float" class="list-group-item">
								<code>float.h</code>
							</a>
							<a href="#c-lib-limits" class="list-group-item">
								<code>limits.h</code>
							</a>
							<a href="#c-lib-locale" class="list-group-item">
								<code>locale.h</code>
							</a>
							<a href="#c-lib-setjmp" class="list-group-item">
								<code>setjmp.h</code>
							</a>
							<a href="#c-lib-signal" class="list-group-item">
								<code>signal.h</code>
							</a>
							<a href="#c-lib-stdarg" class="list-group-item">
								<code>stdarg.h</code>
							</a>
							<a href="#c-lib-stddef" class="list-group-item">
								<code>stddef.h</code>
							</a>
						</div>
					
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#c-lib-11" aria-expanded="true">
							C 标准库(11)<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="c-lib-11" class="panel-collapse collapse in" role="tabpanel">
							<a href="#c-lib-iso646" class="list-group-item">
								<code>iso646.h</code>
							</a>
							<a href="#c-lib-wchar" class="list-group-item">
								<code>wchar.h</code>
							</a>
							<a href="#c-lib-wctype" class="list-group-item">
								<code>wctype.h</code>
							</a>
							<a href="#c-lib-complex" class="list-group-item">
								<code>complex.h</code>
							</a>
							<a href="#c-lib-fenv" class="list-group-item">
								<code>fenv.h</code>
							</a>
							<a href="#c-lib-inttypes" class="list-group-item">
								<code>inttypes.h</code>
							</a>
							<a href="#c-lib-stdbool" class="list-group-item">
								<code>stdbool.h</code>
							</a>
							<a href="#c-lib-stdint" class="list-group-item">
								<code>stdint.h</code>
							</a>
							<a href="#c-lib-tgmath" class="list-group-item">
								<code>tgmath.h</code>
							</a>
							<a href="#c-lib-stdalign" class="list-group-item">
								<code>stdalign.h</code>
							</a>
							<a href="#c-lib-stdatomic" class="list-group-item">
								<code>stdatomic.h</code>
							</a>
							<a href="#c-lib-stdnoreturn" class="list-group-item">
								<code>stdnoreturn.h</code>
							</a>
							<a href="#c-lib-threads" class="list-group-item">
								<code>threads.h</code>
							</a>
							<a href="#c-lib-uchar" class="list-group-item">
								<code>uchar.h</code>
							</a>
						</div>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<p>C 语言是一种通用的、面向过程式的计算机程序设计语言。C 语言是一种广泛使用的计算机语言，它与 Java
							编程语言一样普及，二者在现代软件程序员之间都得到广泛使用。</p>
						<ul>
							<li>OS: Linux Mint 17 (32位)</li>
							<li>GCC/G++: 4.4.7</li>
							<li>MAKE: GNU Make 3.81</li>
						</ul>

						<p>
							<b>Linux 下的 libc 和 glibc 库:</b>
						</p>
						<ul>
							<li>
								<p>
									<b>libc</b> -- libc 是 Linux 下的 ANSI C 函数库；libc 实际上是一个泛指。凡是符合实现了
									C 标准规定的内容，都是一种 libc 。 ANSI C 函数库是基本的 C 语言函数库，包含了 C
									语言最基本的库函数。这个库可以根据头文件划分为 15 个部分，参见下面的 C 标准库。
								</p>
							</li>
							<li>
								<p>
									<b>glibc</b> -- GNU C 函数库是一种类似于第三方插件的东西。由于 Linux 是用 C 语言写的，所以
									Linux 的一些操作是用 C 语言实现的，因此，GUN 组织开发了一个 C 语言的库 以便让我们更好的利用 C 语言开发基于
									Linux 操作系统的程序。不过现在的不同的 Linux
									的发行版本对这两个函数库有不同的处理方法，有的可能已经集成在同一个库里了；glibc 是 GNU 组织对 libc
									的一种实现。它是 unix/linux 的根基之一。
								</p>
							</li>
						</ul>
						<p>
							<b>glibc</b> 是 Linux 下面 C 标准库的实现，即GNU C Library。glibc 本身是 GNU 旗下的
							C 标准库，<b>后来逐渐成为了 Linux 的标准 C 库，而 Linux 下原来的标准 C 库 Linux libc
								逐渐不再被维护</b>。Linux 下面的标准 C 库不仅有这一个，如 uclibc、klibc，以及上面被提到的 Linux
							libc，但是<b>glibc 无疑是用得最多的</b>。
						</p>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-compile" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">C 语言程序编译过程</h3>
					</div>
					<div class="panel-body">
						<p width="100%">
							<img src="images/c-compile.png"
								class="img-responsive center-block">
						</p>
						<pre class="brush: bash;">
# 1.预处理, 生成 .i 文件
$ gcc -E test.c -o test.i

# 2.编译, 生成 .s 文件(汇编文件)
$ gcc -S test.i -o test.s

# 3.汇编, 生成 .o 文件(机器代码,二进制文件)
$ gcc -c test.s -o test.o

# 4.链接, 生成可执行文件(二进制文件)
$ gcc test.o -o test
</pre>
						<p>
							源代码:
							<code>test.c</code>
						</p>
						<pre class="brush: cpp;">
#include &lt;stdio.h>
 
int main() {
   /* 我的第一个 C 程序 */
   printf("Hello, World!\n");
   
   return 0;
}
</pre>
						<ul>
							<li>
								<p>
									<b>预处理</b> -- C
									语言程序从源代码变成可执行程序的第一步，主要是C语言编译器对各种预处理命令进行处理，包括头文件的包含、宏定义的扩展、条件编译的选择等。打印出预处理之后的结果,这样我们就可以看到源代码中的各种预处理命令是如何被解释的，从而方便理解和查错。
									<code>$ gcc -E test.c -o test.i</code>
									, 看到这个预处理过的 test.i 文件有 800 多行。
								</p>
								<pre class="brush: cpp;">
# 1 "test.c"
# 1 "&lt;built-in>"
# 1 "&lt;command-line>"
# 1 "test.c"
# 1 "/usr/include/stdio.h" 1 3 4

......
......


# 2 "test.c" 2

int main() {

   printf("Hello, World!\n");

   return 0;
}
</pre>
							</li>
							<li>
								<p>
									<b>编译</b> -- C 语言编译器会进行词法分析、语法分析，接着会把源代码翻译成中间语言，即汇编语言。<br>
									<code>$ gcc -S test.i -o test.s</code>
									。
								</p>
								<pre class="brush: cpp;">
	.file	"test.c"
	.section	.rodata
.LC0:
	.string	"Hello, World!"
	.text
.globl main
	.type	main, @function
main:
	pushl	%ebp
	movl	%esp, %ebp
	andl	$-16, %esp
	subl	$16, %esp
	movl	$.LC0, (%esp)
	call	puts
	movl	$0, %eax
	leave
	ret
	.size	main, .-main
	.ident	"GCC: (Ubuntu/Linaro 4.4.7-8ubuntu1) 4.4.7"
	.section	.note.GNU-stack,"",@progbits

</pre>
							</li>
							<li>
								<p>
									<b>汇编</b> -- 把作为中间结果的汇编代码翻译成了机器代码，即目标代码，不过它还不可以运行。<br>
									<code>$ gcc -c test.s -o test.o</code>
									, 生成的 .o 文件是二进制文件，直接用文本工具打开看到的将是乱码，我们需要反汇编工具如GDB的帮助才能读懂它.
								</p>
							</li>
							<li>
								<p>
									<b>链接</b> --
									链接是处理可重定位文件，把它们的各种符号引用和符号定义转换为可执行文件中的各适信息(一般是虚拟内存地址)的过程。链接又分为静态链接和动态链接，前者是程序开发阶段程序员用ld(gcc实际上在后台调用了ld)静态链接器手动链接的过程，而动态链接则是程序运行期间系统调用动态链接器(ld-linux.so)自动链接的过程。
									gcc 默认优先选择动态库，如果想要让 gcc 选择静态链接，那么需要指定一个选项，就是 -static, 这样就会强制
									gcc 找静态库文件了。 生成可执行文件:
									<code>$ gcc test.o -o test</code>
								</p>
								<p>
									<b>函数库</b>一般分为静态库和动态库两种:
								</p>
								<p>静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为”.a”。</p>
								<p>动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为”.so”，如前面所述的
									libc.so.6 就是动态库。gcc 在编译时默认使用动态库。</p>
							</li>
						</ul>
					</div>
				</div>

				<!-- item start -->
				<a id="c-base" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">C 语言基础</h3>
					</div>
					<div class="panel-body">
						<a id="c-keyword" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">关键字</h5>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<td style="width: 25%">auto</td>
										<td style="width: 25%">else</td>
										<td style="width: 25%">long</td>
										<td style="width: 25%">switch</td>
									</tr>
									<tr>
										<td>break</td>
										<td>enum</td>
										<td>register</td>
										<td>typedef</td>
									</tr>
									<tr>
										<td>case</td>
										<td>extern</td>
										<td>return</td>
										<td>union</td>
									</tr>
									<tr>
										<td>char</td>
										<td>float</td>
										<td>short</td>
										<td>unsigned</td>
									</tr>
									<tr>
										<td>const</td>
										<td>for</td>
										<td>signed</td>
										<td>void</td>
									</tr>
									<tr>
										<td>continue</td>
										<td>goto</td>
										<td>sizeof</td>
										<td>volatile</td>
									</tr>
									<tr>
										<td>default</td>
										<td>if</td>
										<td>static</td>
										<td>while</td>
									</tr>
									<tr>
										<td>do</td>
										<td>int</td>
										<td>struct</td>
										<td>_Packed</td>
									</tr>
									<tr>
										<td>double</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
								</tbody>
							</table>

							<pre class="brush: c;">
// C 语言中提供了存储说明符 auto、register、extern、static 说明的四种存储类别:
auto -- 定义局部变量，仅在语句块内部使用，所有的非全局变量的缺省值假定为 auto ,因此 auto 几乎不使用。

extern -- 可置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量或函数时，在其它模块中寻找其定义。

register -- 修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。

static -- 只能在内部使用，和 java 相反; 如果修饰局部变量，那么这个局部变量是静态局部变量了。
</pre>
						</div>

						<a id="c-type" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">数据类型</h5>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th>序号</th>
										<th>类型与描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>基本类型：</b><br>它们是算术类型，包括两种类型：整数类型和浮点类型。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>枚举类型：</b><br>它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>void 类型：</b><br>类型说明符 <i>void</i> 表明没有可用的值。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>派生类型：</b><br>它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td>
									</tr>
								</tbody>
							</table>
							<p>
								<b>整数类型</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th>类型</th>
										<th>存储大小</th>
										<th>值范围</th>
									</tr>
									<tr>
										<td>char</td>
										<td>1 字节</td>
										<td>-128 到 127 或 0 到 255</td>
									</tr>
									<tr>
										<td>unsigned char</td>
										<td>1 字节</td>
										<td>0 到 255</td>
									</tr>
									<tr>
										<td>signed char</td>
										<td>1 字节</td>
										<td>-128 到 127</td>
									</tr>
									<tr>
										<td>int</td>
										<td>2 或 4 字节</td>
										<td>-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
									</tr>
									<tr>
										<td>unsigned int</td>
										<td>2 或 4 字节</td>
										<td>0 到 65,535 或 0 到 4,294,967,295</td>
									</tr>
									<tr>
										<td>short</td>
										<td>2 字节</td>
										<td>-32,768 到 32,767</td>
									</tr>
									<tr>
										<td>unsigned short</td>
										<td>2 字节</td>
										<td>0 到 65,535</td>
									</tr>
									<tr>
										<td>long</td>
										<td>4 字节</td>
										<td>-2,147,483,648 到 2,147,483,647</td>
									</tr>
									<tr>
										<td>unsigned long</td>
										<td>4 字节</td>
										<td>0 到 4,294,967,295</td>
									</tr>
								</tbody>
							</table>
							<p>
								<b>浮点类型</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">

								<tbody>
									<tr>
										<th>类型</th>
										<th>存储大小</th>
										<th>值范围</th>
										<th>精度</th>
									</tr>
									<tr>
										<td>float</td>
										<td>4 字节</td>
										<td>1.2E-38 到 3.4E+38</td>
										<td>6 位小数</td>
									</tr>
									<tr>
										<td>double</td>
										<td>8 字节</td>
										<td>2.3E-308 到 1.7E+308</td>
										<td>15 位小数</td>
									</tr>
									<tr>
										<td>long double</td>
										<td>16 字节</td>
										<td>3.4E-4932 到 1.1E+4932</td>
										<td>19 位小数</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>void 类型</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th width="8%">序号</th>
										<th>类型与描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>函数返回为空</b><br>C
											中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <b>void exit
												(int status);</b></td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>函数参数为空</b><br>C 中有各种函数不接受任何参数。不带参数的函数可以接受一个
											void。例如 <b>int rand(void);</b></td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>指针指向 void</b><br>类型为 void *
											的指针代表对象的地址，而不是类型。例如，内存分配函数 <b>void *malloc( size_t size
												);</b> 返回指向 void 的指针，可以转换为任何数据类型。</td>
									</tr>
								</tbody>
							</table>
						</div>

						<a id="c-converter" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">强制类型转换</h5>
							<p>强制类型转换是把变量从一种类型转换为另一种数据类型。例如，如果您想存储一个 long
								类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int
								类型。您可以使用强制类型转换运算符来把值显式地从一种类型转换为另一种类型。</p>
							<p>类型转换可以是隐式的，由编译器自动执行，也可以是显式的，通过使用强制类型转换运算符来指定。在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。</p>
							<div class="row">
								<div class="col-md-8">
									<p>常用的算术转换是隐式地把值强制转换为相同的类型。编译器首先执行整数提升，如果操作数类型不同，则它们会被转换为右侧层次中出现的最高层次的类型：</p>
									<pre class="brush: cpp;">
#include &lt;stdio.h>
      
int main() {
    int sum = 17, count = 5;
    double avg;

    /** 强制类型转换运算符的优先级大于除法，因此 sum 的值首先被转换
     * 为 double 型，然后除以 count，得到一个类型为 double 的值。
     */
    avg = (double) sum / count;
    printf("Value of avg : %f\n", avg );


    int  i = 17;
    char c = 'c'; /* ascii 值是 99 */

    // 整数提升
    sum = i + c;
    printf("Value of sum : %d\n", sum );
    
    return 0;
}
</pre>
								</div>
								<div class="col-md-4">
									<img src="images/usual_arithmetic_conversion.png"
										class="img-responsive">
								</div>
							</div>
						</div>

						<a id="c-const" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">常量</h5>
							<p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。</p>
							<p>常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。</p>
							<p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。</p>
							<p>有两种简单的定义常量的方式：1.使用 #define 预处理器。2.使用 const 关键字。</p>
							<pre class="brush: cpp;">
#define LENGTH 10			// define 没有类型, 是在预处理阶段展开
#define WIDTH  5		

int main() {
	printf("%d\n", LENGTH * WIDTH);
	
	const int A = 3;		// const 有类型, 是编译运行阶段使用
	const int B = 4;
	printf("%d\n", A * B);
 
	return 0;
}
</pre>
						</div>

						<a id="c-calculator" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">运算符</h5>
							<p>
								<b>算术运算符</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>+</td>
										<td>把两个操作数相加</td>
										<td>A + B 将得到 30</td>
									</tr>
									<tr>
										<td>-</td>
										<td>从第一个操作数中减去第二个操作数</td>
										<td>A - B 将得到 -10</td>
									</tr>
									<tr>
										<td>*</td>
										<td>把两个操作数相乘</td>
										<td>A * B 将得到 200</td>
									</tr>
									<tr>
										<td>/</td>
										<td>分子除以分母</td>
										<td>B / A 将得到 2</td>
									</tr>
									<tr>
										<td>%</td>
										<td>取模运算符，整除后的余数</td>
										<td>B % A 将得到 0</td>
									</tr>
									<tr>
										<td>++</td>
										<td>自增运算符，整数值增加 1</td>
										<td>A++ 将得到 11</td>
									</tr>
									<tr>
										<td>--</td>
										<td>自减运算符，整数值减少 1</td>
										<td>A-- 将得到 9</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>关系运算符</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>==</td>
										<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
										<td>(A == B) 不为真。</td>
									</tr>
									<tr>
										<td>!=</td>
										<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
										<td>(A != B) 为真。</td>
									</tr>
									<tr>
										<td>&gt;</td>
										<td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
										<td>(A &gt; B) 不为真。</td>
									</tr>
									<tr>
										<td>&lt;</td>
										<td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
										<td>(A &lt; B) 为真。</td>
									</tr>
									<tr>
										<td>&gt;=</td>
										<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
										<td>(A &gt;= B) 不为真。</td>
									</tr>
									<tr>
										<td>&lt;=</td>
										<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
										<td>(A &lt;= B) 为真。</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>逻辑运算符</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>&amp;&amp;</td>
										<td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
										<td>(A &amp;&amp; B) 为假。</td>
									</tr>
									<tr>
										<td>||</td>
										<td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
										<td>(A || B) 为真。</td>
									</tr>
									<tr>
										<td>!</td>
										<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
										<td>!(A &amp;&amp; B) 为真。</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>位运算符</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>&amp;</td>
										<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
										<td>(A &amp; B) 将得到 12，即为 0000 1100</td>
									</tr>
									<tr>
										<td>|</td>
										<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
										<td>(A | B) 将得到 61，即为 0011 1101</td>
									</tr>
									<tr>
										<td>^</td>
										<td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>
										<td>(A ^ B) 将得到 49，即为 0011 0001</td>
									</tr>
									<tr>
										<td>~</td>
										<td>二进制补码运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0。</td>
										<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
									</tr>
									<tr>
										<td>&lt;&lt;</td>
										<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
										<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
									</tr>
									<tr>
										<td>&gt;&gt;</td>
										<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
										<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>赋值运算符</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>=</td>
										<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
										<td>C = A + B 将把 A + B 的值赋给 C</td>
									</tr>
									<tr>
										<td>+=</td>
										<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
										<td>C += A 相当于 C = C + A</td>
									</tr>
									<tr>
										<td>-=</td>
										<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
										<td>C -= A 相当于 C = C - A</td>
									</tr>
									<tr>
										<td>*=</td>
										<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
										<td>C *= A 相当于 C = C * A</td>
									</tr>
									<tr>
										<td>/=</td>
										<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
										<td>C /= A 相当于 C = C / A</td>
									</tr>
									<tr>
										<td>%=</td>
										<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
										<td>C %= A 相当于 C = C % A</td>
									</tr>
									<tr>
										<td>&lt;&lt;=</td>
										<td>左移且赋值运算符</td>
										<td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>
									</tr>
									<tr>
										<td>&gt;&gt;=</td>
										<td>右移且赋值运算符</td>
										<td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>
									</tr>
									<tr>
										<td>&amp;=</td>
										<td>按位与且赋值运算符</td>
										<td>C &amp;= 2 等同于 C = C &amp; 2</td>
									</tr>
									<tr>
										<td>^=</td>
										<td>按位异或且赋值运算符</td>
										<td>C ^= 2 等同于 C = C ^ 2</td>
									</tr>
									<tr>
										<td>|=</td>
										<td>按位或且赋值运算符</td>
										<td>C |= 2 等同于 C = C | 2</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>杂项运算符 ↦ sizeof & 三元</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>sizeof()</td>
										<td>返回变量的大小。</td>
										<td>sizeof(a) 将返回 4，其中 a 是整数。</td>
									</tr>
									<tr>
										<td>&amp;</td>
										<td>返回变量的地址。</td>
										<td>&amp;a; 将给出变量的实际地址。</td>
									</tr>
									<tr>
										<td>*</td>
										<td>指向一个变量。</td>
										<td>*a; 将指向一个变量。</td>
									</tr>
									<tr>
										<td>? :</td>
										<td>条件表达式</td>
										<td>如果条件为真 ? 则值为 X : 否则值为 Y</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>C 中的运算符优先级</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th>类别&nbsp;</th>
										<th>运算符&nbsp;</th>
										<th>结合性&nbsp;</th>
									</tr>
									<tr>
										<td>后缀&nbsp;</td>
										<td>() [] -&gt; . ++ - - &nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>一元&nbsp;</td>
										<td>+ - ! ~ ++ - - (type)* &amp; sizeof&nbsp;</td>
										<td>从右到左&nbsp;</td>
									</tr>
									<tr>
										<td>乘除&nbsp;</td>
										<td>* / %&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>加减&nbsp;</td>
										<td>+ -&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>移位&nbsp;</td>
										<td>&lt;&lt; &gt;&gt;&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>关系&nbsp;</td>
										<td>&lt; &lt;= &gt; &gt;=&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>相等&nbsp;</td>
										<td>== !=&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>位与 AND&nbsp;</td>
										<td>&amp;&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>位异或 XOR&nbsp;</td>
										<td>^&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>位或 OR&nbsp;</td>
										<td>|&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>逻辑与 AND&nbsp;</td>
										<td>&amp;&amp;&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>逻辑或 OR&nbsp;</td>
										<td>||&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>条件&nbsp;</td>
										<td>?:&nbsp;</td>
										<td>从右到左&nbsp;</td>
									</tr>
									<tr>
										<td>赋值&nbsp;</td>
										<td>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^=
											|=&nbsp;</td>
										<td>从右到左&nbsp;</td>
									</tr>
									<tr>
										<td>逗号&nbsp;</td>
										<td>,&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
								</tbody>
							</table>
						</div>

						<a id="c-ifelse" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">流程控制</h5>
							<p>
								<b>判断</b> -- C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。
							</p>
							<pre class="brush: cpp;">
/* 1. if-else 结构, 非零和非空的值为 true */
if(boolean_expression) {
	/* 如果布尔表达式为真将执行的语句 */
} else if(boolean_expression) {
	/* 如果前面布尔表达式为假，这个为真将执行的语句 */
} else {
	/* 如果布尔表达式为假将执行的语句 */
}

/**
 * 2.switch 结构, 语句中的 expression 必须是一个整型或枚举类型，或者是一个 class 类型，
 *	其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
 */
switch(expression){
	case constant-expression :
		statement(s);
		break; /* 可选的 */
	case constant-expression  :
		statement(s);
		break; /* 可选的 */
    default : /* 可选的 */
		statement(s);
}
</pre>
							<p>
								<b>循环</b>
							</p>
							<pre class="brush: cpp;">
/* 1.while 循环 */
while(condition) {
   statement(s);
}

/* 2.for 循环,  无限循环: for( ; ; ){} */
for(init; condition; increment) {
   statement(s);
}

/* 3.do-while 循环 */
do {
   statement(s);
} while(condition);

/**
 * break: 终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。
 * continue: 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。
 * goto: C 语言中的 goto 语句允许把控制无条件转移到同一函数内的被标记的语句。
 */
</pre>
						</div>

						<a id="c-function" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">函数</h5>
							<p>
								<b>函数声明:</b> 函数声明会告诉编译器函数名称及如何调用函数。
							</p>
							<pre class="brush: cpp;">
return_type function_name(parameter list);	// 在函数声明中，参数的名称并不重要，只有参数的类型是必需的
return_type function_name(parameter);		// 省略参数名
</pre>
							<p>
								<b>函数定义:</b> 函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：
							</p>
							<ul>
								<li>
									<b>返回类型：</b>一个函数可以返回一个值。<b>return_type</b>
									是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <b>void</b>。
								</li>
								<li>
									<b>函数名称：</b>这是函数的实际名称。函数名和参数列表一起构成了函数签名。
								</li>
								<li>
									<b>参数：</b>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
								</li>
								<li>
									<b>函数主体：</b>函数主体包含一组定义函数执行任务的语句。
								</li>
							</ul>
							<p>
								<b>内部函数:</b> 如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数是，在函数名和函数类型的前面加
								<code>static</code>
								。
							</p>
							<p>
								<b>外部函数:</b> 如果在定义函数时，在函数的首部的最左端加关键字 extern，则此函数是外部函数，可供其它文件调用。
								C 语言规定，如果在定义函数时省略 extern，则默认为外部函数。
							</p>
							<pre class="brush: cpp;">
/* test.c */
#include &lt;stdio.h>

int main() {
   printf("Sum is %d.\n", sum(3, 4));
   printf("Sum is %d.\n", minus(1000, 4));
   
   return 0;
}

static int minus(int a, int b) {
    return a - b;
}

/* support.c */
#include &lt;stdio.h>
 
static int sum(int x, int y) {
   return x + y;
}
</pre>
						</div>

						<a id="c-area" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">作用域规则</h5>
							<p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p>
							<ol>
								<li>
									在函数或块内部的<b>局部</b>变量
								</li>
								<li>
									在所有函数外部的<b>全局</b>变量
								</li>
								<li>
									在<b>形式</b>参数的函数参数定义中
								</li>
							</ol>
						</div>

						<a id="c-array" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">数组</h5>
							<p>C
								语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>
							<pre class="brush: cpp;">

#include &lt;stdio.h>
#include &lt;stdlib.h>  
      
int main() {  
    int a[12] = { 1,2,3,4,5,6 };  
    printf("a:     %d\n", a);       // 数组首元素地址
    printf("&a:    %d\n", &a);      // 整个数组地址位置
    printf("&a[0]: %d\n", &a[0]);   // 数组首元素地址另一种获取方法
    printf("&a[1]: %d\n\n", &a[1]); // 数组第二个元素的地址

    printf("a:     %d\n", a+1);     // 数组首元素地址加1后的地址，即第二个元素a[1]的地址
    printf("&a[1]: %d\n", &a[1]);   // 数组第二个元素的地址  
    printf("&a:    %d\n", &a+1);    // 首地址位置 + 4x12（(类型x数组size)），即位移整个数组的长度   

    return 0;
}  

type arrayName [ arraySize ];		// 数组声明语句

double balance[10];
balance[4] = 50.0;					// balance[4] 值赋为 50.0

double balance[5] = { 1000.0, 2.0, 3.4, 7.0, 50.0 };	// 初始化数组
double balance[] = { 1000.0, 2.0, 3.4, 7.0, 50.0 };		// 省略数组的大小

/* 多维数组 */
type name[size1][size2]...[sizeN];
int a[3][4] = {  
	{ 0, 1, 2, 3 } ,   /*  初始化索引号为 0 的行 */
	{ 4, 5, 6, 7 } ,   /*  初始化索引号为 1 的行 */
	{ 8, 9, 10, 11 }   /*  初始化索引号为 2 的行 */
};
</pre>
						</div>



						<a id="c-header" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">头文件</h5>
							<p>头文件是扩展名为 .h 的文件，包含了 C
								函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p>
							<p>在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它。前面我们已经看过 stdio.h
								头文件，它是编译器自带的头文件。</p>
							<p>建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p>
							<p class="text-warning">如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中。</p>
							<p>使用预处理指令 #include 可以引用用户和系统头文件。它的形式有以下两种：</p>
							<pre class="brush: cpp;">
/** 这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。
 *		在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。
 */
#include &lt;file>

/** 这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。
 * 在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。
 */
#include "file"
</pre>
							<p>
								<b>C 标准头文件</b>
							</p>
							<p>C89 标准头文件(共 15 个)</p>
							<ul>
								<li>
									<p>
										<code>stdio.h</code>
										-- 标准输入输出
									</p>
								</li>
								<li>
									<p>
										<code>stdlib.h</code>
										-- 一些通用函数
									</p>
								</li>
								<li>
									<p>
										<code>string.h</code>
										-- 定义 C 语言字符串处理函数。
									</p>
								</li>
								<li>
									<p>
										<code>errno.h</code>
										-- 用来测试由库函数报的错误代码。
									</p>
								</li>
								<li>
									<p>
										<code>assert.h</code>
										-- 包含断言宏，被用来在程序的调试版本中帮助检测逻辑错误以及其他类型的 bug。
									</p>
								</li>
								<li>
									<p>
										<code>math.h</code>
										-- 定义C语言数学函数。
									</p>
								</li>
								<li>
									<p>
										<code>stdarg.h</code>
										-- 标准参数，主要目的为让函数能够接收可变参数。
									</p>
								</li>
								<li>
									<p>
										<code>stddef.h</code>
										-- 定义了一些标准宏以及类型。
									</p>
								</li>
								<li>
									<p>
										<code>ctype.h</code>
										-- 定义了一组函数，用来根据类型来给字符分类，或者进行大小写转换，而不关心所使用的字符集。
									</p>
								</li>
								<li>
									<p>
										<code>time.h</code>
										-- 日期和时间头文件。用于需要时间方面的函数。
									</p>
								</li>
								<li>
									<p>
										<code>locale.h</code>
										-- 定义C语言本地化函数。
									</p>
								</li>
								<li>
									<p>
										<code>float.h</code>
										-- 提供了浮点型的范围和精度的宏，没有类型和函数的定义，一般用于数值分析。
									</p>
								</li>
								<li>
									<p>
										<code>limits.h</code>
										-- 门用于检测整型数据数据类型的表达值范围。
									</p>
								</li>
								<li>
									<p>
										<code>signal.h</code>
										-- 定义 C 语言信号处理函数。
									</p>
								</li>
								<li>
									<p>
										<code>setjmp.h</code>
										-- 定义了宏 setjmp 和 longjmp，在非局部跳转的时候使用。
									</p>
								</li>
							</ul>
							<p>C99 另加的标准头文件(前 3 个为 1995 年添加，后 6 个为 1999 年添加，共 24 个)</p>
							<ul>
								<li>
									<p>
										<code>iso646.h</code>
										-- 定义了一批 C 语言常见运算符的可选拼写。
									</p>
								</li>
								<li>
									<p>
										<code>wchar.h</code>
										-- 宽字符处理及输入/输出
									</p>
								</li>
								<li>
									<p>
										<code>wctype.h</code>
										-- 宽字符分类
									</p>
								</li>
								<li>
									<p>
										<code>complex.h</code>
										-- 一组操作复数的函数。
									</p>
								</li>
								<li>
									<p>
										<code>fenv.h</code>
										-- 定义了一组用来控制浮点数环境的函数。
									</p>
								</li>
								<li>
									<p>
										<code>inttypes.h</code>
										-- 整数格式转换
									</p>
								</li>
								<li>
									<p>
										<code>stdbool.h</code>
										-- 布尔环境
									</p>
								</li>
								<li>
									<p>
										<code>stdint.h</code>
										-- 整型环境
									</p>
								</li>
								<li>
									<p>
										<code>tgmath.h</code>
										-- 通用类型数学宏
									</p>
								</li>
							</ul>
							<p>C11 另加的标准头文件(2011 年添加了 5 个, 共 29 个)</p>
							<ul>
								<li>
									<p>
										<code>stdalign.h</code>
										-- 用于查询和指定对象的数据结构对齐。
									</p>
								</li>
								<li>
									<p>
										<code>stdatomic.h</code>
										-- 用于在线程之间共享数据的原子操作。
									</p>
								</li>
								<li>
									<p>
										<code>stdnoreturn.h</code>
										-- 用于指定非返回函数。
									</p>
								</li>
								<li>
									<p>
										<code>threads.h</code>
										-- 定义用于管理多线程功能以及互斥锁和条件变量。
									</p>
								</li>
								<li>
									<p>
										<code>uchar.h</code>
										-- 处理 unicode 字符的类型和函数。
									</p>
								</li>
							</ul>

						</div>

						<a id="c-string" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">字符串</h5>
							<p>
								在 C 语言中，字符串实际上是使用 null 字符 '\0' 终止的一维字符数组。更多 string 用法查看:
								<code>string.h</code>
							</p>
							<pre class="brush: cpp;">
int main () {
	char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
	char str_2[] = "Hello";
	
	/* 输出返回值 */
	printf( "str： %s \n", str );
	printf( "str_2 : %s \n", str_2 );
	
	char str1[12] = "Hello";
	char str2[12] = "World";
	char str3[12];
	int  len ;
	
	/* 复制 str1 到 str3 */
	strcpy(str3, str1);
	printf("strcpy( str3, str1) :  %s\n", str3);
	
	/* 连接 str1 和 str2 */
	strcat(str1, str2);
	printf("strcat( str1, str2):   %s\n", str1);
	
	/* 连接后，str1 的总长度 */
	len = strlen(str1);
	printf("strlen(str1) :  %d\n", len);
	 
	return 0;
}
</pre>
						</div>

						<a id="c-struct" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">结构体</h5>
							<p>C 数组允许定义可存储相同类型数据项的变量，结构是 C
								编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;string.h>

struct Student {
    int id;
    char name[32];
};

void show_person(const struct Student s) {
    printf("id:%d name:%s\n", s.id, s.name);    
}

void show_person_p(const struct Student *s) {
    printf("id:%d name:%s\n", s->id, s->name);
}

/** 结构体变量作为参数 */
struct Student update_person(struct Student s) {
    s.id = 1002;
    strcpy(s.name, "李四");
    return s;
}

/** 结构体指针作为参数 */
void update_person_p(struct Student *s) {
    s->id = 1003;
    strcpy(s->name, "王五");
}

/** 结构体成员变量作为参数 */
int update_person_id(int id, int new_id) {
    id = new_id;
    return id;
}

/** 结构体成员变量指针作为参数 */
void update_person_id_p(int *id, int new_id) {
    *id = new_id;
}

int main() {      
    struct Student s;
    s.id = 1001;
    strcpy(s.name, "张三");

    printf("== 1. 如果只是读取，两种都可以：\n");
    show_person(s);
    show_person_p(&s);

    printf("== 2. 传结构体变量，对变量做一份拷贝，不修改原来的值：\n");
    struct Person s2 = update_person(s);
    show_person(s2);    // s2 为拷贝，修改 s2 的值不影响 s
    show_person(s);

    printf("== 3. 传结构体指针，直接修改原来的值：\n");
    update_person_p(&s);
    show_person(s);

    printf("== 4. 结构体成员变量，对变量做一份拷贝，不修改原来的值: \n");
    update_person_id(s.id, 1004);
    show_person(s);

    printf("== 5. 结构体成员指针，直接修改原来的值: \n");
    update_person_id_p(&s.id, 1005);
    show_person(s);

    return 0;
}

</pre>
						</div>

						<a id="c-share" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">共用体</h5>
							<p>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;string.h>
 
union Data {
   int i;
   float f;
   char  str[20];
};
 
int main() {
   union Data data;        

   data.i = 10;                         
   // data.f = 20.5;					// 同一时刻只能使用共用体中的一个变量, 不能再使用其它变量
   printf("data.i : %d\n", data.i);
   
   data.f = 220.5;
   printf("data.f : %f\n", data.f);
   
   strcpy(data.str, "C Programming");
   printf("data.str : %s\n", data.str);

   return 0;
}
</pre>
						</div>

						<a id="c-bit-area" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">位域</h5>
							<p>带有预定义宽度的变量被称为位域。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7
								的值，您可以定义一个宽度为 3 位的位域，如下：</p>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;string.h>

struct {
	unsigned int age : 3;					// 只有三位，能表示 0-7
} Age;

int main() {
	Age.age = 4;
	printf( "Sizeof( Age ) : %d\n", sizeof(Age) );
	printf( "Age.age : %d\n", Age.age );
	
	Age.age = 7;
	printf( "Age.age : %d\n", Age.age );
	
	Age.age = 8;							// 三位无法表示 8, 编译会有警告，但是能通过，结果是不对的
	printf( "Age.age : %d\n", Age.age );
	
	return 0;
}
</pre>
						</div>

						<a id="c-error" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">错误处理</h5>
							<p>
								C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或
								UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码
								errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在
								<error.h> 头文件中找到各种各样的错误代码。 
							</p>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;errno.h>
#include &lt;string.h>

extern int errno ;

int main () {
    FILE * pf;
    int errnum;
    pf = fopen ("unexist.txt", "rb");
    if (pf == NULL) {
        errnum = errno;
        fprintf(stderr, "错误号: %d\n", errno);
        perror("通过 perror 输出错误");
        fprintf(stderr, "打开文件错误: %s\n", strerror( errnum ));
    } else {
        fclose (pf);
    }
    return 0;
}
</pre>
						</div>

						<a id="c-variable-arg" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">可变参数</h5>
							<p>有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。C
								语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。</p>
							<p>
								请注意，函数 <b>func()</b> 最后一个参数写成省略号，即三个点号（<b>...</b>），省略号之前的那个参数总是
								<b>int</b>，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 <b>stdarg.h</b>
								头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：
							</p>
							<ul>
								<li>
									定义一个函数，最后一个参数为省略号，省略号前面的那个参数总是 <b>int</b>，表示了参数的个数。
								</li>
								<li>
									在函数定义中创建一个 <b>va_list</b> 类型变量，该类型是在 stdarg.h 头文件中定义的。
								</li>
								<li>
									使用 <b>int</b> 参数和 <b>va_start</b> 宏来初始化 <b>va_list</b>
									变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。
								</li>
								<li>
									使用 <b>va_arg</b> 宏和 <b>va_list</b> 变量来访问参数列表中的每个项。
								</li>
								<li>
									使用宏 <b>va_end</b> 来清理赋予 <b>va_list</b> 变量的内存。
								</li>
							</ul>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;stdarg.h>

double average(int num, ...) {
    va_list valist;
    double sum = 0.0;
    int i;

    /* 为 num 个参数初始化 valist */
    va_start(valist, num);

    /* 访问所有赋给 valist 的参数 */
    for (i = 0; i < num; i++) {
       sum += va_arg(valist, int);
    }
    /* 清理为 valist 保留的内存 */
    va_end(valist);

    return sum / num;
}

int main() {
   printf("Average of 2, 3, 4, 5 = %f\n", average(4, 2,3,4,5));
   printf("Average of 5, 10, 15 = %f\n", average(3, 5,10,15));

   return 0;
}
</pre>
						</div>

						<a id="c-memory" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">内存管理</h5>
							<p>
								C 语言为内存的分配和管理提供了几个函数。这些函数可以在
								<stdlib.h> 头文件中找到。 
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th>序号</th>
										<th>函数和描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>void *calloc(int num, int size);</b><br>该函数分配一个带有
											<b>num</b> 个元素的数组，每个元素的大小为 <b>size</b> 字节。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>void free(void *address); </b><br>该函数释放
											address 所指向的h内存块。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>void *malloc(int num); </b><br>该函数分配一个 <b>num</b>
											字节的数组，并把它们进行初始化。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>void *realloc(void *address, int newsize); </b><br>该函数重新分配内存，把内存扩展到
											<b>newsize</b>。</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>

int main() {
   char name[100];
   char *description;

   strcpy(name, "Zara Ali");

   /* 动态分配内存 */
   description = malloc( 30 * sizeof(char) );
   if( description == NULL )  {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   } else {
      strcpy( description, "Zara ali a DPS student.");
   }
   /* 假设您想要存储更大的描述信息 */
   description = realloc( description, 100 * sizeof(char) );
   if( description == NULL ) {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   } else {
      strcat( description, "She is in class 10th");
   }
   
   printf("Name = %s\n", name );
   printf("Description: %s\n", description );

   /* 使用 free() 函数释放内存 */
   free(description);

   return 0;
}
</pre>
						</div>

						<a id="c-cmd" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">命令行参数</h5>
							<p>执行程序时，可以从命令行传值给 C
								程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。
							</p>
							<p>
								命令行参数是使用 main() 函数参数来处理的，其中，<b>argc</b> 是指传入参数的个数，<b>argv[]</b>
								是一个指针数组，指向传递给程序的每个参数。
							</p>
							<pre class="brush: c;">
#include &lt;stdio.h>

int main( int argc, char *argv[] ) {
   if( argc == 2 ) {
      printf("The argument supplied is %s\n", argv[1]);
   } else if( argc > 2 ) {
      printf("Too many arguments supplied.\n");
   } else {
      printf("One argument expected.\n");
   }
   
   return 0;
}
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-printf" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">格式化输出</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>int printf(char *format, ...);</code>
							函数是最常用的格式化输出函数。
						</p>
						<p>根据参数 format
							字符串来转换并格式化数据，然后将结果输出到标准输出设备（显示器），直到出现字符串结束('\0')为止。</p>
						<p>格式转换为一个百分比符号(%)及其后的格式字符所组成。一般而言，每个%符号在其后都必需有一个参数与之相呼应（只有当%%转换字符出现时会直接输出%字符），而欲输出的数据类型必须与其相对应的转换字符类型相同。</p>
						<pre class="brush: cpp;">
/* 格式转换的一般形式如下：% 和 type 是必要的 */
%[flags][width][.precision][length]type
</pre>
						<p>
							<b>type 的类型:</b>
						</p>
						<table class="table table-bordered table-responsive table-striped"
							<tbody>
								<tr>
									<th>格式字符</th>
									<th>意义</th>
								</tr>
								<tr>
									<td>d</td>
									<td>以十进制形式输出带符号整数(正数不输出符号)</td>
								</tr>
								<tr>
									<td>o</td>
									<td>以八进制形式输出无符号整数(不输出前缀0)</td>
								</tr>
								<tr>
									<td>x,X</td>
									<td>以十六进制形式输出无符号整数(不输出前缀Ox)</td>
								</tr>
								<tr>
									<td>u</td>
									<td>以十进制形式输出无符号整数</td>
								</tr>
								<tr>
									<td>f</td>
									<td>以小数形式输出单、双精度实数</td>
								</tr>
								<tr>
									<td>e,E</td>
									<td>以指数形式输出单、双精度实数</td>
								</tr>
								<tr>
									<td>g,G</td>
									<td>以%f或%e中较短的输出宽度输出单、双精度实数</td>
								</tr>
								<tr>
									<td>c</td>
									<td>输出单个字符</td>
								</tr>
								<tr>
									<td>s</td>
									<td>输出字符串</td>
								</tr>

								<tr>
									<td>p</td>
									<td>输出指针地址</td>
								</tr>

								<tr>
									<td>lu</td>
									<td>32位无符号整数</td>
								</tr>

								<tr>
									<td>llu</td>
									<td>64位无符号整数</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>flags 有下列几种情况:</b>
						</p>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th style="width: 18%">flags（标识）</th>
									<th>描述</th>
								</tr>
								<tr>
									<td>-</td>
									<td>在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。</td>
								</tr>
								<tr>
									<td>+</td>
									<td>强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 -
										号。</td>
								</tr>
								<tr>
									<td>空格</td>
									<td>如果没有写入任何符号，则在该值前面插入一个空格。</td>
								</tr>
								<tr>
									<td>#</td>
									<td>与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。<br> 与
										e、E 和 f
										一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。<br>
										与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。
									</td>
								</tr>
								<tr>
									<td>0</td>
									<td>在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>width</b> -- 为参数的最小长度，若此栏并非数值，而是 * 符号，则表示以下一个参数当做参数长度。
						</p>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th style="width: 18%">width（宽度）</th>
									<th>描述</th>
								</tr>
								<tr>
									<td>(number)</td>
									<td>要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。</td>
								</tr>
								<tr>
									<td>*</td>
									<td>宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>precision 有几种情况：</b>
						</p>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th style="width: 18%">.precision（精度）</th>
									<th>描述</th>
								</tr>
								<tr>
									<td>.number</td>
									<td>对于整数说明符（d、i、o、u、x、X）：precision
										指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0
										意味着不写入任何字符。<br> 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。<br> 对于
										g 和 G 说明符：要输出的最大有效位数。<br> 对于 s:
										要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。<br> 对于 c 类型：没有任何影响。<br>
										当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。
									</td>
								</tr>
								<tr>
									<td>.*</td>
									<td>精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>length 有下列几种情况:</b>
						</p>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th style="width: 18%">length（长度）</th>
									<th>描述</th>
								</tr>
								<tr>
									<td>h</td>
									<td>参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。</td>
								</tr>
								<tr>
									<td>l</td>
									<td>参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符
										c（表示一个宽字符）和 s（表示宽字符字符串）。</td>
								</tr>
								<tr>
									<td>L</td>
									<td>参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。</td>
								</tr>
							</tbody>
						</table>
						<pre class="brush: cpp;">
#include &lt;stdio.h>

int main() {
    /* 整数 */
    printf("==原始输出:=======%d======\n", 6);
    printf("==正数加 + 号:======+d======\n", 6);
    printf("==最小宽度控制,左边补空格:======%3d--%3d======\n", 6, 10000);
    printf("==最小宽度控制,右边补空格:======%-3d--%-3d======\n", 6, 10000);
    printf("==最小宽度控制,左边补0:======%03d--%03d======\n", 6, 10000);
    printf("\n");

    /* 浮点数 */
    printf("==原始输出:=======%f======\n", 6.0);
    printf("==精度控制:=======%.2f--%5.2f--%05.2f--%-5.2f======\n", 6.0, 1.2345, 1.2345, 6.0);
    printf("\n");
   
    /* 其它控制 */
    printf ("==整型数的参数会被转成 unsigned char 型:======%c %c \n", 'a', 65);
    printf ("==原始:%d 十六进制:%x 八进制:%o 加0x的十六进制:%#x 加0的八进制:%#o \n", 100, 100, 100, 100, 100);
    printf ("==double 型的参数以指数形式打印: %+.0e %E \n", 3.1416, 3.1416);
    printf ("==由参数作参数长度控制打印:======%*d======\n", 5, 10);
    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-preprocessor" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">预处理器</h3>
					</div>
					<div class="panel-body">
						<p>C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C
							预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。</p>
						<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p>
						<table
							class="table table-responsive table-bordered table-condensed">
							<tbody>
								<tr>
									<th style="width: 20%">指令</th>
									<th>描述</th>
								</tr>
								<tr>
									<td>#define</td>
									<td>定义宏</td>
								</tr>
								<tr>
									<td>#include</td>
									<td>包含一个源代码文件</td>
								</tr>
								<tr>
									<td>#undef</td>
									<td>取消已定义的宏</td>
								</tr>
								<tr>
									<td>#ifdef</td>
									<td>如果宏已经定义，则返回真</td>
								</tr>
								<tr>
									<td>#ifndef</td>
									<td>如果宏没有定义，则返回真</td>
								</tr>
								<tr>
									<td>#if</td>
									<td>如果给定条件为真，则编译下面代码</td>
								</tr>
								<tr>
									<td>#else</td>
									<td>#if 的替代方案</td>
								</tr>
								<tr>
									<td>#elif</td>
									<td>如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
								</tr>
								<tr>
									<td>#endif</td>
									<td>结束一个 #if……#else 条件编译块</td>
								</tr>
								<tr>
									<td>#error</td>
									<td>当遇到标准错误时，输出错误消息</td>
								</tr>
								<tr>
									<td>#pragma</td>
									<td>使用标准化方法，向编译器发布特殊的命令到编译器中</td>
								</tr>
							</tbody>
						</table>

						<p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
						<table
							class="table table-responsive table-bordered table-condensed">
							<tbody>
								<tr>
									<th style="width: 20%">宏</th>
									<th>描述</th>
								</tr>
								<tr>
									<td>__DATE__</td>
									<td>当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。</td>
								</tr>
								<tr>
									<td>__TIME__</td>
									<td>当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。</td>
								</tr>
								<tr>
									<td>__FILE__</td>
									<td>这会包含当前文件名，一个字符串常量。</td>
								</tr>
								<tr>
									<td>__LINE__</td>
									<td>这会包含当前行号，一个十进制常量。</td>
								</tr>
								<tr>
									<td>__STDC__</td>
									<td>当编译器以 ANSI 标准编译时，则定义为 1。</td>
								</tr>
							</tbody>
						</table>

						<pre class="brush: cpp;">
#include &lt;stdio.h>

#ifndef MESSAGE
   #define MESSAGE "You wish!"
#endif
// defined 达到上面相同的效果
#if !defined (MESSAGE)
   #define MESSAGE "You wish!"
#endif

// 在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。
#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")

// 宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。
#define tokenpaster(n) printf ("token" #n" = %d\n", token##n)

#define MAX(x,y) ((x) > (y) ? (x) : (y))
      
int main() {
    printf("Message: %s.\n", MESSAGE);

    int token34 = 40;
    tokenpaster(34);

    message_for(Carole, Debra);

    printf("Max between 20 and 10 is %d.\n", MAX(10, 20));

    printf("Date Time: %s %s.\n", __DATE__, __TIME__);

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-poiter" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">指针</h3>
					</div>
					<div class="panel-body">
						<p>计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样。</p>
						<p>C语言用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 CPU 使用。</p>
						<p>

							数据和代码都以二进制的形式存储在内存中，计算机无法从格式上区分某块内存到底存储的是数据还是代码。当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，拥有读取和执行权限的内存块就是代码，而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。
						</p>
						CPU 只能通过地址来取得内存中的代码和数据，程序在执行过程中会告知 CPU
						要执行的代码以及要读写的数据的地址。如果程序不小心出错，或者开发者有意为之，在 CPU
						要写入数据时给它一个代码区域的地址，就会发生内存访问错误。这种内存访问错误会被硬件和操作系统拦截，强制程序崩溃，程序员没有挽救的机会。
						</p>
						<p>CPU
							访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。
						</p>
						<p>指针是一个变量，其值为另一个变量的地址，即内存位置的直接地址。下图为 4G 内存地址空间:</p>
						<p width="100%">
							<img src="images/c-pointer.png"
								class="img-responsive center-block">
						</p>
						<h5 class="text-primary">一个指针包括的四方面的内容:</h5>
						<ul>
							<li>
								<b>指针的类型</b> -- 把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。
								<pre class="brush: cpp;">
int		*ptr;				// 指针的类型是 int * 
char	*ptr;				// 指针的类型是 char *
int		**ptr;				// 指针的类型是 int **
int		(*ptr)[3];			// 指针的类型是 int(*)[3]
int		*(*ptr)[4];			// 指针的类型是 int *(*)[4] 
</pre>
							</li>
							<li>
								<b>指针所指向的类型</b> -- 把指针声明语句中的指针名字和名字左边的指针声明符 * 去掉，剩下的就是指针所指向的类型。
								<pre class="brush: cpp;">
int		*ptr;				// 指针所指向的类型是 int
char	*ptr;				// 指针所指向的类型是 char
int		**ptr;				// 指针所指向的类型是 int *
int		(*ptr)[3];			// 指针所指向的类型是 int()[3]
int		*(*ptr)[4];			// 指针所指向的类型是 int *()[4] 
</pre>
							</li>
							<li>
								<b>指针的值</b> -- 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。
								<pre class="brush: cpp;">
#include &lt;stdio.h>

int main() {
	int a = 100;
	printf("%#X\n", &a);		// 输出变量 a 内存地址
	
	char str[20] = "c.biancheng.net";
	printf("%#X\n", str);		// 数组的内存地址为 str[0] 的地址
	printf("%#X\n", &str[0]);	// 和上面的输出是一样的

	return 0;
}
</pre>
							</li>
							<li>
								<b>指针本身所占据的内存区</b> --
								指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。
							</li>
						</ul>

						<h5 class="text-primary">指针的算术运算</h5>
						<p>
							C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：
							<code>++</code>
							、
							<code>--</code>
							、
							<code>+</code>
							、
							<code>-</code>
							。
						</p>
						<pre class="brush: cpp;">

</pre>

						<h5 class="text-primary">指向指针的指针</h5>
						<p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p>
						<p width="100%">
							<img src="images/pointer_to_pointer.jpg"
								class="img-responsive center-block">
						</p>
						<pre class="brush: cpp;">

</pre>

						<h5 class="text-primary">指针数组</h5>
						<pre class="brush: cpp;">

</pre>

						<h5 class="text-primary">指针与函数</h5>
						<pre class="brush: cpp;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-file" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							文件读写 -- 参见 C 标准库
							<code>stdio.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C
							语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。</p>
						<p>
							<b>打开文件</b>
						</p>
						<p>使用 fopen() 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型
							FILE 包含了所有用来控制流的必要的信息</p>
						<pre class="brush: cpp;">FILE *fopen(const char *filename, const char *mode)</pre>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th style="width: 8%">模式</th>
									<th>描述</th>
								</tr>
								<tr>
									<td>r</td>
									<td>打开一个已有的文本文件，允许读取文件。</td>
								</tr>
								<tr>
									<td>w</td>
									<td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。</td>
								</tr>
								<tr>
									<td>a</td>
									<td>打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td>
								</tr>
								<tr>
									<td>r+</td>
									<td>打开一个文本文件，允许读写文件。</td>
								</tr>
								<tr>
									<td>w+</td>
									<td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
								</tr>
								<tr>
									<td>a+</td>
									<td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
								</tr>
							</tbody>
						</table>
						<p class="text-warning">
							如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：<br>
							<code> "rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b",
								"ab+", "a+b"</code>
						</p>
						<p>
							<b>关闭文件</b>
						</p>
						<p>如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回
							EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h
							中的常量。</p>
						<pre class="brush: cpp;">int fclose(FILE *fp)</pre>

						<p>
							<b>写入文件</b>
						</p>
						<p>函数 fputc() 把参数 c 的字符值写入到 fp
							所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。</p>
						<p>函数 fputs() 把字符串 s 写入到 fp
							所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。</p>
						<pre class="brush: cpp;">
int fprintf(FILE *stream, const char *format, ...)

int fputs(const char *s, FILE *fp)

int fputc(int c, FILE *fp)

int putc(int char, FILE *stream)

int vfprintf(FILE *stream, const char *format, va_list arg)
</pre>

						<p>
							<b>读取文件</b>
						</p>
						<p>fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。</p>
						<p>函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区
							buf，并在最后追加一个 null 字符来终止字符串。</p>
						<pre class="brush: cpp;">
int fscanf(FILE *stream, const char *format, ...)

char *fgets(char *str, int n, FILE *stream)

int getc(FILE * fp);

int fgetc(FILE *stream)
</pre>

						<p>
							<b>二进制 I/O 函数</b>
						</p>
						<p>这两个函数都是用于存储块的读写 - 通常是数组或结构体。</p>
						<pre class="brush: cpp;">
size_t fread(void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file);

size_t fwrite(const void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file);
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-string" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>string.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>string.h</code>
							头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。
						</p>

						<p>
							<b>库变量</b>
						</p>
						<p>下面是头文件 string.h 中定义的变量类型：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>变量 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>size_t </b><br>这是无符号整数类型，它是 <b>sizeof</b>
										关键字的结果。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库宏</b>
						</p>
						<p>下面是头文件 string.h 中定义的宏：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>NULL</b><br>这个宏是一个空指针常量的值。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库函数</b>
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-memchr.html">void
											*memchr(const void *str, int c, size_t n)</a><br>在参数 <i>str</i>
										所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-function-memcmp.html">int memcmp(const
											void *str1, const void *str2, size_t n)</a><br>把 <i>str1</i>
										和 <i>str2</i> 的前 n 个字节进行比较。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-function-memcpy.html">void *memcpy(void
											*dest, const void *src, size_t n)</a><br>从 src 复制 n 个字符到 <i>dest</i>。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><a href="c-function-memmove.html">void
											*memmove(void *dest, const void *src, size_t n)</a><br>另一个用于从
										<i>str2</i> 复制 n 个字符到 <i>str1</i> 的函数。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><a href="c-function-memset.html">void *memset(void
											*str, int c, size_t n)</a><br>复制字符 c（一个无符号字符）到参数 <i>str</i>
										所指向的字符串的前 n 个字符。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><a href="c-function-strcat.html">char *strcat(char
											*dest, const char *src)</a><br>把 <i>src</i> 所指向的字符串追加到 <i>dest</i>
										所指向的字符串的结尾。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><a href="c-function-strncat.html">char
											*strncat(char *dest, const char *src, size_t n)</a><br>把 <i>src</i>
										所指向的字符串追加到 <i>dest</i> 所指向的字符串的结尾，直到 n 字符长度为止。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><a href="c-function-strchr.html">char
											*strchr(const char *str, int c)</a><br>在参数 <i>str</i>
										所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><a href="c-function-strcmp.html">int strcmp(const
											char *str1, const char *str2)</a><br>把 <i>str1</i> 所指向的字符串和
										<i>str2</i> 所指向的字符串进行比较。</td>
								</tr>
								<tr>
									<td>10</td>
									<td><a href="c-function-strncmp.html">int
											strncmp(const char *str1, const char *str2, size_t n)</a><br>把
										<i>str1</i> 和 <i>str2</i> 进行比较，最多比较前 n 个字节。</td>
								</tr>
								<tr>
									<td>11</td>
									<td><a href="c-function-strcoll.html">int
											strcoll(const char *str1, const char *str2)</a><br>把 <i>str1</i>
										和 <i>str2</i> 进行比较，结果取决于 LC_COLLATE 的位置设置。</td>
								</tr>
								<tr>
									<td>12</td>
									<td><a href="c-function-strcpy.html">char *strcpy(char
											*dest, const char *src)</a><br>把 <i>src</i> 所指向的字符串复制到 <i>dest</i>。</td>
								</tr>
								<tr>
									<td>13</td>
									<td><a href="c-function-strncpy.html">char
											*strncpy(char *dest, const char *src, size_t n)</a><br>把 <i>src</i>
										所指向的字符串复制到 <i>dest</i>，最多复制 n 个字符。</td>
								</tr>
								<tr>
									<td>14</td>
									<td><a href="c-function-strcspn.html">size_t
											strcspn(const char *str1, const char *str2)</a><br>检索字符串
										str1 开头连续有几个字符都不含字符串 str2 中的字符。</td>
								</tr>
								<tr>
									<td>15</td>
									<td><a href="c-function-strerror.html">char
											*strerror(int errnum)</a><br>从内部数组中搜索错误号
										errnum，并返回一个指向错误消息字符串的指针。</td>
								</tr>
								<tr>
									<td>16</td>
									<td><a href="c-function-strlen.html">size_t
											strlen(const char *str)</a><br>计算字符串 str
										的长度，直到空结束字符，但不包括空结束字符。</td>
								</tr>
								<tr>
									<td>17</td>
									<td><a href="c-function-strpbrk.html">char
											*strpbrk(const char *str1, const char *str2)</a><br>检索字符串 <i>str1</i>
										中第一个匹配字符串 <i>str2</i> 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1
										中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</td>
								</tr>
								<tr>
									<td>18</td>
									<td><a href="c-function-strrchr.html">char
											*strrchr(const char *str, int c)</a><br>在参数 <i>str</i>
										所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</td>
								</tr>
								<tr>
									<td>19</td>
									<td><a href="c-function-strspn.html">size_t
											strspn(const char *str1, const char *str2)</a><br>检索字符串 <i>str1</i>
										中第一个不在字符串 <i>str2</i> 中出现的字符下标。</td>
								</tr>
								<tr>
									<td>20</td>
									<td><a href="c-function-strstr.html">char
											*strstr(const char *haystack, const char *needle)</a><br>在字符串
										<i>haystack</i> 中查找第一次出现字符串 <i>needle</i>（不包含空结束字符）的位置。</td>
								</tr>
								<tr>
									<td>21</td>
									<td><a href="c-function-strtok.html">char *strtok(char
											*str, const char *delim)</a><br>分解字符串 <i>str</i> 为一组字符串，<i>delim</i>
										为分隔符。</td>
								</tr>
								<tr>
									<td>22</td>
									<td><a href="c-function-strxfrm.html">size_t
											strxfrm(char *dest, const char *src, size_t n)</a><br>根据程序当前的区域选项中的
										LC_COLLATE 来转换字符串 <b>src</b> 的前 <b>n</b> 个字符，并把它们放置在字符串 <b>dest</b>
										中。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b></b>
						</p>
						<pre class="brush: c;">
#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;assert.h>
#include &lt;errno.h>

int main() {
    /** 1.字符串长度 */
    assert(12 == strlen("Hello World!"));
    assert(18 == strlen("我是中国人！"));        // 中文3个字节

    /** 2.字符串比较
     *  strcmp 是按照字节比较的，并且比较的过程中会检查是否出现了"/0"结束符，一旦任意一个字符串指针前进过程中遇到结束符，
     *  将终止比较。而 memcmp 函数是用于比较两个内存块的内容是否相等，在用于字符串比较时通常用于测试字符串是否相等，
     *  不常进行 byte-wise 的字符串比较。如果要比较的对象中包含一些由于边界对齐需求而填入结构对象中的空格、
     *  联合 (union)结束的额外空格、字符串所分配的空间未使用完的部分引起的“holes”的话，最好使用memcmp来完成。
     *  
     *  strcmp 比较的字符串，而 memcmp 比较的是内存块，strcmp 需要时刻检查是否遇到了字符串结束的 /0 字符，
     *  而 memcmp 则完全不用担心这个问题，所以 memcmp 的效率要高于 strcmp
     *
     *  strcoll 默认情况下(LC_COLLATE为"POSIX"或"C")和 strcmp 一样根据 ASCII 比较字符串大小。
     *  对于设置了LC_COLLATE语言环境的情况下，则根据LC_COLLATE设置的语言排序方式进行比较。例如：汉字，根据拼音进行比较。
     */
    assert(!strcmp("abc", "abc"));              // ascii 码值相同返回 0
    assert(!strncmp("abc", "abcd", 3));         // 最多比较前 3 个字节
    assert(!memcmp("abc", "abcd", 3));          // memcmp 比较的是内存块
    assert(!strcoll("abc", "abc"));             // LC_COLLATE 有关


    /** 3.复制字符串
     *  strcpy 和 memcpy 主要有以下 3 方面的区别。
     *  1. 复制的内容不同。strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。
     *  2. 复制的方法不同。strcpy 不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。
     *      memcpy 则是根据其第3个参数决定复制的长度。
     *  3. 用途不同。通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy
     *
     *  memmove 和 memcpy 区别功能差不多，但是在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法。
     *  如果目标区域和源区域有重叠的话，memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，
     *  复制后源区域的内容会被更改。如果目标区域与源区域没有重叠，则和 memcpy() 函数功能相同。
     *
     *  strxfrm 根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中
     */
    char *s1 = "jiwanger";
    char s2[20];

    strcpy(s2, s1);                            // 复制字符串
    assert(!strcmp(s1, s2));
    
    memset(s2, '\0', sizeof(s2));              // 清空 s2, 用 '\0' 填充 s2 的前 sizeof(s2) 个字符
    
    strncpy(s2, s1, 3);                        // 最多复制前 3 个字符
    assert(!strcmp(s2, "jiw"));

    memset(s2, '\0', sizeof(s2));              // 清空 s2
    memcpy(s2, s1, 3);                         // 使用 memcpy 复制
    assert(!strcmp(s2, "jiw"));

    memset(s2, '\0', sizeof(s2));              // 清空 s2
    memmove(s2, s1, 3);
    assert(!strcmp(s2, "jiw"));

    char s_3[20];
    strxfrm(s_3, s1, 20);                      // 最多复制 20 个字符
    assert(!strcmp(s_3, s1));

    /** 4.查找，截取
     *  strchr  -- 搜索第一次出现字符 c 的位置，返回查找到的结束字符串
     *  strrchr -- 搜索最后出现字符 c 的位置，返回查找到的结束字符串
     *  memchr  -- 前 n 个字节中搜索第一次出现字符 c 的位置，返回查找到的结束字符串
     *
     *  strspn  -- 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标
     *
     *  strcspn -- 开头连续不含字符串 “012” 中任何一个字符的字符数量
     *
     *  strstr  -- 从出现字符串的位置截取
     *  strpbrk -- 从出现串中的任何一个字符的位置截取
     */
    char *s3 = "nate-nate";
    char *s4 = strchr(s3, 't');                 // 截取从第一个 't' 开始到结束的串
    assert(!strcmp("te-nate", s4));
    assert(!strcmp("te", strrchr(s3, 't')));    // 截取从最后一个 't' 开始到结束的串
    char *s5 = memchr(s3, 't', sizeof(s3));     // 前 n 个字节中搜索第一次出现字符 c 的位置
    assert(!strcmp("te-nate", s5));

    assert(2 == strspn("abc", "ab0"));          // 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标
    assert(7 == strcspn("abcdefg1234", "012")); // 开头连续不含字符串 “012” 中字符的字符数

    assert(!strcmp("efghi", strstr("abecdefghi", "ef")));    // 第一次出现 "ef" 的位置开始截取
    assert(!strcmp("cdefg", strpbrk("abcdefg", "cf"))); // 第一次出现 ‘c’ 或 'f' 的位置开始截取

    /** 5.追加 */
    char s6[20];
    strcpy(s6, "jiwanger");
    char *s7 = "@126.com";
    strcat(s6, s7);                 // 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾
    assert(!strcmp("jiwanger@126.com", s6));

    strncat(s6, s7, 4);             // 追加最多 4 个字符
    assert(!strcmp("jiwanger@126.com@126", s6));
    
    /** 6.errno 转换为可读的 string， 就像一个 map 一条错误码对应一条错误消息     */
    printf("Message: %s\n", strerror(errno));       // errno 轮换为 string
    FILE *fp = fopen("file.txt", "r");
    if(NULL == fp) {
         printf("Message: %s\n", strerror(errno));  // errno 轮换为 string
    }
    // 查看定义了哪些错误消息，共 134 条错误码对应的错误消息
    for(int i = 0; i < 1000; i++) {
        printf("%d.%s\n", i+1, strerror(i));
    }

    /** 7.分割字符串 */
    char str[80] = "1001:nate:jiwanger@126.com";
    char *token;
   
    token = strtok(str, ":");   // 获取第一个子字符串
    
    while(token != NULL) {      // 继续获取其他的子字符串
        printf("%s\n", token);
        token = strtok(NULL, ":");
    }

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-stdio" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>stdio.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>stdio.h</code>
							头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出。
						</p>
						<p>
							<b>库变量</b>
						</p>
						<p>下面是头文件 stdio.h 中定义的变量类型：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>变量 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>size_t </b><br>这是无符号整数类型，它是 <b>sizeof</b>
										关键字的结果。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>FILE </b><br>这是一个适合存储文件流信息的对象类型。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>fpos_t </b><br>这是一个适合存储文件中任何位置的对象类型。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库宏</b>
						</p>
						<p>下面是头文件 stdio.h 中定义的宏：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>NULL</b><br>这个宏是一个空指针常量的值。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>_IOFBF、_IOLBF</b> 和 <b> _IONBF </b><br>这些宏扩展了带有特定值的整型常量表达式，并适用于
										<b>setvbuf</b> 函数的第三个参数。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>BUFSIZ</b><br>这个宏是一个整数，该整数代表了 <b>setbuf</b>
										函数使用的缓冲区大小。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><b>EOF</b> <br>这个宏是一个表示已经到达文件结束的负整数。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><b>FOPEN_MAX</b> <br>这个宏是一个整数，该整数代表了系统可以同时打开的文件数量。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><b>FILENAME_MAX</b> <br>这个宏是一个整数，该整数代表了字符数组可以存储的文件名的最大长度。如果实现没有任何限制，则该值应为推荐的最大值。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><b>L_tmpnam</b> <br>这个宏是一个整数，该整数代表了字符数组可以存储的由
										tmpnam 函数创建的临时文件名的最大长度。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><b>SEEK_CUR、SEEK_END</b> 和 <b>SEEK_SET</b> <br>这些宏是在These
										macros are used in the <b>fseek</b> 函数中使用，用于在一个文件中定位不同的位置。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><b>TMP_MAX </b> <br>这个宏是 tmpnam 函数可生成的独特文件名的最大数量。</td>
								</tr>
								<tr>
									<td>10</td>
									<td><b>stderr、stdin</b> 和 <b>stdout </b> <br>这些宏是指向
										FILE 类型的指针，分别对应于标准错误、标准输入和标准输出流。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库函数</b>
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-fclose.html">int fclose(FILE
											*stream)</a><br>关闭流 stream。刷新所有的缓冲区。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-function-clearerr.html">void
											clearerr(FILE *stream)</a><br>清除给定流 stream 的文件结束和错误标识符。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-function-feof.html">int feof(FILE
											*stream)</a><br>测试给定流 stream 的文件结束标识符。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><a href="c-function-ferror.html">int ferror(FILE
											*stream)</a><br>测试给定流 stream 的错误标识符。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><a href="c-function-fflush.html">int fflush(FILE
											*stream)</a><br>刷新流 stream 的输出缓冲区。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><a href="c-function-fgetpos.html">int fgetpos(FILE
											*stream, fpos_t *pos)</a><br>获取流 stream 的当前文件位置，并把它写入到 pos。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><a href="c-function-fopen.html">FILE *fopen(const
											char *filename, const char *mode)</a><br>使用给定的模式 mode 打开
										filename 所指向的文件。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><a href="c-function-fread.html">size_t fread(void
											*ptr, size_t size, size_t nmemb, FILE *stream)</a><br>从给定流
										stream 读取数据到 ptr 所指向的数组中。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><a href="c-function-freopen.html">FILE
											*freopen(const char *filename, const char *mode, FILE
											*stream)</a><br>把一个新的文件名 filename 与给定的打开的流 stream
										关联，同时关闭流中的旧文件。</td>
								</tr>
								<tr>
									<td>10</td>
									<td><a href="c-function-fseek.html">int fseek(FILE
											*stream, long int offset, int whence)</a><br>设置流 stream
										的文件位置为给定的偏移 offset，参数 <i>offset</i> 意味着从给定的 <i>whence</i>
										位置查找的字节数。</td>
								</tr>
								<tr>
									<td>11</td>
									<td><a href="c-function-fsetpos.html">int fsetpos(FILE
											*stream, const fpos_t *pos)</a><br>设置给定流 stream
										的文件位置为给定的位置。参数 <i>pos</i> 是由函数 fgetpos 给定的位置。</td>
								</tr>
								<tr>
									<td>12</td>
									<td><a href="c-function-ftell.html">long int
											ftell(FILE *stream)</a><br>返回给定流 stream 的当前文件位置。</td>
								</tr>
								<tr>
									<td>13</td>
									<td><a href="c-function-fwrite.html">size_t
											fwrite(const void *ptr, size_t size, size_t nmemb, FILE
											*stream)</a><br>把 ptr 所指向的数组中的数据写入到给定流 stream 中。</td>
								</tr>
								<tr>
									<td>14</td>
									<td><a href="c-function-remove.html">int remove(const
											char *filename)</a><br>删除给定的文件名 filename，以便它不再被访问。</td>
								</tr>
								<tr>
									<td>15</td>
									<td><a href="c-function-rename.html">int rename(const
											char *old_filename, const char *new_filename)</a><br>把
										old_filename 所指向的文件名改为 new_filename。</td>
								</tr>
								<tr>
									<td>16</td>
									<td><a href="c-function-rewind.html">void rewind(FILE
											*stream)</a><br>设置文件位置为给定流 stream 的文件的开头。</td>
								</tr>
								<tr>
									<td>17</td>
									<td><a href="c-function-setbuf.html">void setbuf(FILE
											*stream, char *buffer)</a><br>定义流 stream 应如何缓冲。</td>
								</tr>
								<tr>
									<td>18</td>
									<td><a href="c-function-setvbuf.html">int setvbuf(FILE
											*stream, char *buffer, int mode, size_t size)</a><br>另一个定义流
										stream 应如何缓冲的函数。</td>
								</tr>
								<tr>
									<td>19</td>
									<td><a href="c-function-tmpfile.html">FILE
											*tmpfile(void)</a><br>以二进制更新模式(wb+)创建临时文件。</td>
								</tr>
								<tr>
									<td>20</td>
									<td><a href="c-function-tmpnam.html">char *tmpnam(char
											*str)</a><br>生成并返回一个有效的临时文件名，该文件名之前是不存在的。</td>
								</tr>
								<tr>
									<td>21</td>
									<td><a href="c-function-fprintf.html">int fprintf(FILE
											*stream, const char *format, ...)</a><br>发送格式化输出到流 stream 中。</td>
								</tr>
								<tr>
									<td>22</td>
									<td><a href="c-function-printf.html">int printf(const
											char *format, ...)</a><br>发送格式化输出到标准输出 stdout。</td>
								</tr>
								<tr>
									<td>23</td>
									<td><a href="c-function-sprintf.html">int sprintf(char
											*str, const char *format, ...)</a><br>发送格式化输出到字符串。</td>
								</tr>
								<tr>
									<td>24</td>
									<td><a href="c-function-vfprintf.html">int
											vfprintf(FILE *stream, const char *format, va_list arg)</a><br>使用参数列表发送格式化输出到流
										stream 中。</td>
								</tr>
								<tr>
									<td>25</td>
									<td><a href="c-function-vprintf.html">int
											vprintf(const char *format, va_list arg)</a><br>使用参数列表发送格式化输出到标准输出
										stdout。</td>
								</tr>
								<tr>
									<td>26</td>
									<td><a href="c-function-vsprintf.html">int
											vsprintf(char *str, const char *format, va_list arg)</a><br>使用参数列表发送格式化输出到字符串。</td>
								</tr>
								<tr>
									<td>27</td>
									<td><a href="c-function-fscanf.html">int fscanf(FILE
											*stream, const char *format, ...)</a><br>从流 stream 读取格式化输入。</td>
								</tr>
								<tr>
									<td>28</td>
									<td><a href="c-function-scanf.html">int scanf(const
											char *format, ...)</a><br>从标准输入 stdin 读取格式化输入。</td>
								</tr>
								<tr>
									<td>29</td>
									<td><a href="c-function-sscanf.html">int sscanf(const
											char *str, const char *format, ...)</a><br>从字符串读取格式化输入。</td>
								</tr>
								<tr>
									<td>30</td>
									<td><a href="c-function-fgetc.html">int fgetc(FILE
											*stream)</a><br>从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</td>
								</tr>
								<tr>
									<td>31</td>
									<td><a href="c-function-fgets.html">char *fgets(char
											*str, int n, FILE *stream)</a><br>从指定的流 stream 读取一行，并把它存储在
										str 所指向的字符串内。当读取 <b>(n-1)</b>
										个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</td>
								</tr>
								<tr>
									<td>32</td>
									<td><a href="c-function-fputc.html">int fputc(int
											char, FILE *stream)</a><br>把参数 char 指定的字符（一个无符号字符）写入到指定的流
										stream 中，并把位置标识符往前移动。</td>
								</tr>
								<tr>
									<td>33</td>
									<td><a href="c-function-fputs.html">int fputs(const
											char *str, FILE *stream)</a><br>把字符串写入到指定的流 stream
										中，但不包括空字符。</td>
								</tr>
								<tr>
									<td>34</td>
									<td><a href="c-function-getc.html">int getc(FILE
											*stream)</a><br>从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</td>
								</tr>
								<tr>
									<td>35</td>
									<td><a href="c-function-getchar.html">int
											getchar(void)</a><br>从标准输入 stdin 获取一个字符（一个无符号字符）。</td>
								</tr>
								<tr>
									<td>36</td>
									<td><a href="c-function-gets.html">char *gets(char
											*str)</a><br>从标准输入 stdin 读取一行，并把它存储在 str
										所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</td>
								</tr>
								<tr>
									<td>37</td>
									<td><a href="c-function-putc.html">int putc(int char,
											FILE *stream)</a><br>把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream
										中，并把位置标识符往前移动。</td>
								</tr>
								<tr>
									<td>38</td>
									<td><a href="c-function-putchar.html">int putchar(int
											char)</a><br>把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。</td>
								</tr>
								<tr>
									<td>39</td>
									<td><a href="c-function-puts.html">int puts(const char
											*str)</a><br>把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。</td>
								</tr>
								<tr>
									<td>40</td>
									<td><a href="c-function-ungetc.html">int ungetc(int
											char, FILE *stream)</a><br>把字符 char（一个无符号字符）推入到指定的流 stream
										中，以便它是下一个被读取到的字符。</td>
								</tr>
								<tr>
									<td>41</td>
									<td><a href="c-function-perror.html">void perror(const
											char *str)</a><br>把一个描述性错误消息输出到标准错误 stderr。首先输出字符串
										str，后跟一个冒号，然后是一个空格。</td>
								</tr>
							</tbody>
						</table>

						<pre class="brush: c;">
#include &lt;stdio.h>
#include &lt;math.h>
#include &lt;string.h>
#include &lt;stdarg.h>
#include &lt;errno.h>

char buffer[40];
/** 
 * vprintf -- 使用参数列表发送格式化输出到标准输出
 * vsprintf -- 使用参数列表发送格式化输出到字符串， 相对于 vprintf 多一个参数用于接收格式化后的内容
 * */
void vprintf_test(char * format, ...) {
    va_list args;
   
    va_start(args, format);
    vprintf(format, args);              // 使用参数列表发送格式化输出到标准输出
    vsprintf(buffer, format, args);     // 使用参数列表发送格式化输出到 buffer 数组
    va_end(args);
}

/** 标准输入和输出
 *  printf -- 发送格式化输出到标准输出, 更多参见 -- 格式化输出
 *  sprintf -- 发送格式化输出到字符串, 此方法可用于复制字符串
 *  scanf -- 从标准输入读取数据
 *  sscanf -- 从字符串读取格式化输入
 *  getchar -- 标准输入读取一个字符
 *  putchar -- 标准输入输出一个字符
 *  gets -- 标准输入读取一行
 *  puts -- 标准输入输出一行
 *  perror -- 把描述性错误消息输出到标准错误 stderr。输出字符串 str，后跟一个冒号，然后是一个空格
 */
void in_out(){
    /** 1.常用的宏 */
    printf("%d \n", EOF);           // 表示已经到达文件结束的负整数
    printf("%d \n", BUFSIZ);        // 该整数代表了 setbuf 函数使用的缓冲区大小
    printf("%d \n", FOPEN_MAX);     // 该整数代表了系统可以同时打开的文件数量
    printf("%d \n", FILENAME_MAX);  // 该整数代表了字符数组可以存储的文件名的最大长度
    printf("%d \n", TMP_MAX);       // 是 tmpnam 函数可生成的独特文件名的最大数量

    /** 2.格式化输出 */
    int len = printf("%f %2.0f\n", pow(2, 32), pow(2, 32));// 发送格式化输出到标准输出, 更多参见 -- 格式化输出
    printf("%d\n", len);            // 如果成功，则返回写入的字符总数，否则返回一个负数。
    char s1[20];
    sprintf(s1, "%2.0f", pow(2, 32));   // 发送格式化输出到字符串, 此方法可用于复制字符串
    printf("%s\n", s1);

    vprintf_test("%2.0f\n", pow(2, 32));
    printf("buffer: %s\n", buffer);
    vprintf_test("%d 的 %d 次幂为: %2.0f\n", 2, 32, pow(2,32));
    printf("buffer: %s\n", buffer);

    /** 3.格式化输入 */
    char name[20];
    int age;
    printf("输入你的姓名和年龄，中间用空格分割：\n");
    scanf("%s %d", name, &age);                 // 从标准输入读取数据
    printf("你的姓名为： %s, 你的年龄为: %d。\n", name, age);

    sscanf("jiwanger 27", "%s %d", name, &age); // 从字符串读取格式化输入
    printf("你的姓名为： %s, 你的年龄为: %d。\n", name, age);

    /** 4.标准输入和标准输出
     * 此处有输入缓冲区问题, 因为前面使用 scanf 函数有数据残留，getchar 直接读取了，不会停留在输入。
     */
    printf("标准输入读取一个字符：(请输入)\n");
    char ch = getchar();
    printf("输入字符为:");
    putchar(ch);

    char str_fgets[50];
    printf("请输入一个字符串：");
    gets(str_fgets);
    printf("您输入的字符串是：");
    puts(str_fgets);

    /** 5.标准错误 */
    perror("An error!");    // 把描述性错误消息输出到标准错误 stderr。输出字符串 str，后跟一个冒号，然后是一个空格。
}

char en_str[] = "English Only!";
char zh_en_str[] = "中文abcd测试！";
/** 6.文件写入
 *  fopen -- 打开文件，更多模式查看 -- 文件读写章节
 *  fclose -- 关闭文件
 *  fprintf -- 和 printf 一样，但不是发送到标准输出流，发送到打开的文件流
 *  fputs -- 和 puts 一样，只是流不一样
 *  putc / fputc -- 把参数 char 指定的字符写入到指定的流 stream 中，并把位置标识符往前移动
 *  vfprintf -- 和 vprintf 一样，只是流不一样
 */
void file_write() {
    FILE * fp;
    
    const char * filename = "files/file.txt";

    fp = fopen (filename, "w");        // 打开文件，更多模式查看 -- 文件读写章节
    if(fp == NULL) {
       printf("Error: %s\n", strerror(errno));
    }

    fprintf(fp, "%s %d.\n", "We are in", 2017);     // 发送格式化输出到流 stream 中
    fprintf(fp, "%s\n", "Wellcome!");
   
    fputs("使用 fputs 写入！\n", fp);                // fputs 写入

    char *chs = "使用 putc / fputc 写入！";
    for(int i = 0; i < strlen(chs); i++) {
        putc(chs[i], fp);
    }
    fputs("\n", fp);
    for(int i = 0; i < strlen(chs); i++) {
        fputc(chs[i], fp);
    }

    fclose(fp);
    puts("文件写入完成！");
}

/** 文本读取
 *  fscanf -- 从文件读取格式化输入
 *  fgets -- 当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止
 *  feof -- 是否到达文件末尾
 *  fgetc / getc -- 读取一个字符
 */
void file_read() {
    FILE * fp;
    
    const char * filename = "files/file.txt";
    fp = fopen (filename, "r");        // 打开文件，更多模式查看 -- 文件读写章节

    if(fp == NULL) {
       printf("=== Error: %s ===\n", strerror(errno));
       return;
    }

    char line_1_s1[20],line_1_s2[20],line_1_s3[20],line_1_s4[20];
    int line_1_d;
    char br;            // 用于读取换行符
    // 文件第一行为: We are in 2017.
    fscanf(fp, "%s %s %s %d %s%c", line_1_s1, line_1_s2, line_1_s3, &line_1_d, line_1_s4, &br);
    printf("%s %s %s %d%s%c", line_1_s1, line_1_s2, line_1_s3, line_1_d, line_1_s4, br);

    char line_2_s[40];
    fscanf(fp, "%s%c", line_2_s, &br);      // %c 用于读取换行符
    printf("%s%c", line_2_s, br);

    char str_gets[40];
    fgets(str_gets, BUFSIZ, fp);// 当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止
    printf("%s", str_gets);

    char str_fgetc[BUFSIZ] = "\0";
    int index = 0;
    while(!feof(fp)) {          // 是否到达文件末尾
        str_fgetc[index] = fgetc(fp);
        index++;
    }
    printf("%s\n", str_fgetc);

    fclose(fp);
}

typedef struct {
    char id[20];
    char name[32];
    unsigned char age;
} Person;

/** 二进制写入结构体
 * fwrite -- 二进制写入
 */
void obj_write() {
    FILE * fp = fopen("files/persons.dat", "wb");
    if(fp == NULL) {
        printf("=== Error: %s ===\n", strerror(errno));
        return;
    }

    Person p1;
    strcpy(p1.id, "431122198903241712");
    strcpy(p1.name, "jiwanger");
    p1.age = 27;
    fwrite(&p1, sizeof(p1), 1, fp);

    strcpy(p1.id, "13823039350");
    strcpy(p1.name, "nate");
    p1.age = 28;
    fwrite(&p1, sizeof(p1), 1, fp);

    fclose(fp);
}

/** 二进制读取结构体 
 * fread -- 二进制读取
 */
void obj_read() {
    FILE * fp = fopen("files/persons.dat", "rb");
    if(fp == NULL) {
        printf("=== Error: %s ===\n", strerror(errno));
        return;
    }

    Person p1;
    fread(&p1, sizeof(p1), 1, fp);
    printf("id:%s name:%s age:%d\n", p1.id, p1.name, p1.age);

    fread(&p1, sizeof(p1), 1, fp);
    printf("id:%s name:%s age:%d\n", p1.id, p1.name, p1.age);

    fclose(fp);
}

/** stdio.h 其它一些方法
 *  freopen -- 把一个新的文件名 filename 与给定的打开的流 stream 关联，同时关闭流中的旧文件
 *  ferror -- 测试给定流 stream 是否有错误标识符
 *  clearerr -- 清除给定流 stream 的文件结束和错误标识符
 *  fgetpos -- 获取流 stream 的当前文件位置，并把它写入到 position
 *  fsetpos -- 设置给定流 stream 的文件位置为给定的位置 posiction
 *  rewind -- 设置文件位置为给定流 stream 的文件的开头
 * 	rename -- 重命名
 *  remove -- 删除文件
 *  tmpfile -- 创建临时文件
 *  tmpnam -- 生成并返回一个有效的临时文件名
 *  ftell -- 返回给定流 stream 的当前文件位置
 *  fseek -- 设置流 stream 的文件位置为给定的偏移 offset
 */
void other() {
    char * filename = "files/error.txt";
    FILE * fp = fopen(filename, "w");
    if(fp == NULL) {
        printf("=== Error: %s ===\n", strerror(errno));
        return;
    }

    fp = freopen(filename, "w", fp);
    char c = fgetc(fp);
    if(ferror(fp)) {    // 测试是否有错误，因为 fgetc 读取空文件，有错误发生
        printf("1.读取文件：%s 时发生错误!\n", filename);
    }
    clearerr(fp);       // 清除给定流 stream 的文件结束和错误标识符
    if(ferror(fp)) {    // 无错误，因为前面 clearerr, 下面代码不执行
        printf("2.读取文件：%s 时发生错误!\n", filename);
    }

    fpos_t position;
    fgetpos(fp, &position);         // 将当前位置写入 position
    fputs("Hello, World!", fp);
  
    fsetpos(fp, &position);         // 移动到 posiction 位置
    fputs("这将覆盖之前的内容", fp);

    fclose(fp);
}

/**
 *  setbuf -- 定义流 stream 应如何缓冲
 *  setvbuf -- 定义流 stream 应如何缓冲的函数
 *  fflush -- 刷新流 stream 的输出缓冲区
 */
void buffer_test(){
    char buff[1024];

    memset(buff, '\0', sizeof(buff));

    fprintf(stdout, "启用全缓冲\n");
    setvbuf(stdout, buff, _IOFBF, 1024);    // 启用全缓冲，因为大小为 buffer 大小

    fprintf(stdout, "该输出将保存到 buff\n");

    fprintf(stdout, "这将在编程时出现\n");
    fprintf(stdout, "最后休眠 3 秒钟\n");
    fflush(stdout);     // 如果不使用这句，上面的两行输出会在休眠后打印，因为数据在缓冲区

    sleep(3);
    fprintf(stdout, "休眠完成！\n");
}

int main() {
    in_out();           // 库变量和标准输入，输出

    file_write();       // 写文本文件

    file_read();        // 读文本文件

    obj_write();        // 写二进制文件

    obj_read();         // 读二进制文件

    other();            // 其它一些方法

    buffer_test();      // 使用缓冲

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-stdlib" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>stdlib.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>stdlib.h</code>
							头文件定义了四个变量类型、一些宏和各种通用工具函数。
						</p>


						<p>
							<b>库变量</b>
						</p>
						<p>下面是头文件 stdlib.h 中定义的变量类型：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>变量 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>size_t </b><br>这是无符号整数类型，它是 <b>sizeof</b>
										关键字的结果。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>wchar_t </b><br>这是一个宽字符常量大小的整数类型。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>div_t </b><br>这是 <b>div</b> 函数返回的结构。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><b>ldiv_t </b><br>这是 <b>ldiv</b> 函数返回的结构。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库宏</b>
						</p>
						<p>下面是头文件 stdlib.h 中定义的宏：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>NULL</b><br>这个宏是一个空指针常量的值。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>EXIT_FAILURE</b><br>这是 exit 函数失败时要返回的值。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>EXIT_SUCCESS</b><br>这是 exit 函数成功时要返回的值。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><b>RAND_MAX </b><br>这个宏是 rand 函数返回的最大值。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><b>MB_CUR_MAX </b> <br>这个宏表示在多字节字符集中的最大字符数，不能大于
										MB_LEN_MAX。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库函数</b>
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-atof.html">double atof(const
											char *str)</a><br>把参数 <i>str</i> 所指向的字符串转换为一个浮点数（类型为 double
										型）。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-function-atoi.html">int atoi(const char
											*str)</a><br>把参数 <i>str</i> 所指向的字符串转换为一个整数（类型为 int 型）。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-function-atol.html">long int atol(const
											char *str)</a><br>把参数 <i>str</i> 所指向的字符串转换为一个长整数（类型为 long
										int 型）。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><a href="c-function-strtod.html">double
											strtod(const char *str, char **endptr)</a><br>把参数 <i>str</i>
										所指向的字符串转换为一个浮点数（类型为 double 型）。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><a href="c-function-strtol.html">long int
											strtol(const char *str, char **endptr, int base)</a><br>把参数
										<i>str</i> 所指向的字符串转换为一个长整数（类型为 long int 型）。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><a href="c-function-strtoul.html">unsigned long
											int strtoul(const char *str, char **endptr, int base)</a><br>把参数
										<i>str</i> 所指向的字符串转换为一个无符号长整数（类型为 unsigned long int 型）。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><a href="c-function-calloc.html">void
											*calloc(size_t nitems, size_t size)</a><br>分配所需的内存空间，并返回一个指向它的指针。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><a href="c-function-free.html">void free(void
											*ptr)</a><br>释放之前调用 <i>calloc、malloc</i> 或 <i>realloc</i>
										所分配的内存空间。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><a href="c-function-malloc.html">void
											*malloc(size_t size)</a><br>分配所需的内存空间，并返回一个指向它的指针。</td>
								</tr>
								<tr>
									<td>10</td>
									<td><a href="c-function-realloc.html">void
											*realloc(void *ptr, size_t size)</a><br>尝试重新调整之前调用 <i>malloc</i>
										或 <i>calloc</i> 所分配的 ptr 所指向的内存块的大小。</td>
								</tr>
								<tr>
									<td>11</td>
									<td><a href="c-function-abort.html">void abort(void)</a><br>使一个异常程序终止。</td>
								</tr>
								<tr>
									<td>12</td>
									<td><a href="c-function-atexit.html">int atexit(void
											(*func)(void))</a><br>当程序正常终止时，调用指定的函数 <b>func</b>。</td>
								</tr>
								<tr>
									<td>13</td>
									<td><a href="c-function-exit.html">void exit(int
											status)</a><br>使程序正常终止。</td>
								</tr>
								<tr>
									<td>14</td>
									<td><a href="c-function-getenv.html">char
											*getenv(const char *name)</a><br>搜索 name
										所指向的环境字符串，并返回相关的值给字符串。</td>
								</tr>
								<tr>
									<td>15</td>
									<td><a href="c-function-system.html">int system(const
											char *string)</a><br>由 string 指定的命令传给要被命令处理器执行的主机环境。</td>
								</tr>
								<tr>
									<td>16</td>
									<td><a href="c-function-bsearch.html">void
											*bsearch(const void *key, const void *base, size_t nitems,
											size_t size, int (*compar)(const void *, const void *))</a><br>执行二分查找。</td>
								</tr>
								<tr>
									<td>17</td>
									<td><a href="c-function-qsort.html">void qsort(void
											*base, size_t nitems, size_t size, int (*compar)(const void
											*, const void*))</a><br>数组排序。</td>
								</tr>
								<tr>
									<td>18</td>
									<td><a href="c-function-abs.html">int abs(int x)</a><br>返回
										x 的绝对值。</td>
								</tr>
								<tr>
									<td>19</td>
									<td><a href="c-function-div.html">div_t div(int numer,
											int denom)</a><br>分子除以分母。</td>
								</tr>
								<tr>
									<td>20</td>
									<td><a href="c-function-labs.html">long int labs(long
											int x)</a><br>返回 x 的绝对值。</td>
								</tr>
								<tr>
									<td>21</td>
									<td><a href="c-function-ldiv.html">ldiv_t ldiv(long
											int numer, long int denom)</a><br>分子除以分母。</td>
								</tr>
								<tr>
									<td>22</td>
									<td><a href="c-function-rand.html">int rand(void)</a><br>返回一个范围在
										0 到 <i>RAND_MAX</i> 之间的伪随机数。</td>
								</tr>
								<tr>
									<td>23</td>
									<td><a href="c-function-srand.html">void
											srand(unsigned int seed)</a><br>该函数播种由函数 <b>rand</b>
										使用的随机数发生器。</td>
								</tr>
								<tr>
									<td>24</td>
									<td><a href="c-function-mblen.html">int mblen(const
											char *str, size_t n)</a><br>返回参数 <i>str</i> 所指向的多字节字符的长度。</td>
								</tr>
								<tr>
									<td>25</td>
									<td><a href="c-function-mbstowcs.html">size_t
											mbstowcs(schar_t *pwcs, const char *str, size_t n)</a><br>把参数
										<i>str</i> 所指向的多字节字符的字符串转换为参数 <i>pwcs</i> 所指向的数组。</td>
								</tr>
								<tr>
									<td>26</td>
									<td><a href="c-function-mbtowc.html">int
											mbtowc(whcar_t *pwc, const char *str, size_t n)</a><br>检查参数
										<i>str</i> 所指向的多字节字符。</td>
								</tr>
								<tr>
									<td>27</td>
									<td><a href="c-function-wcstombs.html">size_t
											wcstombs(char *str, const wchar_t *pwcs, size_t n)</a><br>把数组
										<i>pwcs</i> 中存储的编码转换为多字节字符，并把它们存储在字符串 <i>str</i> 中。</td>
								</tr>
								<tr>
									<td>28</td>
									<td><a href="c-function-wctomb.html">int wctomb(char
											*str, wchar_t wchar)</a><br>检查对应于参数 <i>wchar</i>
										所给出的多字节字符的编码。</td>
								</tr>
							</tbody>
						</table>

						<pre class="brush: c;">
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;assert.h>
#include &lt;time.h>

int cmpfunc (const void * a, const void * b){
   return (*(int*)a - *(int*)b);
}

void print_int_array(int arr[], int len) {
    for(int i = 0; i < len; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

void when_exit() {
    printf("Application exited!\n");
}

int main() {
    /** 数值相关
     *  atof -- 字符串转换为一个浮点数
     *  strtod -- 符串转换为一个浮点数, 和 atof 不同的是它存储了转换数据的后面部分
     *  atoi -- 转换为整型
     *  atol -- 转换为长型
     *  strol -- 把参数 str 所指向的字符串转换为一个长整数
     *  stroul -- 把参数 str 所指向的字符串转换为一个无符号长整数
     *  abs -- 绝对值，参数为 int 
     *  labs -- 绝对值，参数为 long int 
     *  div -- 分子除以分母，返回结果为 div_t 类型，包括商和余数
     *  ldiv -- 分子除以分母，参数为 long int 
     *  rand -- 生成 0 - RAND_MAX 间的伪随机数
     *  srand -- 产生新的随机种子，随机种子一样，rand 生成的数一样
     */
    assert(3.141592 - atof("3.141592") <= 1E-6);    // 转换为浮点数, 1E-6 为 0.000001
    assert(3 == atoi("3"));                         // 转换为整数
    assert(3 == atoi("3.6"));
    assert(3 == atol("3"));                         // 长整数
    char *ptr;
    assert(20.30300 - strtod("20.30300 This is test", &ptr) <= 1E-6);  // 符串转换为一个浮点数
    assert(!strcmp(" This is test", ptr));
    assert(10003000 == strtol("10003000 This is long int test", &ptr, 10));  // 长整数，10进制
    assert(10003000 == strtoul("10003000 This is long int test", &ptr, 10)); // 无符号长整数，10进制
    assert(!strcmp(" This is long int test", ptr));

    assert(3 == abs(3) && 3 == abs(-3));            // 绝对值
    assert(3 == labs(3L) && 3 == labs(-3L));        // 绝对值

    div_t result = div(27, 4);                      // 分子除以分母，返回结果为 div_t 类型，包括商和余数
    assert(6 == result.quot && 3 == result.rem);
    ldiv_t l_result = ldiv(27L, 4L);                  // 分子除以分母，返回结果为 ldiv_t 类型，包括商和余数
    assert(6 == l_result.quot && 3 == l_result.rem);

    time_t t;       // time_t 为 time.h 中定义的时间类型
    srand((unsigned) time(&t)); // 产生新的随机种子，随机种子一样，rand 产生的数字一亲，最大为宏 RAND_MAX 定义
    printf("%d\n", rand());

    /** 内存相关
     *  calloc -- 分配所需的内存空间，并返回一个指向它的指针
     *  malloc -- 和 calloc 之间的不同点是，malloc 不会设置内存为零，而 calloc 会设置分配的内存为零
     *  free -- 释放之前调用 calloc、malloc 或 realloc 所分配的内存空间
     *  realloc -- 尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小
     */
    int *a = calloc(2, sizeof(int));    // 分配 2 个大小为 sizeof(int) 的空间
    a[0] = 1001;
    a[1] = 1002;
    assert(a[0] == 1001 && a[1] ==  1002);
    free(a);

    char *str;
    str = (char *) malloc(15);
    strcpy(str, "runoob");
    printf("String = %s,  Address = %#x\n", str, str);

    str = (char *) realloc(str, 25);
    strcat(str, ".com");
    printf("String = %s,  Address = %#x\n", str, str);

    free(str);      // 清除 str 内存空间
    
    /** 多字节字符
     *  mblen -- 返回参数 str 所指向的多字节字符的长度
     *  mbtowc -- 检查参数 str 所指向的多字节字符
     *  mbstowcs -- 把参数 str 所指向的多字节字符的字符串转换为参数 pwcs 所指向的数组
     *  wcstombs -- 把数组 pwcs 中存储的编码转换为多字节字符，并把它们存储在字符串 str 中
     *  wctomb -- 检查对应于参数 wchar 所给出的多字节字符的编码
     */
    char *pmb = (char *)malloc( MB_CUR_MAX );
    wchar_t *pwc = L"Hi";

    int len = wcstombs(pmb, pwc, MB_CUR_MAX);   // 转换为多字节字符串
    printf("被转换的字符 %d\n", len);
    printf("第一个多字节字符的十六进制值：%#x\n", pmb);
    
    len = mblen( pmb, MB_CUR_MAX );
    printf( "多字节字符 %x 的字节长度：%u\n", pmb, len );

    /** 排序和查找
     *  qsort -- 数组排序
     *  bsearch -- 执行二分查找
     */
    int values[5] = { 3, 2, 100, 80, 4 };
    print_int_array(values, 5);
    qsort(values, 5, sizeof(int), cmpfunc);
    print_int_array(values, 5);

    int *item;
    int key = 80;
    /* 使用 bsearch() 在数组中查找值 32 */
    item = (int*) bsearch(&key, values, 5, sizeof (int), cmpfunc);
    if(item != NULL) {
        printf("Found item = %d\n", *item);
    }

    /** 系统控制
     *  getenv -- 搜索 name 所指向的环境字符串，并返回相关的值给字符串
     *  system -- 由 string 指定的命令传给要被命令处理器执行的主机环境
     *  abort -- 使一个异常程序终止
     *  exit -- 使程序正常终止
     *  atexit -- 当程序正常终止时，调用指定的函数 func
     */
    printf("PATH:%s\n", getenv("PATH"));
    printf("HOME:%s\n", getenv("HOME"));
    system("ls -l");
    atexit(when_exit);                  // exit 前调用 when_exit 函数

    exit(0);
    printf("Allready exited!\n");       // 不会执行
    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-error" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>errno.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							C 标准库的 <b>errno.h</b> 头文件定义了整数变量 <b>errno</b>，它是通过系统调用设置的，在错误事件中的某些库函数表明了什么发生了错误。该宏扩展为类型为
							int 的可更改的左值，因此它可以被一个程序读取和修改。
						</p>
						<p>
							在程序启动时，<b>errno</b> 设置为零，C
							标准库中的特定函数修改它的值为一些非零值以表示某些类型的错误。您也可以在适当的时候修改它的值或重置为零。
						</p>
						<p>
							<b>errno.h</b> 头文件也顶了以一系列表示不同错误代码的宏，这些宏应扩展为类型为 <b>int</b>
							的整数常量表达式。
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-macro-errno.html">extern int errno</a><br>这是通过系统调用设置的宏，在错误事件中的某些库函数表明了什么发生了错误。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-macro-edom.html">EDOM Domain Error</a><br>这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno
										被设置为 EDOM。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-macro-erange.html">ERANGE Range Error</a><br>这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno
										被设置为 ERANGE。</td>
								</tr>
							</tbody>
						</table>

						<pre class="brush: c;">
#include &lt;stdio.h>
#include &lt;errno.h>
#include &lt;string.h>
#include &lt;math.h>

int main() {
    // 只读方式打开一个不存在的文件
    FILE * fp = fopen("no-exist.txt", "r");
    if( fp == NULL ) {
        printf("errno:%d \nmessage:%s\n", errno, strerror(errno));
    } else {
        fclose(fp);
    }

    errno = 0;
    double val = sqrt(-10);
    // 这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno 被设置为 EDOM
    if( errno == EDOM) {
        printf("errno:%d \nmessage:%s\n", errno, strerror(errno));
    }

    errno = 0;
    double value = log(0.00);
    // 这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno 被设置为 ERANGE
    if( errno == ERANGE ) {
        printf("errno:%d \nmessage:%s\n", errno, strerror(errno));
    }
    
    return(0);
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-math" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>math.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>math.h</code>
							头文件定义了各种数学函数和一个宏。在这个库中所有可用的功能都带有一个 double 类型的参数，且都返回 double
							类型的结果。
						</p>

						<p>
							<b>库宏</b>
						</p>
						<p>下面是这个库中定义的唯一的一个宏：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>HUGE_VAL</b><br>
										<p>当函数的结果不可以表示为浮点数时。如果是因为结果的幅度太大以致于无法表示，则函数会设置 errno 为
											ERANGE 来表示范围错误，并返回一个由宏 HUGE_VAL 或者它的否定（-
											HUGE_VAL）命名的一个特定的很大的值。</p>
										<p>如果结果的幅度太小，则会返回零值。在这种情况下，error 可能会被设置为 ERANGE，也有可能不会被设置为
											ERANGE。</p></td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库函数</b>
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>

								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-acos.html">double acos(double
											x)</a><br>返回以弧度表示的 x 的反余弦。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-function-asin.html">double asin(double
											x)</a><br>返回以弧度表示的 x 的反正弦。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-function-atan.html">double atan(double
											x)</a><br>返回以弧度表示的 x 的反正切。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><a href="c-function-atan2.html">double
											atan2(double y, double x)</a><br>返回以弧度表示的 y/x 的反正切。y 和 x
										的值的符号决定了正确的象限。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><a href="c-function-cos.html">double cos(double x)</a><br>返回弧度角
										x 的余弦。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><a href="c-function-cosh.html">double cosh(double
											x)</a><br>返回 x 的双曲余弦。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><a href="c-function-sin.html">double sin(double x)</a><br>返回弧度角
										x 的正弦。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><a href="c-function-sinh.html">double sinh(double
											x)</a><br>返回 x 的双曲正弦。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><a href="c-function-tanh.html">double tanh(double
											x)</a><br>返回 x 的双曲正切。</td>
								</tr>
								<tr>
									<td>10</td>
									<td><a href="c-function-exp.html">double exp(double x)</a><br>返回
										e 的 x 次幂的值。</td>
								</tr>
								<tr>
									<td>11</td>
									<td><a href="c-function-frexp.html">double
											frexp(double x, int *exponent)</a><br>把浮点数 x
										分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x = mantissa * 2 ^
										exponent。</td>
								</tr>
								<tr>
									<td>12</td>
									<td><a href="c-function-ldexp.html">double
											ldexp(double x, int exponent)</a><br>返回 x 乘以 2 的 exponent
										次幂。</td>
								</tr>
								<tr>
									<td>13</td>
									<td><a href="c-function-log.html">double log(double x)</a><br>返回
										x 的自然对数（基数为 e 的对数）。</td>
								</tr>
								<tr>
									<td>14</td>
									<td><a href="c-function-log10.html">double
											log10(double x)</a><br>返回 x 的常用对数（基数为 10 的对数）。</td>
								</tr>
								<tr>
									<td>15</td>
									<td><a href="c-function-modf.html">double modf(double
											x, double *integer)</a><br>返回值为小数部分（小数点后的部分），并设置 integer
										为整数部分。</td>
								</tr>
								<tr>
									<td>16</td>
									<td><a href="c-function-pow.html">double pow(double x,
											double y)</a><br>返回 x 的 y 次幂。</td>
								</tr>
								<tr>
									<td>17</td>
									<td><a href="c-function-sqrt.html">double sqrt(double
											x)</a><br>返回 x 的平方根。</td>
								</tr>
								<tr>
									<td>18</td>
									<td><a href="c-function-ceil.html">double ceil(double
											x)</a><br>返回大于或等于 x 的最小的整数值。</td>
								</tr>
								<tr>
									<td>19</td>
									<td><a href="c-function-fabs.html">double fabs(double
											x)</a><br>返回 x 的绝对值。</td>
								</tr>
								<tr>
									<td>20</td>
									<td><a href="c-function-floor.html">double
											floor(double x)</a><br>返回小于或等于 x 的最大的整数值。</td>
								</tr>
								<tr>
									<td>21</td>
									<td><a href="c-function-fmod.html">double fmod(double
											x, double y)</a><br>返回 x 除以 y 的余数。</td>
								</tr>
							</tbody>
						</table>

						<pre class="brush: c;">
#include &lt;stdio.h>
#include &lt;math.h>
#include &lt;string.h>
#include &lt;assert.h>

int main() {
    /** 三角函数, 参数为浮点数，是一个以弧度表示的角度。弧度 = (角度 / 180) * PI
     *  sin -- 正弦，对边 / 斜边，返回弧度角 x 的正弦
     *  cos -- 余弦，邻边 / 斜边，返回弧度角 x 的余弦
     *  asin -- 返回以弧度表示的 x 的反正弦
     *  acos -- 返回以弧度表示的 x 的反余弦
     *  atan -- 返回以弧度表示的 x 的反正切
     *  atan2 -- 返回以弧度表示的 y/x 的反正切
     *  sinh -- 返回 x 的双曲正弦
     *  cosh -- 返回 x 的双曲余弦
     *  tanh -- 返回 x 的双曲正切
     */
    const double PI = 3.14159265;

    printf("%lf\n", sin(0 / 180.0 * PI));     // 0 度角 sin 值
    printf("%lf\n", sin(30 / 180.0 * PI));    // 30 度角 sin 值
    printf("%lf\n", sin(45 / 180.0 * PI));    // 45 度角 sin 值
    printf("%lf\n", sin(60 / 180.0 * PI));    // 60 度角 sin 值
    printf("%lf\n", sin(90 / 180.0 * PI));     // 60 度角 sin 值

    printf("%lf\n", sin(120 / 180.0 * PI));    // 120 度角 sin 值
    printf("%lf\n", sin(180 / 180.0 * PI));    // 180 度角 sin 值
    printf("%lf\n", sin(225 / 180.0 * PI));    // 225 度角 sin 值
    printf("%lf\n", sin(270 / 180.0 * PI));    // 270 度角 sin 值
    printf("%lf\n", sin(360 / 180.0 * PI));    // 360 度角 sin 值
    
    /** 幂次运算
     *  pow -- 返回 x 的 y 次幂
     *  sqrt -- 返回 x 的平方根
     *  exp -- 返回 e 的 x 次幂的值, e 约为 2.718281828459...
     *  log -- 返回 x 的自然对数（基数为 e 的对数）
     *  log10 -- 返回 x 的常用对数（基数为 10 的对数）
     *  ldexp -- 返回 x 乘以 2 的 exponent 次幂
     *  frexp -- 把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中
     *      尾数的绝对值范围从 1/2（包含）到 1（不包含）
     */
    assert(8 == pow(2, 3));
    assert(4 == sqrt(16));
    printf("e 的三次方：%lf\n", exp(3));
    assert(10 == log(exp(10)));
    assert(2 == log10(100));
    assert(48 == ldexp(3, 4));  // 相当于： 3 * pow(2, 4)
    int e;
    double num = 6.0;
    double fraction = frexp(num, &e);
    printf("%lf = %lf * 2^%d\n", num, fraction, e);

    /** 
     *  fabs -- 返回 x 的绝对值
     *  floor -- 返回小于或等于 x 的最大的整数值
     *  cell -- 返回大于或等于 x 的最小的整数值
     *  fmod -- 返回 x 除以 y 的余数
     *  modf -- 返回值为小数部分（小数点后的部分），并设置 integer 为整数部分
     */
    assert(3.14 - fabs(-3.14) < 1E-6);
    assert(3 == floor(3.9));
    assert(4 == ceil(3.1));
    assert(2 == fmod(8, 3));
    double v;
    double result = modf(3.1415926, &v);
    printf("%.0lf %.8lf\n", v, result);

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-time" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>time.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>time.h</code>
							头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数。
						</p>
						<p>
							<b>库变量</b>
						</p>
						<p>下面是头文件 time.h 中定义的变量类型：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>变量 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>size_t</b><br>是无符号整数类型，它是 <b>sizeof</b>
										关键字的结果。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>clock_t</b><br>这是一个适合存储处理器时间的类型。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>time_t</b><br>这是一个适合存储日历时间类型。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><b>struct tm</b><br>这是一个用来保存时间和日期的结构。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>struct tm 结构体</b>
						</p>
						<pre class="brush: c;">
struct tm {
    int tm_sec;         /* 秒，范围从 0 到 59		*/
    int tm_min;         /* 分，范围从 0 到 59		*/
    int tm_hour;        /* 小时，范围从 0 到 23		*/
    int tm_mday;        /* 一月中的第几天，范围从 1 到 31	*/
    int tm_mon;         /* 月，范围从 0 到 11		*/
    int tm_year;        /* 自 1900 年起的年数		*/
    int tm_wday;        /* 一周中的第几天，范围从 0 到 6	*/
    int tm_yday;        /* 一年中的第几天，范围从 0 到 365	*/
    int tm_isdst;       /* 夏令时				*/
};
</pre>
						<p>
							<b>库宏</b>
						</p>
						<p>下面是头文件 time.h 中定义的宏：</p>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>NULL</b><br>这个宏是一个空指针常量的值。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>CLOCKS_PER_SEC </b><br>这个宏表示每秒的处理器时钟个数。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库函数</b>
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-asctime.html">char
											*asctime(const struct tm *timeptr)</a><br>返回一个指向字符串的指针，它代表了结构
										timeptr 的日期和时间。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-function-clock.html">clock_t
											clock(void)</a><br>返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-function-ctime.html">char *ctime(const
											time_t *timer)</a><br>返回一个表示当地时间的字符串，当地时间是基于参数 timer。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><a href="c-function-difftime.html">double
											difftime(time_t time1, time_t time2)</a><br>返回 time1 和 time2
										之间相差的秒数 (time1-time2)。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><a href="c-function-gmtime.html">struct tm
											*gmtime(const time_t *timer)</a><br>timer 的值被分解为 tm
										结构，并用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><a href="c-function-localtime.html">struct tm
											*localtime(const time_t *timer)</a><br>timer 的值被分解为 tm
										结构，并用本地时区表示。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><a href="c-function-mktime.html">time_t
											mktime(struct tm *timeptr)</a><br>把 timeptr
										所指向的结构转换为一个依据本地时区的 time_t 值。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><a href="c-function-strftime.html">size_t
											strftime(char *str, size_t maxsize, const char *format, const
											struct tm *timeptr)</a><br>根据 format 中定义的格式化规则，格式化结构 timeptr
										表示的时间，并把它存储在 str 中。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><a href="c-function-time.html">time_t time(time_t
											*timer)</a><br>计算当前日历时间，并把它编码成 time_t 格式。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>strftime 函数格式化时间的格式说明符</b>
						</p>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th style="width: 8%">说明符</th>
									<th>替换为</th>
									<th>实例</th>
								</tr>
								<tr>
									<td>%a</td>
									<td>缩写的星期几名称</td>
									<td>Sun</td>
								</tr>
								<tr>
									<td>%A</td>
									<td>完整的星期几名称</td>
									<td>Sunday</td>
								</tr>
								<tr>
									<td>%b</td>
									<td>缩写的月份名称</td>
									<td>Mar</td>
								</tr>
								<tr>
									<td>%B</td>
									<td>完整的月份名称</td>
									<td>March</td>
								</tr>
								<tr>
									<td>%c</td>
									<td>日期和时间表示法</td>
									<td>Sun Aug 19 02:56:02 2012</td>
								</tr>
								<tr>
									<td>%d</td>
									<td>一月中的第几天（01-31）</td>
									<td>19</td>
								</tr>
								<tr>
									<td>%H</td>
									<td>24 小时格式的小时（00-23）</td>
									<td>14</td>
								</tr>
								<tr>
									<td>%I</td>
									<td>12 小时格式的小时（01-12）</td>
									<td>05</td>
								</tr>
								<tr>
									<td>%j</td>
									<td>一年中的第几天（001-366）</td>
									<td>231</td>
								</tr>
								<tr>
									<td>%m</td>
									<td>十进制数表示的月份（01-12）</td>
									<td>08</td>
								</tr>
								<tr>
									<td>%M</td>
									<td>分（00-59）</td>
									<td>55</td>
								</tr>
								<tr>
									<td>%p</td>
									<td>AM 或 PM 名称</td>
									<td>PM</td>
								</tr>
								<tr>
									<td>%S</td>
									<td>秒（00-61）</td>
									<td>02</td>
								</tr>
								<tr>
									<td>%U</td>
									<td>一年中的第几周，以第一个星期日作为第一周的第一天（00-53）</td>
									<td>33</td>
								</tr>
								<tr>
									<td>%w</td>
									<td>十进制数表示的星期几，星期日表示为 0（0-6）</td>
									<td>4</td>
								</tr>
								<tr>
									<td>%W</td>
									<td>一年中的第几周，以第一个星期一作为第一周的第一天（00-53）</td>
									<td>34</td>
								</tr>
								<tr>
									<td>%x</td>
									<td>日期表示法</td>
									<td>08/19/12</td>
								</tr>
								<tr>
									<td>%X</td>
									<td>时间表示法</td>
									<td>02:50:06</td>
								</tr>
								<tr>
									<td>%y</td>
									<td>年份，最后两个数字（00-99）</td>
									<td>01</td>
								</tr>
								<tr>
									<td>%Y</td>
									<td>年份</td>
									<td>2012</td>
								</tr>
								<tr>
									<td>%Z</td>
									<td>时区的名称或缩写</td>
									<td>CDT</td>
								</tr>
								<tr>
									<td>%%</td>
									<td>一个 % 符号</td>
									<td>%</td>
								</tr>
							</tbody>
						</table>
						<pre class="brush: c;">
#include &lt;stdio.h>
#include &lt;time.h>

#define CCT (+8)

int main() {
    // 1. time -- 计算当前日历时间, 并存储在 time_t 中, time_t 为从1970年到现在经过了多少秒
    time_t timer;
    time(&timer);           // time_t 为从1970年到现在经过了多少秒
    printf("1970 年到现在为 %ld 秒, 约 %ld 年.\n", timer, timer / 60 / 60 / 24 / 365);

    // 2. gmtime -- 返回 time_t 结构体, 这个是时间 0 的时间，所以要加中国时区 8，前面的 CCT
    struct tm *now = gmtime(&timer);
    printf("现在时间： %d 年 %d 月 %d 日, 星期 %d, %d 时 %d 分 %d 秒\n", \
        1900 + now->tm_year, 1 + now->tm_mon, now->tm_mday, \
        now->tm_wday, CCT + now->tm_hour, now->tm_min, now->tm_sec);
    
    // 3. localtime -- 返回 time_t 结构体, 这个是本地时区
    now = localtime(&timer);
    printf("现在时间: %d 年 %d 月 %d 日, 星期 %d, %d 时 %d 分 %d 秒\n", \
        1900 + now->tm_year, 1 + now->tm_mon, now->tm_mday, \
        now->tm_wday, now->tm_hour, now->tm_min, now->tm_sec);
    
    // 4. ctime -- 返回一个表示当地时间的字符串
    printf("现在时间: %s", ctime(&timer));

    // 5. mktime -- 所指向的 struct tm 结构转换为一个依据本地时区的 time_t 值
    struct tm birthday;
    birthday.tm_year = 1989 - 1900;
    birthday.tm_mon = 2;
    birthday.tm_mday = 24;
    birthday.tm_hour = 10;
    birthday.tm_min = 30;
    birthday.tm_sec = 0;
    birthday.tm_isdst = -1;
    time_t bth = mktime(&birthday);
    printf("生日为: %s", ctime(&bth));

    // 6. difftime -- 返回 time1 和 time2 之间相差的秒数
    double diff = difftime(timer, bth);
    double diff_day = diff / 60 / 60 / 24;
    printf("我的生是过去了 %.0lf 秒，%.0lf 天, %.0lf 年。\n", diff, diff_day, diff_day / 365);

    // 7. strtime -- 将 struct tm 结构格式化为 format 指定的格式，存储在 buffer 数组中
    char buffer[80];
    char * format = "%x - %I:%M%p";         // format 格式
    strftime(buffer, sizeof(buffer), format, &birthday);
    printf("%s\n", buffer);

    // 8. asctime -- 和 ctime 不同的只是参数
    printf("%s\n", asctime(&birthday));

    // 9. clock -- 为了获取 CPU 所使用的秒数，需要除以 CLOCKS_PER_SEC
    clock_t start_t = clock();
    for(int i = 0; i < 10000000; i++) {}
    clock_t end_t = clock();
    printf("CPU 占用的总时间: %f 秒。\n", (double)(end_t - start_t) / CLOCKS_PER_SEC);

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-assert" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>assert.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							C 标准库的
							<code>assert.h</code>
							头文件提供了一个名为 assert 的宏，它可用于验证程序做出的假设，并在假设为假时输出诊断消息。
						</p>

						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-macro-assert.html">void assert(int
											expression)</a><br>这实际上是一个宏，不是一个函数，可用于在 C 程序中添加诊断。</td>
								</tr>
							</tbody>
						</table>

						<pre class="brush: c;">
#include &lt;assert.h>
#include &lt;string.h>

int main() {
    assert(1);                          // 非 0 为真
    assert('a');
    assert('a' == 'a');                 // 字符

    assert(1 == 1);                     // 整数
    double PI = 3.1415926;
    assert(3.1415926 - PI < 1E-6);      // 浮点数不能直接对比


    assert(!strcmp("abc", "abc"));	   // 字符串

    int x = 32;							// 指针
    int *a = &x, *b = &x;
    assert(a == b);

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-ctype" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>ctype.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							C 标准库的
							<code>ctype.h</code>
							头文件提供了一些函数，可用于测试和映射字符。
						</p>
						<p>这些函数接受 int 作为参数，它的值必须是 EOF 或表示为一个无符号字符。</p>

						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-isalnum.html">int isalnum(int
											c)</a><br>该函数检查所传的字符是否是字母和数字。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-function-isalpha.html">int isalpha(int
											c)</a><br>该函数检查所传的字符是否是字母。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-function-iscntrl.html">int iscntrl(int
											c)</a><br>该函数检查所传的字符是否是控制字符。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><a href="c-function-isdigit.html">int isdigit(int
											c)</a><br>该函数检查所传的字符是否是十进制数字。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><a href="c-function-isgraph.html">int isgraph(int
											c)</a><br>该函数检查所传的字符是否有图形表示法。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><a href="c-function-islower.html">int islower(int
											c)</a><br>该函数检查所传的字符是否是小写字母。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><a href="c-function-isprint.html">int isprint(int
											c)</a><br>该函数检查所传的字符是否是可打印的。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><a href="c-function-ispunct.html">int ispunct(int
											c)</a><br>该函数检查所传的字符是否是标点符号字符。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><a href="c-function-isspace.html">int isspace(int
											c)</a><br>该函数检查所传的字符是否是空白字符。</td>
								</tr>
								<tr>
									<td>10</td>
									<td><a href="c-function-isupper.html">int isupper(int
											c)</a><br>该函数检查所传的字符是否是大写字母。</td>
								</tr>
								<tr>
									<td>11</td>
									<td><a href="c-function-isxdigit.html">int
											isxdigit(int c)</a><br>该函数检查所传的字符是否是十六进制数字。</td>
								</tr>
								<tr>
									<td>12</td>
									<td><a href="c-function-tolower.html">int tolower(int
											c)</a><br>该函数把大写字母转换为小写字母。</td>
								</tr>
								<tr>
									<td>13</td>
									<td><a href="c-function-toupper.html">int toupper(int
											c)</a><br>该函数把小写字母转换为大写字母。</td>
								</tr>
							</tbody>
						</table>

						<pre class="brush: c;">
#include &lt;ctype.h>
#include &lt;stdio.h>
#include &lt;assert.h>
#include &lt;limits.h>

int main() {
    /** 1. 字母或数字
     *  isalnum -- 检查所传的字符是否是字母或数字
     *      48-57 对应数字 0-9
     *      65-90 对应字母 A-Z
     *      97-122 对应字母 a-z
     */
    assert(isalnum('0'));
    assert(isalnum(48));
    assert(isalnum(65));

    /** 2. 字母
     *  isalpha -- 检查所传的字符是否是字母
     *  islower -- 查所传的字符是否是小写字母
     *  isupper -- 检查所传的字符是否是大写字母
     *  toupper -- 把小写字母转换为大写字母
     *  tolower -- 把大写字母转换为小写字母
     *      65-90 对应字母 A-Z
     *      97-122 对应字母 a-z
     */
    assert(isalpha('A'));
    assert(isalpha(65));
    assert(!isalpha(48));

    assert(islower('a'));
    assert(islower(97));

    assert(isupper('A'));
    assert(isupper(65));

    assert(isupper(toupper('a')));
    assert(islower(tolower('A')));

    /** 3. 数字
     *  isdigit -- 检查所传的字符是否是十进制数字
     *  isxdigit -- 检查所传的字符是否是十六进制数字
     *      48-57 对应数字 0-9
     *      65-70 对应字母 A-F
     *      97-102 对应字母 a-f
     */
    assert(isdigit('0'));
    assert(isdigit(48));

    assert(isxdigit('A'));
    assert(isxdigit('a'));
    assert(isxdigit(65));
    assert(isxdigit(97));

    /** 4. 其它字符
     *  isspace -- 空白字符,标准的空白字符包括:
     *      ' '     (0x20)	space (SPC) 空格符
     *      '\t'	(0x09)	horizontal tab (TAB) 水平制表符	
     *      '\n'	(0x0a)	newline (LF) 换行符
     *      '\v'	(0x0b)	vertical tab (VT) 垂直制表符
     *      '\f'	(0x0c)	feed (FF) 换页符
     *      '\r'	(0x0d)	carriage return (CR) 回车符
     *  iscntrl -- 检查所传的字符是否是控制字符
     *      0-31 及 127 为控制字符
     *  isgraph -- 检查所传的字符是否有图形表示法, 除了控制字符和空白字符
     *  ispunct -- 检查所传的字符是否是标点符号字符, 
     *      标点符号字符可以是非字母数字（正如 isalnum 中的一样）的任意图形字符（正如 isgraph 中的一样）
     *  isprint -- 检查所传的字符是否是可打印的, 可打印字符是非控制字符的字符
     */
    assert(isspace(' '));
    assert(isspace(32));

    assert(iscntrl('\t'));
    assert(iscntrl('\r'));
    assert(iscntrl('\n'));
    assert(iscntrl(0));
    assert(iscntrl(31));
    assert(iscntrl(127));
    assert(!iscntrl(32));

    assert(isgraph('0'));
    assert(!isgraph('\t'));
    assert(!isgraph(' '));
    assert(!isgraph('\n'));
    assert(!isgraph(32));

    assert(ispunct(','));

    assert(isprint('A'));
    assert(isprint(' '));
    
    /** ASCII 字符查看 */
    for(int i = CHAR_MIN; i <= CHAR_MAX; i++) {
        printf("%d == %c\n", i, i);
    }

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-float" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>float.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							C 标准库的
							<code>float.h</code>
							头文件包含了一组与浮点值相关的依赖于平台的常量。这些常量是由 ANSI C 提出的，这让程序更具有可移植性。
							浮点数是由下面四个元素组成的：
						</p>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th style="width: 10%">组件</th>
									<th>组件描述</th>
								</tr>
								<tr>
									<td>S</td>
									<td>符号 ( +/- )</td>
								</tr>
								<tr>
									<td>b</td>
									<td>指数表示的基数，2 表示二进制，10 表示十进制，16 表示十六进制，等等...</td>
								</tr>
								<tr>
									<td>e</td>
									<td>指数，一个介于最小值 <b>e<sub>min</sub></b> 和最大值 <b>e<sub>max</sub></b>
										之间的整数。
									</td>
								</tr>
								<tr>
									<td>p</td>
									<td>精度，基数 b 的有效位数</td>
								</tr>
							</tbody>
						</table>
						<p>基于以上 4 个组成部分，一个浮点数的值如下：</p>
						<p>
							<strong>floating-point = ( S ) p x b<sup>e</sup></strong>
						</p>
						<p>或</p>
						<p>
							<strong>floating-point = (+/-) precision x base<sup>exponent</sup></strong>
						</p>

						<p>下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。请注意，所有的实例
							FLT 是指类型 float，DBL 是指类型 double，LDBL 是指类型 long double。</p>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th style="width: 30%">宏</th>
									<th>描述</th>
								</tr>
								<tr>
									<td>FLT_ROUNDS</td>
									<td>定义浮点加法的舍入模式，它可以是下列任何一个值：
										<ul>
											<li>
												<p>-1 - 无法确定</p>
											</li>
											<li>
												<p>0 - 趋向于零</p>
											</li>
											<li>
												<p>1 - 去最近的值</p>
											</li>
											<li>
												<p>2 - 趋向于正无穷</p>
											</li>
											<li>
												<p>3 - 趋向于负无穷</p>
											</li>
										</ul>
									</td>
								</tr>
								<tr>
									<td>FLT_RADIX 2</td>
									<td>这个宏定义了指数表示的基数。基数 2 表示二进制，基数 10 表示十进制，基数 16 表示十六进制。</td>
								</tr>
								<tr>
									<td>
										<p>FLT_MANT_DIG</p>
										<p>DBL_MANT_DIG</p>
										<p>LDBL_MANT_DIG</p>
									</td>
									<td>这些宏定义了 FLT_RADIX 基数中的位数。</td>
								</tr>
								<tr>
									<td>
										<p>FLT_DIG 6</p>
										<p>DBL_DIG 10</p>
										<p>LDBL_DIG 10</p>
									</td>
									<td>这些宏定义了舍入后不会改变表示的十进制数字的最大值（基数 10）。</td>
								</tr>
								<tr>
									<td>
										<p>FLT_MIN_EXP</p>
										<p>DBL_MIN_EXP</p>
										<p>LDBL_MIN_EXP</p>
									</td>
									<td>这些宏定义了基数为 FLT_RADIX 时的指数的最小负整数值。</td>
								</tr>
								<tr>
									<td>
										<p>FLT_MIN_10_EXP -37</p>
										<p>DBL_MIN_10_EXP -37</p>
										<p>LDBL_MIN_10_EXP -37</p>
									</td>
									<td>这些宏定义了基数为 10 时的指数的最小负整数值。</td>
								</tr>
								<tr>
									<td>
										<p>FLT_MAX_EXP</p>
										<p>DBL_MAX_EXP</p>
										<p>LDBL_MAX_EXP</p>
									</td>
									<td>这些宏定义了基数为 FLT_RADIX 时的指数的最大整数值。</td>
								</tr>
								<tr>
									<td>
										<p>FLT_MAX_10_EXP +37</p>
										<p>DBL_MAX_10_EXP +37</p>
										<p>LDBL_MAX_10_EXP +37</p>
									</td>
									<td>这些宏定义了基数为 10 时的指数的最大整数值。</td>
								</tr>
								<tr>
									<td>
										<p>FLT_MAX 1E+37</p>
										<p>DBL_MAX 1E+37</p>
										<p>LDBL_MAX 1E+37</p>
									</td>
									<td>这些宏定义最大的有限浮点值。</td>
								</tr>
								<tr>
									<td>
										<p>FLT_EPSILON 1E-5</p>
										<p>DBL_EPSILON 1E-9</p>
										<p>LDBL_EPSILON 1E-9</p>
									</td>
									<td>这些宏定义了可表示的最小有效数字。</td>
								</tr>
								<tr>
									<td>
										<p>FLT_MIN 1E-37</p>
										<p>DBL_MIN 1E-37</p>
										<p>LDBL_MIN 1E-37</p>
									</td>
									<td>这些宏定义了最小的浮点值。</td>
								</tr>
							</tbody>
						</table>

						<pre class="brush: c;">
#include &lt;stdio.h>
#include &lt;float.h>

int main() {
    /** 
     *  如果浮点数的整数部分比较大，小数位精度相应变小，因为占用总字节地址限制，优先保证整数能存储
     *  float -- 4 字节，最大 6 位小数, 第 6 位还可能是进了一位的数
     *  double -- 8 字节，最大 15 位小数，第 15 位还可能是进了一位的数
     *  long double -- 16 字节， 最大 19 位小数，第 19 位还可能是进了一位的数
     */
    float PI_7 = 3.1415926f;
    double D_PI_16 = 3.1415926535897932;
    long double LD_PI_20 = 3.14159265358979323876;

    printf("float: %.6f\n", PI_7);
    printf("double: %.15f\n", D_PI_16);
    printf("long louble: %.19Lf\n", LD_PI_20);

    printf("舍入模式：%d\n", FLT_ROUNDS);     // 舍入模式

    printf("指数表示的基数：%d\n", FLT_RADIX); // 指数表示的基数

    // 不同类型,定义了宏 FLT_RADIX 基数中的位数
    printf("宏 FLT_RADIX 基数中的位数:\n");
    printf("float: %d\n", FLT_MANT_DIG);
    printf("double: %d\n", DBL_MANT_DIG);
    printf("long double: %d\n", LDBL_MANT_DIG);

    // 舍入后不会改变表示的十进制数字的最大值
    printf("舍入后不会改变表示的十进制数字的最大值:\n");
    printf("float: %d\n", FLT_DIG);
    printf("double: %d\n", DBL_DIG);
    printf("long double: %d\n", LDBL_DIG);

    // 定义了基数为 FLT_RADIX 时的指数的最小负整数值
    printf("定义了基数为 FLT_RADIX 时的指数的最小负整数值:\n");
    printf("float: %d\n", FLT_MIN_EXP);
    printf("double: %d\n", DBL_MIN_EXP);
    printf("long double: %d\n", LDBL_MIN_EXP);

    // 定义了基数为 10 时的指数的最小负整数值
    printf("定义了基数为 10 时的指数的最小负整数值:\n");
    printf("float: %d\n", FLT_MIN_10_EXP);
    printf("double: %d\n", DBL_MIN_10_EXP);
    printf("long double: %d\n", LDBL_MIN_10_EXP);

    // 定义了基数为 FLT_RADIX 时的指数的最大整数值
    printf("定义了基数为 FLT_RADIX 时的指数的最大整数值:\n");
    printf("float: %d\n", FLT_MAX_EXP);
    printf("double: %d\n", DBL_MAX_EXP);
    printf("long double: %d\n", LDBL_MAX_EXP);

    // 定义了基数为 10 时的指数的最大整数值
    printf("定义了基数为 10 时的指数的最大整数值:\n");
    printf("float: %d\n", FLT_MAX_10_EXP);
    printf("double: %d\n", DBL_MAX_10_EXP);
    printf("long double: %d\n", LDBL_MAX_10_EXP);

    // 定义最大的有限浮点值
    printf("定义最大的有限浮点值:\n");
    printf("float: %f\n", FLT_MAX);
    printf("double: %f\n", DBL_MAX);
    printf("long double: %Lf\n", LDBL_MAX);

    // 定义了可表示的最小有效数字
    printf("定义了可表示的最小有效数字:\n");
    printf("float: %f\n", FLT_EPSILON);
    printf("double: %f\n", DBL_EPSILON);
    printf("long double: %LF\n", LDBL_EPSILON);

    // 定义了最小的浮点值
    printf("定义了最小的浮点值:\n");
    printf("float: %f\n", FLT_MIN);
    printf("double: %f\n", DBL_MIN);
    printf("long double: %Lf\n", LDBL_MIN);

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-limits" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>limits.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>limits.h</code>
							头文件决定了各种变量类型的各种属性。定义在该头文件中的宏限制了各种变量类型（比如 char、int 和 long）的值。
						</p>
						<p>这些限制指定了变量不能存储任何超出这些限制的值，例如一个无符号可以存储的最大值是 255。</p>


						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 25%">宏</th>
									<th style="width: 25%">值</th>
									<th>描述</th>
								</tr>
								<tr>
									<td>CHAR_BIT</td>
									<td>8</td>
									<td>定义一个字节的比特数。</td>
								</tr>
								<tr>
									<td>SCHAR_MIN</td>
									<td>-128</td>
									<td>定义一个有符号字符的最小值。</td>
								</tr>
								<tr>
									<td>SCHAR_MAX</td>
									<td>127</td>
									<td>定义一个有符号字符的最大值。</td>
								</tr>
								<tr>
									<td>UCHAR_MAX</td>
									<td>255</td>
									<td>定义一个无符号字符的最大值。</td>
								</tr>
								<tr>
									<td>CHAR_MIN</td>
									<td>0</td>
									<td>定义类型 char 的最小值，如果 char 表示负值，则它的值等于 SCHAR_MIN，否则等于 0。</td>
								</tr>
								<tr>
									<td>CHAR_MAX</td>
									<td>127</td>
									<td>定义类型 char 的最大值，如果 char 表示负值，则它的值等于 SCHAR_MAX，否则等于
										UCHAR_MAX。</td>
								</tr>
								<tr>
									<td>MB_LEN_MAX</td>
									<td>1</td>
									<td>定义多字节字符中的最大字节数。</td>
								</tr>
								<tr>
									<td>SHRT_MIN</td>
									<td>-32768</td>
									<td>定义一个短整型的最小值。</td>
								</tr>
								<tr>
									<td>SHRT_MAX</td>
									<td>+32767</td>
									<td>定义一个短整型的最大值。</td>
								</tr>
								<tr>
									<td>USHRT_MAX</td>
									<td>65535</td>
									<td>定义一个无符号短整型的最大值。</td>
								</tr>
								<tr>
									<td>INT_MIN</td>
									<td>-32768</td>
									<td>定义一个整型的最小值。</td>
								</tr>
								<tr>
									<td>INT_MAX</td>
									<td>+32767</td>
									<td>定义一个整型的最大值。</td>
								</tr>
								<tr>
									<td>UINT_MAX</td>
									<td>65535</td>
									<td>定义一个无符号整型的最大值。</td>
								</tr>
								<tr>
									<td>LONG_MIN</td>
									<td>-2147483648</td>
									<td>定义一个长整型的最小值。</td>
								</tr>
								<tr>
									<td>LONG_MAX</td>
									<td>+2147483647</td>
									<td>定义一个长整型的最大值。</td>
								</tr>
								<tr>
									<td>ULONG_MAX</td>
									<td>4294967295</td>
									<td>定义一个无符号长整型的最大值。</td>
								</tr>
							</tbody>
						</table>

						<pre class="brush: c;">
#include &lt;limits.h>
#include &lt;math.h>
#include &lt;stdio.h>

int main()
{
    printf("%d\n", CHAR_BIT); // 定义一个字节的比特数

    printf("%d %d\n", SCHAR_MIN, SCHAR_MAX); // 定义一个有符号字符的最小和最大值
    printf("%d %d\n", CHAR_MIN, CHAR_MAX); // 定义类型 char 的最小和最大值
    printf("%d\n", UCHAR_MAX); // 定义一个无符号字符的最大值

    printf("%d\n", MB_LEN_MAX); // 定义多字节字符中的最大字节数

    printf("%d %d\n", SHRT_MIN, SHRT_MAX); // 定义一个短整型的最小和最大值
    printf("%d\n", USHRT_MAX); // 定义一个无符号短整型的最大值

    printf("%d %d\n", INT_MIN, INT_MAX); // 定义一个整型的最小和最大值
    printf("%u\n", UINT_MAX); // 定义一个无符号整型的最大值

    printf("%ld %ld\n", LONG_MIN, LONG_MAX); // 定义一个长整型的最小和最大值
    printf("%lu\n", ULONG_MAX); // 定义一个无符号长整型的最大值

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-locale" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>locale.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>locale.h</code>
							头文件定义了特定地域的设置，比如日期格式和货币符号。接下来我们将介绍一些宏，以及一个重要的结构 struct lconv
							和两个重要的函数。
						</p>

						<p>
							<b>lconv 结构体</b>
						</p>
						<pre class="brush: c;">
typedef struct {
   char *decimal_point;
   char *thousands_sep;
   char *grouping;	
   char *int_curr_symbol;
   char *currency_symbol;
   char *mon_decimal_point;
   char *mon_thousands_sep;
   char *mon_grouping;
   char *positive_sign;
   char *negative_sign;
   char int_frac_digits;
   char frac_digits;
   char p_cs_precedes;
   char p_sep_by_space;
   char n_cs_precedes;
   char n_sep_by_space;
   char p_sign_posn;
   char n_sign_posn;
} lconv
</pre>
						<p>
							<b>lconv 结构体字段的描述</b>
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 10%">序号</th>
									<th>字段 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>decimal_point</b><br>用于非货币值的小数点字符。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>thousands_sep</b><br>用于非货币值的千位分隔符。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>grouping</b><br>一个表示非货币量中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为
										0 意味着前一个值将应用于剩余的分组。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><b>int_curr_symbol</b><br>国际货币符号使用的字符串。前三个字符是由
										ISO 4217:1987 指定的，第四个字符用于分隔货币符号和货币量。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><b>currency_symbol</b><br>用于货币的本地符号。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><b>mon_decimal_point</b><br>用于货币值的小数点字符。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><b>mon_thousands_sep</b><br>用于货币值的千位分隔符。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><b>mon_grouping</b><br>一个表示货币值中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为
										0 意味着前一个值将应用于剩余的分组。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><b>positive_sign</b><br>用于正货币值的字符。</td>
								</tr>
								<tr>
									<td>10</td>
									<td><b>negative_sign</b><br>用于负货币值的字符。</td>
								</tr>
								<tr>
									<td>11</td>
									<td><b>int_frac_digits</b><br>国际货币值中小数点后要显示的位数。</td>
								</tr>
								<tr>
									<td>12</td>
									<td><b>frac_digits</b><br>货币值中小数点后要显示的位数。</td>
								</tr>
								<tr>
									<td>13</td>
									<td><b>p_cs_precedes</b><br>如果等于 1，则 currency_symbol
										出现在正货币值之前。如果等于 0，则 currency_symbol 出现在正货币值之后。</td>
								</tr>
								<tr>
									<td>14</td>
									<td><b>p_sep_by_space</b><br>如果等于 1，则 currency_symbol
										和正货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和正货币值之间不使用空格分隔。</td>
								</tr>
								<tr>
									<td>15</td>
									<td><b>n_cs_precedes</b><br>如果等于 1，则 currency_symbol
										出现在负货币值之前。如果等于 0，则 currency_symbol 出现在负货币值之后。</td>
								</tr>
								<tr>
									<td>16</td>
									<td><b>n_sep_by_space</b><br>如果等于 1，则 currency_symbol
										和负货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和负货币值之间不使用空格分隔。</td>
								</tr>
								<tr>
									<td>17</td>
									<td><b>p_sign_posn</b><br>表示正货币值中正号的位置。</td>
								</tr>
								<tr>
									<td>18</td>
									<td><b>n_sign_posn</b><br>表示负货币值中负号的位置。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库宏</b>
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 10%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>LC_ALL</b><br>设置下面的所有选项。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>LC_COLLATE</b><br>影响 strcoll 和 strxfrm 函数。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>LC_CTYPE</b><br>影响所有字符函数。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><b>LC_MONETARY</b><br>影响 localeconv 函数提供的货币信息。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><b>LC_NUMERIC</b><br>影响 localeconv
										函数提供的小数点格式化和信息。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><b>LC_TIME</b><br>影响 strftime 函数。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库函数</b>
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-setlocale.html">char
											*setlocale(int category, const char *locale)</a><br>设置或读取地域化信息。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-function-localeconv.html">struct lconv
											*localeconv(void)</a><br>设置或读取地域化信息。</td>
								</tr>
							</tbody>
						</table>

						<pre class="brush: c;">
#include &lt;locale.h>
#include &lt;stdio.h>

void print_conv(struct lconv* lc)
{
    printf("%s\n", lc->decimal_point); // 用于非货币值的小数点字符
    printf("%s\n", lc->thousands_sep); // 用于非货币值的千位分隔符
    printf("%s\n", lc->grouping); // 一个表示非货币量中每组数字大小的字符串

    printf("%s\n", lc->int_curr_symbol); // 国际货币符号使用的字符串
    printf("%s\n", lc->currency_symbol); // 用于货币的本地符号

    printf("%s\n", lc->mon_decimal_point); // 用于货币值的小数点字符
    printf("%s\n", lc->mon_thousands_sep); // 用于货币值的千位分隔符
    printf("%s\n", lc->mon_grouping); // 一个表示货币值中每组数字大小的字符串

    printf("%s\n", lc->positive_sign); // 用于正货币值的字符
    printf("%s\n", lc->negative_sign); // 用于负货币值的字符

    printf("%c\n", lc->int_frac_digits); // 国际货币值中小数点后要显示的位数
    printf("%c\n", lc->frac_digits); // 货币值中小数点后要显示的位数

    /** 如果等于 1，则 currency_symbol 出现在正货币值之前。
     *	如果等于 0，则 currency_symbol 出现在正货币值之后
     */
    printf("%c\n", lc->p_cs_precedes);
    /** 如果等于 1，则 currency_symbol 和正货币值之间使用空格分隔。
     *  如果等于 0，则 currency_symbol 和正货币值之间不使用空格分隔
     */
    printf("%c\n", lc->p_sep_by_space);
    /** 如果等于 1，则 currency_symbol 出现在负货币值之前。
     *  如果等于 0，则 currency_symbol 出现在负货币值之后
     */
    printf("%c\n", lc->n_cs_precedes);
    /** 如果等于 1，则 currency_symbol 和负货币值之间使用空格分隔。
     *  如果等于 0，则 currency_symbol 和负货币值之间不使用空格分隔
     */
    printf("%c\n", lc->n_sep_by_space);
    // 表示正货币值中正号的位置
    printf("%c\n", lc->p_sign_posn);
    // 表示负货币值中负号的位置
    printf("%c\n", lc->n_sign_posn);
}

int main()
{
    setlocale(LC_ALL, "");

    struct lconv* lc = localeconv();
    print_conv(lc);

    setlocale(LC_ALL, "C");
    lc = localeconv();
    print_conv(lc);

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-setjmp" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>setjmp.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>setjmp.h</code>
							头文件定义了宏 setjmp()、函数 longjmp() 和变量类型 jmp_buf，该变量类型会绕过正常的函数调用和返回规则。
						</p>

						<p>
							<b>库变量</b>
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>变量 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>jmp_buf </b><br>这是一个用于存储宏 <b>setjmp()</b> 和函数
										<b>longjmp()</b> 相关信息的数组类型。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库宏</b>
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-macro-setjmp.html">int setjmp(jmp_buf
											environment)</a><br>这个宏把当前环境保存在变量 <b>environment</b> 中，以便函数
										<b>longjmp()</b> 后续使用。如果这个宏直接从宏调用中返回，则它会返回零，但是如果它从 <b>longjmp()</b>
										函数调用中返回，则它会返回一个非零值。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库函数</b>
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-longjmp.html">void
											longjmp(jmp_buf environment, int value)</a><br>该函数恢复最近一次调用 <b>setjmp()</b>
										宏时保存的环境，<b>jmp_buf</b> 参数的设置是由之前调用 setjmp() 生成的。</td>
								</tr>
							</tbody>
						</table>

						<pre class="brush: c;">
#include &lt;setjmp.h>
#include &lt;stdio.h>

static jmp_buf buf;

void second(void)
{
    printf("second\n"); // 打印
    longjmp(buf, 1); // 跳回 setjmp 的调用处 - 使得 setjmp 返回值为 1
}

void first(void)
{
    second();
    printf("first\n"); // 不可能执行到此行
}

int main()
{
    if (!setjmp(buf)) {
        first(); // 进入此行前，setjmp 返回 0
    } else { // 当 longjmp 跳转回，setjmp 返回 1，因此进入此行
        printf("main\n"); // 打印
    }

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-signal" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>signal.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>signal.h</code>
							头文件定义了一个变量类型 <b>sig_atomic_t</b>、两个函数调用和一些宏来处理程序执行期间报告的不同信号。
						</p>

						<p>
							<b>库变量</b>
						</p>
						<p>下面是头文件 signal.h 中定义的变量类型：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>变量 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>sig_atomic_t </b><br>这是 <b>int</b>
										类型，在信号处理程序中作为变量使用。它是一个对象的整数类型，该对象可以作为一个原子实体访问，即使存在异步信号时，该对象可以作为一个原子实体访问。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库宏</b>
						</p>
						<p>
							下面是头文件 signal.h 中定义的宏，这些宏将在下列两个函数中使用。<b>SIG_</b> 宏与 signal
							函数一起使用来定义信号的功能。
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>SIG_DFL</b><br>默认的信号处理程序。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>SIG_ERR</b><br>表示一个信号错误。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>SIG_IGN</b><br>忽视信号。</td>
								</tr>
							</tbody>
						</table>
						<p>
							<b>SIG</b> 宏用于表示以下各种条件的信号码：
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>SIGABRT</b><br>程序异常终止。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>SIGFPE</b><br>算术运算出错，如除数为 0 或溢出。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>SIGILL</b><br>非法函数映象，如非法指令。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><b>SIGINT</b><br>中断信号，如 ctrl-C。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><b>SIGSEGV</b><br>非法访问存储器，如访问不存在的内存单元。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><b>SIGTERM</b><br>发送给本程序的终止请求信号。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库函数</b>
						</p>
						<p>下面是头文件 signal.h 中定义的函数：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-signal.html">void (*signal(int
											sig, void (*func)(int)))(int)</a><br>该函数设置一个函数来处理信号，即信号处理程序。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-function-raise.html">int raise(int sig)</a><br>该函数会促使生成信号
										<b>sig</b>。sig 参数与 SIG 宏兼容。</td>
								</tr>
							</tbody>
						</table>
						<pre class="brush: c;">
#include &lt;signal.h>
#include &lt;stdio.h>
#include &lt;stdlib.h>

void signal_catchfunc(int signal)
{
    printf("!! 信号捕获 %d!!\n", signal);
}

int main()
{
    int ret;

    ret = signal(SIGINT, signal_catchfunc);

    if (ret == SIG_ERR) {
        printf("错误：不能设置信号处理程序。\n");
        exit(0);
    }
    printf("开始生成一个信号\n");
    ret = raise(SIGINT);
    if (ret != 0) {
        printf("错误：不能生成 SIGINT 信号。\n");
        exit(0);
    }

    printf("退出...\n");

    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-stdarg" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>stdarg.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<b>stdarg.h</b> 主要是为了实现可变参数，定义了一个变量类型 <b>va_list</b>
							和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。
						</p>
						<p>可变参数的函数通在参数列表的末尾是使用省略号(,...)定义的。</p>

						<p>
							<b>库变量</b>
						</p>
						<p>下面是头文件 stdarg.h 中定义的变量类型：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>变量 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>va_list </b><br>这是一个适用于 <b>va_start()、va_arg()</b>
										和 <b>va_end()</b> 这三个宏存储信息的类型。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库宏</b>
						</p>
						<p>下面是头文件 stdarg.h 中定义的宏：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-macro-va_start.html">void
											va_start(va_list ap, last_arg)</a><br>这个宏初始化 <b>ap</b> 变量，它与
										<b>va_arg</b> 和 <b>va_end</b> 宏是一起使用的。<b>last_arg</b>
										是最后一个传递给函数的已知的固定参数，即省略号之前的参数。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-macro-va_arg.html">type va_arg(va_list
											ap, type)</a><br>这个宏检索函数参数列表中类型为 <b>type</b> 的下一个参数。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-macro-va_end.html">void va_end(va_list
											ap)</a><br>这个宏允许使用了 <b>va_start</b>
										宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 <b>va_end</b>，则结果为未定义。</td>
								</tr>
							</tbody>
						</table>
						<pre class="brush: c;">
#include &lt;stdarg.h>
#include &lt;stdio.h>

int sum(int, ...);

int main(void)
{
    printf("10、20 和 30 的和 = %d\n", sum(3, 10, 20, 30));
    printf("4、20、25 和 30 的和 = %d\n", sum(4, 4, 20, 25, 30));

    return 0;
}

int sum(int num_args, ...)
{
    int val = 0;
    va_list ap;
    int i;

    va_start(ap, num_args);
    for (i = 0; i < num_args; i++) {
        val += va_arg(ap, int);
    }
    va_end(ap);

    return val;
}
</pre>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-stddef" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>stddef.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<b>stddef .h</b> 头文件定义了各种变量类型和宏。这些定义中的大部分也出现在其它头文件中。
						</p>

						<p>
							<b>库变量</b>
						</p>
						<p>下面是头文件 stddef.h 中定义的变量类型：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>变量 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>ptrdiff_t</b><br>这是有符号整数类型，它是两个指针相减的结果。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>size_t </b><br>这是无符号整数类型，它是 <b>sizeof</b>
										关键字的结果。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>wchar_t </b><br>这是一个宽字符常量大小的整数类型。</td>
								</tr>
							</tbody>
						</table>

						<p>
							<b>库宏</b>
						</p>
						<p>下面是头文件 stddef.h 中定义的宏：</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-macro-null.html">NULL</a><br>这个宏是一个空指针常量的值。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-macro-offsetof.html">offsetof(type,
											member-designator)</a><br>这会生成一个类型为 size_t
										的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 <i>member-designator</i>
										给定的，结构的名称是在 <i>type</i> 中给定的。</td>
								</tr>
							</tbody>
						</table>
						<pre class="brush: c;">
#include &lt;stddef.h>
#include &lt;stdio.h>

struct address {
    char name[50];
    char street[50];
    int phone;
};

int main()
{
    printf("address 结构中的 name 偏移 = %d 字节。\n",
        offsetof(struct address, name));

    printf("address 结构中的 street 偏移 = %d 字节。\n",
        offsetof(struct address, street));

    printf("address 结构中的 phone 偏移 = %d 字节。\n",
        offsetof(struct address, phone));

    return (0);
}
</pre>


					</div>
				</div>
				<!-- item over -->


			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushCpp.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushBash.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>



</body>
</html>
