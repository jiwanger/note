<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--C</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					style="position: fixed; top: 70px; width: 260px; height: 85%; overflow: auto; float: left;">
					<div class="panel-heading">
						<h3 class="panel-title">C</h3>
					</div>
					<div class="list-group">
						<a href="#" class="list-group-item">简介</a>
						<a href="#c-compile" class="list-group-item">C 语言程序编译过程</a>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#c-base-menu" aria-expanded="true">
							C 语言基础<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="c-base-menu" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#c-keyword" class="list-group-item">关键字</a>
							<a href="#c-type" class="list-group-item">数据类型</a>
							<a href="#c-converter" class="list-group-item">强制类型转换</a>
							<a href="#c-const" class="list-group-item">常量</a>
							<a href="#c-calculator" class="list-group-item">运算符</a>
							<a href="#c-ifelse" class="list-group-item">流程控制</a>
							<a href="#c-function" class="list-group-item">函数</a>
							<a href="#c-area" class="list-group-item">作用域规则</a>
							<a href="#c-array" class="list-group-item">数组</a>
							<a href="#c-preprocessor" class="list-group-item">预处理器</a>
							<a href="#c-header" class="list-group-item">头文件</a>
							<a href="#c-string" class="list-group-item">字符串</a>
							<a href="#c-struct" class="list-group-item">结构体</a>
							<a href="#c-bit-area" class="list-group-item">位域</a>
							<a href="#c-error" class="list-group-item">错误处理</a>
							<a href="#c-variable-arg" class="list-group-item">可变参数</a>
							<a href="#c-memory" class="list-group-item">内存管理</a>
							<a href="#c-cmd" class="list-group-item">命令行参数</a>
						</div>
						<a href="#c-printf" class="list-group-item">格式化输出</a>
						<a href="#c-poiter" class="list-group-item">指针</a>
						<a href="#c-file" class="list-group-item">文件读写</a>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#c-lib" aria-expanded="true">
							C 标准库<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="c-lib" class="panel-collapse collapse in" role="tabpanel">
							<a href="#c-lib-string" class="list-group-item">
								<code>string.h</code>
							</a>
							<a href="#c-lib-stdio" class="list-group-item">
								<code>stdio.h</code>
							</a>
							<a href="#c-lib-stdlib" class="list-group-item">
								<code>stdlib.h</code>
							</a>
							<a href="#c-lib-error" class="list-group-item">
								<code>error.h</code>
							</a>
							<a href="#c-lib-math" class="list-group-item">
								<code>math.h</code>
							</a>
							<a href="#c-lib-time" class="list-group-item">
								<code>time.h</code>
							</a>
							<a href="#c-lib-assert" class="list-group-item">
								<code>assert.h</code>
							</a>
							<a href="#c-lib-ctype" class="list-group-item">
								<code>ctype.h</code>
							</a>
							<a href="#c-lib-float" class="list-group-item">
								<code>float.h</code>
							</a>
							<a href="#c-lib-limits" class="list-group-item">
								<code>limits.h</code>
							</a>
							<a href="#c-lib-locale" class="list-group-item">
								<code>locale.h</code>
							</a>
							<a href="#c-lib-setjmp" class="list-group-item">
								<code>setjmp.h</code>
							</a>
							<a href="#c-lib-signal" class="list-group-item">
								<code>signal.h</code>
							</a>
							<a href="#c-lib-stdarg" class="list-group-item">
								<code>stdarg.h</code>
							</a>
							<a href="#c-lib-stddef" class="list-group-item">
								<code>stddef.h</code>
							</a>
						</div>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<p>C 语言是一种通用的、面向过程式的计算机程序设计语言。C 语言是一种广泛使用的计算机语言，它与 Java
							编程语言一样普及，二者在现代软件程序员之间都得到广泛使用。</p>
						<ul>
							<li>OS: Linux Mint 17 (32位)</li>
							<li>GCC/G++: 4.4.7</li>
							<li>MAKE: GNU Make 3.81</li>
						</ul>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-compile" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">C 语言程序编译过程</h3>
					</div>
					<div class="panel-body">
						<p width="100%">
							<img src="images/c-compile.png"
								class="img-responsive center-block">
						</p>
						<pre class="brush: bash;">
# 1.预处理, 生成 .i 文件
$ gcc -E test.c -o test.i

# 2.编译, 生成 .s 文件(汇编文件)
$ gcc -S test.i -o test.s

# 3.汇编, 生成 .o 文件(机器代码,二进制文件)
$ gcc -c test.s -o test.o

# 4.链接, 生成可执行文件(二进制文件)
$ gcc test.o -o test
</pre>
						<p>
							源代码:
							<code>test.c</code>
						</p>
						<pre class="brush: cpp;">
#include &lt;stdio.h>
 
int main() {
   /* 我的第一个 C 程序 */
   printf("Hello, World!\n");
   
   return 0;
}
</pre>
						<ul>
							<li>
								<p>
									<b>预处理</b> -- C
									语言程序从源代码变成可执行程序的第一步，主要是C语言编译器对各种预处理命令进行处理，包括头文件的包含、宏定义的扩展、条件编译的选择等。打印出预处理之后的结果,这样我们就可以看到源代码中的各种预处理命令是如何被解释的，从而方便理解和查错。
									<code>$ gcc -E test.c -o test.i</code>
									, 看到这个预处理过的 test.i 文件有 800 多行。
								</p>
								<pre class="brush: cpp;">
# 1 "test.c"
# 1 "&lt;built-in>"
# 1 "&lt;command-line>"
# 1 "test.c"
# 1 "/usr/include/stdio.h" 1 3 4

......
......


# 2 "test.c" 2

int main() {

   printf("Hello, World!\n");

   return 0;
}
</pre>
							</li>
							<li>
								<p>
									<b>编译</b> -- C 语言编译器会进行词法分析、语法分析，接着会把源代码翻译成中间语言，即汇编语言。<br>
									<code>$ gcc -S test.i -o test.s</code>
									。
								</p>
								<pre class="brush: cpp;">
	.file	"test.c"
	.section	.rodata
.LC0:
	.string	"Hello, World!"
	.text
.globl main
	.type	main, @function
main:
	pushl	%ebp
	movl	%esp, %ebp
	andl	$-16, %esp
	subl	$16, %esp
	movl	$.LC0, (%esp)
	call	puts
	movl	$0, %eax
	leave
	ret
	.size	main, .-main
	.ident	"GCC: (Ubuntu/Linaro 4.4.7-8ubuntu1) 4.4.7"
	.section	.note.GNU-stack,"",@progbits

</pre>
							</li>
							<li>
								<p>
									<b>汇编</b> -- 把作为中间结果的汇编代码翻译成了机器代码，即目标代码，不过它还不可以运行。<br>
									<code>$ gcc -c test.s -o test.o</code>
									, 生成的 .o 文件是二进制文件，直接用文本工具打开看到的将是乱码，我们需要反汇编工具如GDB的帮助才能读懂它.
								</p>
							</li>
							<li>
								<p>
									<b>链接</b> --
									链接是处理可重定位文件，把它们的各种符号引用和符号定义转换为可执行文件中的各适信息(一般是虚拟内存地址)的过程。链接又分为静态链接和动态链接，前者是程序开发阶段程序员用ld(gcc实际上在后台调用了ld)静态链接器手动链接的过程，而动态链接则是程序运行期间系统调用动态链接器(ld-linux.so)自动链接的过程。
									gcc 默认优先选择动态库，如果想要让 gcc 选择静态链接，那么需要指定一个选项，就是 -static, 这样就会强制
									gcc 找静态库文件了。 生成可执行文件:
									<code>$ gcc test.o -o test</code>
								</p>
								<p>
									<b>函数库</b>一般分为静态库和动态库两种:
								</p>
								<p>静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为”.a”。</p>
								<p>动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为”.so”，如前面所述的
									libc.so.6 就是动态库。gcc 在编译时默认使用动态库。</p>
							</li>
						</ul>
					</div>
				</div>

				<!-- item start -->
				<a id="c-base" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">C 语言基础</h3>
					</div>
					<div class="panel-body">
						<a id="c-keyword" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">关键字</h5>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<td style="width: 25%">auto</td>
										<td style="width: 25%">else</td>
										<td style="width: 25%">long</td>
										<td style="width: 25%">switch</td>
									</tr>
									<tr>
										<td>break</td>
										<td>enum</td>
										<td>register</td>
										<td>typedef</td>
									</tr>
									<tr>
										<td>case</td>
										<td>extern</td>
										<td>return</td>
										<td>union</td>
									</tr>
									<tr>
										<td>char</td>
										<td>float</td>
										<td>short</td>
										<td>unsigned</td>
									</tr>
									<tr>
										<td>const</td>
										<td>for</td>
										<td>signed</td>
										<td>void</td>
									</tr>
									<tr>
										<td>continue</td>
										<td>goto</td>
										<td>sizeof</td>
										<td>volatile</td>
									</tr>
									<tr>
										<td>default</td>
										<td>if</td>
										<td>static</td>
										<td>while</td>
									</tr>
									<tr>
										<td>do</td>
										<td>int</td>
										<td>struct</td>
										<td>_Packed</td>
									</tr>
									<tr>
										<td>double</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
										<td>&nbsp;</td>
									</tr>
								</tbody>
							</table>
						</div>

						<a id="c-type" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">数据类型</h5>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th>序号</th>
										<th>类型与描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>基本类型：</b><br>它们是算术类型，包括两种类型：整数类型和浮点类型。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>枚举类型：</b><br>它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>void 类型：</b><br>类型说明符 <i>void</i> 表明没有可用的值。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>派生类型：</b><br>它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td>
									</tr>
								</tbody>
							</table>
							<p>
								<b>整数类型</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th>类型</th>
										<th>存储大小</th>
										<th>值范围</th>
									</tr>
									<tr>
										<td>char</td>
										<td>1 字节</td>
										<td>-128 到 127 或 0 到 255</td>
									</tr>
									<tr>
										<td>unsigned char</td>
										<td>1 字节</td>
										<td>0 到 255</td>
									</tr>
									<tr>
										<td>signed char</td>
										<td>1 字节</td>
										<td>-128 到 127</td>
									</tr>
									<tr>
										<td>int</td>
										<td>2 或 4 字节</td>
										<td>-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
									</tr>
									<tr>
										<td>unsigned int</td>
										<td>2 或 4 字节</td>
										<td>0 到 65,535 或 0 到 4,294,967,295</td>
									</tr>
									<tr>
										<td>short</td>
										<td>2 字节</td>
										<td>-32,768 到 32,767</td>
									</tr>
									<tr>
										<td>unsigned short</td>
										<td>2 字节</td>
										<td>0 到 65,535</td>
									</tr>
									<tr>
										<td>long</td>
										<td>4 字节</td>
										<td>-2,147,483,648 到 2,147,483,647</td>
									</tr>
									<tr>
										<td>unsigned long</td>
										<td>4 字节</td>
										<td>0 到 4,294,967,295</td>
									</tr>
								</tbody>
							</table>
							<p>
								<b>浮点类型</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">

								<tbody>
									<tr>
										<th>类型</th>
										<th>存储大小</th>
										<th>值范围</th>
										<th>精度</th>
									</tr>
									<tr>
										<td>float</td>
										<td>4 字节</td>
										<td>1.2E-38 到 3.4E+38</td>
										<td>6 位小数</td>
									</tr>
									<tr>
										<td>double</td>
										<td>8 字节</td>
										<td>2.3E-308 到 1.7E+308</td>
										<td>15 位小数</td>
									</tr>
									<tr>
										<td>long double</td>
										<td>16 字节</td>
										<td>3.4E-4932 到 1.1E+4932</td>
										<td>19 位小数</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>void 类型</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th>序号</th>
										<th>类型与描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>函数返回为空</b><br>C
											中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <b>void exit
												(int status);</b></td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>函数参数为空</b><br>C 中有各种函数不接受任何参数。不带参数的函数可以接受一个
											void。例如 <b>int rand(void);</b></td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>指针指向 void</b><br>类型为 void *
											的指针代表对象的地址，而不是类型。例如，内存分配函数 <b>void *malloc( size_t size
												);</b> 返回指向 void 的指针，可以转换为任何数据类型。</td>
									</tr>
								</tbody>
							</table>
						</div>

						<a id="c-converter" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">强制类型转换</h5>
							<p>强制类型转换是把变量从一种类型转换为另一种数据类型。例如，如果您想存储一个 long
								类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int
								类型。您可以使用强制类型转换运算符来把值显式地从一种类型转换为另一种类型。</p>
							<p>类型转换可以是隐式的，由编译器自动执行，也可以是显式的，通过使用强制类型转换运算符来指定。在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。</p>
							<div class="row">
								<div class="col-md-8">
									<p>常用的算术转换是隐式地把值强制转换为相同的类型。编译器首先执行整数提升，如果操作数类型不同，则它们会被转换为右侧层次中出现的最高层次的类型：</p>
									<pre class="brush: cpp;">
#include &lt;stdio.h>
      
int main() {
    int sum = 17, count = 5;
    double avg;

    /** 强制类型转换运算符的优先级大于除法，因此 sum 的值首先被转换
     * 为 double 型，然后除以 count，得到一个类型为 double 的值。
     */
    avg = (double) sum / count;
    printf("Value of avg : %f\n", avg );


    int  i = 17;
    char c = 'c'; /* ascii 值是 99 */

    // 整数提升
    sum = i + c;
    printf("Value of sum : %d\n", sum );
    
    return 0;
}
</pre>
								</div>
								<div class="col-md-4">
									<img src="images/usual_arithmetic_conversion.png"
										class="img-responsive">
								</div>
							</div>
						</div>

						<a id="c-const" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">常量</h5>
							<p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。</p>
							<p>常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。</p>
							<p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。</p>
							<p>有两种简单的定义常量的方式：1.使用 #define 预处理器。2.使用 const 关键字。</p>
							<pre class="brush: cpp;">
#define LENGTH 10			// define 没有类型, 是在预处理阶段展开
#define WIDTH  5		

int main() {
	printf("%d\n", LENGTH * WIDTH);
	
	const int A = 3;		// const 有类型, 是编译运行阶段使用
	const int B = 4;
	printf("%d\n", A * B);
 
	return 0;
}
</pre>
						</div>

						<a id="c-calculator" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">运算符</h5>
							<p>
								<b>算术运算符</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>+</td>
										<td>把两个操作数相加</td>
										<td>A + B 将得到 30</td>
									</tr>
									<tr>
										<td>-</td>
										<td>从第一个操作数中减去第二个操作数</td>
										<td>A - B 将得到 -10</td>
									</tr>
									<tr>
										<td>*</td>
										<td>把两个操作数相乘</td>
										<td>A * B 将得到 200</td>
									</tr>
									<tr>
										<td>/</td>
										<td>分子除以分母</td>
										<td>B / A 将得到 2</td>
									</tr>
									<tr>
										<td>%</td>
										<td>取模运算符，整除后的余数</td>
										<td>B % A 将得到 0</td>
									</tr>
									<tr>
										<td>++</td>
										<td>自增运算符，整数值增加 1</td>
										<td>A++ 将得到 11</td>
									</tr>
									<tr>
										<td>--</td>
										<td>自减运算符，整数值减少 1</td>
										<td>A-- 将得到 9</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>关系运算符</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>==</td>
										<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
										<td>(A == B) 不为真。</td>
									</tr>
									<tr>
										<td>!=</td>
										<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
										<td>(A != B) 为真。</td>
									</tr>
									<tr>
										<td>&gt;</td>
										<td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
										<td>(A &gt; B) 不为真。</td>
									</tr>
									<tr>
										<td>&lt;</td>
										<td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
										<td>(A &lt; B) 为真。</td>
									</tr>
									<tr>
										<td>&gt;=</td>
										<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
										<td>(A &gt;= B) 不为真。</td>
									</tr>
									<tr>
										<td>&lt;=</td>
										<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
										<td>(A &lt;= B) 为真。</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>逻辑运算符</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>&amp;&amp;</td>
										<td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
										<td>(A &amp;&amp; B) 为假。</td>
									</tr>
									<tr>
										<td>||</td>
										<td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
										<td>(A || B) 为真。</td>
									</tr>
									<tr>
										<td>!</td>
										<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
										<td>!(A &amp;&amp; B) 为真。</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>位运算符</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>&amp;</td>
										<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
										<td>(A &amp; B) 将得到 12，即为 0000 1100</td>
									</tr>
									<tr>
										<td>|</td>
										<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
										<td>(A | B) 将得到 61，即为 0011 1101</td>
									</tr>
									<tr>
										<td>^</td>
										<td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>
										<td>(A ^ B) 将得到 49，即为 0011 0001</td>
									</tr>
									<tr>
										<td>~</td>
										<td>二进制补码运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0。</td>
										<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
									</tr>
									<tr>
										<td>&lt;&lt;</td>
										<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
										<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
									</tr>
									<tr>
										<td>&gt;&gt;</td>
										<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
										<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>赋值运算符</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>=</td>
										<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
										<td>C = A + B 将把 A + B 的值赋给 C</td>
									</tr>
									<tr>
										<td>+=</td>
										<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
										<td>C += A 相当于 C = C + A</td>
									</tr>
									<tr>
										<td>-=</td>
										<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
										<td>C -= A 相当于 C = C - A</td>
									</tr>
									<tr>
										<td>*=</td>
										<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
										<td>C *= A 相当于 C = C * A</td>
									</tr>
									<tr>
										<td>/=</td>
										<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
										<td>C /= A 相当于 C = C / A</td>
									</tr>
									<tr>
										<td>%=</td>
										<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
										<td>C %= A 相当于 C = C % A</td>
									</tr>
									<tr>
										<td>&lt;&lt;=</td>
										<td>左移且赋值运算符</td>
										<td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>
									</tr>
									<tr>
										<td>&gt;&gt;=</td>
										<td>右移且赋值运算符</td>
										<td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>
									</tr>
									<tr>
										<td>&amp;=</td>
										<td>按位与且赋值运算符</td>
										<td>C &amp;= 2 等同于 C = C &amp; 2</td>
									</tr>
									<tr>
										<td>^=</td>
										<td>按位异或且赋值运算符</td>
										<td>C ^= 2 等同于 C = C ^ 2</td>
									</tr>
									<tr>
										<td>|=</td>
										<td>按位或且赋值运算符</td>
										<td>C |= 2 等同于 C = C | 2</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>杂项运算符 ↦ sizeof & 三元</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 10%">运算符</th>
										<th style="width: 55%;">描述</th>
										<th>实例</th>
									</tr>
									<tr>
										<td>sizeof()</td>
										<td>返回变量的大小。</td>
										<td>sizeof(a) 将返回 4，其中 a 是整数。</td>
									</tr>
									<tr>
										<td>&amp;</td>
										<td>返回变量的地址。</td>
										<td>&amp;a; 将给出变量的实际地址。</td>
									</tr>
									<tr>
										<td>*</td>
										<td>指向一个变量。</td>
										<td>*a; 将指向一个变量。</td>
									</tr>
									<tr>
										<td>? :</td>
										<td>条件表达式</td>
										<td>如果条件为真 ? 则值为 X : 否则值为 Y</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>C 中的运算符优先级</b>
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th>类别&nbsp;</th>
										<th>运算符&nbsp;</th>
										<th>结合性&nbsp;</th>
									</tr>
									<tr>
										<td>后缀&nbsp;</td>
										<td>() [] -&gt; . ++ - - &nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>一元&nbsp;</td>
										<td>+ - ! ~ ++ - - (type)* &amp; sizeof&nbsp;</td>
										<td>从右到左&nbsp;</td>
									</tr>
									<tr>
										<td>乘除&nbsp;</td>
										<td>* / %&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>加减&nbsp;</td>
										<td>+ -&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>移位&nbsp;</td>
										<td>&lt;&lt; &gt;&gt;&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>关系&nbsp;</td>
										<td>&lt; &lt;= &gt; &gt;=&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>相等&nbsp;</td>
										<td>== !=&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>位与 AND&nbsp;</td>
										<td>&amp;&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>位异或 XOR&nbsp;</td>
										<td>^&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>位或 OR&nbsp;</td>
										<td>|&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>逻辑与 AND&nbsp;</td>
										<td>&amp;&amp;&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>逻辑或 OR&nbsp;</td>
										<td>||&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
									<tr>
										<td>条件&nbsp;</td>
										<td>?:&nbsp;</td>
										<td>从右到左&nbsp;</td>
									</tr>
									<tr>
										<td>赋值&nbsp;</td>
										<td>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^=
											|=&nbsp;</td>
										<td>从右到左&nbsp;</td>
									</tr>
									<tr>
										<td>逗号&nbsp;</td>
										<td>,&nbsp;</td>
										<td>从左到右&nbsp;</td>
									</tr>
								</tbody>
							</table>
						</div>

						<a id="c-ifelse" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">流程控制</h5>
							<p>
								<b>判断</b> -- C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。
							</p>
							<pre class="brush: cpp;">
/* 1. if-else 结构, 非零和非空的值为 true */
if(boolean_expression) {
	/* 如果布尔表达式为真将执行的语句 */
} else if(boolean_expression) {
	/* 如果前面布尔表达式为假，这个为真将执行的语句 */
} else {
	/* 如果布尔表达式为假将执行的语句 */
}

/**
 * 2.switch 结构, 语句中的 expression 必须是一个整型或枚举类型，或者是一个 class 类型，
 *	其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
 */
switch(expression){
	case constant-expression :
		statement(s);
		break; /* 可选的 */
	case constant-expression  :
		statement(s);
		break; /* 可选的 */
    default : /* 可选的 */
		statement(s);
}
</pre>
							<p>
								<b>循环</b>
							</p>
							<pre class="brush: cpp;">
/* 1.while 循环 */
while(condition) {
   statement(s);
}

/* 2.for 循环,  无限循环: for( ; ; ){} */
for(init; condition; increment) {
   statement(s);
}

/* 3.do-while 循环 */
do {
   statement(s);
} while(condition);

/**
 * break: 终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。
 * continue: 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。
 * goto: C 语言中的 goto 语句允许把控制无条件转移到同一函数内的被标记的语句。
 */
</pre>
						</div>

						<a id="c-function" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">函数</h5>
							<p>
								<b>函数声明:</b> 函数声明会告诉编译器函数名称及如何调用函数。
							</p>
							<pre class="brush: cpp;">
return_type function_name(parameter list);	// 在函数声明中，参数的名称并不重要，只有参数的类型是必需的
return_type function_name(parameter);		// 省略参数名
</pre>
							<p>
								<b>函数定义:</b> 函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：
							</p>
							<ul>
								<li>
									<b>返回类型：</b>一个函数可以返回一个值。<b>return_type</b>
									是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <b>void</b>。
								</li>
								<li>
									<b>函数名称：</b>这是函数的实际名称。函数名和参数列表一起构成了函数签名。
								</li>
								<li>
									<b>参数：</b>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
								</li>
								<li>
									<b>函数主体：</b>函数主体包含一组定义函数执行任务的语句。
								</li>
							</ul>
							<p>
								<b>内部函数:</b> 如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数是，在函数名和函数类型的前面加
								<code>static</code>
								。
							</p>
							<p>
								<b>外部函数:</b> 如果在定义函数时，在函数的首部的最左端加关键字 extern，则此函数是外部函数，可供其它文件调用。
								C 语言规定，如果在定义函数时省略 extern，则默认为外部函数。
							</p>
							<pre class="brush: cpp;">
/* test.c */
#include &lt;stdio.h>

int main() {
   printf("Sum is %d.\n", sum(3, 4));
   printf("Sum is %d.\n", minus(1000, 4));
   
   return 0;
}

static int minus(int a, int b) {
    return a - b;
}

/* support.c */
#include &lt;stdio.h>
 
static int sum(int x, int y) {
   return x + y;
}
</pre>
						</div>

						<a id="c-area" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">作用域规则</h5>
							<p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p>
							<ol>
								<li>
									在函数或块内部的<b>局部</b>变量
								</li>
								<li>
									在所有函数外部的<b>全局</b>变量
								</li>
								<li>
									在<b>形式</b>参数的函数参数定义中
								</li>
							</ol>
						</div>

						<a id="c-array" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">数组</h5>
							<p>C
								语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>
							<pre class="brush: cpp;">

#include &lt;stdio.h>
#include &lt;stdlib.h>  
      
int main() {  
    int a[12] = { 1,2,3,4,5,6 };  
    printf("a:     %d\n", a);       // 数组首元素地址
    printf("&a:    %d\n", &a);      // 整个数组地址位置
    printf("&a[0]: %d\n", &a[0]);   // 数组首元素地址另一种获取方法
    printf("&a[1]: %d\n\n", &a[1]); // 数组第二个元素的地址

    printf("a:     %d\n", a+1);     // 数组首元素地址加1后的地址，即第二个元素a[1]的地址
    printf("&a[1]: %d\n", &a[1]);   // 数组第二个元素的地址  
    printf("&a:    %d\n", &a+1);    // 首地址位置 + 4x12（(类型x数组size)），即位移整个数组的长度   

    return 0;
}  

type arrayName [ arraySize ];		// 数组声明语句

double balance[10];
balance[4] = 50.0;					// balance[4] 值赋为 50.0

double balance[5] = { 1000.0, 2.0, 3.4, 7.0, 50.0 };	// 初始化数组
double balance[] = { 1000.0, 2.0, 3.4, 7.0, 50.0 };		// 省略数组的大小

/* 多维数组 */
type name[size1][size2]...[sizeN];
int a[3][4] = {  
	{ 0, 1, 2, 3 } ,   /*  初始化索引号为 0 的行 */
	{ 4, 5, 6, 7 } ,   /*  初始化索引号为 1 的行 */
	{ 8, 9, 10, 11 }   /*  初始化索引号为 2 的行 */
};
</pre>
						</div>

						<a id="c-preprocessor" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">预处理器</h5>
							<p>C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C
								预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。</p>
							<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 20%">指令</th>
										<th>描述</th>
									</tr>
									<tr>
										<td>#define</td>
										<td>定义宏</td>
									</tr>
									<tr>
										<td>#include</td>
										<td>包含一个源代码文件</td>
									</tr>
									<tr>
										<td>#undef</td>
										<td>取消已定义的宏</td>
									</tr>
									<tr>
										<td>#ifdef</td>
										<td>如果宏已经定义，则返回真</td>
									</tr>
									<tr>
										<td>#ifndef</td>
										<td>如果宏没有定义，则返回真</td>
									</tr>
									<tr>
										<td>#if</td>
										<td>如果给定条件为真，则编译下面代码</td>
									</tr>
									<tr>
										<td>#else</td>
										<td>#if 的替代方案</td>
									</tr>
									<tr>
										<td>#elif</td>
										<td>如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
									</tr>
									<tr>
										<td>#endif</td>
										<td>结束一个 #if……#else 条件编译块</td>
									</tr>
									<tr>
										<td>#error</td>
										<td>当遇到标准错误时，输出错误消息</td>
									</tr>
									<tr>
										<td>#pragma</td>
										<td>使用标准化方法，向编译器发布特殊的命令到编译器中</td>
									</tr>
								</tbody>
							</table>

							<p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th style="width: 20%">宏</th>
										<th>描述</th>
									</tr>
									<tr>
										<td>__DATE__</td>
										<td>当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。</td>
									</tr>
									<tr>
										<td>__TIME__</td>
										<td>当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。</td>
									</tr>
									<tr>
										<td>__FILE__</td>
										<td>这会包含当前文件名，一个字符串常量。</td>
									</tr>
									<tr>
										<td>__LINE__</td>
										<td>这会包含当前行号，一个十进制常量。</td>
									</tr>
									<tr>
										<td>__STDC__</td>
										<td>当编译器以 ANSI 标准编译时，则定义为 1。</td>
									</tr>
								</tbody>
							</table>

							<pre class="brush: cpp;">
#include &lt;stdio.h>

#ifndef MESSAGE
   #define MESSAGE "You wish!"
#endif
// defined 达到上面相同的效果
#if !defined (MESSAGE)
   #define MESSAGE "You wish!"
#endif

// 在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。
#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")

// 宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。
#define tokenpaster(n) printf ("token" #n" = %d\n", token##n)

#define MAX(x,y) ((x) > (y) ? (x) : (y))
      
int main() {
    printf("Message: %s.\n", MESSAGE);

    int token34 = 40;
    tokenpaster(34);

    message_for(Carole, Debra);

    printf("Max between 20 and 10 is %d.\n", MAX(10, 20));

    printf("Date Time: %s %s.\n", __DATE__, __TIME__);

    return 0;
}
</pre>
						</div>

						<a id="c-header" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">头文件</h5>
							<p>头文件是扩展名为 .h 的文件，包含了 C
								函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p>
							<p>在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它。前面我们已经看过 stdio.h
								头文件，它是编译器自带的头文件。</p>
							<p>建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p>
							<p class="text-warning">如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中。</p>
							<p>使用预处理指令 #include 可以引用用户和系统头文件。它的形式有以下两种：</p>
							<pre class="brush: cpp;">
/** 这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。
 *		在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。
 */
#include &lt;file>

/** 这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。
 * 在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。
 */
#include "file"
</pre>
						</div>

						<a id="c-string" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">字符串</h5>
							<p>
								在 C 语言中，字符串实际上是使用 null 字符 '\0' 终止的一维字符数组。更多 string 用法查看:
								<code>string.h</code>
							</p>
							<pre class="brush: cpp;">
int main () {
	char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
	char str_2[] = "Hello";
	
	/* 输出返回值 */
	printf( "str： %s \n", str );
	printf( "str_2 : %s \n", str_2 );
	
	char str1[12] = "Hello";
	char str2[12] = "World";
	char str3[12];
	int  len ;
	
	/* 复制 str1 到 str3 */
	strcpy(str3, str1);
	printf("strcpy( str3, str1) :  %s\n", str3);
	
	/* 连接 str1 和 str2 */
	strcat(str1, str2);
	printf("strcat( str1, str2):   %s\n", str1);
	
	/* 连接后，str1 的总长度 */
	len = strlen(str1);
	printf("strlen(str1) :  %d\n", len);
	 
	return 0;
}
</pre>
						</div>

						<a id="c-struct" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">结构体</h5>
							<p>C 数组允许定义可存储相同类型数据项的变量，结构是 C
								编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;string.h>
 
struct Books {
	char  title[50];
	char  author[50];
	char  subject[100];
	int   book_id;
};

/* 函数声明 */
void printBook( struct Books book );
 
struct Books {
	char  title[50];
	char  author[50];
	char  subject[100];
	int   book_id;
};

/* 函数声明 */
void printBook( struct Books book );
 
int main() {
	struct Books Book1;        /* 声明 Book1，类型为 Book */
	struct Books Book2;        /* 声明 Book2，类型为 Book */
	
	/* Book1 详述 */
	strcpy( Book1.title, "C Programming");
	strcpy( Book1.author, "Nuha Ali"); 
	strcpy( Book1.subject, "C Programming Tutorial");
	Book1.book_id = 6495407;
	
	/* Book2 详述 */
	strcpy( Book2.title, "Telecom Billing");
	strcpy( Book2.author, "Zara Ali");
	strcpy( Book2.subject, "Telecom Billing Tutorial");
	Book2.book_id = 6495700;
	
	/* 输出 Book1 信息 */
	printBook(Book1);
	printBookPointer(&Book1);
	
	/* 输出 Book2 信息 */
	printBook(Book2);
	printBookPointer(&Book2);
	
	return 0;
}

/* 结构作为函数参数 */
void printBook( struct Books book ) {
	printf( "Book title : %s\n", book.title);
	printf( "Book author : %s\n", book.author);
	printf( "Book subject : %s\n", book.subject);
	printf( "Book book_id : %d\n", book.book_id);
}

/* 指向结构的指针 */
void printBookPointer( struct Books *book ) {
	printf( "Book title : %s\n", book->title);
	printf( "Book author : %s\n", book->author);
	printf( "Book subject : %s\n", book->subject);
	printf( "Book book_id : %d\n", book->book_id);
}
</pre>
						</div>

						<a id="c-share" class="offset"></a>
						<div class="sub-item">
							<h5 class="sub-item">共用体</h5>
							<p>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;string.h>
 
union Data {
   int i;
   float f;
   char  str[20];
};
 
int main() {
   union Data data;        

   data.i = 10;                         
   // data.f = 20.5;					// 同一时刻只能使用共用体中的一个变量, 不能再使用其它变量
   printf("data.i : %d\n", data.i);
   
   data.f = 220.5;
   printf("data.f : %f\n", data.f);
   
   strcpy(data.str, "C Programming");
   printf("data.str : %s\n", data.str);

   return 0;
}
</pre>
						</div>

						<a id="c-bit-area" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">位域</h5>
							<p>带有预定义宽度的变量被称为位域。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7
								的值，您可以定义一个宽度为 3 位的位域，如下：</p>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;string.h>

struct {
	unsigned int age : 3;					// 只有三位，能表示 0-7
} Age;

int main() {
	Age.age = 4;
	printf( "Sizeof( Age ) : %d\n", sizeof(Age) );
	printf( "Age.age : %d\n", Age.age );
	
	Age.age = 7;
	printf( "Age.age : %d\n", Age.age );
	
	Age.age = 8;							// 三位无法表示 8, 编译会有警告，但是能通过，结果是不对的
	printf( "Age.age : %d\n", Age.age );
	
	return 0;
}
</pre>
						</div>

						<a id="c-error" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">错误处理</h5>
							<p>
								C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或
								UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码
								errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在
								<error.h> 头文件中找到各种各样的错误代码。 
							</p>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;errno.h>
#include &lt;string.h>

extern int errno ;

int main () {
    FILE * pf;
    int errnum;
    pf = fopen ("unexist.txt", "rb");
    if (pf == NULL) {
        errnum = errno;
        fprintf(stderr, "错误号: %d\n", errno);
        perror("通过 perror 输出错误");
        fprintf(stderr, "打开文件错误: %s\n", strerror( errnum ));
    } else {
        fclose (pf);
    }
    return 0;
}
</pre>
						</div>

						<a id="c-variable-arg" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">可变参数</h5>
							<p>有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。C
								语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。</p>
							<p>
								请注意，函数 <b>func()</b> 最后一个参数写成省略号，即三个点号（<b>...</b>），省略号之前的那个参数总是
								<b>int</b>，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 <b>stdarg.h</b>
								头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：
							</p>
							<ul>
								<li>
									定义一个函数，最后一个参数为省略号，省略号前面的那个参数总是 <b>int</b>，表示了参数的个数。
								</li>
								<li>
									在函数定义中创建一个 <b>va_list</b> 类型变量，该类型是在 stdarg.h 头文件中定义的。
								</li>
								<li>
									使用 <b>int</b> 参数和 <b>va_start</b> 宏来初始化 <b>va_list</b>
									变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。
								</li>
								<li>
									使用 <b>va_arg</b> 宏和 <b>va_list</b> 变量来访问参数列表中的每个项。
								</li>
								<li>
									使用宏 <b>va_end</b> 来清理赋予 <b>va_list</b> 变量的内存。
								</li>
							</ul>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;stdarg.h>

double average(int num, ...) {
    va_list valist;
    double sum = 0.0;
    int i;

    /* 为 num 个参数初始化 valist */
    va_start(valist, num);

    /* 访问所有赋给 valist 的参数 */
    for (i = 0; i < num; i++) {
       sum += va_arg(valist, int);
    }
    /* 清理为 valist 保留的内存 */
    va_end(valist);

    return sum / num;
}

int main() {
   printf("Average of 2, 3, 4, 5 = %f\n", average(4, 2,3,4,5));
   printf("Average of 5, 10, 15 = %f\n", average(3, 5,10,15));

   return 0;
}
</pre>
						</div>

						<a id="c-memory" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">内存管理</h5>
							<p>
								C 语言为内存的分配和管理提供了几个函数。这些函数可以在
								<stdlib.h> 头文件中找到。 
							</p>
							<table
								class="table table-responsive table-bordered table-condensed">
								<tbody>
									<tr>
										<th>序号</th>
										<th>函数和描述</th>
									</tr>
									<tr>
										<td>1</td>
										<td><b>void *calloc(int num, int size);</b><br>该函数分配一个带有
											<b>num</b> 个元素的数组，每个元素的大小为 <b>size</b> 字节。</td>
									</tr>
									<tr>
										<td>2</td>
										<td><b>void free(void *address); </b><br>该函数释放
											address 所指向的h内存块。</td>
									</tr>
									<tr>
										<td>3</td>
										<td><b>void *malloc(int num); </b><br>该函数分配一个 <b>num</b>
											字节的数组，并把它们进行初始化。</td>
									</tr>
									<tr>
										<td>4</td>
										<td><b>void *realloc(void *address, int newsize); </b><br>该函数重新分配内存，把内存扩展到
											<b>newsize</b>。</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: cpp;">
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>

int main() {
   char name[100];
   char *description;

   strcpy(name, "Zara Ali");

   /* 动态分配内存 */
   description = malloc( 30 * sizeof(char) );
   if( description == NULL )  {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   } else {
      strcpy( description, "Zara ali a DPS student.");
   }
   /* 假设您想要存储更大的描述信息 */
   description = realloc( description, 100 * sizeof(char) );
   if( description == NULL ) {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   } else {
      strcat( description, "She is in class 10th");
   }
   
   printf("Name = %s\n", name );
   printf("Description: %s\n", description );

   /* 使用 free() 函数释放内存 */
   free(description);

   return 0;
}
</pre>
						</div>

						<a id="c-cmd" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">命令行参数</h5>
							<p>执行程序时，可以从命令行传值给 C
								程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。
							</p>
							<p>
								命令行参数是使用 main() 函数参数来处理的，其中，<b>argc</b> 是指传入参数的个数，<b>argv[]</b>
								是一个指针数组，指向传递给程序的每个参数。
							</p>
							<pre class="brush: c;">
#include &lt;stdio.h>

int main( int argc, char *argv[] ) {
   if( argc == 2 ) {
      printf("The argument supplied is %s\n", argv[1]);
   } else if( argc > 2 ) {
      printf("Too many arguments supplied.\n");
   } else {
      printf("One argument expected.\n");
   }
   
   return 0;
}
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-printf" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">格式化输出</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>int printf(char *format, ...);</code>
							函数是最常用的格式化输出函数。
						</p>
						<p>根据参数 format
							字符串来转换并格式化数据，然后将结果输出到标准输出设备（显示器），直到出现字符串结束('\0')为止。</p>
						<p>格式转换为一个百分比符号(%)及其后的格式字符所组成。一般而言，每个%符号在其后都必需有一个参数与之相呼应（只有当%%转换字符出现时会直接输出%字符），而欲输出的数据类型必须与其相对应的转换字符类型相同。</p>
						<pre class="brush: cpp;">
/* 格式转换的一般形式如下：% 和 type 是必要的 */
%(flags)(width)(.prec)type
</pre>
						<p>
							<b>type 的类型:</b>
						</p>
						<ul>
							<li>
								<b>数值</b>
								<ul>
									<li>
										<code>%d / %ld</code>
										-- 整数的参数会被转成有符号的十进制数字(%ld 表示输出 long 整数)
									</li>
									<li>
										<code>%u</code>
										-- 整数的参数会被转成无符号的十进制数字
									</li>
									<li>
										<code>%o</code>
										-- 整数的参数会被转成无符号的八进制数字
									</li>
									<li>
										<code>%x</code>
										-- 整数的参数会被转成无符号的十六进制数字，并以小写 abcdef 表示
									</li>
									<li>
										<code>%X</code>
										-- 整数的参数会被转成无符号的十六进制数字，并以大写 ABCDEF 表示浮点型数
									</li>
									<li>
										<code>%f / %lf</code>
										-- double 型的参数会被转成十制数字，并取到小数点以下六位，四舍五入(%lf 表示输出double浮点数)
									</li>
									<li>
										<code>%e</code>
										-- double 型的参数以指数形式打印，有一个数字会在小数点前，六位数字在小数点后，而在指数部分会以小写的 e 来表示
									</li>
									<li>
										<code>%E</code>
										-- 与 %e 作用相同，唯一区别是指数部分将以大写的E 来表示
									</li>
									<li>
										<code>%g</code>
										-- double 型的参数会自动选择以 %f 或 %e 的格式来打印，其标准是根据打印的数值及所设置的有效位数来决定。
									</li>
									<li>
										<code>%G</code>
										-- 与 %g 作用相同，唯一区别在以指数形态打印时会选择 %E 格式。
									</li>
								</ul>
							</li>
							<li>
								<b>字符及字符串</b>
								<ul>
									<li>
										<code>%c</code>
										-- 整型数的参数会被转成 unsigned char 型打印出
									</li>
									<li>
										<code>%s</code>
										-- 指向字符串的参数会被逐字输出，直到出现 NULL 字符为止
									</li>
									<li>
										<code>%p</code>
										-- 如果是参数是 "void *" 型指针则使用十六进制格式显示
									</li>
								</ul>
							</li>
						</ul>
						<p>
							<b>prec 有几种情况：</b>
						</p>
						<ul>
							<li>正整数的最小位数</li>
							<li>在浮点型数中代表小数位数</li>
							<li>格式代表有效位数的最大值</li>
							<li>在%s 格式代表字符串的最大长度</li>
							<li>若为×符号则代表下个参数值为最大长度</li>
						</ul>

						<p>
							<b>width</b> -- 为参数的最小长度，若此栏并非数值，而是 * 符号，则表示以下一个参数当做参数长度。
						</p>

						<p>
							<b>flags 有下列几种情况:</b>
						</p>
						<ul>
							<li>
								<code>+</code>
								-- 一般在打印负数时，printf()会加印一个负号，整数则不加任何负号，此旗标会使得在打印正数前多一个正号 (+)。
							</li>
							<li>
								<code>#</code>
								-- 此旗标会根据其后转换字符的不同而有不同含义。当在类型为 o 之前 (如 %#o )，则会在打印八进制数值前多印一个
								o。而在类型为 x 之前 (%#x)则会在打印十六进制数前多印 '0x'，在型态为 e、E、f、g 或 G
								之前则会强迫数值打印小数点。在类型为 g 或 G 之前时则同时保留小数点及小数位数末尾的零。
							</li>
							<li>
								<code>0</code>
								-- 当有指定参数时，无数字的参数将补上0。默认是关闭此旗标，所以一般会打印出空白字符。
							</li>
						</ul>

						<pre class="brush: cpp;">
#include &lt;stdio.h>

int main() {
    /* 整数 */
    printf("==原始输出:=======%d======\n", 6);
    printf("==正数加 + 号:======+d======\n", 6);
    printf("==最小宽度控制,左边补空格:======%3d--%3d======\n", 6, 10000);
    printf("==最小宽度控制,右边补空格:======%-3d--%-3d======\n", 6, 10000);
    printf("==最小宽度控制,左边补0:======%03d--%03d======\n", 6, 10000);
    printf("\n");

    /* 浮点数 */
    printf("==原始输出:=======%f======\n", 6.0);
    printf("==精度控制:=======%.2f--%5.2f--%05.2f--%-5.2f======\n", 6.0, 1.2345, 1.2345, 6.0);
    printf("\n");
   
    /* 其它控制 */
    printf ("==整型数的参数会被转成 unsigned char 型:======%c %c \n", 'a', 65);
    printf ("==原始输出:%d 十六进制:%x 八进制:%o 加0x的十六进制:%#x 加0的八进制:%#o \n", 100, 100, 100, 100, 100);
    printf ("==double 型的参数以指数形式打印: %+.0e %E \n", 3.1416, 3.1416);
    printf ("==由参数作参数长度控制打印:======%*d======\n", 5, 10);
    return 0;
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-poiter" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">指针</h3>
					</div>
					<div class="panel-body">
						<p>计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样。</p>
						<p>C语言用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 CPU 使用。</p>
						<p>

							数据和代码都以二进制的形式存储在内存中，计算机无法从格式上区分某块内存到底存储的是数据还是代码。当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，拥有读取和执行权限的内存块就是代码，而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。
						</p>
						CPU 只能通过地址来取得内存中的代码和数据，程序在执行过程中会告知 CPU
						要执行的代码以及要读写的数据的地址。如果程序不小心出错，或者开发者有意为之，在 CPU
						要写入数据时给它一个代码区域的地址，就会发生内存访问错误。这种内存访问错误会被硬件和操作系统拦截，强制程序崩溃，程序员没有挽救的机会。
						</p>
						<p>CPU
							访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。
						</p>
						<p>指针是一个变量，其值为另一个变量的地址，即内存位置的直接地址。下图为 4G 内存地址空间:</p>
						<p width="100%">
							<img src="images/c-pointer.png"
								class="img-responsive center-block">
						</p>
						<h5 class="text-primary">一个指针包括的四方面的内容:</h5>
						<ul>
							<li>
								<b>指针的类型</b> -- 把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。
								<pre class="brush: cpp;">
int		*ptr;				// 指针的类型是 int * 
char	*ptr;				// 指针的类型是 char *
int		**ptr;				// 指针的类型是 int **
int		(*ptr)[3];			// 指针的类型是 int(*)[3]
int		*(*ptr)[4];			// 指针的类型是 int *(*)[4] 
</pre>
							</li>
							<li>
								<b>指针所指向的类型</b> -- 把指针声明语句中的指针名字和名字左边的指针声明符 * 去掉，剩下的就是指针所指向的类型。
								<pre class="brush: cpp;">
int		*ptr;				// 指针所指向的类型是 int
char	*ptr;				// 指针所指向的类型是 char
int		**ptr;				// 指针所指向的类型是 int *
int		(*ptr)[3];			// 指针所指向的类型是 int()[3]
int		*(*ptr)[4];			// 指针所指向的类型是 int *()[4] 
</pre>
							</li>
							<li>
								<b>指针的值</b> -- 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。
								<pre class="brush: cpp;">
#include &lt;stdio.h>

int main() {
	int a = 100;
	printf("%#X\n", &a);		// 输出变量 a 内存地址
	
	char str[20] = "c.biancheng.net";
	printf("%#X\n", str);		// 数组的内存地址为 str[0] 的地址
	printf("%#X\n", &str[0]);	// 和上面的输出是一样的

	return 0;
}
</pre>
							</li>
							<li>
								<b>指针本身所占据的内存区</b> --
								指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。
							</li>
						</ul>

						<h5 class="text-primary">指针的算术运算</h5>
						<p>
							C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：
							<code>++</code>
							、
							<code>--</code>
							、
							<code>+</code>
							、
							<code>-</code>
							。
						</p>
						<pre class="brush: cpp;">

</pre>

						<h5 class="text-primary">指向指针的指针</h5>
						<p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p>
						<p width="100%">
							<img src="images/pointer_to_pointer.jpg"
								class="img-responsive center-block">
						</p>
						<pre class="brush: cpp;">

</pre>

						<h5 class="text-primary">指针数组</h5>
						<pre class="brush: cpp;">

</pre>

						<h5 class="text-primary">指针与函数</h5>
						<pre class="brush: cpp;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-file" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">文件读写</h3>
					</div>
					<div class="panel-body">
						<p>一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C
							语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。</p>
						<p>
							<b>打开文件</b>
						</p>
						<p>使用 fopen() 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型
							FILE 包含了所有用来控制流的必要的信息</p>
						<pre class="brush: cpp;">FILE *fopen(const char *filename, const char *mode);</pre>
						<table class="table table-bordered table-responsive table-striped">
							<tbody>
								<tr>
									<th style="width: 8%">模式</th>
									<th>描述</th>
								</tr>
								<tr>
									<td>r</td>
									<td>打开一个已有的文本文件，允许读取文件。</td>
								</tr>
								<tr>
									<td>w</td>
									<td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。</td>
								</tr>
								<tr>
									<td>a</td>
									<td>打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td>
								</tr>
								<tr>
									<td>r+</td>
									<td>打开一个文本文件，允许读写文件。</td>
								</tr>
								<tr>
									<td>w+</td>
									<td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
								</tr>
								<tr>
									<td>a+</td>
									<td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
								</tr>
							</tbody>
						</table>
						<p class="text-warning">
							如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：<br>
							<code> "rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b",
								"ab+", "a+b"</code>
						</p>
						<p>
							<b>关闭文件</b>
						</p>
						<p>如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回
							EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h
							中的常量。</p>
						<pre class="brush: cpp;">int fclose(FILE *fp);</pre>

						<p>
							<b>写入文件</b>
						</p>
						<p>函数 fputc() 把参数 c 的字符值写入到 fp
							所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。</p>
						<p>函数 fputs() 把字符串 s 写入到 fp
							所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。</p>
						<pre class="brush: cpp;">
int fputc(int c, FILE *fp);

int fputs(const char *s, FILE *fp);
</pre>

						<p>
							<b>读取文件</b>
						</p>
						<p>fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。</p>
						<p>函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区
							buf，并在最后追加一个 null 字符来终止字符串。</p>
						<pre class="brush: cpp;">
int fgetc(FILE * fp);

char *fgets( char *buf, int n, FILE *fp );
</pre>

						<p>
							<b>二进制 I/O 函数</b>
						</p>
						<p>这两个函数都是用于存储块的读写 - 通常是数组或结构体。</p>
						<pre class="brush: cpp;">
size_t fread(void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file);

size_t fwrite(const void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file);
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-string" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>string.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>string.h</code>
							头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。
						</p>
						<p>
							<b>库函数</b>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-memchr.html">void
											*memchr(const void *str, int c, size_t n)</a><br>在参数 <i>str</i>
										所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-function-memcmp.html">int memcmp(const
											void *str1, const void *str2, size_t n)</a><br>把 <i>str1</i>
										和 <i>str2</i> 的前 n 个字节进行比较。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-function-memcpy.html">void *memcpy(void
											*dest, const void *src, size_t n)</a><br>从 src 复制 n 个字符到 <i>dest</i>。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><a href="c-function-memmove.html">void
											*memmove(void *dest, const void *src, size_t n)</a><br>另一个用于从
										<i>str2</i> 复制 n 个字符到 <i>str1</i> 的函数。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><a href="c-function-memset.html">void *memset(void
											*str, int c, size_t n)</a><br>复制字符 c（一个无符号字符）到参数 <i>str</i>
										所指向的字符串的前 n 个字符。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><a href="c-function-strcat.html">char *strcat(char
											*dest, const char *src)</a><br>把 <i>src</i> 所指向的字符串追加到 <i>dest</i>
										所指向的字符串的结尾。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><a href="c-function-strncat.html">char
											*strncat(char *dest, const char *src, size_t n)</a><br>把 <i>src</i>
										所指向的字符串追加到 <i>dest</i> 所指向的字符串的结尾，直到 n 字符长度为止。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><a href="c-function-strchr.html">char
											*strchr(const char *str, int c)</a><br>在参数 <i>str</i>
										所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><a href="c-function-strcmp.html">int strcmp(const
											char *str1, const char *str2)</a><br>把 <i>str1</i> 所指向的字符串和
										<i>str2</i> 所指向的字符串进行比较。</td>
								</tr>
								<tr>
									<td>10</td>
									<td><a href="c-function-strncmp.html">int
											strncmp(const char *str1, const char *str2, size_t n)</a><br>把
										<i>str1</i> 和 <i>str2</i> 进行比较，最多比较前 n 个字节。</td>
								</tr>
								<tr>
									<td>11</td>
									<td><a href="c-function-strcoll.html">int
											strcoll(const char *str1, const char *str2)</a><br>把 <i>str1</i>
										和 <i>str2</i> 进行比较，结果取决于 LC_COLLATE 的位置设置。</td>
								</tr>
								<tr>
									<td>12</td>
									<td><a href="c-function-strcpy.html">char *strcpy(char
											*dest, const char *src)</a><br>把 <i>src</i> 所指向的字符串复制到 <i>dest</i>。</td>
								</tr>
								<tr>
									<td>13</td>
									<td><a href="c-function-strncpy.html">char
											*strncpy(char *dest, const char *src, size_t n)</a><br>把 <i>src</i>
										所指向的字符串复制到 <i>dest</i>，最多复制 n 个字符。</td>
								</tr>
								<tr>
									<td>14</td>
									<td><a href="c-function-strcspn.html">size_t
											strcspn(const char *str1, const char *str2)</a><br>检索字符串
										str1 开头连续有几个字符都不含字符串 str2 中的字符。</td>
								</tr>
								<tr>
									<td>15</td>
									<td><a href="c-function-strerror.html">char
											*strerror(int errnum)</a><br>从内部数组中搜索错误号
										errnum，并返回一个指向错误消息字符串的指针。</td>
								</tr>
								<tr>
									<td>16</td>
									<td><a href="c-function-strlen.html">size_t
											strlen(const char *str)</a><br>计算字符串 str
										的长度，直到空结束字符，但不包括空结束字符。</td>
								</tr>
								<tr>
									<td>17</td>
									<td><a href="c-function-strpbrk.html">char
											*strpbrk(const char *str1, const char *str2)</a><br>检索字符串 <i>str1</i>
										中第一个匹配字符串 <i>str2</i> 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1
										中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</td>
								</tr>
								<tr>
									<td>18</td>
									<td><a href="c-function-strrchr.html">char
											*strrchr(const char *str, int c)</a><br>在参数 <i>str</i>
										所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</td>
								</tr>
								<tr>
									<td>19</td>
									<td><a href="c-function-strspn.html">size_t
											strspn(const char *str1, const char *str2)</a><br>检索字符串 <i>str1</i>
										中第一个不在字符串 <i>str2</i> 中出现的字符下标。</td>
								</tr>
								<tr>
									<td>20</td>
									<td><a href="c-function-strstr.html">char
											*strstr(const char *haystack, const char *needle)</a><br>在字符串
										<i>haystack</i> 中查找第一次出现字符串 <i>needle</i>（不包含空结束字符）的位置。</td>
								</tr>
								<tr>
									<td>21</td>
									<td><a href="c-function-strtok.html">char *strtok(char
											*str, const char *delim)</a><br>分解字符串 <i>str</i> 为一组字符串，<i>delim</i>
										为分隔符。</td>
								</tr>
								<tr>
									<td>22</td>
									<td><a href="c-function-strxfrm.html">size_t
											strxfrm(char *dest, const char *src, size_t n)</a><br>根据程序当前的区域选项中的
										LC_COLLATE 来转换字符串 <b>src</b> 的前 <b>n</b> 个字符，并把它们放置在字符串 <b>dest</b>
										中。</td>
								</tr>
							</tbody>
						</table>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-stdio" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>stdio.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>stdio.h</code>
							头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出。
						</p>
						<p>
							<b>库函数</b>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-fclose.html">int fclose(FILE
											*stream)</a><br>关闭流 stream。刷新所有的缓冲区。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-function-clearerr.html">void
											clearerr(FILE *stream)</a><br>清除给定流 stream 的文件结束和错误标识符。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-function-feof.html">int feof(FILE
											*stream)</a><br>测试给定流 stream 的文件结束标识符。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><a href="c-function-ferror.html">int ferror(FILE
											*stream)</a><br>测试给定流 stream 的错误标识符。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><a href="c-function-fflush.html">int fflush(FILE
											*stream)</a><br>刷新流 stream 的输出缓冲区。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><a href="c-function-fgetpos.html">int fgetpos(FILE
											*stream, fpos_t *pos)</a><br>获取流 stream 的当前文件位置，并把它写入到 pos。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><a href="c-function-fopen.html">FILE *fopen(const
											char *filename, const char *mode)</a><br>使用给定的模式 mode 打开
										filename 所指向的文件。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><a href="c-function-fread.html">size_t fread(void
											*ptr, size_t size, size_t nmemb, FILE *stream)</a><br>从给定流
										stream 读取数据到 ptr 所指向的数组中。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><a href="c-function-freopen.html">FILE
											*freopen(const char *filename, const char *mode, FILE
											*stream)</a><br>把一个新的文件名 filename 与给定的打开的流 stream
										关联，同时关闭流中的旧文件。</td>
								</tr>
								<tr>
									<td>10</td>
									<td><a href="c-function-fseek.html">int fseek(FILE
											*stream, long int offset, int whence)</a><br>设置流 stream
										的文件位置为给定的偏移 offset，参数 <i>offset</i> 意味着从给定的 <i>whence</i>
										位置查找的字节数。</td>
								</tr>
								<tr>
									<td>11</td>
									<td><a href="c-function-fsetpos.html">int fsetpos(FILE
											*stream, const fpos_t *pos)</a><br>设置给定流 stream
										的文件位置为给定的位置。参数 <i>pos</i> 是由函数 fgetpos 给定的位置。</td>
								</tr>
								<tr>
									<td>12</td>
									<td><a href="c-function-ftell.html">long int
											ftell(FILE *stream)</a><br>返回给定流 stream 的当前文件位置。</td>
								</tr>
								<tr>
									<td>13</td>
									<td><a href="c-function-fwrite.html">size_t
											fwrite(const void *ptr, size_t size, size_t nmemb, FILE
											*stream)</a><br>把 ptr 所指向的数组中的数据写入到给定流 stream 中。</td>
								</tr>
								<tr>
									<td>14</td>
									<td><a href="c-function-remove.html">int remove(const
											char *filename)</a><br>删除给定的文件名 filename，以便它不再被访问。</td>
								</tr>
								<tr>
									<td>15</td>
									<td><a href="c-function-rename.html">int rename(const
											char *old_filename, const char *new_filename)</a><br>把
										old_filename 所指向的文件名改为 new_filename。</td>
								</tr>
								<tr>
									<td>16</td>
									<td><a href="c-function-rewind.html">void rewind(FILE
											*stream)</a><br>设置文件位置为给定流 stream 的文件的开头。</td>
								</tr>
								<tr>
									<td>17</td>
									<td><a href="c-function-setbuf.html">void setbuf(FILE
											*stream, char *buffer)</a><br>定义流 stream 应如何缓冲。</td>
								</tr>
								<tr>
									<td>18</td>
									<td><a href="c-function-setvbuf.html">int setvbuf(FILE
											*stream, char *buffer, int mode, size_t size)</a><br>另一个定义流
										stream 应如何缓冲的函数。</td>
								</tr>
								<tr>
									<td>19</td>
									<td><a href="c-function-tmpfile.html">FILE
											*tmpfile(void)</a><br>以二进制更新模式(wb+)创建临时文件。</td>
								</tr>
								<tr>
									<td>20</td>
									<td><a href="c-function-tmpnam.html">char *tmpnam(char
											*str)</a><br>生成并返回一个有效的临时文件名，该文件名之前是不存在的。</td>
								</tr>
								<tr>
									<td>21</td>
									<td><a href="c-function-fprintf.html">int fprintf(FILE
											*stream, const char *format, ...)</a><br>发送格式化输出到流 stream 中。</td>
								</tr>
								<tr>
									<td>22</td>
									<td><a href="c-function-printf.html">int printf(const
											char *format, ...)</a><br>发送格式化输出到标准输出 stdout。</td>
								</tr>
								<tr>
									<td>23</td>
									<td><a href="c-function-sprintf.html">int sprintf(char
											*str, const char *format, ...)</a><br>发送格式化输出到字符串。</td>
								</tr>
								<tr>
									<td>24</td>
									<td><a href="c-function-vfprintf.html">int
											vfprintf(FILE *stream, const char *format, va_list arg)</a><br>使用参数列表发送格式化输出到流
										stream 中。</td>
								</tr>
								<tr>
									<td>25</td>
									<td><a href="c-function-vprintf.html">int
											vprintf(const char *format, va_list arg)</a><br>使用参数列表发送格式化输出到标准输出
										stdout。</td>
								</tr>
								<tr>
									<td>26</td>
									<td><a href="c-function-vsprintf.html">int
											vsprintf(char *str, const char *format, va_list arg)</a><br>使用参数列表发送格式化输出到字符串。</td>
								</tr>
								<tr>
									<td>27</td>
									<td><a href="c-function-fscanf.html">int fscanf(FILE
											*stream, const char *format, ...)</a><br>从流 stream 读取格式化输入。</td>
								</tr>
								<tr>
									<td>28</td>
									<td><a href="c-function-scanf.html">int scanf(const
											char *format, ...)</a><br>从标准输入 stdin 读取格式化输入。</td>
								</tr>
								<tr>
									<td>29</td>
									<td><a href="c-function-sscanf.html">int sscanf(const
											char *str, const char *format, ...)</a><br>从字符串读取格式化输入。</td>
								</tr>
								<tr>
									<td>30</td>
									<td><a href="c-function-fgetc.html">int fgetc(FILE
											*stream)</a><br>从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</td>
								</tr>
								<tr>
									<td>31</td>
									<td><a href="c-function-fgets.html">char *fgets(char
											*str, int n, FILE *stream)</a><br>从指定的流 stream 读取一行，并把它存储在
										str 所指向的字符串内。当读取 <b>(n-1)</b>
										个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</td>
								</tr>
								<tr>
									<td>32</td>
									<td><a href="c-function-fputc.html">int fputc(int
											char, FILE *stream)</a><br>把参数 char 指定的字符（一个无符号字符）写入到指定的流
										stream 中，并把位置标识符往前移动。</td>
								</tr>
								<tr>
									<td>33</td>
									<td><a href="c-function-fputs.html">int fputs(const
											char *str, FILE *stream)</a><br>把字符串写入到指定的流 stream
										中，但不包括空字符。</td>
								</tr>
								<tr>
									<td>34</td>
									<td><a href="c-function-getc.html">int getc(FILE
											*stream)</a><br>从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</td>
								</tr>
								<tr>
									<td>35</td>
									<td><a href="c-function-getchar.html">int
											getchar(void)</a><br>从标准输入 stdin 获取一个字符（一个无符号字符）。</td>
								</tr>
								<tr>
									<td>36</td>
									<td><a href="c-function-gets.html">char *gets(char
											*str)</a><br>从标准输入 stdin 读取一行，并把它存储在 str
										所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</td>
								</tr>
								<tr>
									<td>37</td>
									<td><a href="c-function-putc.html">int putc(int char,
											FILE *stream)</a><br>把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream
										中，并把位置标识符往前移动。</td>
								</tr>
								<tr>
									<td>38</td>
									<td><a href="c-function-putchar.html">int putchar(int
											char)</a><br>把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。</td>
								</tr>
								<tr>
									<td>39</td>
									<td><a href="c-function-puts.html">int puts(const char
											*str)</a><br>把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。</td>
								</tr>
								<tr>
									<td>40</td>
									<td><a href="c-function-ungetc.html">int ungetc(int
											char, FILE *stream)</a><br>把字符 char（一个无符号字符）推入到指定的流 stream
										中，以便它是下一个被读取到的字符。</td>
								</tr>
								<tr>
									<td>41</td>
									<td><a href="c-function-perror.html">void perror(const
											char *str)</a><br>把一个描述性错误消息输出到标准错误 stderr。首先输出字符串
										str，后跟一个冒号，然后是一个空格。</td>
								</tr>
							</tbody>

						</table>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-stdlib" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>stdlib.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>stdlib.h</code>
							头文件定义了四个变量类型、一些宏和各种通用工具函数。
						</p>
						<p>
							<b>库函数</b>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>函数 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-function-atof.html">double atof(const
											char *str)</a><br>把参数 <i>str</i> 所指向的字符串转换为一个浮点数（类型为 double
										型）。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-function-atoi.html">int atoi(const char
											*str)</a><br>把参数 <i>str</i> 所指向的字符串转换为一个整数（类型为 int 型）。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-function-atol.html">long int atol(const
											char *str)</a><br>把参数 <i>str</i> 所指向的字符串转换为一个长整数（类型为 long
										int 型）。</td>
								</tr>
								<tr>
									<td>4</td>
									<td><a href="c-function-strtod.html">double
											strtod(const char *str, char **endptr)</a><br>把参数 <i>str</i>
										所指向的字符串转换为一个浮点数（类型为 double 型）。</td>
								</tr>
								<tr>
									<td>5</td>
									<td><a href="c-function-strtol.html">long int
											strtol(const char *str, char **endptr, int base)</a><br>把参数
										<i>str</i> 所指向的字符串转换为一个长整数（类型为 long int 型）。</td>
								</tr>
								<tr>
									<td>6</td>
									<td><a href="c-function-strtoul.html">unsigned long
											int strtoul(const char *str, char **endptr, int base)</a><br>把参数
										<i>str</i> 所指向的字符串转换为一个无符号长整数（类型为 unsigned long int 型）。</td>
								</tr>
								<tr>
									<td>7</td>
									<td><a href="c-function-calloc.html">void
											*calloc(size_t nitems, size_t size)</a><br>分配所需的内存空间，并返回一个指向它的指针。</td>
								</tr>
								<tr>
									<td>8</td>
									<td><a href="c-function-free.html">void free(void
											*ptr)</a><br>释放之前调用 <i>calloc、malloc</i> 或 <i>realloc</i>
										所分配的内存空间。</td>
								</tr>
								<tr>
									<td>9</td>
									<td><a href="c-function-malloc.html">void
											*malloc(size_t size)</a><br>分配所需的内存空间，并返回一个指向它的指针。</td>
								</tr>
								<tr>
									<td>10</td>
									<td><a href="c-function-realloc.html">void
											*realloc(void *ptr, size_t size)</a><br>尝试重新调整之前调用 <i>malloc</i>
										或 <i>calloc</i> 所分配的 ptr 所指向的内存块的大小。</td>
								</tr>
								<tr>
									<td>11</td>
									<td><a href="c-function-abort.html">void abort(void)</a><br>使一个异常程序终止。</td>
								</tr>
								<tr>
									<td>12</td>
									<td><a href="c-function-atexit.html">int atexit(void
											(*func)(void))</a><br>当程序正常终止时，调用指定的函数 <b>func</b>。</td>
								</tr>
								<tr>
									<td>13</td>
									<td><a href="c-function-exit.html">void exit(int
											status)</a><br>使程序正常终止。</td>
								</tr>
								<tr>
									<td>14</td>
									<td><a href="c-function-getenv.html">char
											*getenv(const char *name)</a><br>搜索 name
										所指向的环境字符串，并返回相关的值给字符串。</td>
								</tr>
								<tr>
									<td>15</td>
									<td><a href="c-function-system.html">int system(const
											char *string)</a><br>由 string 指定的命令传给要被命令处理器执行的主机环境。</td>
								</tr>
								<tr>
									<td>16</td>
									<td><a href="c-function-bsearch.html">void
											*bsearch(const void *key, const void *base, size_t nitems,
											size_t size, int (*compar)(const void *, const void *))</a><br>执行二分查找。</td>
								</tr>
								<tr>
									<td>17</td>
									<td><a href="c-function-qsort.html">void qsort(void
											*base, size_t nitems, size_t size, int (*compar)(const void
											*, const void*))</a><br>数组排序。</td>
								</tr>
								<tr>
									<td>18</td>
									<td><a href="c-function-abs.html">int abs(int x)</a><br>返回
										x 的绝对值。</td>
								</tr>
								<tr>
									<td>19</td>
									<td><a href="c-function-div.html">div_t div(int numer,
											int denom)</a><br>分子除以分母。</td>
								</tr>
								<tr>
									<td>20</td>
									<td><a href="c-function-labs.html">long int labs(long
											int x)</a><br>返回 x 的绝对值。</td>
								</tr>
								<tr>
									<td>21</td>
									<td><a href="c-function-ldiv.html">ldiv_t ldiv(long
											int numer, long int denom)</a><br>分子除以分母。</td>
								</tr>
								<tr>
									<td>22</td>
									<td><a href="c-function-rand.html">int rand(void)</a><br>返回一个范围在
										0 到 <i>RAND_MAX</i> 之间的伪随机数。</td>
								</tr>
								<tr>
									<td>23</td>
									<td><a href="c-function-srand.html">void
											srand(unsigned int seed)</a><br>该函数播种由函数 <b>rand</b>
										使用的随机数发生器。</td>
								</tr>
								<tr>
									<td>24</td>
									<td><a href="c-function-mblen.html">int mblen(const
											char *str, size_t n)</a><br>返回参数 <i>str</i> 所指向的多字节字符的长度。</td>
								</tr>
								<tr>
									<td>25</td>
									<td><a href="c-function-mbstowcs.html">size_t
											mbstowcs(schar_t *pwcs, const char *str, size_t n)</a><br>把参数
										<i>str</i> 所指向的多字节字符的字符串转换为参数 <i>pwcs</i> 所指向的数组。</td>
								</tr>
								<tr>
									<td>26</td>
									<td><a href="c-function-mbtowc.html">int
											mbtowc(whcar_t *pwc, const char *str, size_t n)</a><br>检查参数
										<i>str</i> 所指向的多字节字符。</td>
								</tr>
								<tr>
									<td>27</td>
									<td><a href="c-function-wcstombs.html">size_t
											wcstombs(char *str, const wchar_t *pwcs, size_t n)</a><br>把数组
										<i>pwcs</i> 中存储的编码转换为多字节字符，并把它们存储在字符串 <i>str</i> 中。</td>
								</tr>
								<tr>
									<td>28</td>
									<td><a href="c-function-wctomb.html">int wctomb(char
											*str, wchar_t wchar)</a><br>检查对应于参数 <i>wchar</i>
										所给出的多字节字符的编码。</td>
								</tr>
							</tbody>
						</table>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-error" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>error.h</code>
						</h3>
					</div>
					<div class="panel-body">
						<p>
							C 标准库的 <b>errno.h</b> 头文件定义了整数变量 <b>errno</b>，它是通过系统调用设置的，在错误事件中的某些库函数表明了什么发生了错误。该宏扩展为类型为
							int 的可更改的左值，因此它可以被一个程序读取和修改。
						</p>
						<p>
							在程序启动时，<b>errno</b> 设置为零，C
							标准库中的特定函数修改它的值为一些非零值以表示某些类型的错误。您也可以在适当的时候修改它的值或重置为零。
						</p>
						<p>
							<b>errno.h</b> 头文件也顶了以一系列表示不同错误代码的宏，这些宏应扩展为类型为 <b>int</b>
							的整数常量表达式。
						</p>
						<table
							class="table table-bordered table-responsive table-striped runoob"
							data-base="http://www.runoob.com/cprogramming/">
							<tbody>
								<tr>
									<th style="width: 8%">序号</th>
									<th>宏 &amp; 描述</th>
								</tr>
								<tr>
									<td>1</td>
									<td><a href="c-macro-errno.html">extern int errno</a><br>这是通过系统调用设置的宏，在错误事件中的某些库函数表明了什么发生了错误。</td>
								</tr>
								<tr>
									<td>2</td>
									<td><a href="c-macro-edom.html">EDOM Domain Error</a><br>这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno
										被设置为 EDOM。</td>
								</tr>
								<tr>
									<td>3</td>
									<td><a href="c-macro-erange.html">ERANGE Range Error</a><br>这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno
										被设置为 ERANGE。</td>
								</tr>
							</tbody>
						</table>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-math" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>math.h</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-time" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>time.h</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-assert" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>assert.h</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-ctype" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>ctype.h</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-float" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>float.h</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-limits" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>limits.h</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-locale" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>locale.h</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-setjmp" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>setjmp.h</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-signal" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>signal.h</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-stdarg" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>stdarg.h</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a id="c-lib-stddef" class="offset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>stddef.h</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushCpp.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushBash.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>



</body>
</html>
