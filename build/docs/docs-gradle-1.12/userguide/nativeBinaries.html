<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>第54章. 构建原生二进制文件 - Chapter&nbsp;54.&nbsp;Building native binaries</title>
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css">
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css">
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css">
  <meta content="DocBook XSL Stylesheets V1.75.2" name="generator">
  <link rel="home" href="userguide.html" title="Gradle 用户指南">
  <link rel="up" href="userguide.html" title="Gradle 用户指南">
  <link rel="prev" href="signing_plugin.html" title="第五十三章. 签名插件">
  <link rel="next" href="build_lifecycle.html" title="第55章. 构建的生命周期">
 </head>
 <body>
  <div class="navheader">
   <div>
    <div class="navbar">
     <a xmlns:xslthl="http://xslthl.sf.net" href="signing_plugin.html" title="第五十三章. 签名插件">上一章</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南">目录</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="build_lifecycle.html" title="第55章. 构建的生命周期">下一章</a>
    </div>
   </div>
  </div>
  <div class="chapter">
   <div class="titlepage">
    <div>
     <div>
      <h1 xmlns:xslthl="http://xslthl.sf.net"><a name="nativeBinaries"></a>第54章. 构建原生二进制文件</h1>
      <h3 xmlns:xslthl="http://xslthl.sf.net"><a name="nativeBinaries"></a>Chapter&nbsp;54.&nbsp;Building native binaries</h3>
     </div>
    </div>
   </div>
   <div class="note">
    <p> Gradle 对构建原生二进制文件的支持目前还是<a class="link" href="feature_lifecycle.html">孵化</a>阶段。请务必注意，在以后的 Gradle 版本中，相关的 DSL 和其他配置可能会有所改变。 <br>The Gradle support for building native binaries is currently <a class="link" href="feature_lifecycle.html">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.</p>
   </div>
   <p> 不同的原生二进制插件添加了对从C++，C，Objective-C，Objective-C++以及汇编源文件构建原生软件组件的支持。虽然对于这种软件开发的空间，已经有许多优秀的构建工具存在，但是Gradle 向开发人员提供的是它的强大特征和灵活性，以及在依赖管理实践上，在JVM开发空间上更为传统的发现。 <br>The various native binary plugins add support for building native software components from C++, C, Objective-C, Objective-C++ and Assembler sources. While many excellent build tools exist for this space of software development, Gradle offers developers it's trademark power and flexibility together with the dependency management practices more traditionally found in the JVM development space.</p>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="native-binaries:tool-chain-support"></a>54.1. 工具链支持</h2>
       <h4 class="title"><a name="native-binaries:tool-chain-support"></a>54.1.&nbsp;Tool chain support</h4>
      </div>
     </div>
    </div>
    <p> Gradle 提供了使用不同的工具链执行相同的构建的能力。你可以通过更改操作系统的PATH让其包含所需的工具链编译器，来控制使用哪个工具链。或者，你可以直接配置工具链，就如下面的“原生二进制变种”中描述的。 <br>Gradle offers the ability to execute the same build using different tool chains. You can control which tool chain will be used to build by changing the operating system PATH to include the desired tool chain compiler. Alternatively, you can configure the tool chains directly, as described in the `Native Binary Variants` section, below.</p>
    <p> 支持以下的工具链： <br>The following tool chains are supported:</p>
    <div xmlns:xslthl="http://xslthl.sf.net" class="table">
     <div class="table-contents">
      <table id="N157FA"> 
       <tbody>
        <tr>
         <td>操作系统<br>Operating System</td>
         <td>工具链<br>Tool Chain</td>
         <td>备注<br>Notes</td>
        </tr> 
        <tr> 
         <td>Linux</td>
         <td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></td> 
         <td></td> 
        </tr>
        <tr> 
         <td>Linux</td>
         <td><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a></td>
         <td></td> 
        </tr>
        <tr> 
         <td>Mac OS X</td>
         <td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></td>
         <td>使用 XCode 中的 GCC。<br>Using GCC distributed with XCode.</td> 
        </tr>
        <tr> 
         <td>Mac OS X</td>
         <td><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a></td>
         <td>使用 XCode 中的 Clang。<br>Using Clang distributed with XCode.</td> 
        </tr>
        <tr> 
         <td>Windows</td>
         <td><a class="ulink" href="http://www.microsoft.com/visualstudio/en-us" target="_top">Visual C++</a></td>
         <td>Windows XP及以上，Visual C++ 2010 及以上版本。<br>Windows XP and later, Visual C++ 2010 and later.</td> 
        </tr>
        <tr> 
         <td>Windows</td>
         <td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></td>
         <td>Windows XP及以上，使用Cygwin的GCC。<br>Windows XP and later, using GCC distributed with Cygwin.</td> 
        </tr>
        <tr> 
         <td>Windows</td>
         <td><a class="ulink" href="http://www.mingw.org/" target="_top">MinGW</a></td>
         <td>Windows XP 及以上。<br>Windows XP and later.</td> 
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="N15851"></a>54.2. 组件模型</h2>
       <h4 class="title"><a name="N15851"></a>54.2.&nbsp;Component model</h4>
      </div>
     </div>
    </div>
    <p> 一个原生二进制project定义了一组<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a>和<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a>组件，每一个的 Gradle 都映射大量的<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a>输出。对于每个定义的<code class="literal">executable</code>或<code class="literal">library</code>，Gradle 添加了具有相同名称的<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/javadoc/org/gradle/language/base/FunctionalSourceSet.html" target="_top"><code class="classname">FunctionalSourceSet</code> </a> 。这些功能源码集将为project所支持的每一种语言包含指定语言的源码集。 <br>A native binary project defines a set of <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> and <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a> components, each of which Gradle maps to a number of <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> outputs. For each <code class="literal">executable</code> or <code class="literal">library</code> defined, Gradle adds a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/javadoc/org/gradle/language/base/FunctionalSourceSet.html" target="_top"><code class="classname">FunctionalSourceSet</code></a> with the same name. Each of these functional source sets will contain a language-specific source set for each of the languages supported by the project.</p>
    <p> 为构建一个静态或共享的原生库二进制文件，一个<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a>组件将添加到<code class="literal">libraries</code>容器中。每个<code class="literal">library</code>组件可以产生至少一个<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.SharedLibraryBinary.html" target="_top"><code class="classname">SharedLibraryBinary</code></a>和至少一个<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.StaticLibraryBinary.html" target="_top"><code class="classname">StaticLibraryBinary</code></a>。 <br>To build either a static or shared native library binary, a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a> component is added to the <code class="literal">libraries</code> container. Each <code class="literal">library</code> component can produce at least one <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.SharedLibraryBinary.html" target="_top"><code class="classname">SharedLibraryBinary</code></a> and at least one <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.StaticLibraryBinary.html" target="_top"><code class="classname">StaticLibraryBinary</code></a>.</p>
    <div class="example">
     <a name="cppLibraries"></a>
     <p class="title"><b>示例 54.1. 定义一个库组件 - Example&nbsp;54.1.&nbsp;Defining a library component</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">libraries {
    hello {}
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p> 为构建一个可执行的二进制，<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a>组件添加到<code class="literal">executables</code>容器中，并与源码集相关联。 <br>To build an executable binary, an <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> component is added to the <code class="literal">executables</code> container and associated with a set of sources.</p>
    <div class="example">
     <a name="cppExecutables"></a>
     <p class="title"><b>示例 54.2. 定义可执行组件 - Example&nbsp;54.2.&nbsp;Defining executable components</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">executables {
    main {}
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p> 在许多情况下，一个组件可以产生超过一个的原生二进制文件。基于构建所使用的工具链，提供的编译器/链接器标志，提供的依赖或其他源文件，这些二进制文件可能会发生变化。组件所产生的每个原生二进制称为<code class="literal">variant</code>。下面将详细讨论二进制 variant。 <br>In many cases, more than one native binary can be produced for a component. These binaries may vary based on the tool chain used to build, the compiler/linker flags supplied, the dependencies provided, or additional source files provided. Each native binary produced for a component is referred to as <code class="literal">variant</code>. Binary variants are discussed in detail below.</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="N158AA"></a>54.3. 任务</h2>
       <h4 class="title"><a name="N158AA"></a>54.3.&nbsp;Tasks</h4>
      </div>
     </div>
    </div>
    <p> 针对由构建所产生的每一个 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a>，我们构造了一个<em class="firstterm">生命周期任务</em>用于创建二进制，以及一系统的其他做实际工作，如编译，链接或者是装配二进制文件的任务。 <br>For each <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> that can be produced by a build, a single <em class="firstterm">lifecycle task</em> is constructed that can be used to create that binary, together with a set of other tasks that do the actual work of compiling, linking or assembling the binary.</p>
    <div xmlns:xslthl="http://xslthl.sf.net" class="table">
     <div class="table-contents">
      <table id="N158B7"> 
       <tbody>
        <tr>
         <td>组件类型<br>Component Type</td>
         <td>原生二进制文件类型<br>Native Binary Type</td>
         <td>生命周期任务<br>Lifecycle task</td>
         <td>创建二进制文件的位置<br>Location of created binary</td>
        </tr> 
        <tr> 
         <td><a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a></td>
         <td><a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.ExecutableBinary.html" target="_top"><code class="classname">ExecutableBinary</code></a></td>
         <td><code class="literal"><em class="replaceable"><code>$component.name</code></em>Executable</code></td>
         <td><code class="filename"><em class="replaceable"><code>$buildDir</code></em>/binaries/<em class="replaceable"><code>$binary.name</code></em>/<em class="replaceable"><code>$component.name</code></em></code></td> 
        </tr>
        <tr> 
         <td><a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a></td>
         <td><a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.SharedLibraryBinary.html" target="_top"><code class="classname">SharedLibraryBinary</code></a></td>
         <td><code class="literal"><em class="replaceable"><code>$component.name</code></em>SharedLibrary</code></td>
         <td><code class="filename"><em class="replaceable"><code>$buildDir</code></em>/binaries/<em class="replaceable"><code>$binary.name</code></em>/lib<em class="replaceable"><code>$component.name</code></em>.so</code></td> 
        </tr>
        <tr> 
         <td><a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a></td>
         <td><a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.StaticLibraryBinary.html" target="_top"><code class="classname">StaticLibraryBinary</code></a></td>
         <td><code class="literal"><em class="replaceable"><code>$component.name</code></em>StaticLibrary</code></td>
         <td><code class="filename"><em class="replaceable"><code>$buildDir</code></em>/binaries/<em class="replaceable"><code>$binary.name</code></em>/<em class="replaceable"><code>$component.name</code></em>.a</code></td> 
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N1591A"></a>54.3.1. 使用共享库</h3>
        <h5 class="title"><a name="N1591A"></a>54.3.1.&nbsp;Working with shared libraries</h5>
       </div>
      </div>
     </div>
     <p> 对于每个产生的可执行二进制文件， <code class="literal">cpp</code>插件提供了<code class="literal">install${binary.name}</code>任务，这个任务可以创建该可执行文件及它需要的共享库的开发安装。它允许你运行可执行文件，而无需在其最终的位置安装共享库。 <br>For each executable binary produced, the <code class="literal">cpp</code> plugin provides an <code class="literal">install${binary.name}</code> task, which creates a development install of the executable, along with the shared libraries it requires. This allows you to run the executable without needing to install the shared libraries in their final locations.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="native_binaries:languages"></a>544.核心语言支持: C、C++、汇编，Objective-C和Objective-C++ </h2>
       <h4 class="title"><a name="native_binaries:languages"></a>54.4.&nbsp;Core language support: C, C++, Assembler, Objective-C and Objective-C++</h4>
      </div>
     </div>
    </div>
    <p> 目前，Gradle 支持从C++，C，Assembler，Objective-C 和 Objective-C++源码的任意组合中构建原生二进制文件。一个原生二进制project 将包含一个或多个叫做<code class="literal">FunctionalSourceSet</code>的实例（如"main"，"test"等），其中每一个都可以包含含有C++，C，Assembler，Objective-C或Objective-C++源代码的<code class="literal">LanguageSourceSet</code>s。 <br>Presently, Gradle supports building native binaries from any combination of C++, C, Assembler, Objective-C and Objective-C++ sources. A native binary project will contain one or more named <code class="literal">FunctionalSourceSet</code> instances (eg 'main', 'test', etc), each of which can contain <code class="literal">LanguageSourceSet</code>s containing C++, C, Assembler, Objective-C or Objective-C++ source files.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15931"></a>54.4.1.&nbsp;C++ 源代码</h3>
        <h5 class="title"><a name="N15931"></a>54.4.1.&nbsp;C++ sources</h5>
       </div>
      </div>
     </div>
     <p> <code class="literal">'cpp'</code> 插件提供了C++ 语言的支持。 <br>C++ language support is provided by means of the <code class="literal">'cpp'</code> plugin.</p>
     <div class="example">
      <a name="cppPlugin"></a>
      <p class="title"><b>示例 54.3. cpp 插件 - Example&nbsp;54.3.&nbsp;The 'cpp' plugin</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'cpp'</span></pre>
      </div>
     </div>
     <br class="example-break">
     <p> 把 C++ 源码包含到原生二进制文件中，是通过一个 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>来实现的，它定义了一个C++源文件集以及（可选的）一个可导出的头文件（用于library）集默认情况下，对于任何命名的组件，<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>包含了在<code class="filename">src/${name}/cpp</code>中的<code class="filename">.cpp</code>源文件，和在<code class="filename">src/${name}/headers</code>中的头文件。 <br>C++ sources to be included in a native binary are provided via a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>, which defines a set of C++ source files and optionally a set of exported header files (for a library). By default, for any named component the <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a> contains <code class="filename">.cpp</code> source files in <code class="filename">src/${name}/cpp</code>, and header files in <code class="filename">src/${name}/headers</code>.</p>
     <p> 而<code class="literal">cpp</code>插件为每个<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>定义了这些默认的位置，且可以扩展或重写这些默认值使能够成为不同的项目布局。 <br>While the <code class="literal">cpp</code> plugin defines these default locations for each <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>, it is possible to extend or override these defaults to allow for a different project layout.</p>
     <div class="example">
      <a name="cppSourceSet"></a>
      <p class="title"><b>示例 54.4.&nbsp;C++ 源代码集 - Example&nbsp;54.4.&nbsp;C++ source set</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">sources {
    main {
        cpp {
            source {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/source"</span>
                include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"**/*.cpp"</span>
            }
        }
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p> 对于名字为“main”的library， <code class="filename">src/main/headers</code>中的文件都被视为"公共"或"导出"的头文件。不应该被导出（而是内部使用）的头文件，应该放在 <code class="filename">src/main/cpp</code> 目录（不过要注意，这样的文件应该总是以相对于包含它们的文件这样的一种方式被引用）。 <br>For a library named 'main', files in <code class="filename">src/main/headers</code> are considered the “public” or “exported” headers. Header files that should not be exported (but are used internally) should be placed inside the <code class="filename">src/main/cpp</code> directory (though be aware that such header files should always be referenced in a manner relative to the file including them).</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15974"></a>54.4.2.&nbsp;C 源代码</h3>
        <h5 class="title"><a name="N15974"></a>54.4.2.&nbsp;C sources</h5>
       </div>
      </div>
     </div>
     <p> <code class="literal">'c'</code> 插件提供了C 语言的支持。 <br>C language support is provided by means of the <code class="literal">'c'</code> plugin.</p>
     <div class="example">
      <a name="cPlugin"></a>
      <p class="title"><b>示例 54.5. “C” 插件 - Example&nbsp;54.5.&nbsp;The 'c' plugin</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'c'</span></pre>
      </div>
     </div>
     <br class="example-break">
     <p> 把 C 源码包含到原生二进制文件中，是通过一个 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>来实现的，它定义了一个C源文件集以及（可选的）一个可导出的头文件（用于library）集默认情况下，对于任何命名的组件，<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>包含了在<code class="filename">src/${name}/c</code>中的<code class="filename">.c</code>源文件，和在<code class="filename">src/${name}/headers</code>中的头文件。 <br>C sources to be included in a native binary are provided via a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>, which defines a set of C source files and optionally a set of exported header files (for a library). By default, for any named component the <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a> contains <code class="filename">.c</code> source files in <code class="filename">src/${name}/c</code>, and header files in <code class="filename">src/${name}/headers</code>.</p>
     <p> 而<code class="literal">c</code>插件为每个<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>定义了这些默认的位置，且可以扩展或重写这些默认值使能够成为不同的项目布局。 <br>While the <code class="literal">c</code> plugin defines these default locations for each <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>, it is possible to extend or override these defaults to allow for a different project layout.</p>
     <div class="example">
      <a name="cSourceSet"></a>
      <p class="title"><b>示例 54.4.&nbsp;C 源代码集 - Example&nbsp;54.6.&nbsp;C source set</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">sources {
    hello {
        c {
            source {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/source"</span>
                include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"**/*.c"</span>
            }
            exportedHeaders {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/include"</span>
            }
        }
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p> 对于名字为“main”的library， <code class="filename">src/main/headers</code>中的文件都被视为"公共"或"导出"的头文件。不应该被导出（而是内部使用）的头文件，应该放在 <code class="filename">src/main/c</code> 目录（不过要注意，这样的文件应该总是以相对于包含它们的文件这样一种方式被引用）。 <br>For a library named 'main', files in <code class="filename">src/main/headers</code> are considered the “public” or “exported” headers. Header files that should not be exported (but are used internally) should be placed inside the <code class="filename">src/main/c</code> directory (though be aware that such header files should always be referenced in a manner relative to the file including them).</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N159B7"></a>54.4.3.&nbsp;汇编代码</h3>
        <h5 class="title"><a name="N159B7"></a>54.4.3.&nbsp;Assembler sources</h5>
       </div>
      </div>
     </div>
     <p> <code class="literal">“assembler”</code> 插件提供了汇编语言的支持。 <br>Assembly language support is provided by means of the <code class="literal">'assembler'</code> plugin.</p>
     <div class="example">
      <a name="assemblerPlugin"></a>
      <p class="title"><b>示例 54.3. assembler 插件 - Example&nbsp;54.7.&nbsp;The 'assembler' plugin</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'assembler'</span></pre>
      </div>
     </div>
     <br class="example-break">
     <p> 把汇编源码包含到原生二进制文件中，是通过一个 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a>来实现的，它定义了一个汇编源文件集。默认情况下，对于任何命名的组件，<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a>包含了在<code class="filename">src/${name}/asm</code>中的<code class="filename">.s</code>源文件。 <br>Assembler sources to be included in a native binary are provided via a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a>, which defines a set of Assembler source files. By default, for any named component the <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a> contains <code class="filename">.s</code> source files under <code class="filename">src/${name}/asm</code>.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N159DB"></a>54.4.4.&nbsp;Objective-C 源码</h3>
        <h5 class="title"><a name="N159DB"></a>54.4.4.&nbsp;Objective-C sources</h5>
       </div>
      </div>
     </div>
     <p> <code class="literal">'objective-c'</code> 插件提供了Objective-C 语言的支持。 <br>Objective-C language support is provided by means of the <code class="literal">'objective-c'</code> plugin.</p>
     <div class="example">
      <a name="objectiveCPlugin"></a>
      <p class="title"><b>示例&nbsp;54.8.&nbsp;“objective-c”插件 - Example&nbsp;54.8.&nbsp;The 'objective-c' plugin</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'objective-c'</span></pre>
      </div>
     </div>
     <br class="example-break">
     <p> 把Objective-C源码包含到原生二进制文件中，是通过一个 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html" target="_top"><code class="classname">ObjectiveCSourceSet</code></a>来实现的，它定义了一个Objective-C源文件集。默认情况下，对于任何命名的组件，<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html" target="_top"><code class="classname">ObjectiveCSourceSet</code></a>包含了在<code class="filename">src/${name}/objectiveC</code>中的<code class="filename">.m</code>源文件。 <br>Objective-C sources to be included in a native binary are provided via a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html" target="_top"><code class="classname">ObjectiveCSourceSet</code></a>, which defines a set of Objective-C source files. By default, for any named component the <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html" target="_top"><code class="classname">ObjectiveCSourceSet</code></a> contains <code class="filename">.m</code> source files under <code class="filename">src/${name}/objectiveC</code>.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N159FF"></a>54.4.5.&nbsp;Objective-C++ 源码</h3>
        <h5 class="title"><a name="N159FF"></a>54.4.5.&nbsp;Objective-C++ sources</h5>
       </div>
      </div>
     </div>
     <p> <code class="literal">'objective-cpp'</code> 插件提供了Objective-C++ 语言的支持。 <br>Objective-C++ language support is provided by means of the <code class="literal">'objective-cpp'</code> plugin.</p>
     <div class="example">
      <a name="objectiveCppPlugin"></a>
      <p class="title"><b>示例 54.9. “objective-cpp” 插件 - Example&nbsp;54.9.&nbsp;The 'objective-cpp' plugin</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'objective-cpp'</span></pre>
      </div>
     </div>
     <br class="example-break">
     <p> 把Objective-C++源码包含到原生二进制文件中，是通过一个 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html" target="_top"><code class="classname">ObjectiveCppSourceSet</code></a>来实现的，它定义了一个Objective-C++源文件集。默认情况下，对于任何命名的组件，<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html" target="_top"><code class="classname">ObjectiveCppSourceSet</code></a>包含了在<code class="filename">src/${name}/objectiveCpp</code>中的<code class="filename">.mm</code>源文件。 <br>Objective-C++ sources to be included in a native binary are provided via a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html" target="_top"><code class="classname">ObjectiveCppSourceSet</code></a>, which defines a set of Objective-C++ source files. By default, for any named component the <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html" target="_top"><code class="classname">ObjectiveCppSourceSet</code></a> contains <code class="filename">.mm</code> source files under <code class="filename">src/${name}/objectiveCpp</code>.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="N15A23"></a>54.5. 配置编译器，汇编器和连接器</h2>
       <h4 class="title"><a name="N15A23"></a>54.5.&nbsp;Configuring the compiler, assembler and linker</h4>
      </div>
     </div>
    </div>
    <p> 每一个产生的二进制文件都和一系列的编译器和链接器设置相关联，这些设置包含了命令行参数，以及宏定义。这些设置可以应用于所有的二进制文件，单个二进制文件，或选择性地应用于基于某些条件的一组二进制文件。 <br>Each binary to be produced is associated with a set of compiler and linker settings, which include command-line arguments as well as macro definitions. These settings can be applied to all binaries, an individual binary, or selectively to a group of binaries based on some criteria.</p>
    <div class="example">
     <a name="allBinarySettings"></a>
     <p class="title"><b>示例 54.10. 应用于所有二进制文件的设置 - Example&nbsp;54.10.&nbsp;Settings that apply to all binaries</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">binaries.all {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define a preprocessor macro for every binary</span>
    cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"NDEBUG"</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define toolchain-specific compiler and linker options</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in Gcc) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-O2"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-fno-access-control"</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-Xlinker"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-S"</span>
    }
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/DEBUG"</span>
    }
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p> 每个二进制文件与特定的<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.ToolChain.html" target="_top"><code class="classname">ToolChain</code></a>关联，允许设置基于此值进行针对性的配置。 <br>Each binary is associated with a particular <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.ToolChain.html" target="_top"><code class="classname">ToolChain</code></a>, allowing settings to be targeted based on this value.</p>
    <p> 让设置应用于指定类型的所有二进制文件很简单： <br>It is easy to apply settings to all binaries of a particular type:</p>
    <div class="example">
     <a name="allSharedLibraryBinarySettings"></a>
     <p class="title"><b>示例 54.11. 应用于所有共享库的设置 - Example&nbsp;54.11.&nbsp;Settings that apply to all shared libraries</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// For any shared library binaries built with Visual C++, define the DLL_EXPORT macro</span>
binaries.withType(SharedLibraryBinary) {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
        cCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
        cCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"DLL_EXPORT"</span>
    }
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p> 此外，还可以指定设置应用于某个特定的<code class="literal">executable</code> 或 <code class="literal">library</code> 组件 产生的所有二进制文件： <br>Furthermore, it is possible to specify settings that apply to all binaries produces for a particular <code class="literal">executable</code> or <code class="literal">library</code> component:</p>
    <div class="example">
     <a name="componentBinarySettings"></a>
     <p class="title"><b>示例 54.12. 应用于“main”可执行组件所产生的所有二进制文件的设置 - Example&nbsp;54.12.&nbsp;Settings that apply to all binaries produced for the 'main' executable component</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">executables {
    main {
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
                assembler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
            } <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">else</span> {
                assembler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-g"</span>
            }
        }
    }
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p> 上面的例子将会把提供的配置应用到所有构建的 <code class="literal">executable</code>二进制文件。 <br>The example above will apply the supplied configuration to all <code class="literal">executable</code> binaries built.</p>
    <p> 同样，也可以为某种特定类型的组件，把设置指向目标二进制文件：例如所有<code class="literal">main library</code>组件的<code class="literal">shared libraries</code>。 <br>Similarly, settings can be specified to target binaries for a component that are of a particular type: eg all <code class="literal">shared libraries</code> for the <code class="literal">main library</code> component.</p>
    <div class="example">
     <a name="sharedLibraryArgs"></a>
     <p class="title"><b>示例 54.13. 仅应用于“main”library组件所产生的共享库的设置 - Example&nbsp;54.13.&nbsp;Settings that apply only to shared libraries produced for the 'main' library component</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">libraries {
    main {
        binaries.withType(SharedLibraryBinary) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define a preprocessor macro that only applies to shared libraries</span>
            cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"DLL_EXPORT"</span>
        }
    }
}</pre>
     </div>
    </div>
    <br class="example-break">
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="native_binaries:windows-resources"></a>54.6.&nbsp;Windows Resource</h2>
       <h4 class="title"><a name="native_binaries:windows-resources"></a>54.6.&nbsp;Windows Resources</h4>
      </div>
     </div>
    </div>
    <p> 当使用<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.VisualCpp.html" target="_top"><code class="classname">VisualCpp</code></a>工具链时，Gradle 时能够编译Window Resource (<code class="literal">rc</code>) 文件并将它们链接到本地的二进制文件。这个功能是由<code class="literal">'windows-resources'</code> 插件所提供的。 <br>When using the <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.VisualCpp.html" target="_top"><code class="classname">VisualCpp</code></a> tool chain, Gradle is able to compile Window Resource (<code class="literal">rc</code>) files and link them into a native binary. This functionality is provided by the <code class="literal">'windows-resources'</code> plugin.</p>
    <div class="example">
     <a name="windowsResourcesPlugin"></a>
     <p class="title"><b>示例&nbsp;54.14.&nbsp;'windows-resources' 插件 - Example&nbsp;54.14.&nbsp;The 'windows-resources' plugin</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'windows-resources'</span></pre>
     </div>
    </div>
    <br class="example-break">
    <p> 将 Windows 资源包含进本机二进制文件中，是通过一个<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.rc.WindowsResourceSet.html" target="_top"><code class="classname">WindowsResourceSet</code></a>提供的，它定义了一组Windows Resource源文件。默认情况下，<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.rc.WindowsResourceSet.html" target="_top"><code class="classname">WindowsResourceSet</code></a>为所有的命名组件包含了在<code class="filename">src/${name}/rc</code>下的<code class="filename">.rc</code>源文件。 <br>Windows resources to be included in a native binary are provided via a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.rc.WindowsResourceSet.html" target="_top"><code class="classname">WindowsResourceSet</code></a>, which defines a set of Windows Resource source files. By default, for any named component the <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.rc.WindowsResourceSet.html" target="_top"><code class="classname">WindowsResourceSet</code></a> contains <code class="filename">.rc</code> source files under <code class="filename">src/${name}/rc</code>.</p>
    <p> 与其他源文件类型一样，您可以配置把windows 资源的位置包含进二进制文件中。 <br>As with other source types, you can configure the location of the windows resources that should in included in the binary.</p>
    <div class="example">
     <a name="windowsResourceSet"></a>
     <p class="title"><b>示例 54.15. 配置 Windows 资源源文件的位置 - Example&nbsp;54.15.&nbsp;Configuring the location of Windows resource sources</b></p>
     <div class="example-contents">
      <p><code class="filename">build-resource-only-dll.gradle</code></p>
      <pre class="programlisting">sources {
    helloRes {
        rc {
            source {
                srcDirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/hello/rc"</span>
            }
            exportedHeaders {
                srcDirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/hello/headers"</span>
            }
        }
    }
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p> 你能够通过提供没有任何其他语言来源的 Windows Resource 源文件，来构造纯资源库，并适当地配置链接器︰ <br>You are able to construct a resource-only library by providing Windows Resource sources with no other language sources, and configure the linker as appropriate:</p>
    <div class="example">
     <a name="resourceOnlyDll"></a>
     <p class="title"><b>示例 54.16. 构建一个纯资源 dll - Example&nbsp;54.16.&nbsp;Building a resource-only dll</b></p>
     <div class="example-contents">
      <p><code class="filename">build-resource-only-dll.gradle</code></p>
      <pre class="programlisting">libraries {
    helloRes {
        binaries.all {
            rcCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/v"</span>
            linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/noentry"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/machine:x86"</span>
        }
    }
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p> 上面的示例还演示了将额外的命令行参数传递给资源编译器的机制。<code class="literal">rcCompiler</code>扩展是<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.language.PreprocessingTool.html" target="_top"><code class="classname">PreprocessingTool</code></a>类型。 <br>The example above also demonstrates the mechanism of passing extra command-line arguments to the resource compiler. The <code class="literal">rcCompiler</code> extension is of type <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.language.PreprocessingTool.html" target="_top"><code class="classname">PreprocessingTool</code></a>.</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="N15ABD"></a>54.7.&nbsp;库依赖</h2>
       <h4 class="title"><a name="N15ABD"></a>54.7.&nbsp;Library Dependencies</h4>
      </div>
     </div>
    </div>
    <p> C++ 项目的依赖是导出头文件的二进制库。这些头文件在编译期间使用，而编译的二进制依赖则在链接过程中使用。 <br>Dependencies for C++ projects are binary libraries that export header files. The header files are used during compilation, with the compiled binary dependency being used during the linking.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15AC2"></a>54.7.1.&nbsp;同一项目的依赖</h3>
        <h5 class="title"><a name="N15AC2"></a>54.7.1.&nbsp;Dependencies within the same project</h5>
       </div>
      </div>
     </div>
     <p> 一组源文件可能依赖于在同一个项目中由另一个二进制组件提供的头文件。一个常见的例子是一个本地可执行组件，使用了由一个单独的本地库组件提供的功能。 <br>A set of sources may depend on header files provided by another binary component within the same project. A common example is a native executable component that uses functions provided by a separate native library component.</p>
     <p> 这样的库依赖可以很方便地提供给source set关联上<code class="literal">executable</code>组件。 <br>Such a library dependency can be easily provided to source set associated with the <code class="literal">executable</code> component:</p>
     <div class="example">
      <a name="cppSourceLibrary"></a>
      <p class="title"><b>示例 54.17. 向source set提供库依赖 - Example&nbsp;54.17.&nbsp;Providing a library dependency to the source set</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">sources {
    main {
        cpp {
            lib libraries.hello
        }
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p> 另外，一个库依赖项可以直接提供给<code class="literal">ExecutableBinary</code>的<code class="literal">executable</code>。 <br>Alternatively, a library dependency can be provided directly to the <code class="literal">ExecutableBinary</code> for the <code class="literal">executable</code>.</p>
     <div class="example">
      <a name="cppBinaryLibrary"></a>
      <p class="title"><b>示例 54.18. 向二进制文件提供库依赖 - Example&nbsp;54.18.&nbsp;Providing a library dependency to the binary</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">executables {
    main {
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Each executable binary produced uses the 'hello' static library binary</span>
            lib libraries.hello.<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">static</span>
        }
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15AE8"></a>54.7.2. 项目依赖</h3>
        <h5 class="title"><a name="N15AE8"></a>54.7.2.&nbsp;Project Dependencies</h5>
       </div>
      </div>
     </div>
     <p> 对于在不同的 Gradle 项目产生的组件，notation是类似的。 <br>For a component produced in a different Gradle project, the notation is similar.</p>
     <div class="example">
      <a name="cppProjectDependencies"></a>
      <p class="title"><b>示例 54.19. 定义项目依赖 - Example&nbsp;54.19.&nbsp;Declaring project dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":lib"</span>) {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cpp"</span>
    libraries {
        main {}
    }
}

project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":exe"</span>) {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cpp"</span>

    executables {
        main {}
    }

    sources {
        main {
            cpp {
                lib project: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':lib'</span>, library: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'main'</span>
            }
        }
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="native_binaries:variants"></a>54.8.&nbsp;本地二进制变种</h2>
       <h4 class="title"><a name="native_binaries:variants"></a>54.8.&nbsp;Native Binary Variants</h4>
      </div>
     </div>
    </div>
    <p> 对于每个定义的可执行文件或库，Gradle 能够构建多个不同的本机二进制变种。这样的例子包括debug及release的二进制文件，32位及64位的二进制文件，以及使用不同的自定义预处理标志生成的二进制文件。 <br>For each executable or library defined, Gradle is able to build a number of different native binary variants. Examples of different variants include debug vs release binaries, 32-bit vs 64-bit binaries, and binaries produced with different custom preprocessor flags.</p>
    <p> Gradle 产生的二进制文件可以区分 <a class="link" href="nativeBinaries.html#native_binaries:build_type">构建类型</a>， <a class="link" href="nativeBinaries.html#native_binaries:platform">平台</a>以及 <a class="link" href="nativeBinaries.html#native_binaries:flavor">flavor</a>。对于这里的每一个“变种维度”，它可以指定一组可用的值，并且针对每个组件使用这里的一个或多个或全部的值。例如，一个插件可以定义一系列的支持平台，但你可以选择某个特定组件只构建Windows-x86平台。 <br>Binaries produced by Gradle can be differentiated on <a class="link" href="nativeBinaries.html#native_binaries:build_type">build type</a>, <a class="link" href="nativeBinaries.html#native_binaries:platform">platform</a> and <a class="link" href="nativeBinaries.html#native_binaries:flavor">flavor</a>. For each of these 'variant dimensions', it is possible to specify a set of available values as well as target each component at one, some or all of these. For example, a plugin may define a range of support platforms, but you may choose to only target Windows-x86 for a particular component.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="native_binaries:build_type"></a>54.8.1. 构建类型</h3>
        <h5 class="title"><a name="native_binaries:build_type"></a>54.8.1.&nbsp;Build types</h5>
       </div>
      </div>
     </div>
     <p> 一个 <code class="literal">build type</code> 确定了一个二进制文件的各种非功能性方面，比如是否包含调试信息，或者使用什么样的优化级别来编译二进制文件。典型的构建类型是“debug”和“release”，但一个project可以自由定义任意的构建类型。 <br>A <code class="literal">build type</code> determines various non-functional aspects of a binary, such as whether debug information is included, or what optimisation level the binary is compiled with. Typical build types are 'debug' and 'release', but a project is free to define any set of build types.</p>
     <div class="example">
      <a name="buildTypes"></a>
      <p class="title"><b>示例 54.20. 定义构建类型 - Example&nbsp;54.20.&nbsp;Defining build types</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">model {
    buildTypes {
        debug
        release
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p> 如果在project中没有定义任何构建类型，那么会有一个默认的“debug”构建类型被加进去。 <br>If no build types are defined in a project, then a single, default build type called 'debug' is added.</p>
     <p> 对于一个构建类型，Gradle project 通常会定义一组每个工具链的编译器/链接器标志。 <br>For a build type, a Gradle project will typically define a set of compiler/linker flags per tool chain.</p>
     <div class="example">
      <a name="buildTypeConfig"></a>
      <p class="title"><b>示例 54.21. 配置debug二进制文件 - Example&nbsp;54.21.&nbsp;Configuring debug binaries</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">binaries.all {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in Gcc &amp;&amp; buildType == buildTypes.debug) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-g"</span>
    }
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp &amp;&amp; buildType == buildTypes.debug) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'/Zi'</span>
        cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'DEBUG'</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'/DEBUG'</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <div class="note">
       在这个阶段，它就完全符合构建脚本来为每个构建类型配置相关的编译器/链接器标志。未来版本的 Gradle 将自动包括任何“debug”构建类型的适当调试标志，并且还可能知道各个优化级别。 
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="native_binaries:platform"></a>54.8.2.&nbsp;平台</h3>
        <h5 class="title"><a name="native_binaries:platform"></a>54.8.2.&nbsp;Platform</h5>
       </div>
      </div>
     </div>
     <p> 通过为每个平台生成一个变种，能够使一个可执行文件或库构建为可以运行在不同的操作系统及CPU架构上。Gradle 把每一个系统架构组合定义为一个 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.platform.Platform.html" target="_top"><code class="classname">Platform</code></a>，一个project可以定义多个platforms。如果在project里没有定义任何平台，那么会添加一个默认的“current”平台。 <br>An executable or library can be built to run on different operating systems and cpu architectures, with a variant being produced for each platform. Gradle defines each OS/architecture combination as a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.platform.Platform.html" target="_top"><code class="classname">Platform</code></a>, and a project may define any number of platforms. If no platforms are defined in a project, then a single, default platform 'current' is added.</p>
     <div class="note">
       目前，一个
      <code class="literal">Platform</code>由一个定义的操作系统和架构构成。随着我们继续开发 Gradle 的本地二进制支持，将扩展Platform的概念，包括 C-runtime版本，Windows SDK，ABI，等等。复杂的构建，可能使用 Gradle 的扩展性来把附加属性应用到每个platform中，然后可以查询为一个本地二进制包含了哪些特别指定的预处理器或者是编译器参数。 
     </div>
     <div class="example">
      <a name="platforms"></a>
      <p class="title"><b>示例 54.22. 定义platform - Example&nbsp;54.22.&nbsp;Defining platforms</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">model {
    platforms {
        x8<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">6</span> {
            architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x86"</span>
        }
        x6<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">4</span> {
            architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x86_64"</span>
        }
        itanium {
            architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ia-64"</span>
        }
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p> 对于给定的变种，Gradle 将尝试查找能够构建目标平台的<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.ToolChain.html" target="_top"><code class="classname">ToolChain</code></a>。可用的工具链将按照定义的顺序进行查找。更多的细节请参阅下面的<a class="link" href="nativeBinaries.html#native_binaries:tool_chain">工具链</a>部分。 <br>For a given variant, Gradle will attempt to find a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.ToolChain.html" target="_top"><code class="classname">ToolChain</code></a> that is able to build for the target platform. Available tool chains are searched in the order defined. See the <a class="link" href="nativeBinaries.html#native_binaries:tool_chain">tool chain</a> section below for more details.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="native_binaries:flavor"></a>54.8.3.&nbsp;Flavor</h3>
        <h5 class="title"><a name="native_binaries:flavor"></a>54.8.3.&nbsp;Flavor</h5>
       </div>
      </div>
     </div>
     <p> 每个组件都可以有一组<code class="literal">flavors</code>，并且能为每一个flavor生成一个单独的二进制变种。在Gradle中 <code class="literal">build type</code> 和 <code class="literal">target platform</code> 变种维度是有一个确定的定义的，而每一个project都可以自由地定义数量的flavor并且用任何方式去应用它们的意义。 <br>Each component can have a set of named <code class="literal">flavors</code>, and a separate binary variant can be produced for each flavor. While the <code class="literal">build type</code> and <code class="literal">target platform</code> variant dimensions have a defined meaning in Gradle, each project is free to define any number of flavors and apply meaning to them in any way.</p>
     <p> 一个关于组件flavor的例子是可以区分组件的“demo”，“paid”和“enterprise”版本，它们都用同样的源码来生成不同功能的二进制文件。 <br>An example of component flavors might differentiate between 'demo', 'paid' and 'enterprise' editions of the component, where the same set of sources is used to produce binaries with different functions.</p>
     <div class="example">
      <a name="flavors"></a>
      <p class="title"><b>示例 54.23. 定义flavors - Example&nbsp;54.23.&nbsp;Defining flavors</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">model {
    flavors {
        english
        french
    }
}

libraries {
    hello {
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (flavor == flavors.french) {
                cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"FRENCH"</span>
            }
        }
        source sources.lib
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p> 在上面的示例中，library 定义了“english”和“french”两个flavor。当编译“french”变种时，会定义一个单独的宏，以产生不同的二进制文件。 <br>In the example above, a library is defined with a 'english' and 'french' flavor. When compiling the 'french' variant, a separate macro is defined which leads to a different binary being produced.</p>
     <p> 如果一个组件没有定义任何的flavor，那么会使用一个默认的“default”的flavor。 <br>If no flavor is defined for a component, then a single default flavor named 'default' is used.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15B72"></a>54.8.4.&nbsp;为一个组件选择构建类型，平台和flavor</h3>
        <h5 class="title"><a name="N15B72"></a>54.8.4.&nbsp;Selecting the build types, platforms and flavors for a component</h5>
       </div>
      </div>
     </div>
     <p> 对于一个默认的组件， Gradle会尝试为这个project所定义的每一个<code class="literal">buildType</code>， <code class="literal">platform</code> 和 <code class="literal">flavor</code>，以及它们的每一种组合，创建一个本地二进制变种。通过指定的 <code class="literal">targetBuildTypes</code>， <code class="literal">targetPlatforms</code> 或 <code class="literal">targetFlavors</code>，是可以在每一个组件的基础上进行重写的。 <br>For a default component, Gradle will attempt to create a native binary variant for each and every combination of <code class="literal">buildType</code>, <code class="literal">platform</code> and <code class="literal">flavor</code> defined for the project. It is possible to override this on a per-component basis, by specifying the set of <code class="literal">targetBuildTypes</code>, <code class="literal">targetPlatforms</code> and/or <code class="literal">targetFlavors</code>.</p>
     <div class="example">
      <a name="targets"></a>
      <p class="title"><b>示例&nbsp;54.24.&nbsp;针对一个组件的特定平台 - Example&nbsp;54.24.&nbsp;Targeting a component at particular platforms</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">executables {
    main {
        targetPlatforms <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x86"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x64"</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p> 在这里你可以看到 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.TargetedNativeComponent.html#org.gradle.nativebinaries.TargetedNativeComponent:targetPlatforms(java.lang.String...)" target="_top"><code class="classname">TargetedNativeComponent.targetPlatforms()</code></a> 方法被用于为 <code class="literal">executables.main</code>选择一组平台。 <br>Here you can see that the <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.TargetedNativeComponent.html#org.gradle.nativebinaries.TargetedNativeComponent:targetPlatforms(java.lang.String...)" target="_top"><code class="classname">TargetedNativeComponent.targetPlatforms()</code></a> method is used to select the set of platforms to target for <code class="literal">executables.main</code>.</p>
     <p> 在选择 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.TargetedNativeComponent.html#org.gradle.nativebinaries.TargetedNativeComponent:targetBuildTypes(java.lang.String...)" target="_top"><code class="classname">TargetedNativeComponent.targetBuildTypes()</code></a> and和<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.TargetedNativeComponent.html#org.gradle.nativebinaries.TargetedNativeComponent:targetFlavors(java.lang.String...)" target="_top"><code class="classname">TargetedNativeComponent.targetFlavors()</code></a>上也有类似的机制。 <br>A similar mechanism exists for selecting <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.TargetedNativeComponent.html#org.gradle.nativebinaries.TargetedNativeComponent:targetBuildTypes(java.lang.String...)" target="_top"><code class="classname">TargetedNativeComponent.targetBuildTypes()</code></a> and <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.TargetedNativeComponent.html#org.gradle.nativebinaries.TargetedNativeComponent:targetFlavors(java.lang.String...)" target="_top"><code class="classname">TargetedNativeComponent.targetFlavors()</code></a>.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15BA9"></a>54.8.5.&nbsp;构建所有可能的变种</h3>
        <h5 class="title"><a name="N15BA9"></a>54.8.5.&nbsp;Building all possible variants</h5>
       </div>
      </div>
     </div>
     <p> 当为一个组件定义了一组构建类型，目标平台，以及flavor时，将会为它们的每一种可能的组合创建一个<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> 模型元素。然而，在许多情况下是不可能构建一个特定的变种的，可能的原因是某个特定的平台没有可用的工具链。 <br>When a set of build types, target platforms, and flavors is defined for a component, a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> model element is created for every possible combination of these. However, in many cases it is not possible to build a particular variant, perhaps because no tool chain is available to build for a particular platform.</p>
     <p> 如果一个二进制变种因为某些原因不能构建，那么与之关联的<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a>将不会是<code class="literal">buildable</code>。可以用这个属性来创建一个任务，生成在某一特定计算机上所有可能的变种。 <br>If a binary variant cannot be built for any reason, then the <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> associated with that variant will not be <code class="literal">buildable</code>. It is possible to use this property to create a task to generate all possible variants on a particular machine.</p>
     <div class="example">
      <a name="buildable"></a>
      <p class="title"><b>示例 54.25.&nbsp;构建所有可能的变种 - Example&nbsp;54.25.&nbsp;Building all possible variants</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">task buildAllExecutables {
    dependsOn binaries.withType(ExecutableBinary).matching {
        it.buildable
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="native_binaries:tool_chain"></a>54.9. 工具链</h2>
       <h4 class="title"><a name="native_binaries:tool_chain"></a>54.9.&nbsp;Tool chains</h4>
      </div>
     </div>
    </div>
    <p> 一个构建可以使用不同的工具链来构建不同平台的变种。为此，核心的“native-binary”将尝试查找并使支持的工具链可用。不过，一个项目里的一组工具链也可以被显示地定义，允许配置额外的交叉编译器以及指定安装目录。 <br>A single build may utilize different tool chains to build variants for different platforms. To this end, the core 'native-binary' plugins will attempt to locate and make available supported tool chains. However, the set of tool chains for a project may also be explicitly defined, allowing additional cross-compilers to be configured as well as allowing the install directories to be specified.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15BCD"></a>54.9.1.&nbsp;定义工具链</h3>
        <h5 class="title"><a name="N15BCD"></a>54.9.1.&nbsp;Defining tool chains</h5>
       </div>
      </div>
     </div>
     <p> 支持的工具链类型有︰ <br>The supported tool chain types are:</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem"><p><a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.Gcc.html" target="_top"><code class="classname">Gcc</code></a></p></li>
       <li class="listitem"><p><a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.Clang.html" target="_top"><code class="classname">Clang</code></a></p></li>
       <li class="listitem"><p><a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.VisualCpp.html" target="_top"><code class="classname">VisualCpp</code></a></p></li>
      </ul>
     </div>
     <div class="example">
      <a name="toolChains"></a>
      <p class="title"><b>示例 54.26.&nbsp;定义工具链 - Example&nbsp;54.26.&nbsp;Defining tool chains</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">model {
    toolChains {
        visualCpp(VisualCpp) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Specify the installDir if Visual Studio cannot be located by default</span>
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// installDir "C:/Apps/Microsoft Visual Studio 10.0"</span>
        }
        gcc(Gcc) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Uncomment to use a GCC install that is not in the PATH</span>
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// path "/usr/bin/gcc"</span>
        }
        clang(Clang)
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p> 每个工具链的实现都允许一定程度的配置（更多细节请参阅API文档） <br>Each tool chain implementation allows for a certain degree of configuration (see the API documentation for more details).</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15BF1"></a>54.9.2. 使用工具链</h3>
        <h5 class="title"><a name="N15BF1"></a>54.9.2.&nbsp;Using tool chains</h5>
       </div>
      </div>
     </div>
     <p> 指定构建所使用的工具链是不必要和可能的。对于给定的变种，Gradle 将尝试查找能够构建目标平台的<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.ToolChain.html" target="_top"><code class="classname">ToolChain</code></a>。可用的工具链将按照定义的顺序进行查找。 <br>It is not necessary or possible to specify the tool chain that should be used to build. For a given variant, Gradle will attempt to locate a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.ToolChain.html" target="_top"><code class="classname">ToolChain</code></a> that is able to build for the target platform. Available tool chains are searched in the order defined.</p>
     <div class="note">
       当一个平台并没有定义一个架构或操作系统时，会被认为使用默认的工具链目标。所以如果一个平台没有为
      <code class="literal">operatingSystem</code>定义一个值的话，Gradle 将会找到第一个可以用来构建这个指定
      <code class="literal">architecture</code>的工具链。 
     </div>
     <p> 核心 Gradle 工具链针对以下的架构能够开箱即用。在每种情况中，工具链将针对当前的操作系统。关于其他操作系统的交叉编译的信息，可以参考下一节。 <br>The core Gradle tool chains are able to target the following architectures out of the box. In each case, the tool chain will target the current operating system. See the next section for information on cross-compiling for other operating systems.</p>
     <div xmlns:xslthl="http://xslthl.sf.net" class="table">
      <div class="table-contents">
       <table id="N15C05"> 
        <tbody>
         <tr>
          <td>工具链<br>Tool Chain</td>
          <td>架构<br>Architectures</td>
         </tr> 
         <tr> 
          <td>GCC</td>
          <td>x86, x86_64</td> 
         </tr>
         <tr> 
          <td>Clang</td>
          <td>x86, x86_64</td> 
         </tr>
         <tr> 
          <td>Visual C++</td>
          <td>x86, x86_64, ia-64</td> 
         </tr>
        </tbody>
       </table>
      </div>
     </div>
     <p> 所以对于linux上运行的GCC，支持的目标平台是“linux/x86”和“linux/x86_64”。对于通过Cygwin运行在Windows上的GCC，则支持“windows/x86”和“windows/x86_64”。（Cywgin运行时还不能模拟为Platform的一部分，但以后将会实现。） <br>So for GCC running on linux, the supported target platforms are 'linux/x86' and 'linux/x86_64'. For GCC running on Windows via Cygwin, platforms 'windows/x86' and 'windows/x86_64' are supported. (The Cygwin runtime is not yet modelled as part of the Platform, but will be in the future.)</p>
     <p> 如果在project里没有定义任何平台，那么所有的二进制文件会针对一个默认平台“current”进行构建。该默认平台不指定任何<code class="literal">architecture</code>或<code class="literal">operatingSystem</code>的值，因此会使用第一个可用的工具链的默认值。 <br>If no target platforms are defined for a project, then all binaries are built to target a default platform named 'current'. This default platform does not specify any <code class="literal">architecture</code> or <code class="literal">operatingSystem</code> value, hence using the default values of the first available tool chain.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15C2D"></a>54.9.3.&nbsp;使用GCC进行交叉编译</h3>
        <h5 class="title"><a name="N15C2D"></a>54.9.3.&nbsp;Cross-compiling with GCC</h5>
       </div>
      </div>
     </div>
     <p> 使用 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.Gcc.html" target="_top"><code class="classname">Gcc</code></a> 和 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.Clang.html" target="_top"><code class="classname">Clang</code></a> 工具链，通过 以编程方式添加附加的目标平台的支持，是可以做到交叉编译的。它通过 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.PlatformConfigurableToolChain.html" target="_top"><code class="classname">PlatformConfigurableToolChain</code></a> API来完成。每个添加的 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/javadoc/org/gradle/nativebinaries/toolchain/TargetPlatformConfiguration.html" target="_top"><code class="classname">TargetPlatformConfiguration</code></a> 定义了对一个特定的目标平台的支持，并且提供了针对该平台所需要的额外的工具参数。 <br>Cross-compiling is possible with the <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.Gcc.html" target="_top"><code class="classname">Gcc</code></a> and <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.Clang.html" target="_top"><code class="classname">Clang</code></a> tool chains, by programmatically adding support for additional target platforms. This is done using the <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.toolchain.PlatformConfigurableToolChain.html" target="_top"><code class="classname">PlatformConfigurableToolChain</code></a> API. Each added <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/javadoc/org/gradle/nativebinaries/toolchain/TargetPlatformConfiguration.html" target="_top"><code class="classname">TargetPlatformConfiguration</code></a> defines support for a particular target platform, and supplies additional tool arguments that are required to target this platform.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="native_binaries:visual_studio"></a>54.10.&nbsp;Visual Studio IDE 集成</h2>
       <h4 class="title"><a name="native_binaries:visual_studio"></a>54.10.&nbsp;Visual Studio IDE integration</h4>
      </div>
     </div>
    </div>
    <p> Gradle 可以为在你的构建中定义的本地组件生成生成 Visual Studio 项目及解决方案文件。这个功能是通过 <code class="literal">visual-studio</code> 插件添加的。对于多项目构建，所有带有本地组件的project都应该应用这个插件。 <br>Gradle has the ability to generate Visual Studio project and solution files for the native components defined in your build. This ability is added by the <code class="literal">visual-studio</code> plugin. For a multi-project build, all projects with native components should have this plugin applied.</p>
    <p> 当应用 <code class="literal">visual-studio</code> 插件后，会为每一个定义的组件创建一个名为 <code class="literal">${component.name}VisualStudio</code> 的任务。这个任务会为所命名的组件生成一个 Visual Studio Solution 文件。这个方案包含了一个该组件的 Visual Studio Project ，并且为每一个依赖的二进制文件链接到项目文件中。 <br>When the <code class="literal">visual-studio</code> plugin is applied, a task name <code class="literal">${component.name}VisualStudio</code> is created for each defined component. This task will generate a Visual Studio Solution file for the named component. This solution will include a Visual Studio Project for that component, as well as linking to project files for each depended-on binary.</p>
    <p> 通过由<code class="literal">visualStudio</code> 提供的编程hook，可以修改所生成的visual studio文件的内容， 更详细的信息，可以参考“visual-studio”例子，或者参阅 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html#org.gradle.ide.visualstudio.VisualStudioExtension:projects" target="_top"><code class="classname">VisualStudioExtension.getProjects()</code></a> 及 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html#org.gradle.ide.visualstudio.VisualStudioExtension:solutions" target="_top"><code class="classname">VisualStudioExtension.getSolutions()</code></a> 。 <br>The content of the generated visual studio files can be modified via programmatic hooks, provided by the <code class="literal">visualStudio</code> extension. Take a look at the 'visual-studio' sample, or see <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html#org.gradle.ide.visualstudio.VisualStudioExtension:projects" target="_top"><code class="classname">VisualStudioExtension.getProjects()</code></a> and <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html#org.gradle.ide.visualstudio.VisualStudioExtension:solutions" target="_top"><code class="classname">VisualStudioExtension.getSolutions()</code></a> for more details.</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="native_binaries:cunit"></a>54.11.&nbsp;CUnit 支持</h2>
       <h4 class="title"><a name="native_binaries:cunit"></a>54.11.&nbsp;CUnit support</h4>
      </div>
     </div>
    </div>
    <p> Gradle <code class="literal">cunit</code> 插件向你的native-binary项目提供了编译及执行CUnit 测试的支持。对于在你的项目中定义的每一个 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> 和 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a>，Gradle将创建一个匹配的 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.test.cunit.CUnitTestSuite.html" target="_top"><code class="classname">CUnitTestSuite</code></a> 组件，名字为<code class="literal">${component.name}Test</code>。 <br>The Gradle <code class="literal">cunit</code> plugin provides support for compiling and executing CUnit tests in your native-binary project. For each <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> and <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a> defined in your project, Gradle will create a matching <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.test.cunit.CUnitTestSuite.html" target="_top"><code class="classname">CUnitTestSuite</code></a> component, named <code class="literal">${component.name}Test</code>.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15C81"></a>54.11.1.&nbsp;CUnit 源码</h3>
        <h5 class="title"><a name="N15C81"></a>54.11.1.&nbsp;CUnit sources</h5>
       </div>
      </div>
     </div>
     <p> Gradle将为项目中的每一个 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.test.cunit.CUnitTestSuite.html" target="_top"><code class="classname">CUnitTestSuite</code></a> 组件创建一个名字为“cunit”的<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>。这个源码集应包含组件源码的 cunit 测试文件。源文件可以位于约定的位置（<code class="literal">src/${component.name}Test/cunit</code>），或者是像其他源集一样配置到别的地方。 <br>Gradle will create a <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a> named 'cunit' for each <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.test.cunit.CUnitTestSuite.html" target="_top"><code class="classname">CUnitTestSuite</code></a> component in the project. This source set should contain the cunit test files for the component sources. Source files can be located in the conventional location (<code class="literal">src/${component.name}Test/cunit</code>) or can be configured like any other source set.</p>
     <p> 初始化 CUnit 测试注册以及执行这些测试的工作，都由 Gradle 通过一些生成的 CUnit 启动器源码来执行。Gradle 将认定和调用一个<code class="literal">void gradle_cunit_register()</code> 函数，这个函数你可以用于配置实际的CUnit套件以及要执行的测试。 <br>The job of initialising the CUnit test registry and executing the tests is performed by Gradle, via some generated CUnit launcher sources. Gradle will expect and call a function with the signature <code class="literal">void gradle_cunit_register()</code> that you can use to configure the actual CUnit suites and tests to execute.</p>
     <div class="example">
      <a name="cunitSources"></a>
      <p class="title"><b>示例 54.27. 注册 CUnit 测试 - Example&nbsp;54.27.&nbsp;Registering CUnit tests</b></p>
      <div class="example-contents">
       <p><code class="filename">suite_operators.c</code></p>
       <pre class="programlisting">#include &lt;CUnit/Basic.h&gt;
#include "gradle_cunit_register.h"
#include "test_operators.h"

int suite_init(void) {
    return 0;
}

int suite_clean(void) {
    return 0;
}

void gradle_cunit_register() {
    CU_pSuite pSuiteMath = CU_add_suite("operator tests", suite_init, suite_clean);
    CU_add_test(pSuiteMath, "test_plus", test_plus);
    CU_add_test(pSuiteMath, "test_minus", test_minus);
}</pre>
      </div>
     </div>
     <br class="example-break">
     <div class="note">
       由于这一机制，你的 CUnit 源碼可能不包含一个
      <code class="literal">main</code>方法，因为这会与 Gradle 所提供的方法产生冲突。 
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15CA6"></a>54.11.2.&nbsp;构建 CUnit 可执行文件</h3>
        <h5 class="title"><a name="N15CA6"></a>54.11.2.&nbsp;Building CUnit executables</h5>
       </div>
      </div>
     </div>
     <p> 一个 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.test.cunit.CUnitTestSuite.html" target="_top"><code class="classname">CUnitTestSuite</code></a> 组件会有一个相关联的 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> 或 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a> 组件。对于为main 组件配置的每一个<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.ProjectNativeBinary.html" target="_top"><code class="classname">ProjectNativeBinary</code></a>，在测试套件组件上都会配置一个匹配的 <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/javadoc/org/gradle/nativebinaries/test/TestSuiteExecutableBinary.html" target="_top"><code class="classname">TestSuiteExecutableBinary</code></a> 。这些测试套件二进制文件可以以一种类似的方式配置到任何其他二进制的实例︰ <br>A <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.test.cunit.CUnitTestSuite.html" target="_top"><code class="classname">CUnitTestSuite</code></a> component has an associated <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> or <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a> component. For each <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.nativebinaries.ProjectNativeBinary.html" target="_top"><code class="classname">ProjectNativeBinary</code></a> configured for the main component, a matching <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/javadoc/org/gradle/nativebinaries/test/TestSuiteExecutableBinary.html" target="_top"><code class="classname">TestSuiteExecutableBinary</code></a> will be configured on the test suite component. These test suite binaries can be configured in a similar way to any other binary instance:</p>
     <div class="example">
      <a name="cunitSources"></a>
      <p class="title"><b>示例 54.28. 注册 CUnit 测试 - Example&nbsp;54.28.&nbsp;Registering CUnit tests</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">binaries.withType(TestSuiteExecutableBinary) {
    lib library: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cunit"</span>, linkage: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"static"</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (flavor == flavors.failing) {
        cCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"PLUS_BROKEN"</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <div class="note">
       由你的项目和生成的启动器提供的两种 CUnit 源码，都需要核心 CUnit 头文件和库。目前，这个库依赖项必须由你的项目为每个
      <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/javadoc/org/gradle/nativebinaries/test/TestSuiteExecutableBinary.html" target="_top"><code class="classname">TestSuiteExecutableBinary</code></a>提供。 
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15CD5"></a>54.11.3. 运行 CUnit 测试</h3>
        <h5 class="title"><a name="N15CD5"></a>54.11.3.&nbsp;Running CUnit tests</h5>
       </div>
      </div>
     </div>
     <p> 对于每个<a class="ulink" href="http://gradledoc.qiniudn.com/1.12/javadoc/org/gradle/nativebinaries/test/TestSuiteExecutableBinary.html" target="_top"><code class="classname">TestSuiteExecutableBinary</code></a>，Gradle 将创建一个任务来执行此二进制文件，这项任务将运行所有注册的 CUnit 测试。生成的测试结果将位于<code class="literal"><em class="replaceable"><code>${build.dir}</code></em>/test-results</code>目录。 <br>For each <a class="ulink" href="http://gradledoc.qiniudn.com/1.12/javadoc/org/gradle/nativebinaries/test/TestSuiteExecutableBinary.html" target="_top"><code class="classname">TestSuiteExecutableBinary</code></a>, Gradle will create a task to execute this binary, which will run all of the registered CUnit tests. The generated test results will be located in the <code class="literal"><em class="replaceable"><code>${build.dir}</code></em>/test-results</code> directory.</p>
     <div class="example">
      <a name="completeCUnitExample"></a>
      <p class="title"><b>示例 54.29. 运行 CUnit 测试 - Example&nbsp;54.29.&nbsp;Running CUnit tests</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"c"</span>
apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cunit"</span>

model {
    flavors {
        passing
        failing
    }
    repositories {
        libs(PrebuiltLibraries) {
            cunit {
                headers.srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"lib/cunit/2.1-2/include"</span>
                binaries.withType(StaticLibraryBinary) {
                    staticLibraryFile = file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"lib/cunit/2.1-2/lib/"</span> + findCUnitLibForPlatform(targetPlatform))
                }
            }
        }
    }
}

libraries {
    operators {}
}
binaries.withType(TestSuiteExecutableBinary) {
    lib library: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cunit"</span>, linkage: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"static"</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (flavor == flavors.failing) {
        cCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"PLUS_BROKEN"</span>
    }
}</pre>
       <div class="exampleLocation">
        <p><span class="emphasis"><em>注意︰</em> </span>此示例的代码可以在Gradle 的 binary 或 source 分发包的<code class="filename">samples/native-binaries/cunit</code>中找到。。<br><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/native-binaries/cunit</code> which is in both the binary and source distributions of Gradle.</p>
       </div>
      </div>
     </div>
     <br class="example-break">
     <pre class="screen">&gt; gradle -q runFailingOperatorsTestCUnitExe

There were test failures:
  1. /home/user/gradle/samples/native-binaries/cunit/src/operatorsTest/cunit/test_plus.c:6  - plus(0, -2) == -2
  2. /home/user/gradle/samples/native-binaries/cunit/src/operatorsTest/cunit/test_plus.c:7  - plus(2, 2) == 4

:runFailingOperatorsTestCUnitExe FAILED

BUILD FAILED

Total time: 1 secs</pre>
    </div>
    <div class="note">
     <p> 当前对 CUnit 的支持还是相当简陋。未来的集成计划包括： <br>The current support for CUnit is quite rudimentary. Plans for future integration include:</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem"><p>允许测试声明为 javadoc 风格的注解。</p><p>Allow tests to be declared with javadoc-style annotations.</p></li>
       <li class="listitem"><p>改进 HTML 报告，类似于 JUnit 提供的那样。</p><p>Improved HTML reporting, similar to that available for JUnit.</p></li>
       <li class="listitem"><p>测试执行的的实时反馈。</p><p>Real-time feedback for test execution.</p></li>
       <li class="listitem"><p>支持另外的测试框架。</p><p>Support for additional test frameworks.</p></li>
      </ul>
     </div>
    </div>
   </div>
  </div>
  <div class="navfooter">
   <div>
    <div class="navbar">
     <a xmlns:xslthl="http://xslthl.sf.net" href="signing_plugin.html" title="第五十三章. 签名插件">上一章</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南">目录</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="build_lifecycle.html" title="第55章. 构建的生命周期">下一章</a>
    </div>
   </div>
  </div>
 </body>
</html>
