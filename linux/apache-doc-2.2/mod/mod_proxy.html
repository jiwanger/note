<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta name="keywords" content="Apache, 中文, 手册, 中文版, 中文手册, 中文版手册, 参考手册, 中文参考手册, 金步国" />
<meta name="description" content="Apache 2.2 中文版参考手册" />
<meta name="author" content="金步国" />
<link href="../style/css/manual-zip.css" rel="stylesheet" media="all" type="text/css" title="Main stylesheet" />
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" media="all" type="text/css" title="No Sidebar - Default font size" />
<link href="../style/css/manual-print.css" rel="stylesheet" media="print" type="text/css" />
<title>mod_proxy － Apache 2.2 中文版参考手册</title>
</head>
<body><div id="page-header">
<p class="menu"><a href="index.html">模块索引</a> | <a href="directives.html">指令索引</a> | <a href="../faq/index.html">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">站点导航</a></p><p class="apache">Apache HTTP Server 版本2.2</p><img alt="" src="../images/feather.gif" /></div>
<div class="up"><a href="index.html"><img title="&lt;-" alt="&lt;-" src="../images/left.gif" /></a></div>
<div id="path"><a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP Server</a> &gt; <a href="http://httpd.apache.org/docs/">文档</a> &gt; <a href="../index.html">版本2.2</a> &gt; <a href="index.html">模块</a></div>

<div id="translation-info">　　 <a href="../translator_announcement.html#thanks">致谢</a> | 本篇译者：<a href="http://lamp.linux.gov.cn/jinbuguo_florilegium.html">金步国</a>(<a href="http://lamp.linux.gov.cn/jinbuguo_florilegium.html">其他作品</a>) | 本页最后更新：0000年00月00日[<a href="../translator_announcement.html#last_new" style="color:#F91C58">查看最新版本</a>] <a href="http://lamp.linux.gov.cn/Apache/ApacheMenu/index.html">电信镜像</a> <a href="http://lapp.unixmap.net/Apache/ApacheMenu/index.html">网通镜像</a></div>
<div id="page-content"><div id="preamble"><h1>Apache模块 mod_proxy</h1>

<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="module">
<tr><th><a href="module-dict.html#Description">说明</a></th><td>提供HTTP/1.1的代理/网关功能支持</td></tr>
<tr><th><a href="module-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="module-dict.html#ModuleIdentifier">模块名</a></th><td>proxy_module</td></tr>
<tr><th><a href="module-dict.html#SourceFile">源文件</a></th><td>mod_proxy.c</td></tr>
</table>
<h3>概述</h3>

    <div class="warning"><h3>警告</h3>
      <p>在您没有对服务器<a href="mod_proxy.html#access">采取安全措施</a>之前，请不要用<code class="directive"><a href="mod_proxy.html#proxyrequests">ProxyRequests</a></code>启用代理。一个开放的代理服务器不仅对您的网络有威胁，对整个因特网来说也同样如此。</p>
    </div>

    <p>此模块实现了Apache的代理/网关。它实现了以下规范的代理：<code>AJP13</code>(Apache JServe Protocol v1.3), <code>FTP</code>, <code>CONNECT</code>(用于SSL), <code>HTTP/0.9</code>, <code>HTTP/1.0</code>, <code>HTTP/1.1</code> 。此模块经配置后可用上述或其它协议连接其它代理模块。</p>

    <p>Apache的代理功能(除<code class="module"><a href="mod_proxy.html">mod_proxy</a></code>以外)被划分到了几个不同的模块中：<code class="module"><a href="mod_proxy_http.html">mod_proxy_http</a></code>, <code class="module"><a href="mod_proxy_ftp.html">mod_proxy_ftp</a></code>, <code class="module"><a href="mod_proxy_ajp.html">mod_proxy_ajp</a></code>, <code class="module"><a href="mod_proxy_balancer.html">mod_proxy_balancer</a></code>, <code class="module"><a href="mod_proxy_connect.html">mod_proxy_connect</a></code> 。这样，如果想使用一个或多个代理功能，就必须将<code class="module"><a href="mod_proxy.html">mod_proxy</a></code><em>和</em>对应的模块同时加载到服务器中(静态连接或用<code class="directive"><a href="mod_so.html#loadmodule">LoadModule</a></code>动态加载)。</p>

    <p>另外，其它模块还提供了扩展特性。<code class="module"><a href="mod_cache.html">mod_cache</a></code>及其相关模块提供了缓冲特性。<code class="module"><a href="mod_ssl.html">mod_ssl</a></code>提供的<code>SSLProxy*</code>系列指令可以使用SSL/TLS连接远程服务器。这些提供扩展特性的模块必须在被正确加载和配置以后才能提供这些扩展功能。</p>
</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="forwardreverse" id="forwardreverse">正向和反向代理</a></h2>
      <p>Apache可以被配置为<dfn>正向(forward)</dfn>和<dfn>反向(reverse)</dfn>代理。</p>

      <p><dfn>正向代理</dfn>是一个位于客户端和<em>原始服务器(origin server)</em>之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p>

      <p>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性(由<code class="module"><a href="mod_cache.html">mod_cache</a></code>提供)减少网络使用率。</p>

      <p>使用<code class="directive"><a href="mod_proxy.html#proxyrequests">ProxyRequests</a></code>指令即可激活正向代理。因为正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须<a href="mod_proxy.html#access">采取安全措施</a>以确保仅为经过授权的客户端提供服务。</p>

      <p><dfn>反向代理</dfn>正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。</p>

      <p>反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。</p>

      <p>可以使用<code class="directive"><a href="mod_proxy.html#proxypass">ProxyPass</a></code>指令激活反向代理(在<code class="directive"><a href="mod_rewrite.html#rewriterule">RewriteRule</a></code>指令中使用<code>[P]</code>标记也可以)。配置反向代理并<strong>不需要</strong>打开<code class="directive"><a href="mod_proxy.html#proxyrequests">ProxyRequests</a></code>指令。</p>
    </div><div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="examples" id="examples">简单示例</a></h2>

    <p>下面的例子仅仅是为了给你一个基本概念而帮助入门而已，请仔细阅读每个指令的文档。</p>

    <p>另外，如果想使用缓冲特性，请查看<code class="module"><a href="mod_cache.html">mod_cache</a></code>文档。</p>

    <div class="example"><h3>正向代理</h3><p><code>
    ProxyRequests On<br />
    ProxyVia On<br />
    <br />
    &lt;Proxy *&gt;<br />
    <span class="indent">
      Order deny,allow<br />
      Deny from all<br />
      Allow from internal.example.com<br />
    </span>
    &lt;/Proxy&gt;
    </code></p></div>

    <div class="example"><h3>反向代理</h3><p><code>
    ProxyRequests Off<br />
    <br />
    &lt;Proxy *&gt;<br />
    <span class="indent">
      Order deny,allow<br />
      Allow from all<br />
    </span>
    &lt;/Proxy&gt;<br />
    <br />
    ProxyPass /foo http://foo.example.com/bar<br />
    ProxyPassReverse /foo http://foo.example.com/bar
    </code></p></div>
    </div><div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="access" id="access">控制对代理服务器的访问</a></h2>
      <p>您可以通过<code class="directive"><a href="mod_proxy.html#proxy">&lt;Proxy&gt;</a></code>的阻止功能来控制谁能访问您的代理。示例如下：</p>

      <div class="example"><p><code>
        &lt;Proxy *&gt;<br />
        <span class="indent">
          Order Deny,Allow<br />
          Deny from all<br />
          Allow from 192.168.0<br />
        </span>
        &lt;/Proxy&gt;
      </code></p></div>

      <p>要了解更多访问控制信息，请参见<code class="module"><a href="mod_authz_host.html">mod_authz_host</a></code>文档。</p>

      <p>使用正向代理时严格控制访问权限(使用<code class="directive"><a href="mod_proxy.html#proxyrequests">ProxyRequests</a></code>指令)是非常重要的。否则你的代理会被客户端利用来访问其它服务器并且隐藏客户端的真实身份。这不仅对您的网络有威胁，对整个因特网来说也同样如此。当使用反向代理(在"<code>ProxyRequests Off</code>"条件下使用<code class="directive"><a href="mod_proxy.html#proxypass">ProxyPass</a></code>指令)的时候访问控制要相对宽松，因为客户端只能连接你配置的特定主机。</p>

    </div><div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="startup" id="startup">缓慢启动</a></h2>
      <p>如果您使用了<code class="directive"><a href="mod_proxy.html#proxyblock">ProxyBlock</a></code>指令，将会在启动时查找并缓存主机名的IP地址以备后继的匹配测试使用。这将会花费几秒或更长的时间，这主要取决于主机名查找的速度。</p>
    </div><div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="intranet" id="intranet">局域网代理</a></h2>
      <p>位于局域网内的Apache代理服务器需要经由公司的防火墙转发对外部的请求(使用<code class="directive"><a href="mod_proxy.html#proxyremote">ProxyRemote</a></code>指令来配置)。但当它访问局域网内的资源时，它能越过防火墙直接访问目的主机。在访问一个属于局域网的服务器从而进行直接连接时，<code class="directive"><a href="mod_proxy.html#noproxy">NoProxy</a></code>指令就会很有用。</p>

      <p>局域网内的用户习惯于不在他们的WWW请求中加入本地域的名称，于是会使用"http://somehost/"来取代<code>http://somehost.example.com/</code> 。一些商业代理服务器会不管这些，只是采用本地域的配置来简单的伺服这个请求。当使用了<code class="directive"><a href="mod_proxy.html#proxydomain">ProxyDomain</a></code>指令来为服务器<a href="mod_proxy.html#proxyrequests">配置了一个代理服务</a>时，Apache会发出一个重定向应答，以使客户端请求到达正确的、能满足要求的服务器地址。因为这样一来，用户的书签文件就会随之包含完整的主机名，所以这是首选的方法。</p>
    </div><div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="envsettings" id="envsettings">协议调整</a></h2>
      <p>当<code class="module"><a href="mod_proxy.html">mod_proxy</a></code>向一个没有正确实现持久连接(KeepAlive)或HTTP/1.1的原始服务器发送请求的时候，可以通过设置两个<a href="../env.html">环境变量</a>来发送不带持久连接(KeepAlive)的HTTP/1.0请求。这两个变量是通过<code class="directive"><a href="mod_env.html#setenv">SetEnv</a></code>指令设置的。</p>

      <p>以下是<code>force-proxy-request-1.0</code>和<code>proxy-nokeepalive</code>的例子：</p>

      <div class="example"><p><code>
        &lt;Location /buggyappserver/&gt;<br />
        <span class="indent">
          ProxyPass http://buggyappserver:7001/foo/<br />
          SetEnv force-proxy-request-1.0 1<br />
          SetEnv proxy-nokeepalive 1<br />
        </span>
        &lt;/Location&gt;
      </code></p></div>

    </div><div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="request-bodies" id="request-bodies">请求体</a></h2>

    <p>一些请求方法(如POST)包含一个请求体。HTTP协议要求包含请求体的请求或者使用块传输编码(chunked transfer encoding)或者包含一个<code>Content-Length</code>请求头。当将这种请求传递给原始服务器的时候，<code class="module"><a href="mod_proxy_http.html">mod_proxy_http</a></code>会始终尝试使用<code>Content-Length</code>请求头。但如果原始请求使用的是块编码，那么块编码也同样可以用于上行请求。可以使用<a href="../env.html">环境变量</a>控制这种选择。设置<code>proxy-sendcl</code>可以确保始终发送<code>Content-Length</code>头以与上游服务器保持最大程度的兼容性，而设置<code>proxy-sendchunked</code>可以通过继续使用块编码以尽可能最小化资源占用率。</p>

    </div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="AllowCONNECT" id="AllowCONNECT">AllowCONNECT</a> <a name="allowconnect" id="allowconnect">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>通过代理允许<code>CONNECT</code>的端口号</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>AllowCONNECT <var>port</var> [<var>port</var>] ...</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>AllowCONNECT 443 563</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">AllowCONNECT</code>指令指定了此代理的<code>CONNECT</code>方法可以连接的端口号列表。当今的浏览器在进行<code>https</code>连接请求时使用这种方法，而代理默认会将其转为<code>http</code>。</p>

    <p>默认只启用了默认的https端口(<code>443</code>)和默认的snews端口(<code>563</code>)。使用<code class="directive">AllowCONNECT</code>指令可以覆盖默认设置而改为仅允许连接列出的端口。</p>

    <p>注意，必须确保<code class="module"><a href="mod_proxy_connect.html">mod_proxy_connect</a></code>也同时存在于服务器中，这样才能支持<code>CONNECT</code> 。</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="NoProxy" id="NoProxy">NoProxy</a> <a name="noproxy" id="noproxy">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>直接进行连接的主机/域/网络</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>NoProxy <var>host</var> [<var>host</var>] ...</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p>此指令仅适用于局域网内的Apache代理服务器。<code class="directive">NoProxy</code>指令指定了一个中间以空格分隔的子网、IP地址、主机和/或域的列表。对某个匹配上述一个或多个列表项的主机的请求将直接被其伺服而不会转交到配置好的<code class="directive"><a href="mod_proxy.html#proxyremote">ProxyRemote</a></code>代理服务器。</p>

    <div class="example"><h3>示例</h3><p><code>
      ProxyRemote  *  http://firewall.mycompany.com:81<br />
      NoProxy         .mycompany.com 192.168.112.0/21
    </code></p></div>

    <p><code class="directive">NoProxy</code>指令的<var>host</var>参数可以是以下选项之一：</p>

    <dl>
    
    <dt><var><a name="domain" id="domain">域</a></var></dt>
    <dd>
    <p><dfn>域</dfn>是一个DNS域名的一部分，并在前面加上点号。它表示一批逻辑上属于同一个DNS区域的主机，也就是所有这些主机名具有相同的后缀，而这个"后缀"就是<dfn>域</dfn>。</p>

    <div class="example"><h3>例子</h3><p><code>
      .com<br />.apache.org.
    </code></p></div>

    <p><var>域</var>和<var><a href="mod_proxy.html#hostname">主机名</a></var>(一个DNS域甚至也可能有一条DNS"A记录"!)的不同之处在于<var>域</var>始终有一个前导点。</p>
    
    <div class="note"><h3>注意</h3>
      <p>域名不区分大小写并且始终认为是锚定在DNS树根上的，因此<code>.MyDomain.com</code>和<code>.mydomain.com.</code>(注意结尾点号)是完全等同的。因为域的比较不需要进行DNS查询，因此它比子网比较更加高效。</p>
    </div></dd>

    
    <dt><var><a name="subnet" id="subnet">子网</a></var></dt>
    <dd>
    <p><dfn>子网</dfn>以点分十进制形式表示了一个因特网地址的一部分，有时会跟着一个斜杠和子网掩码，以指定<var>子网</var>中的有效bit位。它用于表示主机通过自身的普通网络接口可以访问的子网范围。未指定子网掩码的时候就假定忽略掉的(或为零的)结尾数字就是掩码，在这种情况下，掩码bit长度必须是8bit的整数倍。例如：</p>

    <dl>
    <dt><code>192.168</code>或<code>192.168.0.0</code></dt>
    <dd>子网"<code>192.168.0.0</code>"表示掩码为16bit(有时也用<code>255.255.0.0</code>表示)。</dd>
    <dt><code>192.168.112.0/21</code></dt>
    <dd>子网"<code>192.168.112.0/21</code>"表示掩码为21bit(有时也用<code>255.255.248.0</code>表示)。</dd>
    </dl>

    <p>在退化到极限的情况下，一个掩码为32bit的<em>子网</em>就等价于一个<var><a href="mod_proxy.html#ipadr">IP地址</a></var>。而零个合法bit的<var>子网</var>("0.0.0.0/0")等价于常量"<var>_Default_</var>"，可以匹配任何IP地址。</p></dd>

    
    <dt><var><a name="ipaddr" id="ipaddr">IP地址</a></var></dt>
    <dd>
    <p><dfn>IP地址</dfn>以点分十进制形式表示了一个完整的因特网地址。一般来说，此地址代表一个主机，但并不需要一个DNS域名与这个地址对应。</p>
    <div class="example"><h3>示例</h3><p><code>
      192.168.123.7
    </code></p></div>
    
    <div class="note"><h3>注意</h3>
      <p>一个<var>IP地址</var>不需要为一个DNS系统所解析，所以它能使apache获取更高性能。</p>
    </div></dd>

    
    <dt><var><a name="hostname" id="hostname">主机名</a></var></dt>
    <dd>
    <p><dfn>主机名</dfn>是一个完整的DNS域名，可以通过DNS域名服务解析为一个或多个<var><a href="mod_proxy.html#ipaddr">IP地址</a></var>。它代表了一个逻辑主机(与<var><a href="mod_proxy.html#domain">域</a></var>相反)而且必须解析成至少一个<var><a href="mod_proxy.html#ipaddr">IP地址</a></var>(或经常解析成具有不同<var><a href="mod_proxy.html#ipaddr">IP地址</a></var>的主机列表)。</p>

    <div class="example"><h3>例子</h3><p><code>
      prep.ai.mit.edu<br />
      www.apache.org
    </code></p></div>

    <div class="note"><h3>注意</h3>
      <p>在很多情况下，指定一个<var><a href="mod_proxy.html#ipaddr">IP地址</a></var>代替<var>主机名</var>会更有效率。因为可以避免一次DNS查询。当使用一个低速的PPP与域名服务器连接时，Apache的域名解析会花费相当可观的时间。</p>
      <p><var>主机名</var>不区分大小写并且始终认为是锚定在DNS树根上的，因此<code>WWW.MyDomain.com</code>和<code>www.mydomain.com.</code>(注意结尾点号)是完全等同的。</p>
     </div></dd>
    </dl>

<h3>参见</h3>
<ul>
<li><a href="../misc/dns-caveats.html">DNS相关问题</a></li>
</ul>
</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="Proxy" id="Proxy">&lt;Proxy&gt;</a> <a name="proxy" id="proxy">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>应用于所代理资源的容器</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;Proxy <var>wildcard-url</var>&gt; ...&lt;/Proxy&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p>位于<code class="directive">&lt;Proxy&gt;</code>配置段中的指令仅作用于匹配的代理内容。语句中可以使用shell风格的通配符。</p>

    <p>比如说：下例仅允许<code>yournetwork.example.com</code>中的主机通过您的代理服务器访问代理内容：</p>

    <div class="example"><p><code>
      &lt;Proxy *&gt;<br />
      <span class="indent">
        Order Deny,Allow<br />
        Deny from all<br />
        Allow from yournetwork.example.com<br />
      </span>
      &lt;/Proxy&gt;
    </code></p></div>

    <p>下例将在所有<code>example.com</code>的<code>foo</code>目录下的文件通过代理服务器发送之前用<code>INCLUDES</code>过滤器进行处理：</p>

    <div class="example"><p><code>
      &lt;Proxy http://example.com/foo/*&gt;<br />
      <span class="indent">
        SetOutputFilter INCLUDES<br />
      </span>
      &lt;/Proxy&gt;
    </code></p></div>


</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyBadHeader" id="ProxyBadHeader">ProxyBadHeader</a> <a name="proxybadheader" id="proxybadheader">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>确定如何处理不合法的应答头</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyBadHeader IsError|Ignore|StartBody</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ProxyBadHeader IsError</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.0.44 及以后的版本中可用</td></tr>
</table>
    <p><code class="directive">ProxyBadHeader</code>指令决定<code class="module"><a href="mod_proxy.html">mod_proxy</a></code>如何处理不合法的应答头(比如丢失冒号(:))。参数的取值范围如下：</p>

    <dl>
    <dt><code>IsError</code></dt>
    <dd>以"502"(Bad Gateway)应答中止请求。这是默认行为。</dd>

    <dt><code>Ignore</code></dt>
    <dd>忽略，就像它们不存在一样。</dd>

    <dt><code>StartBody</code></dt>
    <dd>在接收到第一个非法头行时停止读取头，并将剩余部分当作应答体。这样做有助于和一个不规范的、经常忘记在应答头和应答体之间插入空行的后端服务器协同工作。</dd>
    </dl>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyBlock" id="ProxyBlock">ProxyBlock</a> <a name="proxyblock" id="proxyblock">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>设置被代理屏蔽的语句、主机、域</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyBlock *|<var>word</var>|<var>host</var>|<var>domain</var> [<var>word</var>|<var>host</var>|<var>domain</var>] ...</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">ProxyBlock</code>指令指定了一个由空格分隔的语句、主机和/或域的列表。对所有匹配这些语句、主机和/或域的HTTP、HTTPS、FTP文档的请求都将被代理服务器<em>阻断</em>。代理模块亦会在启动时尝试确定列表中可能是主机名的项目对应的IP地址，并将其缓冲用于匹配测试。比如说：</p>

    <div class="example"><h3>示例</h3><p><code>
      ProxyBlock joes-garage.com some-host.co.uk rocky.wotsamattau.edu
    </code></p></div>

    <p>通过IP地址，<code>rocky.wotsamattau.edu</code>将可能同样被匹配。</p>

    <p>请注意，<code>wotsamattau</code>已经足够匹配<code>wotsamattau.edu</code>了。</p>

    <p>请注意</p>

    <div class="example"><p><code>
      ProxyBlock *
    </code></p></div>

    <p>将屏蔽对所有站点的连接。</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyDomain" id="ProxyDomain">ProxyDomain</a> <a name="proxydomain" id="proxydomain">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>代理请求的默认域名</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyDomain <var>Domain</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p>此指令仅对位于局域网内的Apache代理服务器有用。<code class="directive">ProxyDomain</code>指令指定了apache代理服务器归属的默认域。如果遇到了一个对没有域名的主机的请求，就会根据配置自动生成一个加上了<var>Domain</var>的重定向应答。</p>

    <div class="example"><h3>示例</h3><p><code>
      ProxyRemote  *  http://firewall.mycompany.com:81<br />
      NoProxy         .mycompany.com 192.168.112.0/21<br />
      ProxyDomain     .mycompany.com
    </code></p></div>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyErrorOverride" id="ProxyErrorOverride">ProxyErrorOverride</a> <a name="proxyerroroverride" id="proxyerroroverride">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>覆盖代理内容的错误页</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyErrorOverride On|Off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ProxyErrorOverride Off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.0 及以后的版本中可用</td></tr>
</table>
    <p>此指令用于反向代理设置中您想为最终用户提供观感一致的错误页面时。它也同样允许包含文件(通过<code class="module"><a href="mod_include.html">mod_include</a></code>的SSI)获取错误号并作出相应的动作。(默认行为是显示被代理的服务器的错误页面，将此项目设为"On"将显示SSI错误信息。)</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyIOBufferSize" id="ProxyIOBufferSize">ProxyIOBufferSize</a> <a name="proxyiobuffersize" id="proxyiobuffersize">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>内部缓冲区大小</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyIOBufferSize <var>bytes</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ProxyIOBufferSize 8192</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">ProxyIOBufferSize</code>指令用于调整内部缓冲区(作为输入输出数据的暂存器)的大小。取值必须小于等于<code>8192</code> 。</p>

    <p>在绝大多数情况下，不需要调整这个设置。</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyMatch" id="ProxyMatch">&lt;ProxyMatch&gt;</a> <a name="proxymatch" id="proxymatch">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>应用于匹配正则表达式的代理资源的容器</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;ProxyMatch <var>regex</var>&gt; ...&lt;/ProxyMatch&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">&lt;ProxyMatch&gt;</code>和<code class="directive"><a href="mod_proxy.html#proxy">&lt;Proxy&gt;</a></code>指令基本相同，只是匹配字符串可以为<a class="glossarylink" href="../glossary.html#regex" title="see glossary">正则表达式</a>。</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyMaxForwards" id="ProxyMaxForwards">ProxyMaxForwards</a> <a name="proxymaxforwards" id="proxymaxforwards">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>转发请求的最大代理数目</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyMaxForwards <var>number</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ProxyMaxForwards 10</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.0 及以后的版本中可用</td></tr>
</table>
    <p><code class="directive">ProxyMaxForwards</code>指令指定了允许转发请求的最大代理数目。这个设置是为了避免无限代理循环或DoS攻击的发生。</p>

    <div class="example"><h3>示例</h3><p><code>
      ProxyMaxForwards 15
    </code></p></div>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyPass" id="ProxyPass">ProxyPass</a> <a name="proxypass" id="proxypass">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>将一个远端服务器映射到本地服务器的URL空间中</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyPass [<var>path</var>] !|<var>url</var> [<var>key=value</var> <var>key=value</var> ...]]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p>该指令允许你将一个远端服务器映射到本地服务器的URL空间中，此时本地服务器并不充当代理角色，而是充当远程服务器的一个镜像。<var>path</var>是一个本地虚拟路径名，<var>url</var>是一个指向远程服务器的部分URL，并且不允许包含查询字符串。</p>

    <div class="warning">当使用<code class="directive">ProxyPass</code>指令时，<code class="directive"><a href="mod_proxy.html#proxyrequests">ProxyRequests</a></code>指令通常应当被设为 <strong>off</strong> 。</div>

    <p>假设本地服务器地址是：<code>http://example.com/</code> ，那么，</p>

    <div class="example"><p><code>
      ProxyPass /mirror/foo/ http://backend.example.com/
    </code></p></div>

    <p>将会导致对<code>http://example.com/mirror/foo/bar</code>的本地请求将会在内部转换为一个代理请求：<code>http://backend.example.com/bar</code> 。</p>

    <p>"<code>!</code>"指令对于您不想对某个子目录进行反向代理时很有用。比如说：</p>

    <div class="example"><p><code>
      ProxyPass /mirror/foo/i !<br />
      ProxyPass /mirror/foo http://backend.example.com
    </code></p></div>

    <p>将会代理除<code>/mirror/foo/i</code>之外的所有对<code>backend.example.com</code>下<code>/mirror/foo</code>的请求。</p>

    <div class="note"><h3>注意</h3>
      <p>顺序很重要，您需要把拒绝指令放置在普通<code class="directive">ProxyPass</code>指令<em>之前</em>。</p>
    </div>

    <p>As of Apache 2.1, the ability to use pooled connections to a backend
    server is available. Using the <code>key=value</code> parameters it is
    possible to tune this connection pooling. The default for a <code>Hard
    Maximum</code> for the number of connections is the number of threads per
    process in the active MPM. In the Prefork MPM, this is always 1, while with
    the Worker MPM it is controlled by the
    <code class="directive">ThreadsPerChild</code>.</p>

    <p>Setting <code>min</code> will determine how many connections will always 
    be open to the backend server. Upto the Soft Maximum or <code>smax</code> 
    number of connections will be created on demand. Any connections above 
    <code>smax</code> are subject to a time to live or <code>ttl</code>.  Apache
    will never create more than the Hard Maximum or <code>max</code> connections
    to the backend server.</p>

    <div class="example"><p><code>
        ProxyPass /example http://backend.example.com smax=5 max=20 ttl=120 retry=300
    </code></p></div>

    <table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA">
<tr><th>Parameter</th><th>Default</th><th>Description</th></tr>
<tr><td>min</td><td>0</td><td>Minumum number of connections that will always
            be open to the backend server.</td></tr>
<tr><td>max</td><td>1...n</td><td>Hard Maximum number of connections that will be
    allowed to the backend server. The default for a Hard Maximum
    for the number of connections is the number of threads per process in the 
    active MPM. In the Prefork MPM, this is always 1, while with the Worker MPM
    it is controlled by the <code class="directive">ThreadsPerChild</code>.
    Apache will never create more than the Hard Maximum connections
    to the backend server.</td></tr>
<tr><td>smax</td><td>max</td><td>Upto the Soft Maximum
    number of connections will be created on demand. Any connections above 
    <code>smax</code> are subject to a time to live or <code>ttl</code>.
    </td></tr>
<tr><td>ttl</td><td>-</td><td>Time To Live for the inactive connections above the
        <code>smax</code> connections in seconds. Apache will close all
        connections that has not been used inside that time period.
    </td></tr>
<tr><td>timeout</td><td><code class="directive">Timeout</code></td><td>Connection timeout in seconds.
        If not set the Apache will wait until the free connection
        is available. This directive is used for limiting the number
        of connections to the backend server together with <code>max</code>
        parameter.
    </td></tr>
<tr><td>acquire</td><td>-</td><td>If set this will be the maximum time to wait for a free
    connection in the connection pool. If there are no free connections
    in the pool the Apache will return <code>SERVER_BUSY</code> status to
    the client.
    </td></tr>
<tr><td>keepalive</td><td>Off</td><td>This parameter should be used when you have a firewall between your
    Apache and the backend server, who tend to drop inactive connections.
    This flag will tell the Operating System to send <code>KEEP_ALIVE</code>
    messages on inactive connections (interval depends on global OS settings,
    generally 120ms), and thus prevent the firewall to drop the connection.
    To enable keepalive set this property value to <code>On</code>. 
    </td></tr>
<tr><td>retry</td><td>60</td><td>Connection pool worker retry timeout in seconds.
    If the connection pool worker to the backend server is in the error state,
    Apache will not forward any requests to that server until the timeout
    expires. This enables to shut down the backend server for maintenance,
    and bring it back online later.
    </td></tr>
<tr><td>loadfactor</td><td>1</td><td>Worker load factor. Used with BalancerMember.
         It is a number between 1 and 100 and defines the normalized weighted
         load applied to the worker.
    </td></tr>
<tr><td>route</td><td>-</td><td>Route of the worker when used inside load balancer.
        The route is a value appended to seesion id.
    </td></tr>
<tr><td>redirect</td><td>-</td><td>Redirection Route of the worker. This value is usually
        set dynamically to enable safe removal of the node from
        the cluster. If set all requests without session id will be
        redirected to the BalancerMember that has route parametar
        equal as this value.
    </td></tr>
</table>

    <p>If the Proxy directive scheme starts with the
    <code>balancer://</code> then a virtual worker that does not really
    communicate with the backend server will be created. Instead it is responsible
    for the management of several "real" workers. In that case the special set of
    parameters can be add to this virtual worker.
    </p>
    <table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA">
<tr><th>Parameter</th><th>Default</th><th>Description</th></tr>
<tr><td>lbmethod</td><td>-</td><td>Balancer load-balance method. Select the load-balancing scheduler
        method to use. Either <code>byrequests</code>, to perform weighted
        request counting or <code>bytraffic</code>, to perform weighted
        traffic byte count balancing. Default is <code>byrequests</code>.
    </td></tr>
<tr><td>stickysession</td><td>-</td><td>Balancer sticky session name. The value is usually set to something
        like <code>JSESSIONID</code>或<code>PHPSESSIONID</code>,
        and it depends on the backend application server that support sessions.
    </td></tr>
<tr><td>nofailover</td><td>Off</td><td>If set to <code>On</code> the session will break if the worker is in
        error state or disabled. Set this value to On if backend servers do not
        support session replication.
    </td></tr>
<tr><td>timeout</td><td>0</td><td>Balancer timeout in seconds. If set this will be the maximum time
        to wait for a free worker. Default is not to wait. 
    </td></tr>
<tr><td>maxattempts</td><td>1</td><td>Maximum number of failover attempts before giving up. 
    </td></tr>
</table>
    <div class="example"><p><code>
      ProxyPass /special-area http://special.example.com/ smax=5 max=10<br />
      ProxyPass / balancer://mycluster stickysession=jsessionid nofailover=On<br />
      &lt;Proxy balancer://mycluster&gt;<br />
      <span class="indent">
        BalancerMember http://1.2.3.4:8009<br />
        BalancerMember http://1.2.3.5:8009 smax=10<br />
        # Less powerful server, don't send as many requests there<br />
        BalancerMember http://1.2.3.6:8009 smax=1 loadfactor=20<br />
      </span>
      &lt;/Proxy&gt;
    </code></p></div>
    
    <p>When used inside a <code class="directive"><a href="core.html#location">&lt;Location&gt;</a></code> section, the first argument is omitted and the local
    directory is obtained from the <code class="directive"><a href="core.html#location">&lt;Location&gt;</a></code>.</p>

    <p>If you require a more flexible reverse-proxy configuration, see the
    <code class="directive"><a href="mod_rewrite.html#rewriterule">RewriteRule</a></code> directive with the
    <code>[P]</code> flag.</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyPassReverse" id="ProxyPassReverse">ProxyPassReverse</a> <a name="proxypassreverse" id="proxypassreverse">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>调整由反向代理服务器发送的HTTP应答头中的URL</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyPassReverse [<var>path</var>] <var>url</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p>此指令使Apache调整HTTP重定向应答中<code>Location</code>, <code>Content-Location</code>, <code>URI</code>头里的URL。这样可以避免在Apache作为反向代理使用时，后端服务器的HTTP重定向造成的绕过反向代理的问题。</p>

    <p>只有明确指定的应答头会被重写，其它应答头保持不变，并且HTML页面中的URL也不会被修改。如果被代理的内容包含绝对URL引用，那么将会绕过代理。有一个第三方模块可以检查并改写HTML中的URL引用，该模块就是Nick
    Kew编写的<a href="http://apache.webthing.com/mod_proxy_html/">mod_proxy_html</a>。</p>

    <p><var>path</var>是本地虚拟路径的名称。<var>url</var>是远端服务器的部分URL。与<code class="directive"><a href="mod_proxy.html#proxypass">ProxyPass</a></code>指令中的使用方法相同。</p>

    <p>例如，假定本地服务器拥有地址<code>http://example.com/</code> ，那么</p>

    <div class="example"><p><code>
      ProxyPass         /mirror/foo/ http://backend.example.com/<br />
      ProxyPassReverse  /mirror/foo/ http://backend.example.com/<br />
      ProxyPassReverseCookieDomain  backend.example.com  public.example.com<br />
      ProxyPassReverseCookiePath  /  /mirror/foo/
    </code></p></div>

    <p>不仅会把所有对<code>http://example.com/mirror/foo/bar</code>的请求直接转换为对<code>http://backend.example.com/bar</code>的代理请求(由<code>ProxyPass</code>提供的功能)，它还会重定向服务器<code>backend.example.com</code>的发送：当<code>http://backend.example.com/bar</code>被它重定向到<code>http://backend.example.com/quux</code>时，Apache会在转交HTTP重定向应答到客户端之前调整它为<code>http://example.com/mirror/foo/quux</code> 。注意：被用于构建URL的主机名与<code class="directive"><a href="core.html#usecanonicalname">UseCanonicalName</a></code>指令的设置有关。</p>

    <p>注意，此<code class="directive">ProxyPassReverse</code>指令亦可与<code class="module"><a href="mod_rewrite.html">mod_rewrite</a></code>的代理穿透特性(<code>RewriteRule ...  [P]</code>)联用。因为它不依赖于相应的<code class="directive"><a href="mod_proxy.html#proxypass">ProxyPass</a></code>指令。</p>

    <p>当在<code class="directive"><a href="core.html#location">&lt;Location&gt;</a></code>配置段中使用时，第一个参数会被忽略而采用由<code class="directive"><a href="core.html#location">&lt;Location&gt;</a></code>指令指定的本地目录。</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyPassReverseCookieDomain" id="ProxyPassReverseCookieDomain">ProxyPassReverseCookieDomain</a> <a name="proxypassreversecookiedomain" id="proxypassreversecookiedomain">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>Adjusts the Domain string in Set-Cookie headers from a reverse-
proxied server</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyPassReverseCookieDomain <var>internal-domain</var> <var>public-domain</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
<p>Usage is basically similar to
<code class="directive"><a href="mod_proxy.html#proxypassreverse">ProxyPassReverse</a></code>, but instead of
rewriting headers that are a URL, this rewrites the <code>domain</code>
string in <code>Set-Cookie</code> headers.</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyPassReverseCookiePath" id="ProxyPassReverseCookiePath">ProxyPassReverseCookiePath</a> <a name="proxypassreversecookiepath" id="proxypassreversecookiepath">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>Adjusts the Path string in Set-Cookie headers from a reverse-
proxied server</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyPassReverseCookiePath <var>internal-path</var> <var>public-path</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
<p>Usage is basically similar to
<code class="directive"><a href="mod_proxy.html#proxypassreverse">ProxyPassReverse</a></code>, but instead of
rewriting headers that are a URL, this rewrites the <code>path</code>
string in <code>Set-Cookie</code> headers.</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyPreserveHost" id="ProxyPreserveHost">ProxyPreserveHost</a> <a name="proxypreservehost" id="proxypreservehost">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>使用进入的HTTP请求头来发送代理请求</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyPreserveHost On|Off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ProxyPreserveHost Off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.0.31 及以后的版本中可用</td></tr>
</table>
    <p>当启用时，此选项将把传入请求的"Host:"行传递给被代理的主机，而不是传递在<code class="directive">ProxyPass</code>中指定的主机名。</p>

    <p>此选项一般为<code>Off</code>状态。It is mostly 
    useful in special configurations like proxied mass name-based virtual
    hosting, where the original Host header needs to be evaluated by the
    backend server.</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyReceiveBufferSize" id="ProxyReceiveBufferSize">ProxyReceiveBufferSize</a> <a name="proxyreceivebuffersize" id="proxyreceivebuffersize">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>代理HTTP和FTP连接的接收缓冲区大小(字节)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyReceiveBufferSize <var>bytes</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ProxyReceiveBufferSize 0</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">ProxyReceiveBufferSize</code>指令为增加的吞吐量指定了代理HTTP和FTP连接的(TCP/IP)网络接收缓冲区。这个值必须大于<code>512</code> ，或设置为"<code>0</code>"表示使用系统默认的缓冲大小。</p>

    <div class="example"><h3>示例</h3><p><code>
      ProxyReceiveBufferSize 2048
    </code></p></div>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyRemote" id="ProxyRemote">ProxyRemote</a> <a name="proxyremote" id="proxyremote">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于处理某些特定请求的远端代理</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyRemote <var>match</var> <var>remote-server</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p>此指令定义了此代理的远端代理。<var>match</var>可以是远端服务器支持的URL形式的名称、或是远端服务器使用的部分URL、或是代表服务器可以接受所有请求的"<code>*</code>"。<var>remote-server</var>是远端服务器的部分URL。语法为：</p>

    <div class="example"><p><code>
      <dfn>remote-server</dfn> = <var>scheme</var>://<var>hostname</var>[:<var>port</var>]
    </code></p></div>

    <p><var>scheme</var>是与远端服务器交换信息时使用的协议；本模块暂时只支持<code>http</code>协议。</p>

    <div class="example"><h3>示例</h3><p><code>
      ProxyRemote http://goodguys.com/ http://mirrorguys.com:8000<br />
      ProxyRemote * http://cleversite.com<br />
      ProxyRemote ftp http://ftpproxy.mydomain.com:8080
    </code></p></div>

    <p>在最后一个例子中，代理会将封装到另外一个HTTP代理请求中的FTP请求转交到另外一个能处理它们的代理去。</p>

    <p>此选项也支持反向代理配置：一个后端web服务器可以被嵌入到一个虚拟主机的URL空间中，哪怕它是由另一个代理转交过来的。</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyRemoteMatch" id="ProxyRemoteMatch">ProxyRemoteMatch</a> <a name="proxyremotematch" id="proxyremotematch">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>处理匹配正则表达式的请求的远端代理</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyRemoteMatch <var>regex</var> <var>remote-server</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p><code class="directive">ProxyRemoteMatch</code>与<code class="directive"><a href="mod_proxy.html#proxyremote">ProxyRemote</a></code>令基本相同。除了第一个参数是由一个请求的URL变成了匹配的<a class="glossarylink" href="../glossary.html#regex" title="see glossary">正则表达式</a>。</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyRequests" id="ProxyRequests">ProxyRequests</a> <a name="proxyrequests" id="proxyrequests">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>启用正向(标准)代理请求</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyRequests On|Off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ProxyRequests Off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p>此指令将允许或禁止Apache作为正向代理服务器的功能(设置为<code>Off</code>并不会禁用<code class="directive"><a href="mod_proxy.html#proxypass">ProxyPass</a></code>指令)。</p>

    <p>在一个典型的反向代理配置中，此可选项一般设置为<code>Off</code>。</p>

    <p>为了能够代理HTTP或FTP站点，<code class="module"><a href="mod_proxy_http.html">mod_proxy_http</a></code>或<code class="module"><a href="mod_proxy_ftp.html">mod_proxy_ftp</a></code>必须同时存在于服务器中。</p>

    <div class="warning"><h3>警告</h3>
      <p>在您没有对服务器<a href="mod_proxy.html#access">采取安全措施</a>之前，请不要用<code class="directive"><a href="mod_proxy.html#proxyrequests">ProxyRequests</a></code>启用您的代理。一个开放的代理服务器不仅对您的网络有威胁，对整个因特网来说也同样如此。</p>
    </div>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyTimeout" id="ProxyTimeout">ProxyTimeout</a> <a name="proxytimeout" id="proxytimeout">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>代理请求的网络超时</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyTimeout <var>seconds</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ProxyTimeout 300</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.0.31 及以后的版本中可用</td></tr>
</table>
    <p>此指令允许用户对代理请求指定一个超时值。当你有一个很慢/错误多多的应用服务器经常挂起，而您宁愿返回一个超时的失败信息也不愿意继续等待不知道多久的时候，这个功能是很有用的。</p>

</div>
<div class="top"><a href="mod_proxy.html#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ProxyVia" id="ProxyVia">ProxyVia</a> <a name="proxyvia" id="proxyvia">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>控制代理对<code>Via</code>应答头的使用</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ProxyVia On|Off|Full|Block</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ProxyVia Off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_proxy</td></tr>
</table>
    <p>此指令控制代理对"<code>Via:</code>"头的使用。它的目的是控制位于代理服务器链中的代理请求的流向。参阅<a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>(HTTP/1.1)14.45小节以获得关于"<code>Via:</code>"头的解释。</p>

    <ul>
    <li>如果设置为默认值<code>Off</code> ，将不会采取特殊的处理。如果一个请求或应答包含"<code>Via:</code>"头，将不进行任何修改而直接通过。</li>

    <li>如果设置为<code>On</code>每个请求和应答都会对应当前主机得到一个"<code>Via:</code>"头。</li>

    <li>如果设置为<code>Full</code> ，每个产生的"<code>Via:</code>"头中都会额外加入Apache服务器的版本，以"<code>Via:</code>"注释域出现。</li>

    <li>如果设置为<code>Block</code> ，每个代理请求中的所有"<code>Via:</code>"头行都将被删除。且不会产生新的"<code>Via:</code>"头。</li>
    </ul>

</div>
</div>
<div id="footer">
<p class="apache">本文允许自由使用、分发、转载，但必须保留译者署名；详见：<a href="../translator_announcement.html#announcement">译者声明</a>。</p>
<p class="menu"><a href="index.html">模块索引</a> | <a href="directives.html">指令索引</a> | <a href="../faq/index.html">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">站点导航</a></p></div>
</body></html>
