<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width， initial-scale=1， maximum-scale=1， user-scalable=no">
<meta name="keywords" content="key1， key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--GROOVY</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					style="position: fixed; top: 70px; width: 260px; height: 85%; overflow: auto; float: left;">
					<div class="panel-heading">
						<h3 class="panel-title">GROOVY</h3>
					</div>
					<div class="list-group">
						<a href="#groovy-intro" class="list-group-item">简介</a>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#groovy-user-guide"
							aria-expanded="true">
							Groovy 用户指南<span class="caret pull-right"
								style="margin-top: 5px;"></span>
						</a>
						<div id="groovy-user-guide" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#groovy-install" class="list-group-item">Linux 下安装</a>
							<a href="#groovy-java" class="list-group-item">Groovy vs Java</a>
							<a href="#groovy-devlopment" class="list-group-item">Groovy
								开发套件</a>
							<a href="#groovy-meta" class="list-group-item">元编程</a>
							<a href="#groovy-dependency" class="list-group-item">依赖管理</a>
						</div>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#groovy-base" aria-expanded="true">
							Groovy 基础<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="groovy-base" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#groovy-syntax" class="list-group-item">1. 语法基础</a>
							<a href="#groovy-operator" class="list-group-item">2. 操作符</a>
							<a href="#groovy-structure" class="list-group-item">3. 程序结构</a>
							<a href="#groovy-object" class="list-group-item">4. 面向对象</a>
							<a href="#groovy-closure" class="list-group-item">5. 闭包</a>
							<a href="#groovy-semantics" class="list-group-item">6. 语义</a>
						</div>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#groovy-tools"
							aria-expanded="true">
							Groovy 工具<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="groovy-tools" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#groovy-groovyc" class="list-group-item">
								<code>groovyc</code>
							</a>
							<a href="#groovy-groovysh" class="list-group-item">
								<code>groovysh</code>
							</a>
							<a href="#groovy-groovy-console" class="list-group-item">
								<code>groovyConsole</code>
							</a>
							<a href="#groovy-ide" class="list-group-item">IDE 集成</a>
						</div>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#groovy-kit" aria-expanded="true">
							Groovy组件指南<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="groovy-kit" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#groovy-json" class="list-group-item">解码和编码JSON</a>
							<a href="#groovy-xml" class="list-group-item">处理XML</a>
							<a href="#groovy-db" class="list-group-item">使用关系型数据库</a>
							<a href="#groovy-ant" class="list-group-item">Ant脚本任务</a>
							<a href="#groovy-template" class="list-group-item">模板引擎</a>
							<a href="#groovy-swing" class="list-group-item">创建 Swing UI</a>
							<a href="#groovy-servlet" class="list-group-item">Servlet 支持</a>
							<a href="#groovy-jmx" class="list-group-item">使用 JMX</a>
						</div>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<a class="offset" id="groovy-intro"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<p>Groovy…</p>
						<ul>
							<li>一个基于 JVM 的动态敏捷编程语言</li>
							<li>构建于 Java 的优势之上，并且额外拥有很多来源于 Python、Ruby 和 SmallTalk
								等语言的强大特性</li>
							<li>Java 开发者零学习曲线使用现代语言编程特性</li>
							<li>执行静态类型检查和静态编译代码的健壮性和性能</li>
							<li>支持领域专用语言(Domain-Specific
								Language/DSL)，紧凑的表达式可以使代码更加易读和维护</li>
							<li>强大的处理原语、面向对象程序设计能力、Ant DSL 使编写 shell 和构建脚本更加简单</li>
							<li>在开发WEB应用、数据库应用、控制台应用中通过减少脚手架代码提高开发者效率</li>
							<li>支持单元测试和开箱即用的 MOCK</li>
							<li>无缝集成现在有的 Java 类和库</li>
							<li>直接编译为 Java 字节码，所以你可以任何能使用 Java 的的地方使用它</li>
						</ul>

						<p>
							<b>Groovy 文档</b>
						</p>
						<p>
							官方文档表格版本 --
							<a href="http://groovy-lang.org/documentation.html"
								target="_blank">Groovy 官方文档表格版本</a>
							&nbsp;&nbsp;部分译文 --
							<a href="http://ifeve.com/groovy-guide/" target="_blank">并发编程网
								译文</a>
						</p>
						<p>
							groovy 本地文档 --
							<a href="docs/javadoc/index.html" target="_blank">groovy 本地文档</a>
						</p>
						<p>
							groovy-jdk 文档 --
							<a href="docs/groovy-jdk/index.html" target="_blank">groovy-jdk
								本地文档</a>
						</p>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="groovy-install"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Linux 下安装</h3>
					</div>
					<div class="panel-body">
						<p>
							<code>SDKMAN</code>
							工具让在Bash平台（mac，Linux， Cygwin， Solaris， FreeBSD）安装 Groovy 变得非常简单。
						</p>
						<pre class="brush: bash;">
# 根据屏幕提示完成安装 SDKMAN
$ curl -s get.sdkman.io | bash

# 初始化 SDKMAN 环境
$ source "$HOME/.sdkman/bin/sdkman-init.sh"

# SDKMAN 安装 groovy
$ sdk install groovy

# 查看 groovy 版本信息
$ groovy -v
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="groovy-java"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Groovy 与 Java</h3>
					</div>
					<div class="panel-body">
						<table class="table table-bordered table-responsive">
							<tr>
								<th>比较</th>
								<th>Groovy</th>
								<th>Java</th>
							</tr>
							<tr>
								<td><b>默认导入</b></td>

								<td><ul>
										<li>java.io.*</li>
										<li>java.lang.*</li>
										<li>java.math.BigDecimal</li>
										<li>java.math.BigInteger</li>
										<li>java.net.*</li>
										<li>java.util.*</li>
										<li>groovy.lang.*</li>
										<li>groovy.util.*</li>
									</ul></td>
								<td><ul>
										<li>java.lang.*</li>
									</ul></td>
							</tr>
							<tr>
								<td><b>动态方法</b></td>
								<td><p>在Groovy里，方法的调用是在运行时动态决定。这一特性叫做运行时分发(runtime
										dispatch)或动态方法(multi-methods)。也就是说方法的最后调用是根据传入参数在运行时的类型所决定。</p> <pre
										class="brush: groovy; gutter: false;">
public class Groovy {

    public static int method(String arg) {
        return 1;
    }

    public static int method(Object arg) {
        return 2;
    }

    public static void main(String[] args) {
        Object o = "Object";
        int result = method(o);
        // Groovy 中运行得到结果 1
        println("Groovy: " + result);
    }

}
</pre></td>
								<td>在Java里，这一点是不一样的：在编译时就决定了方法的参数类型。 <pre
										class="brush: java;gutter: false;">
public class Java {

    public static int method(String arg) {
        return 1;
    }

    public static int method(Object arg) {
        return 2;
    }

    public static void main(String[] args) {
        Object o = "Object";
        int result = method(o);
        // Java 中运行结果为 2
        System.out.println("Java: " + result);
    }

}
</pre>
								</td>
							</tr>
							<tr>
								<td><b>数组初始化</b></td>
								<td>在Groovy，{…}已经被用作闭包，也就是说你不能使用下面的语法创建数组。<code>int[]
										array = [1，2，3] </code></td>
								<td><code>int[] array = { 1， 2， 3}</code></td>
							</tr>
							<tr>
								<td><b>包范围可见性</b></td>
								<td>在Groovy里，省略字段的修饰符不会像Java一样使其成为包私有属性</td>
								<td></td>
							</tr>
							<tr>
								<td><b>ARM块</b></td>
								<td></td>
								<td></td>
							</tr>
							<tr>
								<td><b>内部类</b></td>
								<td></td>
								<td></td>
							</tr>
							<tr>
								<td><b>拉姆达表达式</b></td>
								<td></td>
								<td></td>
							</tr>
							<tr>
								<td><b>GStrings</b></td>
								<td></td>
								<td></td>
							</tr>
							<tr>
								<td><b>字符串和字符</b></td>
								<td></td>
								<td></td>
							</tr>
							<tr>
								<td><b>== 的行为</b></td>
								<td></td>
								<td></td>
							</tr>
						</table>
					</div>
				</div>
				<!-- item over -->


				<!-- item start -->
				<a class="offset" id="groovy-devlopment"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Groovy 开发套件</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">1. 使用 I/O</h5>
							<p>Groovy提供了丰富的方法来操作IO流。当然你也可以使用标准的Java代码来进行这些操作。但是Groovy提供了更多方便的方式来操作文件，流…</p>
							<ul>
								<li>
									the io.File class :
									<a
										href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html"
										onclick="javascript:window.open('http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html'); return false;">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a>
								</li>
								<li>
									the io.InputStream class:
									<a
										href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html"
										onclick="javascript:window.open('http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html'); return false;">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a>
								</li>
								<li>
									the io.OutputStream class:
									<a
										href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html"
										onclick="javascript:window.open('http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html'); return false;">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html</a>
								</li>
								<li>
									the io.Reader class:
									<a
										href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html"
										onclick="javascript:window.open('http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html'); return false;">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html</a>
								</li>
								<li>
									the io.Writer class:
									<a
										href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html"
										onclick="javascript:window.open('http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html'); return false;">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html</a>
								</li>
								<li>
									the nio.file.Path class:
									<a
										href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html"
										onclick="javascript:window.open('http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html'); return false;">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html</a>
								</li>
							</ul>

						</div>

						<div class="sub-item">
							<p>
								<b>1.1 读取文本文件</b> -- 参阅
								<code>java.io.File</code>
								,
								<code>java.io.inputStream</code>
								类
							</p>
							<pre class="brush: groovy;">
def baseDir = "./test"

new File(baseDir, 'file.txt').eachLine {
    println it
}

new File("./test/file.txt").eachLine { content, line ->
    println "$line. $content"
}

/** 将文件读取到 list 中 */
def list = new File(baseDir, 'file.txt').collect { it }

for (line in list) {
    println line
}

/** 使用 as 方法将一个文件内容放到一个数组中 */
def array = new File(baseDir, 'file.txt') as String[]
println array[0]

/** inputstream, 这个方式需要你手动关闭输入流 */
def is = new File(baseDir,'file.txt').newInputStream()
// do something ...
is.close()

/** 更简单的方法 */
new File(baseDir,'file.txt').withInputStream { stream ->
	// do something ...
}
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>1.2 写文件</b> -- 参阅
								<code>java.io.Writer</code>
								,
								<code>java.io.OutputStream</code>
								类
							</p>
							<pre class="brush: groovy;">
def baseDir = "./test"

/** 写文本文件 */
new File(baseDir, 'haiku.txt').withWriter('utf-8') { writer ->
    writer.writeLine 'Into the ancient pond'
    writer.writeLine 'A frog jumps'
    writer.writeLine 'Water’s sound!'
}

/** 使用 &lt;&lt; 操作符写文件 */
new File(baseDir, 'haiku.txt') &lt;&lt; '''Into the ancient pond
A frog jumps
Water’s sound!'''

/** outputstream, 这个方式需要你手动关闭输入流 */
def os = new File(baseDir,'data.bin').newOutputStream()
// do something ...
os.close()

/** 更简单的方法 */
new File(baseDir,'file.txt').withOutpoutStream { stream ->
	// do something ...
}
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>1.3 遍历文件树</b> -- 在脚本上下文里，一种很常见的场景是遍历文件树来找到特定的文件进行特定的处理。Groovy
								提供了多种方法来做这个事情。
							</p>
							<pre class="brush: groovy;">
def baseDir = "./file"

def dir = new File(baseDir)
/** 遍历文件 */
dir.eachFile { file ->
    println file.name
}

/** 正则指定文件 */
dir.eachFileMatch(~/.*\.txt/) { file ->
    println file.name
}


baseDir = "."
dir = new File(baseDir)

/** 深层次文件 */
dir.eachFileRecurse { file ->
    println file.name
}

/** 指定类型为文件 */
dir.eachFileRecurse(FileType.FILES) { file ->
    println file.name
}
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>1.4 数据和对象</b> -- 在 Java 里，使用
								<code>java.io.DataOutputStream</code>
								和
								<code>java.io.DataInputStream</code>
								类来序列化和反序列化数据是非常常见的。Groovy
								里，这步操作将变得更加容易，比如，你可以序列化数据到一个文件然后使用下面的代码反序列：
							</p>
							<pre class="brush: groovy;">
def fileName = "./file/serialize.bin"

def file = new File(fileName)

boolean b = true
String message = 'Hello from Groovy'

// 序列化数据，写入文件
file.withDataOutputStream { out ->
    out.writeBoolean(b)
    out.writeUTF(message)
}

// 从文件反序列化读取数据
file.withDataInputStream { input ->
    assert input.readBoolean() == b
    assert input.readUTF() == message
}


// 序列化和反序列化 Object 
class Person implements Serializable {
    def name
    def age
} 

file = new File("./file/person.bin")

Person p = new Person(name:'Bob', age:28)

// 写一对象
file.withObjectOutputStream { out ->
    out.writeObject(p)
}

// 读取对象
file.withObjectInputStream { input ->
    def p2 = input.readObject()
    assert p2.name == p.name
    assert p2.age == p.age
}
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>1.5 执行外部进程</b> -- Groovy 提供了一种简单的方式来执行命令行进程。仅仅需要将命令行写成字符串然后调用
								execute 方法。
							</p>
							<pre class="brush: groovy;">
def process = "ls -l".execute()
// java.lang.Process 类
process.in.eachLine { line ->
    println line
}
</pre>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">2. 使用集合</h5>
							<p>Groovy 提供了各种类型的原生态集合支持，包括 list, maps 和 ranges 。它们大多数都是基于
								Java 集合类型，同时在 Java 集合类型中一些废弃的方法在 Groovy 开发套件中也可以找到。</p>
						</div>

						<div class="sub-item">
							<p>
								<b>2.1 List -- 每一个 list 表达式都是 <code>java.util.ArrayList</code>
									的一个实现。
								</b>
							</p>
							<pre class="brush: groovy;">
def list = [5, 6, 7, 8]

assert list.get(2) == 7
assert list[2] == 7
assert list instanceof java.util.List			// is a java.util.List
assert list instanceof java.util.ArrayList		// is a java.util.ArrayList

def emptyList = []
assert emptyList.size() == 0
emptyList.add(5)
assert emptyList.size() == 1

def list1 = ['a', 'b', 'c']
def list2 = new ArrayList(list1)

assert list2 == list1
def list3 = list1.clone()
assert list3 == list1

// 构造一个新的 List
def list1 = ['a', 'b', 'c']
//construct a new list, seeded with the same items as in list1
def list2 = new ArrayList&lt;String>(list1)

assert list2 == list1 // == checks that each corresponding element is the same

// clone() can also be called
def list3 = list1.clone()
assert list3 == list1

// list 作为一个 boolean 表达式
assert ![]             // an empty list evaluates as false

//all other lists, irrespective of contents, evaluate as true
assert [1] && ['a'] && [0] && [0.0] && [false] && [null]


// list迭代
[1, 2, 3].each {
    println "Item: $it" // `it` is an implicit parameter corresponding to the current element
}
['a', 'b', 'c'].eachWithIndex { it, i -> // `it` is the current element, while `i` is the index
    println "$i: $it"
}

// 通过使用迭代，还可以将某些元素转换为另外一种元素来创建一个新的集合
assert [1, 2, 3].collect { it * 2 } == [2, 4, 6]

// shortcut syntax instead of collect
assert [1, 2, 3]*.multiply(2) == [1, 2, 3].collect { it.multiply(2) }

def list = [0]
// it is possible to give `collect` the list which collects the elements
assert [1, 2, 3].collect(list) { it * 2 } == [0, 2, 4, 6]
assert list == [0, 2, 4, 6]

// 过滤和搜索
assert [1, 2, 3].find { it > 1 } == 2           // find 1st element matching criteria
assert [1, 2, 3].findAll { it > 1 } == [2, 3]   // find all elements matching critieria
assert ['a', 'b', 'c', 'd', 'e'].findIndexOf {      // find index of 1st element matching criteria
    it in ['c', 'e', 'g']
} == 2

assert ['a', 'b', 'c', 'd', 'c'].indexOf('c') == 2  // index returned
assert ['a', 'b', 'c', 'd', 'c'].indexOf('z') == -1 // index -1 means value not in list
assert ['a', 'b', 'c', 'd', 'c'].lastIndexOf('c') == 4

assert [1, 2, 3].every { it < 5 }               // returns true if all elements match the predicate
assert ![1, 2, 3].every { it < 3 }
assert [1, 2, 3].any { it > 2 }                 // returns true if any element matches the predicate
assert ![1, 2, 3].any { it > 3 }

assert [1, 2, 3, 4, 5, 6].sum() == 21                // sum anything with a plus() method
assert ['a', 'b', 'c', 'd', 'e'].sum {
    it == 'a' ? 1 : it == 'b' ? 2 : it == 'c' ? 3 : it == 'd' ? 4 : it == 'e' ? 5 : 0
    // custom value to use in sum
} == 15
assert ['a', 'b', 'c', 'd', 'e'].sum { ((char) it) - ((char) 'a') } == 10
assert ['a', 'b', 'c', 'd', 'e'].sum() == 'abcde'
assert [['a', 'b'], ['c', 'd']].sum() == ['a', 'b', 'c', 'd']

// an initial value can be provided
assert [].sum(1000) == 1000
assert [1, 2, 3].sum(1000) == 1006

assert [1, 2, 3].join('-') == '1-2-3'           // String joining
assert [1, 2, 3].inject('counting: ') {
    str, item -> str + item                     // reduce operation
} == 'counting: 123'
assert [1, 2, 3].inject(0) { count, item ->
    count + item
} == 6

// 查找最大最小值的标准代码
def list = [9, 4, 2, 10, 5]
assert list.max() == 10
assert list.min() == 2

// we can also compare single characters, as anything comparable
assert ['x', 'y', 'a', 'z'].min() == 'a'

// we can use a closure to specify the sorting behaviour
def list2 = ['abc', 'z', 'xyzuvw', 'Hello', '321']
assert list2.max { it.size() } == 'xyzuvw'
assert list2.min { it.size() } == 'z'

// 使用Comparator来定义一个比较 
Comparator mc = { a, b -> a == b ? 0 : (a < b ? -1 : 1) }

def list = [7, 4, 9, -6, -1, 11, 2, 3, -9, 5, -13]
assert list.max(mc) == 11
assert list.min(mc) == -13

Comparator mc2 = { a, b -> a == b ? 0 : (Math.abs(a) < Math.abs(b)) ? -1 : 1 }


assert list.max(mc2) == -13
assert list.min(mc2) == -1

assert list.max { a, b -> a.equals(b) ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 } == -13
assert list.min { a, b -> a.equals(b) ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 } == -1

// 排序操作
assert [6, 3, 9, 2, 7, 1, 5].sort() == [1, 2, 3, 5, 6, 7, 9]

def list = ['abc', 'z', 'xyzuvw', 'Hello', '321']
assert list.sort {
    it.size()
} == ['z', 'abc', '321', 'Hello', 'xyzuvw']

def list2 = [7, 4, -6, -1, 11, 2, 3, -9, 5, -13]
assert list2.sort { a, b -> a == b ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 } ==
        [-1, 2, 3, 4, 5, -6, 7, -9, 11, -13]

Comparator mc = { a, b -> a == b ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 }

// JDK 8+ only
// list2.sort(mc)
// assert list2 == [-1, 2, 3, 4, 5, -6, 7, -9, 11, -13]

def list3 = [6, -3, 9, 2, -7, 1, 5]

Collections.sort(list3)
assert list3 == [-7, -3, 1, 2, 5, 6, 9]

Collections.sort(list3, mc)
assert list3 == [1, 2, -3, 5, 6, -7, 9]
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>2.2 Map</b> -- 在 Groovy 里，maps ( 通常和 arrays 联系在一起 )可以使用 [:]
								来创建
							</p>
							<pre class="brush: groovy;">
def map = [name: 'Gromit', likes: 'cheese', id: 1234]
assert map.get('name') == 'Gromit'
assert map.get('id') == 1234
assert map['name'] == 'Gromit'
assert map['id'] == 1234
assert map instanceof java.util.Map

def emptyMap = [:]
assert emptyMap.size() == 0
emptyMap.put("foo", 5)
assert emptyMap.size() == 1
assert emptyMap.get("foo") == 5

// 使用变量作为 map 的 key, 必须使用括号来转义
def a = 'Bob'
def ages = [a: 43]
assert ages['Bob'] == null // `Bob` is not found
assert ages['a'] == 43     // because `a` is a literal!

ages = [(a): 43]            // now we escape `a` by using parenthesis
assert ages['Bob'] == 43   // and the value is found!

// Map 属性标记, Map s可以像你操作 Bean 那样通过使用属性标记来 get/set Map内部的元素。只要key是Groovy识别的字符串:
def map = [name: 'Gromit', likes: 'cheese', id: 1234]
assert map.name == 'Gromit'     // can be used instead of map.get('name')
assert map.id == 1234

// Maps 的迭代
def map = [
        Bob  : 42,
        Alice: 54,
        Max  : 33
]

// `entry` is a map entry
map.each { entry ->
    println "Name: $entry.key Age: $entry.value"
}

// `entry` is a map entry, `i` the index in the map
map.eachWithIndex { entry, i ->
    println "$i - Name: $entry.key Age: $entry.value"
}

// Alternatively you can use key and value directly
map.each { key, value ->
    println "Name: $key Age: $value"
}

// Key, value and i as the index in the map
map.eachWithIndex { key, value, i ->
    println "$i - Name: $key Age: $value"
}

// 操作 maps
def defaults = [1: 'a', 2: 'b', 3: 'c', 4: 'd']
def overrides = [2: 'z', 5: 'x', 13: 'x']

def result = new LinkedHashMap(defaults)
result.put(15, 't')
result[17] = 'u'
result.putAll(overrides)
assert result == [1: 'a', 2: 'z', 3: 'c', 4: 'd', 5: 'x', 13: 'x', 15: 't', 17: 'u']

// 过滤和查找
def people = [
    1: [name:'Bob', age: 32, gender: 'M'],
    2: [name:'Johnny', age: 36, gender: 'M'],
    3: [name:'Claire', age: 21, gender: 'F'],
    4: [name:'Amy', age: 54, gender:'F']
]

def bob = people.find { it.value.name == 'Bob' } // find a single entry
def females = people.findAll { it.value.gender == 'F' }

// both return entries, but you can use collect to retrieve the ages for example
def ageOfBob = bob.value.age
def agesOfFemales = females.collect {
    it.value.age
}

assert ageOfBob == 32
assert agesOfFemales == [21,54]

// but you could also use a key/pair value as the parameters of the closures
def agesOfMales = people.findAll { id, person ->
    person.gender == 'M'
}.collect { id, person ->
    person.age
}
assert agesOfMales == [32, 36]

// `every` returns true if all entries match the predicate
assert people.every { id, person ->
    person.age > 18
}

// `any` returns true if any entry matches the predicate
assert people.any { id, person ->
    person.age == 54
}

// 访问 keys, values, entries
def map = [1:'a', 2:'b', 3:'c']

def entries = map.entrySet()
entries.each { entry ->
  assert entry.key in [1,2,3]
  assert entry.value in ['a','b','c']
}

def keys = map.keySet()
assert keys == [1,2,3] as Set

// 分组, 以将一个 list 按某些维度分组到一个 map 中
assert ['a', 7, 'b', [2, 3]].groupBy {
    it.class
} == [(String)   : ['a', 'b'],
      (Integer)  : [7],
      (ArrayList): [[2, 3]]
]

assert [
        [name: 'Clark', city: 'London'], [name: 'Sharma', city: 'London'],
        [name: 'Maradona', city: 'LA'], [name: 'Zhang', city: 'HK'],
        [name: 'Ali', city: 'HK'], [name: 'Liu', city: 'HK'],
].groupBy { it.city } == [
        London: [[name: 'Clark', city: 'London'],
                 [name: 'Sharma', city: 'London']],
        LA    : [[name: 'Maradona', city: 'LA']],
        HK    : [[name: 'Zhang', city: 'HK'],
                 [name: 'Ali', city: 'HK'],
                 [name: 'Liu', city: 'HK']],
]
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>2.3 Range</b> -- Ranges 允许你创建一个序列值得 list，它可以当成 list 用，因为
								Range 继承了
								<code>java.util.List</code>
								。
							</p>
							<pre class="brush: groovy;">
// Ranges定义使用 .. 代表闭区间, 使用 ..&lt; 代表一个半开半闭，只包含第一个值不包含最后一个值
def range = 5..8
assert range.size() == 4
assert range.get(2) == 7
assert range[2] == 7
assert range instanceof java.util.List
assert range.contains(5)
assert range.contains(8)

// lets use a half-open range
range = 5..&lt;8
assert range.size() == 3
assert range.get(2) == 7
assert range[2] == 7
assert range instanceof java.util.List
assert range.contains(5)
assert !range.contains(8)

//get the end points of the range without using indexes
range = 1..10
assert range.from == 1
assert range.to == 10

// 循环
for (i in 1..10) {
    println "Hello ${i}"
}

(1..10).each { i ->
    println "Hello ${i}"
}

switch (years) {
    case 1..10: interestRate = 0.076; break;
    case 11..25: interestRate = 0.052; break;
    default: interestRate = 0.037;
}
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>2.4 Collections 的语法增强</b> -- 幸亏属性标记对 Lists 和 Maps 都支持，Groovy
								提供了非常实用的方法来使嵌套集合处理变得非常简洁，示例代码如下:
							</p>
							<pre class="brush: groovy;">
def listOfMaps = [['a': 11, 'b': 12], ['a': 21, 'b': 22]]
assert listOfMaps.a == [11, 21] //GPath notation
assert listOfMaps*.a == [11, 21] //spread dot notation

listOfMaps = [['a': 11, 'b': 12], ['a': 21, 'b': 22], null]
assert listOfMaps*.a == [11, 21, null] // caters for null values
assert listOfMaps*.a == listOfMaps.collect { it?.a } //equivalent notation
// But this will only collect non-null values
assert listOfMaps.a == [11,21]

// Spread 操作可以认为是将一个集合内联到另外一个集合
assert [ 'z': 900, *: ['a': 100, 'b': 200], 'a': 300] == ['a': 300, 'b': 200, 'z': 900]
//spread map notation in map definition
assert [*: [3: 3, *: [5: 5]], 7: 7] == [3: 3, 5: 5, 7: 7]

def f = { [1: 'u', 2: 'v', 3: 'w'] }
assert [*: f(), 10: 'zz'] == [1: 'u', 10: 'zz', 2: 'v', 3: 'w']
//spread map notation in function arguments
f = { map -> map.c }
assert f(*: ['a': 10, 'b': 20, 'c': 30], 'e': 50) == 30

f = { m, i, j, k -> [m, i, j, k] }
//using spread map notation with mixed unnamed and named arguments
assert f('e': 100, *[4, 5], *: ['a': 10, 'b': 20, 'c': 30], 6) ==
        [["e": 100, "b": 20, "c": 30, "a": 10], 4, 5, 6]

// 星号操作
assert [1, 3, 5] == ['a', 'few', 'words']*.size()

class Person {
    String name
    int age
}
def persons = [new Person(name:'Hugo', age:17), new Person(name:'Sandra',age:19)]
assert [17, 19] == persons*.age

// 使用下标操作来分片
def text = 'nice cheese gromit!'
def x = text[2]

assert x == 'c'
assert x.class == String

def sub = text[5..10]
assert sub == 'cheese'

def list = [10, 11, 12, 13]
def answer = list[2,3]
assert answer == [12,13]

list = 100..200
sub = list[1, 3, 20..25, 33]
assert sub == [101, 103, 120, 121, 122, 123, 124, 125, 133]


</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>2.5 有用的工具类</b>
							</p>
							<p>
								<b>2.5.1 ConfigSlurper</b> -- 用来读配置文件的工具类，通常是 Grooy
								脚本格式的配置文件。类似于 Java 里的 *.properties 文件。
							</p>
							<pre class="brush: groovy;">
def config = new ConfigSlurper().parse('''
    app.date = new Date()  
    app.age  = 42
    app {                  
        name = "Test${42}"
    }
''')

assert config.app.date instanceof Date
assert config.app.age == 42
assert config.app.name == 'Test42'
</pre>
							<p>
								<b>2.5.2 Expando</b> -- 用于动态创建可拓展对象。尽管它的类名没有采用
								ExpandoMetaClass。每一个 Expando 对象代表一个独立的动态的实例，可以在运行时被属性或方法所拓展。
							</p>
							<pre class="brush: groovy;">
def expando = new Expando()
expando.name = 'John'

assert expando.name == 'John'

def expando = new Expando()
expando.toString = { -> 'John' }
expando.say = { String s -> "John says: ${s}" }

assert expando as String == 'John'
assert expando.say('Hi') == 'John says: Hi'
</pre>
							<p>
								<b>2.5.3 可观察的 list, map 和 set</b> -- Groovy提供了可观察的 lists, maps 和
								sets。每一个都是一个 java.beans.propertyChangeEvnent
								事件的触发器。当元素被添加，删除，修改就会被触发。注意 PropertyChangeEvent
								不仅仅当某些事件发生才出发，同时可以保存新旧值。
							</p>
							<pre class="brush: groovy;">
import java.beans.PropertyChangeListener

def event                                       
def listener = {
    if (it instanceof ObservableList.ElementEvent)  {  
        event = it
    }
} as PropertyChangeListener


def observable = [1, 2, 3] as ObservableList    
observable.addPropertyChangeListener(listener)  

observable.add 42		// 触发 listener 运行      

assert event instanceof ObservableList.ElementAddedEvent

def elementAddedEvent = event as ObservableList.ElementAddedEvent
assert elementAddedEvent.changeType == ObservableList.ChangeType.ADDED
assert elementAddedEvent.index == 3
assert elementAddedEvent.oldValue == null
assert elementAddedEvent.newValue == 42
</pre>
						</div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="groovy-meta"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">运行时和编译时元编程</h3>
					</div>
					<div class="panel-body">
						<p>Groovy
							语言支持两种风格的元编程：运行时元编程和编译时元编程。第一种元编程支持在程序运行时修改类模型和程序行为，而第二种发生在编译时。两种元编程有各自的优缺点。</p>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="groovy-dependency"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Grape 依赖管理器</h3>
					</div>
					<div class="panel-body">
						<p>Grape 是一个内嵌在 Groovy 里的 Jar 包依赖管理器。Grape 让你可以快速添加 maven
							仓库依赖到你的 classpath 里，使脚本运行更加简单。</p>
						<p>Grape（The Groovy Adaptable Packaging Engine or Groovy
							Advanced Packaging Engine)）是 Groovy 里内嵌的一个基础组件，通过 grab()
							方法调用，一些类可以使用 Ivy 来打包成仓库给 Groovy
							用。这就支持开发者通过写一段脚本来实现一些核心库的需求。装载这段脚本，Grape
							将会在运行时下载并链接所有依赖的库。即便这些库存在于 Jcenter， Ibiblio和 java.net</p>
						<p>Grape遵从Ivy对模块版本标识和命名转换。</p>
						<ul>
							<li>group – 模块属于一个模块组。对应 Maven 的 groupId 或者一个 Ivy 组织。任何匹配
								/groovy[x][\..*]^/ 的组都是被保留的，对于 Groovy 是有特定意义的。</li>
							<li>module – 加载的模块名字，对应 Maven 的 artifactId 或 Ivy 的 artifact</li>
							<li>version – 模块使用的版本号，要么是字符串 ‘1.1-RC3’，要么是 Ivy 的 (2.2.1,)
								代表 2.2.1 或更高版本</li>
							<li>classifier – 可选的分类器，比如 jdk15</li>
						</ul>
						<pre class="brush: groovy;">
// 最简单的一种用法是只需要在你的脚本里添加一个注解：
@Grab(group='org.springframework', module='spring-orm', version='3.2.5.RELEASE')
import org.springframework.jdbc.core.JdbcTemplate

// @Grab也支持简洁版
@Grab('org.springframework:spring-orm:3.2.5.RELEASE')
import org.springframework.jdbc.core.JdbcTemplate

// 不是所有的依赖都在maven中心仓库里，你可以像下面这样添加新的仓库:
@GrabResolver(name='restlet', root='http://maven.restlet.org/')
@Grab(group='org.restlet', module='org.restlet', version='1.1.6')
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="groovy-syntax"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">语法基础</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">1. 注释</h5>
							<pre class="brush: groovy;">
// 单行注释
println "hello" // a comment till the end of the line

// 多行注释
println "hello" /* a multiline comment starting
					at the end of a statement */
					
// GroovyDoc 注释
/**
 * A Class description
 */

class Person {
    /** the name of the person */
    String name

    /**
     * Creates a greeting method for a certain person.
     *
     * @param otherPerson the person to greet
     * @return ag reeting message
     */
    String greet(String otherPerson) {
       "Hello ${otherPerson}"
    }
}

/** Shebang 行， # 字符必须是文件的第一个字符。 任何缩进都会引起一个编译错误。通常在 UNIX 系统中被认知，
 *	它容许脚本直接在命令行中运行那些你已经安装的 Groovy 和那些已经在 PATH 中可用的 groovy 命令。
 */
#!/usr/bin/env groovy

println "Hello from the shebang line"
</pre>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">2. 关键字</h5>
							<table
								class="table table-bordered table-responsive table-striped">
								<tbody>
									<tr>
										<td><p>as</p></td>
										<td><p>assert</p></td>
										<td><p>break</p></td>
										<td><p>case</p></td>
									</tr>
									<tr>
										<td><p>catch</p></td>
										<td><p>class</p></td>
										<td><p>const</p></td>
										<td><p>continue</p></td>
									</tr>
									<tr>
										<td><p>def</p></td>
										<td><p>default</p></td>
										<td><p>do</p></td>
										<td><p>else</p></td>
									</tr>
									<tr>
										<td><p>enum</p></td>
										<td><p>extends</p></td>
										<td><p>false</p></td>
										<td><p>finally</p></td>
									</tr>
									<tr>
										<td><p>for</p></td>
										<td><p>goto</p></td>
										<td><p>if</p></td>
										<td><p>implements</p></td>
									</tr>
									<tr>
										<td><p>import</p></td>
										<td><p>in</p></td>
										<td><p>instanceof</p></td>
										<td><p>interface</p></td>
									</tr>
									<tr>
										<td><p>new</p></td>
										<td><p>null</p></td>
										<td><p>package</p></td>
										<td><p>return</p></td>
									</tr>
									<tr>
										<td><p>super</p></td>
										<td><p>switch</p></td>
										<td><p>this</p></td>
										<td><p>throw</p></td>
									</tr>
									<tr>
										<td><p>throws</p></td>
										<td><p>true</p></td>
										<td><p>try</p></td>
										<td><p>while</p></td>
									</tr>
								</tbody>
							</table>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">3. 标识符</h5>
							<p>
								<b>普通标识符</b> -- 标识符以字母，美元符或下划线开头。不能以数字开头
							</p>
							<p>
								<b>带引号的标识符</b> -- 带引号标识符出现在点号表达式的点号之后。 例如: person.name 表达式中 name
								部分就可以引号引起来成为 person."name" 或 person.'name' 有趣的是，当某些标识符包含由 Java
								语言规范中禁止的非法字符，引号引起来后在 Groovy 就会被容许。 例如，像一个破折号，空格，感叹号等字符。
							</p>
							<pre class="brush: groovy;">
// 普通标识符
def name
def item3
def with_underscore
def $dollarStart

// 带引号的标识符
def map = [:]
map."an identifier with a space and double quotes" = "ALLOWED"
map.'with-dash-signs-and-single-quotes' = "ALLOWED"

assert map."an identifier with a space and double quotes" == "ALLOWED"
assert map.'with-dash-signs-and-single-quotes' == "ALLOWED"

def firstname = "Homer"
map."Simson-${firstname}" = "Homer Simson"
assert map.'Simson-Homer' == "Homer Simson"
</pre>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">4. 字符串</h5>
							<p></p>
							字符以链的形式形成的文本被称作字符串。 Groovy 容许你实例化
							<code>java.lang.String</code>
							对象，以及在其他语言中被称作插值字符串（interpolated strings）的 GStrings (
							<code>groovy.lang.GString</code>
							).
							<p>
								<b>字符串汇总表</b>
							</p>
							<table class="table table-bordered table-responsive"">
								<tbody>
									<tr>
										<td><p>字符串名</p></td>
										<td><p>字符串语法</p></td>
										<td><p>插值</p></td>
										<td><p>多行</p></td>
										<td><p>转义字符</p></td>
									</tr>
									<tr>

										<td><p>单引号</p></td>
										<td><p>
												<code>'…'</code>
											</p></td>
										<td><p>
												<span>否</span>
											</p></td>
										<td><p>
												<span>否</span>
											</p></td>
										<td><p>
												<code>\</code>
											</p></td>
									</tr>
									<tr>
										<td><p>三单引号</p></td>
										<td><p>
												<code>'''…'''</code>
											</p></td>
										<td><p>
												<span>否</span>
											</p></td>
										<td><p>
												<span>是</span>
											</p></td>
										<td><p>
												<code>\</code>
											</p></td>
									</tr>

									<tr>

										<td><p>双引号</p></td>
										<td><p>
												<code>"…"</code>
											</p></td>
										<td><p>
												<span>是</span>
											</p></td>
										<td><p>
												<span>否</span>
											</p></td>
										<td><p>
												<code>\</code>
											</p></td>
									</tr>

									<tr>
										<td><p>三双引号</p></td>
										<td><p>
												<code>"""…"""</code>
											</p></td>
										<td><p>
												<span>是</span>
											</p></td>
										<td><p>
												<span>是</span>
											</p></td>
										<td><p>
												<code>\</code>
											</p></td>
									</tr>
									<tr>
										<td><p>斜杠</p></td>
										<td><p>
												<code>/…/</code>
											</p></td>
										<td><p>
												<span>是</span>
											</p></td>
										<td><p>
												<span>是</span>
											</p></td>
										<td><p>
												<code>\</code>
											</p></td>
									</tr>

									<tr>
										<td><p>美元符斜杠</p></td>
										<td><p>
												<code>$/…/$</code>
											</p></td>
										<td><p>
												<span>是</span>
											</p></td>
										<td><p>
												<span>是</span>
											</p></td>
										<td><p>
												<code>$</code>
											</p></td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: groovy;">
// 单引号字符串， 单引号字符串是纯的 java.lang.String，同时不支持插值。 
def firstname = "Homer"
map."Simson-${firstname}" = "Homer Simson"
assert map.'Simson-Homer' == "Homer Simson"

// 字符串连接
assert 'ab' == 'a' + 'b'

// 三引号字符串， 三引号字符串是纯的java.lang.String，同时不支持插值。 三引号字符串可以是多行的。
def aMultilineString = '''line one
line two
line three'''

// 转义特殊字符串
'an escaped single quote: \' needs a backslash'
'an escaped escape character: \\ needs a double backslash'

/** 双引号字符串， 
 * 如果没有插值表示式的话，双引号字符串是纯的java.lang.String， 
 * 但如果有插值存在的话，双引号字符串就是一个groovy.lang.GString实例。 
 */
"a double quoted string"

/** 字符串插值， 除了单引号和三引号字符串，任何 Groovy 表达式都可以插值到所有的字符串里。 
 * 插值就是当计算字符串的值时，用值替换掉字符串中的占位符。 占位符表达式是用 ${} 围起来的，或者以 $ 为前缀的点表达式。
 */
def name = 'Guillaume' // a plain string
def greeting = "Hello ${name}"
assert greeting.toString() == 'Hello Guillaume'

// 如果没有异义，可以不使用 {}
def person = [name: 'Guillaume'， age: 36]
assert "$person.name is $person.age years old" == 'Guillaume is 36 years old'

/** 插值的特殊形式闭包表达式， 可以插任意值到${}占位符，但这里有一个特殊情况就是闭包表达式。 当
 * 占位符包含一个箭头，${→}，这个表达式事实上是一个闭包表达式 — 你可以把它看作是一个带有美元符前缀的闭包：
 */
def sParameterLessClosure = "1 + 2 == ${-> 3}" 
assert sParameterLessClosure == '1 + 2 == 3'

def sOneParamClosure = "1 + 2 == ${ w -> w &lt;&lt; 3}" 
assert sOneParamClosure == '1 + 2 == 3'

/** 斜杠字符串，除了通常的带引号的字符串，Groovy 提供斜杠字符串，它使用 / 作为分隔符。 
 * 斜杠字符串在定义正则表达式和模式的时候非常有用，因为不必要反斜杠来转义。
 */
def fooPattern = /.*foo.*/
assert fooPattern == '.*foo.*'

def multilineSlashy = /one
    two
    three/
assert multilineSlashy.contains('\n')

/** 美元符斜杠字符串， 美元符斜杠字符串是以 $/ 开始和以 /$ 结束的多行的 GString。 
 * 转义的字符是美元符号，美元符号可以转义其他美元符号，或者正斜杠。 但美元符和正斜杠不是一定要去转义， 
 * 只要转义那些好像 GString 占位符那样以美元符开始的字符串， 或者那些以关闭美元斜杠字符串分割符号为开始的字符串。 
 */
def name = "Guillaume"
def date = "April， 1st"
def dollarSlashy = $/
    Hello $name，
    today we're ${date}.
    $ dollar sign
    $$ escaped dollar sign
    \ backslash
    / forward slash
    $/ escaped forward slash
    $/$ escaped dollar slashy string delimiter
/$
</pre>



						</div>

						<div class="sub-item">
							<h5 class="text-primary">5. 数字</h5>
							<p>Groovy 支持不同种类整型和十进制文本，由 Java 的 Number 类型支持。</p>
							<p>
								如果你使用
								<code>def</code>
								关键字来定义可选的类型，那么整型数字的类型就是可变的： 它能自行适配到合适的类型，以便能持有那个数字。
							</p>
							<p>在 Java6 和之前，以及在 Groovy 中，数字可以用十进制，八进制和十六进制来表示， 而在 Java7 和
								Groovy2，你可以使用带有 0b 前缀的二进制记数法：</p>
							<pre class="brush: groovy;">
int xInt = 0b10101111
assert xInt == 175

short xShort = 0b11001001
assert xShort == 201 as short

byte xByte = 0b11
assert xByte == 3 as byte

long xLong = 0b101101101101
assert xLong == 2925l

BigInteger xBigInteger = 0b111100100001
assert xBigInteger == 3873g

int xNegativeInt = -0b10101111
assert xNegativeInt == -175
</pre>
							<p>
								<b>在数字中的下划线</b>
							</p>
							<p>当在输入一个很长的数字是，是很难看清楚这些数字的，
								通过容许在数字之间输入下划线来分组，这样可以更容易分清楚这些数字:</p>
							<pre class="brush: groovy;">
long creditCardNumber = 1234_5678_9012_3456L
long socialSecurityNumbers = 999_99_9999L
double monetaryAmount = 12_345_132.12
long hexBytes = 0xFF_EC_DE_5E
long hexWords = 0xFFEC_DE5E
long maxLong = 0x7fff_ffff_ffff_ffffL
long alsoMaxLong = 9_223_372_036_854_775_807L
long bytes = 0b11010010_01101001_10010100_10010010
</pre>
							<p>
								<b>算术运算结果</b>
							</p>
							<table class="table table-bordered table-responsive">

								<colgroup>

									<col style="width: 10%;">

									<col style="width: 10%;">

									<col style="width: 10%;">

									<col style="width: 10%;">

									<col style="width: 10%;">

									<col style="width: 10%;">

									<col style="width: 10%;">

									<col style="width: 10%;">

									<col style="width: 10%;">

									<col style="width: 10%;">

								</colgroup>

								<thead>

									<tr>

										<th></th>

										<th>byte</th>

										<th>char</th>

										<th>short</th>

										<th>int</th>

										<th>long</th>

										<th>BigInteger</th>

										<th>float</th>

										<th>double</th>

										<th>BigDecimal</th>

									</tr>

								</thead>

								<tbody>

									<tr>

										<td><p>
												<strong>byte</strong>
											</p></td>

										<td><p>int</p></td>

										<td><p>int</p></td>

										<td><p>int</p></td>

										<td><p>int</p></td>

										<td><p>long</p></td>

										<td><p>BigInteger</p></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

									</tr>

									<tr>

										<td><p>
												<strong>char</strong>
											</p></td>

										<td></td>

										<td><p>int</p></td>

										<td><p>int</p></td>

										<td><p>int</p></td>

										<td><p>long</p></td>

										<td><p>BigInteger</p></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

									</tr>

									<tr>

										<td><p>
												<strong>short</strong>
											</p></td>

										<td></td>

										<td></td>

										<td><p>int</p></td>

										<td><p>int</p></td>

										<td><p>long</p></td>

										<td><p>BigInteger</p></td>

										<td><p>double</p></td> 列表
										<td><p>double</p></td>

										<td><p>double</p></td>

									</tr>

									<tr>

										<td><p>
												<strong>int</strong>
											</p></td>

										<td></td>

										<td></td>

										<td></td>

										<td><p>int</p></td>

										<td><p>long</p></td>

										<td><p>BigInteger</p></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

									</tr>

									<tr>

										<td><p>
												<strong>long</strong>
											</p></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td><p>long</p></td>

										<td><p>BigInteger</p></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

									</tr>

									<tr>

										<td><p>
												<strong>BigInteger</strong>
											</p></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td><p>BigInteger</p></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

									</tr>

									<tr>

										<td><p>
												<strong>float</strong>
											</p></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

									</tr>

									<tr>

										<td><p>
												<strong>double</strong>
											</p></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td><p>double</p></td>

										<td><p>double</p></td>

									</tr>

									<tr>

										<td><p>
												<strong>BigDecimal</strong>
											</p></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td></td>

										<td><p>BigDecimal</p></td>

									</tr>

								</tbody>

							</table>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">6. 列表，数组和映射</h5>
							<p>
								<b>列表</b> -- Groovy 使用逗号分割列表的值，使用方括号括起，来表示列表。 Groovy列表是普通的JDK
								<code>java.util.List</code>
								，因为 Groovy 中没有定义自己的集合类。 在默认情况下，定义列表的实现具体类是
								<code>java.util.ArrayList</code>
								，除非你决定自己指定，正如我们将在后面看到的。
							</p>
							<pre class="brush: groovy;">
def numbers = [1， 2， 3]         
assert numbers instanceof List  
assert numbers.size() == 3

def heterogeneous = [1， "a"， true]

def arrayList = [1， 2， 3]
assert arrayList instanceof java.util.ArrayList		// 使用 as 操作符强制要求一个 ArrayList 的实现 

def linkedList = [2， 3， 4] as LinkedList    
assert linkedList instanceof java.util.LinkedList	// 使用 as 操作符强制要求一个 LinkedList 的实现 

LinkedList otherLinked = [3， 4， 5]          
assert otherLinked instanceof java.util.LinkedList

def letters = ['a'， 'b'， 'c'， 'd']

assert letters[0] == 'a'     
assert letters[1] == 'b'

assert letters[-1] == 'd'	// 用一个负数索引来访问最尾的元素：-1是从尾部算起的第一个元素
assert letters[-2] == 'c'


letters[2] = 'C'             
assert letters[2] == 'C'

letters &lt;&lt; 'e'        // 使用 &lt;&lt; 左移动操作符添加一个元素到列表的最后 

assert letters[ 4] == 'e'
assert letters[-1] == 'e'

assert letters[1， 3] == ['b'， 'd']			// 一次访问两个元素，返回一个包含这两个元素的新列表 
assert letters[2..4] == ['C'， 'd'， 'e']		// 使用一个从开始到结束元素的位置的范围来访问列表的一个范围内的值。 
</pre>
							<p>
								<b>数组</b> -- Groovy
								中重用列表符号表示数组，但创建这样的文字数组，你需要通过强制或类型声明，明确地定义数组类型。<span
									class="text-danger">Groovy 不支持 Java 的数组初始符号，而大括号可能被误解为
									Groovy 闭包的符号。 </span>
							</p>
							<pre class="brush: groovy;">
String[] arrStr = ['Ananas'， 'Banana'， 'Kiwi']  

assert arrStr instanceof String[]		// 使用明确的变量类型声明定义一个字符串数组 
assert !(arrStr instanceof List)		// 断言我们建立了一个字符串数字


def numArr = [1， 2， 3] as int[]      
assert numArr instanceof int[]       
assert numArr.size() == 3
</pre>
							<p>
								<b>映射</b> -- 在其他语言中有时也被称为字典或关联数组的特性在 Groovy 称为映射（maps）。
								映射（maps）关联键到值，用冒号来分隔键到值，用逗号分割每对键值对，同时用方括号把整个键值包起来。 <span
									class="text-danger">Groovy 建立的 maps 实际上是 <code>java.util.LinkedHashMap</code>
									的实例。
								</span>
							</p>
							<pre class="brush: groovy;">
def colors = [red: '#FF0000'， green: '#00FF00'， blue: '#0000FF']   

assert colors['red'] == '#FF0000'
assert colors.green  == '#00FF00' 		// 也可以使用属性表示法来断言绿色的十六进制表示 

colors['pink'] = '#FF00FF'           
colors.yellow  = '#FFFF00'           

assert colors.pink == '#FF00FF'
assert colors['yellow'] == '#FFFF00'

assert colors instanceof java.util.LinkedHashMap
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="groovy-operator"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">操作符</h3>
					</div>
					<div class="panel-body">
						<p>Groovy 支持在数学和其他编程语言如 Java 中常见的算术运算符.Java 中所有的算术运算符都能够被支持.</p>
						<p>Groovy 支持运算符重载，各种运算符被映射到普通的 Java
							对象的方法调用，这就使得开发者可以利用运算符重载的优势来编写自己的Java或者 Groovy 对象。</p>
						<div class="sub-item">
							<h5 class="text-primary">操作符重载</h5>
							<pre class="brush: groovy;">
class Bucket {
    int size

    Bucket(int size) { this.size = size }

    Bucket plus(Bucket other) {                     
        return new Bucket(this.size + other.size)
    }
}

def b1 = new Bucket(4)
def b2 = new Bucket(11)
assert (b1 + b2).size == 15
</pre>
							<p>
								<b>下表是各个操作符的函数名称:</b>
							</p>
							<table class="table table-bordered table-responsive">
								<thead>
									<tr>
										<th style="text-align: center">操作符</th>
										<th>方法</th>
										<th style="text-align: left">操作符</th>
										<th>方法</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td><p>
												<code>+</code>
											</p></td>
										<td><p>a.plus(b)</p></td>
										<td><p>
												<code>a[b]</code>
											</p></td>
										<td><p>a.getAt(b)</p></td>
									</tr>
									<tr>
										<td><p>
												<code>-</code>
											</p></td>
										<td><p>a.minus(b)</p></td>
										<td><p>
												<code>a[b] = c</code>
											</p></td>
										<td><p>a.putAt(b， c)</p></td>
									</tr>
									<tr>
										<td><p>
												<code>*</code>
											</p></td>
										<td><p>a.multiply(b)</p></td>
										<td><p>
												<code>a in b</code>
											</p></td>
										<td><p>b.isCase(a)</p></td>
									</tr>
									<tr>
										<td><p>
												<code>/</code>
											</p></td>
										<td><p>a.div(b)</p></td>
										<td><p>
												<code>&lt;&lt;</code>
											</p></td>
										<td><p>a.leftShift(b)</p></td>
									</tr>
									<tr>
										<td><p>
												<code>%</code>
											</p></td>
										<td><p>a.mod(b)</p></td>
										<td><p>
												<code>&gt;&gt;</code>
											</p></td>
										<td><p>a.rightShift(b)</p></td>
									</tr>
									<tr>
										<td><p>
												<code>**</code>
											</p></td>
										<td><p>a.power(b)</p></td>
										<td><p>
												<code>&gt;&gt;&gt;</code>
											</p></td>
										<td><p>a.rightShiftUnsigned(b)</p></td>
									</tr>
									<tr>
										<td><p>
												<code>|</code>
											</p></td>
										<td><p>a.or(b)</p></td>
										<td><p>
												<code>++</code>
											</p></td>
										<td><p>a.next()</p></td>
									</tr>
									<tr>
										<td><p>
												<code>&amp;</code>
											</p></td>
										<td><p>a.and(b)</p></td>
										<td><p>
												<code>--</code>
											</p></td>
										<td><p>a.previous()</p></td>
									</tr>
									<tr>
										<td><p>
												<code>^</code>
											</p></td>
										<td><p>a.xor(b)</p></td>
										<td><p>
												<code>+a</code>
											</p></td>
										<td><p>a.positive()</p></td>
									</tr>
									<tr>
										<td><p>
												<code>as</code>
											</p></td>
										<td><p>a.asType(b)</p></td>
										<td><p>
												<code>-a</code>
											</p></td>
										<td><p>a.negative()</p></td>
									</tr>
									<tr>
										<td><p>
												<code>a()</code>
											</p></td>
										<td><p>a.call()</p></td>
										<td><p>
												<code>~a</code>
											</p></td>
										<td><p>a.bitwiseNegate()</p></td>
									</tr>
								</tbody>
							</table>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">1. 数学运算符</h5>

							<p>
								<b>1.1 常用数学运算符</b>
							</p>
							<table class="table table-bordered table-responsive">
								<thead>
									<tr>
										<th>Operator</th>
										<th>Purpose</th>
										<th>Remarks</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>+</td>
										<td>加</td>
										<td></td>
									</tr>
									<tr>
										<td>-</td>
										<td>减</td>
										<td></td>
									</tr>
									<tr>
										<td>*</td>
										<td>乘</td>
										<td></td>
									</tr>
									<tr>
										<td>/</td>
										<td>除</td>
										<td>整除使用 <code>intdiv()</code> 方法
										</td>
									</tr>
									<tr>
										<td>%</td>
										<td>求余</td>
										<td></td>
									</tr>
									<tr>
										<td>**</td>
										<td>乘方</td>
									</tr>
								</tbody>
							</table>
							<pre class="brush: groovy;">
assert  1  + 2 == 3
assert  4  - 3 == 1
assert  3  * 5 == 15
assert  3  / 2 == 1.5
assert 10  % 3 == 1
assert  2 ** 3 == 8

assert +3 == 3
assert -4 == 0 - 4
assert -(-1) == 1

def a = 2
def b = a++ * 3             

assert a == 3 && b == 6

def c = 3
def d = c-- * 2             

assert c == 2 && d == 6

def e = 1
def f = ++e + 3             

assert e == 2 && f == 5

def g = 4
def h = --g + 1             

assert g == 3 && h == 4

def a = 4
a += 3

assert a == 7

def b = 5
b -= 3

assert b == 2

def c = 5
c *= 3

assert c == 15

def d = 10
d /= 2

assert d == 5

def e = 10
e %= 3

assert e == 1

def f = 3
f **= 2

assert f == 9							
</pre>

							<p>
								<b>1.2 关系运算符</b>
							</p>
							<table class="table table-bordered table-responsive">
								<thead>
									<tr>
										<th>运算符</th>
										<th>用途</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td><code>==</code></td>
										<td>相等</td>
									</tr>
									<tr>
										<td><code>!=</code></td>
										<td>不等</td>
									</tr>
									<tr>
										<td><code>&lt;</code></td>
										<td>小于</td>
									</tr>
									<tr>
										<td><code>&lt;=</code></td>
										<td>小于等于</td>
									</tr>
									<tr>
										<td><code>&gt;</code></td>
										<td>大于</td>
									</tr>
									<tr>
										<td><code>&gt;=</code></td>
										<td>大于等于</td>
									</tr>
								</tbody>
							</table>

							<p>
								<b>1.3 逻辑运算符</b>
							</p>
							<pre class="brush: groovy;">
assert !false           
assert true && true     
assert true || false
</pre>

							<p>
								<b>1.4 位运算符</b>
							</p>
							<pre class="brush: groovy;">
int a = 0b00101010
assert a==42
int b = 0b00001000
assert b==8
assert (a & a) == a                     
assert (a & b) == b                     
assert (a | a) == a                     
assert (a | b) == a                     

int mask = 0b11111111                   
assert ((a ^ a) & mask) == 0b00000000   
assert ((a ^ b) & mask) == 0b00100010   
assert ((~a) & mask)    == 0b11010101
</pre>

							<p>
								<b>1.5 条件运算符</b>
							</p>
							<pre class="brush: groovy;">
assert (!true)    == false                      
assert (!'foo')   == false                      
assert (!'')      == true
</pre>

							<p>
								<b>1.6 三元表达式</b>
							</p>
							<pre class="brush: groovy;">
if (string != null && string.length() > 0) {
    result = 'Found'
} else {
    result = 'Not found'
}

// 等价于 ==>
result = (string!=null && string.length()>0) ? 'Found' : 'Not found'

// 考虑到 Groovy 的真值表，可以进一步简化为 ==>
result = string ? 'Found' : 'Not found'

// 进一步简化 ==> 
name = name ?: "Anonymous"
</pre>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">2. 对象运算符</h5>
							<p>
								<b>2.1 空对象安全引用运算符</b>
							</p>
							<p>引用空对象会抛出 NullPointerException 异常。安全引用运算符会避免抛出这个异常，仅仅返回
								null 值</p>
							<pre class="brush: groovy;">
class Person{
    int id;
    String name;
}

def p = null
println(p?.id + "==" + p?.name)		// 此处不会报空指针

</pre>
							<p>
								<b>2.2 直接字段访问操作符</b>
							</p>
							<p>直接字段访问 .@ 可以跳过 getXXX 方法，直接获得字段的值</p>
							<p class="text-warning">
								<b>规则：</b>在类内部,引用 fieldName 或者 this.fieldName 将被解释为直接属性访问,而不是
								bean 风格的属性访问(通过访问方法进行);在类的外部,可以使用 reference.@fieldName
								语法直接访问类属性。
							</p>
							<pre class="brush: groovy;">
class User {
    public final String name                 
    User(String name) { this.name = name}
    String getName() { "Name: $name" }       
}

def user = new User('Bob')
assert user.name == 'Name: Bob'

// 相当于 user.getName()
assert user.@name == 'Bob'
</pre>

							<p>
								<b>2.3 方法指针操作符</b>
							</p>
							<p>方法指针 (.&) 操作符可以获取一个方法指针，后面再调用这个指针</p>
							<pre class="brush: groovy;">
def str = 'example of method reference'            
def fun = str.&toUpperCase                         
def upper = fun()                                  
assert upper == str.toUpperCase()
</pre>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">3. 正则表达式运算符</h5>
							<p>
								<b>3.1 模式运算符</b>
							</p>
							<p>模式运算符 (~) 创建一个 java.util.regex.Pattern 对象</p>
							<pre class="brush: groovy;">
def p = ~/foo/
assert p instanceof Pattern

// 其实不一定非要用斜杠创建模式，其他类型的字符串也可以充当模式
p = ~'foo'                                                        
p = ~"foo"                                                        
p = ~$/dollar/slashy $ string/$                                   
p = ~"${pattern}"
</pre>
							<p>
								<b>3.2 匹配对象操作符</b>
							</p>
							<p>匹配对象操作符 =~ 直接创建一个 java.util.regex.Matcher 对象</p>
							<pre class="brush: groovy;">
def text = "some text to match"
def m = text =~ /match/                  
assert m instanceof Matcher                                       
if (!m) {                                                         
    throw new RuntimeException("Oops， text not found!")
}
</pre>
							<p>
								<b>3.3 直接匹配操作符</b>
							</p>
							<p>直接匹配操作符 (==~) 直接返回一个 boolean 值</p>
							<pre class="brush: groovy;">
m = text ==~ /match/                                              
assert m instanceof Boolean                                       
if (m) {                                                          
    throw new RuntimeException("Should not reach that point!")
}
</pre>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">4. 其他操作符</h5>
							<p>
								<b>4.1 扩展操作符</b>
							</p>
							<p>将“对象列表”转换成“对象属性的列表”。有点像 Python 的列表生成</p>
							<pre class="brush: groovy;">
class Car {
    String make
    String model
}

def cars = [
       new Car(make: 'Peugeot'， model: '508')，
       new Car(make: 'Renault'， model: 'Clio')]  

def makes = cars*.make                                
assert makes == ['Peugeot'， 'Renault']
</pre>

							<p>
								<b>4.2 解包方法参数</b>
							</p>
							<pre class="brush: groovy;">
int function(int x， int y， int z) {
    x * y + z
}

def args = [4，5，6]
assert function(*args) == 26
</pre>

							<p>
								<b>4.3 解包列表元素</b>
							</p>
							<pre class="brush: groovy;">
def items = [4，5]                      
def list = [1，2，3，*items，6]            
assert list == [1，2，3，4，5，6]
</pre>

							<p>
								<b>4.4 解包键值对</b>
							</p>
							<pre class="brush: groovy;">
def m1 = [c:3， d:4]                   
def map = [a:1， b:2， *:m1]            
assert map == [a:1， b:2， c:3， d:4]
</pre>

							<p>
								<b>4.5 范围操作符</b>
							</p>
							<p>范围操作符 (..) 创建一个 groovy.lang.Range 对象，这个类型同时实现了 List 接口</p>
							<pre class="brush: groovy;">
def range = 0..5                                    
assert (0..5).collect() == [0， 1， 2， 3， 4， 5]       
assert (0..<5).collect() == [0， 1， 2， 3， 4]         
assert (0..5) instanceof List                       
assert (0..5).size() == 6
</pre>

							<p>
								<b>4.6 比较操作符</b>
							</p>
							<p>比较操作符 (&lt;=&gt;) 其实就是 compareTo 方法</p>
							<pre class="brush: groovy;">
assert (1 &lt;=> 1) == 0
assert (1 &lt;=> 2) == -1
assert (2 &lt;=> 1) == 1
assert ('a' &lt;=> 'z') == -1
</pre>

							<p>
								<b>4.7 索引操作符</b>
							</p>
							<p>索引操作符本质上是调用 getAt 和 putAt 方法，可以切片获取或者切片赋值</p>
							<pre class="brush: groovy;">
def list = [0，1，2，3，4]
assert list[2] == 2                         
list[2] = 4                                 
assert list[0..2] == [0，1，4]                
list[0..2] = [6，6，6]                        
assert list == [6，6，6，3，4]
</pre>

							<p>
								<b>4.8 成员操作符</b>
							</p>
							<p>成员操作符 (in) 相当于调用了列表的 contains 方法或者 isCase 方法</p>
							<pre class="brush: groovy;">
def list = ['Grace'，'Rob'，'Emmy']
assert ('Emmy' in list)
</pre>

							<p>
								<b>4.9 同一操作符</b>
							</p>
							<p>在 Groovy 中， == 仅仅检测值是否相同，如果想检测是否是同一个对象，使用 is 操作符</p>
							<pre class="brush: groovy;">
def list1 = ['Groovy 1.8'，'Groovy 2.0'，'Groovy 2.3']        
def list2 = ['Groovy 1.8'，'Groovy 2.0'，'Groovy 2.3']        
assert list1 == list2                                       
assert !list1.is(list2)
</pre>

							<p>
								<b>4.10 类型转换操作符</b>
							</p>
							<p>转型操作符 (as) 可以转换一些不兼容变量的类型，例如下面的转换会抛出异常</p>
							<pre class="brush: groovy;">
Integer x = 123
String s = (String) x

// ==>
Integer x = 123
String s = x as String
</pre>

							<p>
								<b>4.11 调用操作符</b>
							</p>
							<p>调用操作符 () 隐式调用 call 方法。可以重写 call 实现一些自定义的行为，然后用调用操作符调用</p>
							<pre class="brush: groovy;">
class MyCallable {
    int call(int x) {           
        2 * x
    }
}

def mc = new MyCallable()
assert mc.call(2) == 4
assert mc(2) == 4
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="groovy-structure"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">程序结构</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">1. 包名</h5>
							<p>Groovy 的包名同 Java
								中的包名发挥着同样的角色。包名允许我们分隔代码从而避免冲突。Groovy类必须在定义之前指定他们的包，并且假设默认的包名存在。
							</p>
							<pre class="brush: groovy;">package com.yoursite</pre>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">2. 导包</h5>
							<p>为了引用任意一个类，而不需要包名。Groovy 遵从了 Java 的方式允许使用 import 声明来解决类的导入。</p>
							<pre class="brush: groovy;">
import groovy.xml.MarkupBuilder

// using the imported class to create an object
def xml = new MarkupBuilder()

assert xml != null						
	
// Groovy 中默认导入如下包
import java.lang.*
import java.util.*
import java.io.*
import java.net.*
import groovy.lang.*
import groovy.util.*
import java.math.BigInteger
import java.math.BigDecimal

// Groovy 支持静态导包别名
import static Calendar.getInstance as now
assert now().class == Calendar.getInstance().class
</pre>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">3. 脚本 vs 类</h5>
							<p>Groovy 同时支持 class 和script(即类和脚本)。使用一下代码作为例子:</p>
							<pre class="brush: groovy;">
// 定义一个 Main 类，名字是任意的        
class Main {                      
	static void main(String... args) {          
	    println 'Groovy world!'                 
	}
}

// 等价于 ==>
println 'Groovy world!'

// 脚本总是会被编译成类。Groovy 编译器会为你编译这个类，会把脚本体复制进 run 方法。上面的例子会被编译如下: 
import org.codehaus.groovy.runtime.InvokerHelper

class Main extends Script { //Main类继承了groovy.lang.Script类
	// groovy.lang.Script 需要 run 方法返回一个值
    def run() {                             
        println 'Groovy world!'                 
    }
    
    // 自动生成
    static void main(String[] args) {       
        InvokerHelper.runScript(Main， args) 
    }
}

</pre>
							<p>定义方法在脚本中是可以的，如下:</p>
							<pre class="brush: groovy;">
println 'Hello'					// 脚步开始处                               
int power(int n) {				// 一个没有脚本体的方法            
	2**n 
}       
println "2^6==${power(6)}"		// 脚本 

// 面的例子会被编译如下: ==>
import org.codehaus.groovy.runtime.InvokerHelper

class Main extends Script {
	// power 方法被复制进了自动生成的脚本类里面            
    int power(int n) { 
    	2 ** n
    }
    
    def run() {
        println 'Hello'      //脚本被复制到了这里面                   
        println "2^6==${power(6)}"              
    }
    
    static void main(String[] args) {
        InvokerHelper.runScript(Main， args)
    }
}
</pre>
							<p>变量 -- 变量在脚本中不需要类型声明。然而，二者之间在语义学上是不同的，表现如下:</p>
							<ul>
								<li>
									如果声明变量如同第一个例子，它是本地变量。将会被声明在run方法，在脚本外部不可用。特别的，这种变量在脚本的其他方法中不可见。
								</li>
								<li>
									如果变量没有被声明，变量会被绑定到脚本。并且对其他方法可见，你使用脚本与其他程序交互需要传递数据在脚本和程序之间，这种声明是非常有用的。
								</li>
							</ul>
							<pre class="brush: groovy;">
int x = 1
int y = 2
assert x + y == 3

// 等同于: ==>
x = 1
y = 2
assert x + y == 3
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="groovy-object"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">面向对象</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p>Groovy 类不同于 Java 的一些关键部分:</p>
							<ul>
								<li>Public 字段自动转化成了属性，这就减少了冗余代码，不需要大量的 getter 和 setter
									方法.更多关于这方面的内容，将会在字段和属性部分刊出;</li>
								<li>它们的声明和属性或者方法不需要 public 修饰也可以访问;</li>
								<li>文件名不需要和类型一致;</li>
								<li>一个文件可能会包含一个或多个类(如果一个文件中不包含类，将会被认为是一个脚本)。</li>
							</ul>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">4.1 脚本和类</h5>
							<p>
								<b>类</b> -- 在 groovy 中类的定义几乎与 java 一样;类的声明使用 class 关键字，在类中可以包含多
								个属性、构造方法、初始化器和方法。一般方法和构造方法也许使用了他们自己的本地变量 作为方法实现代码的一部分。
							</p>
							<p>
								<b>脚本</b> -- 提供了额外的灵活性但是也有些限制，它们
								也许包含代码、变量定义、方法定义和类定义，我们将描述所有的这些成员的声明和前面没有看到的操作符。
							</p>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">4.2 变量的声明和使用</h5>
							<p>Groovy 使用 java 的修饰符——关键字为 private、protected 和 public
								用来修饰可访问范 围;final 用来限制对变量再次赋值;static 用来标示为类变量，一个非静态的属性为一个实
								例变量，这些修饰符的意思与 java 中一样。</p>
							<p>缺省属性范围在 groovy 有特殊的意思，在没有指定范围修饰符的属性声明的时候， groovy
								会根据需要生成相应的访问方法(getter 方法和 setter 方法)。</p>
							<pre class="brush: groovy;">
class Person {
    int id;
    public String name;

    Person(){}

    Person(int id， String name) {
        this.id = id
        this.name = name
    }
}

def p1 = new Person(1， "jiwanger")

println p1.getId()				// 缺省修饰符属性会自动生成 getter 和 setter 方法
// println p1.getName()			// 编译错误，使用了范围修饰符，不会自动生成 getter 和 setter 方法

// 动态属性引用
def fieldName = 'name'
assert p1[fieldName] == "jiwanger"

</pre>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">4.3 方法和参数</h5>
							<p>
								方法的声明与你看到的变量的声明有相同的概念：通常能使用
								<code>java</code>
								修饰符；返回类型 的声明是可选的；如果没有修饰符或者返回类型，那么使用
								<code>def</code>
								关键字来填空白，当使用
								<code>def</code>
								关键字的时候，方法的返回类型被认为是没有类型(尽管没有返回类型，这时与
								<code>void</code>
								方法 等价)，在这种情况下，
								<code>groovy</code>
								将方法的返回类型定义为
								<code>java.lang.Object</code>
								，缺省的方法访问范围为
								<code>public</code>
								。
							</p>
							<pre class="brush: groovy;">
class Test {
    /** java 中的 main 方法可以浓缩为如下:
     * 1.省略了 public 关键字，因为　Groovy 中缺省的方法访问范围为 public；
     * 2.省略了 void 返回值，Groovy 返回类型没有使用， 可以省略 void 的声明
     * 3.参数省略了 String[] 类型
     */ 
    static main(args) {
        println "Hello World!"

        def t = new Test()
        t.show()
        assert t.show("arg") == 0
        t.show("arg1"， "arg2")
    }

    // 修饰符和返回值至少有一个
    public show() {
    	println "show"
    }
    
    // 修饰符和返回值至少有一个， def 相当是 Object 返回值类型
    def show(arg) {
    	println "show " + arg
        0           // 最后一名当返回值，省略 return
    }
    
    // def 在此处相当 void 返回值， 因为此方法无返回值
    public def show(arg1， arg2) {
        println "show " + arg1 + " " + arg2
    }
}
</pre>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">4.4 构造方法</h5>
							<ul>
								<li>
									<b>位置参数</b> -- 可以和 java 相同的使用方法，但 groovy 提供了 as 关键字和隐式构造。
								</li>
								<li>
									<b>命名参数</b> -- 是 groovy 提供的更多功能，使用参照如下实例。
								</li>
							</ul>
							<pre class="brush: groovy;">
class Test {
    String name
    String product
    
    Test(){}
    
    Test(name， product) {
        this.name = name
        this.product = product
    }

    static main(args) {
        // 位置参数
        def t1 = new Test("aa"， "aaaa")			// Java 构造方法
        def t2 = ["bb"， "bbbb"] as Test			// as 关键字
        Test t3 = ["cc"， "cccc"]				// 隐式构造

        assert t1.name == "aa"
        assert t2.name == "bb"
        assert t3.name == "cc"
        
        // 命名参数
        def t4 = new Test()
        def t5 = new Test(name: "dd")
        def t6 = new Test(product: "eeee")
        def t7 = new Test(name: "ff"， product: "ffff")
        assert t5.name == "dd"
        assert t6.product == "eeee"
        assert t7.name == "ff"
    }
}
</pre>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">4.5 组织类和脚本</h5>
							<p>
								在文件和类声明的关系不像在
								<code>java</code>
								中那样固定的，
								<code>groovy</code>
								文件根据下面的规则能够包含多个公共类的声明:
							</p>
							<ul>
								<li>
									如果一个
									<code>groovy</code>
									文件不包括类声明，那么它被作为一个脚本处理；也就是说， 它透明的包装为
									<code>Script</code>
									类型的类，自动生成的类的名称与源文件名称相同(不包括扩展名)，文件只能够的内容被包装在一个
									<code>run</code>
									方法中，并且增加了一个
									<code>main</code>
									方法用来容易的启动脚本。

								</li>
								<li>
									如果
									<code>groovy</code>
									文件中只包含一个类声明，并且这个类的名称与文件名相同(不 包括扩展名)，那么这里有与
									<code>java</code>
									中一样的一对一的关系。

								</li>
								<li>
									一个
									<code> groovy</code>
									文件也许包含多个不同访问范围的类声明，这里没有强制规则必 须使类的名称与文件名一样，
									<code>groovyc</code>
									编译器完美的为所有在这个文件中声明的类创建
									<code>*.class</code>
									文件，如果你希望直接调用你的脚本，例如在命令行或者
									<code>IDE</code>
									中使用
									<code>groovy</code>
									， 那么在你的文件中的第一个类中应该有一个
									<code>main</code>
									方法。

								</li>
								<li>
									一个
									<code>groovy</code>
									文件也许混合了类的声明和脚本代码，在这种情况下，脚本代码 将变成一个主类被执行，因此不要声明一个与源文件同名的类。
								</li>
							</ul>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="groovy-closure"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">闭包</h3>
					</div>
					<div class="panel-body">
						<p>
							<b>闭包</b> --
							是指一段开放的、匿名的代码块，它可以拥有参数、返回值或者直接被赋值给一个变量使用。与其他常见的闭包不同，Groovy 中的
							Closure 不但可以引用在其内部作用域中声明的变量，而且也可以包含任何在其作用域之外定义的变量。
						</p>
						<div class="sub-item">
							<pre class="brush: groovy;">
{ [closureParameters -> ] statements }
// 其中，[closureParameters->] 表示可选参数列表，多个参数之间由 ， 分隔；
// statements 是指 Groovy 语句。闭包的参数列表与方法的参数列表相似，可以给每个参数指定具体的类型，也可以不用指定。

1. { item++ }  									// 引用了一个名叫item的变量的闭包
2. { -> item++ }								   // 通过增加一个箭头符号->可以从闭包代码中显示的区分参数
3. { println it }								// 使用了隐式参数 it 的闭包
4. { it -> println it }							// 使用了显式参数 it 的闭包
5. { name -> println name }						// 在使用闭包时最好为每个参数显式地命名
6. { String x， int y ->							// 接受了两个有类型的参数的闭包
		println "hey ${x} the value is ${y}"
	}
7. { reader -> 									// 一个闭包可以包含多条语句
		def line = reader.readLine()
		line.trim()
	}
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>把闭包当做一个对象</b> -- 尽管闭包是一段代码块，但它本质上是
								<code>groovy.lang.Closure</code>
								类的一个实例，因此可以将它像其他变量一样赋给另一个变量或字段。
							</p>
							<pre class="brush: groovy;">
// 可以将一个闭包赋给一个变量，因为闭包是groovy.lang.Closure类的实例
def listener = { e -> println "clicked on $e.source" }
assert listener instance Closure
	
// 如果不使用 def 的话，可以将一个闭包赋给一个类型为 groovy.lang.Closure 的变量
Closure callback = { println 'Done!' }

//  你还可以视情况而定，利用 groovy.lang.Closure 的泛型类型为闭包指定返回值
Closure&lt;Boolean&gt; isTextFile = {
	File it -> it.name.endsWith('.txt')
}
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>闭包调用和参数</b> -- 闭包作为一段匿名代码块，可以像调用其他方法一样被调用。
							</p>
							<pre class="brush: groovy;">
def code = { 123 }
assert code() == 123
assert code.call() == 123

def isOdd = { int i -> i % 2 == 1 }
assert isOdd(3) == true
assert isOdd.call(2) == false

// 参数
def closureWithOneArgWithExplicitType = { String str -> str.toUpperCase() }
assert closureWithOneArgWithExplicitType('groovy') == 'GROOVY'

// 隐式参数
def greeting = { "hello, $it!" }
assert greeting('Patrick') == 'hello, Patrick!'

// 可变参数
def concat1 = { String... args -> args.join('') }
assert concat1('abc', 'def') == 'abcdef'
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>委托机制</b> -- Groovy 中的闭包是作为 Closure 类的实例存在的。这使得它和 Java8 中的
								lambda 表达式有着很大的区别。委托 (delegate) 是 Groovy 闭包中很重要的概念，但它和 lambda 中的
								delegate 不同。Groovy 具有修改闭包的委托（亦称代理）或委托策略的能力，这使得在 Groovy
								中设计优美的特定领域定义语言 （DSL）成为一种可能。
							</p>
							<p>
								<code>owner</code>
								,
								<code>delegate</code>
								和
								<code>this</code>
								-- 要想理解委托的概念，我们必须先要解释闭包中 this 的含义。一个闭包实际上定义了 3 个隐含的变量：
							</p>
							<ul>
								<li>
									<code>this</code>
									是指定义了闭包本身的那个<strong>class</strong>
								</li>
								<li>
									<code>owner</code>
									拥有者，是指定义了闭包本身的那个对象, 它有可能是一个类或者一个闭包
								</li>
								<li>
									<code>delegate</code>
									代理者，表示不管何时何地，调用方法或者解析属性时，没有定义消息接收者的一个第三方对象
								</li>
							</ul>
							<p>
								<b>闭包的 <code>this</code>
								</b>
							</p>
							<pre class="brush: groovy;">
class Enclosing {
    /** 
     * 在 Enclosing 类内部定义了一个闭包，它返回 getThisObject
     * 调用闭包将返回 Enclosing 类的实例，闭包就是在 Enclosing 中定义的
     * 更常见的方式是，直接使用简写的 this 方式
     * 准确的返回了同一个对象
     */
    void run() {
    	def whatIsThisObject = { getThisObject() }
    	assert whatIsThisObject() == this
    	def whatIsThis = { this }
    	assert whatIsThis() == this
    }
}

class EnclosedInnerClass {
    /** 
     * 在内部类中定义了一个闭包
     * 闭包返回的自然是内部类的实例，而不是它外层的类实例
     */
	class Inner {
		Closure cl = { this }
	}

	void run() {
		def inner = new Inner()
		assert inner.cl() == inner
	}
}

class NestedClosures {
    /** 
     * 嵌套闭包，就像此处的 cl，它是在闭包 nestedClosures 里面定义的闭包
     * 那么这个 this 对应的就是最近的外部类，而不是闭包
     */
	void run() {
		def nestedClosures = {
			def cl = { this }
			cl()
		}
		assert nestedClosures() == this
	}
}

new Enclosing().run()
new EnclosedInnerClass().run()
new NestedClosures().run()
</pre>
							<p>
								<b>闭包的 <code>owner</code></b> -- 闭包的
								<code>owner</code>
								和前面所讲的
								<code>this</code>
								很相似，仅仅有一点不同：它可以返回直接的闭合的对象，可能是一个闭包的，也可能是一个类的。
							</p>
							<pre class="brush: groovy;">
class Enclosing {
    /**
     * 在 Enclosing 类里定义了一个闭包，返回 getOwner
     * 调用这个闭包将返回定义了这个闭包的类 Enclosing 的实例
     * 更常用的是，可以直接使用简写方式 owner
     * 返回的还是同一个对象
     */
	void run() {
		def whatIsOwnerMethod = { getOwner() }
		assert whatIsOwnerMethod() == this
		def whatIsOwner = { owner }
		assert whatIsOwner() == this
	}
}

class EnclosedInnerClass {
    /** 
     * 在内部类中定义一个闭包
     * 闭包中的 owner 返回的是内部类，而不是最上层的类
     */
	class Inner {
		Closure cl = { owner }
	}
	void run() {
		def inner = new Inner()
		assert inner.cl() == inner
	}
}

class NestedClosures {
    /**
     * 定义了嵌套闭包 cl
     * 但是此处的 owner 指的是闭合的闭包，而不是外部类，这一点和 this 有所不同
     */ 
	void run() {
		def nestedClosures = {
			def cl = { owner }
			cl()
		}
		assert nestedClosures() == nestedClosures
	}
}

new Enclosing().run()
new EnclosedInnerClass().run()
new NestedClosures().run()
</pre>
							<p>
								<b>闭包的 <code>delegate</code></b> -- 一个闭包的 delegate 可以通过
								<code>delegate</code>
								属性或者
								<code>getDelegate</code>
								方法访问。在 Groovy 中，它是一个很强大的概念，尤其是在构建DSL的时候。与
								<code>this</code>
								和
								<code>owner</code>
								表示的是闭包的<strong>词法作用域</strong>的含义不同，
								<code>delegate</code>
								是指一个由用户自己定义的对象，而且闭包可以使用它。默认情况下，
								<code>delegate</code>
								被设置为
								<code>owner</code>
								：
							</p>
							<pre class="brush: groovy;">
/**
 * 可以通过调用 getDelegate 方法获取到闭包的 delegate
 * 或者直接使用 delegate 属性
 * 两者返回的都是同一个对象
 * 有可能是闭合的类或者闭包
 * 在特殊的嵌套闭包的情形中
 * delegate 和 owner 保持一致
 */
class Enclosing {
	void run() {
		def cl = { getDelegate() }
		def cl2 = { delegate }
		assert cl() == cl2()
		assert cl() == this
		def enclosed = {
			{ -> delegate }.call()
		}
		assert enclosed() == enclosed
	}
}

class People {
	String name
}

class Thing {
	String name
}

def p = new People(name: 'tom')
def t = new Thing(name: 'tea')

def upperCasedName = { delegate.name.toUpperCase() }
upperCasedName.delegate = p
assert upperCasedName() == 'TOM'
upperCasedName.delegate = t
assert upperCasedName() == 'TEA'
</pre>
							<p>
								<b>委托机制</b> -- 在一个闭包中，无论何时，属性都可以被访问，而不必显式的为其设置接收者对象。
							</p>
							<pre class="brush: groovy;">
class People {
	String name
}

def p = new People(name: 'tom')
def cl = { name.toUpperCase() }
cl.delegate = p
assert cl() == 'TOM'
</pre>
							<p>
								这段代码能够正常执行是因为属性 name 被显式地解析到了 delegate
								对象上。这种解析闭包里的属性和方法的方式是非常强大的。使用时也不必显式的设置接收者
								<code>delegate.</code>
								，闭包默认的委托机制很好的完成了调用。闭包实际上定义了多种委托机制，你可以自由选择：
							</p>
							<ul>
								<li>
									<code>Closure.OWNER_FIRST</code>
									是默认机制。如果闭包的 <strong>owner</strong> 拥有对应的属性或方法，那么他们将会调用 <strong>owner</strong>
									的，否则，就会调用 <strong>delegate</strong> 的。
								</li>
								<li>
									<code>Closure.DELEGATE_FIRST</code>
									刚好和上面的逻辑相反，首先调用 <strong>delegate</strong> 的，然后才是 <strong>owner</strong>
									的。
								</li>
								<li>
									<code>Closure.OWNER_ONLY</code>
									这种机制下，将只会调用 <strong>owner</strong> 的，<strong>delegate</strong>
									将会被忽略。
								</li>
								<li>
									<code>Closure.DELEGATE_ONLY</code>
									这种机制则只会查找 <strong>delegate</strong> 的，而 <strong>owner</strong>
									会被忽略。
								</li>
								<li>
									<code>Closure.TO_SELF</code>
									这种机制是为那些想实现更高级的元编程技术和想实现自定义机制的开发者提供的。它既不会作用于 <strong>owner</strong>，也不会作用于
									<strong>delegate</strong>，而只会作用于闭包类自己。通常，它只会在你实现了自己的
									<code>Closure</code>
									子类后才会有意义。
								</li>
							</ul>
							<pre class="brush: groovy;">
/** OWNER_FIRST 机制说明 */
class Person {
	String name
	def pretty = { "my name is $name" }			// 1. 此处定义了一个闭包成员，它引用了 “name”
	String toString() {
		pretty()
	}
}

class Thing {
	String name									// 2. Person 类和 Thing 类都定义了一个 name 属性
}

def p = new Person(name: 'Tom')
def t = new Thing(name: 'Tea')

assert p.toString() == 'my name is Tom'			// 3. 使用默认机制的话，name 属性会优先被解析为 owner 的
p.pretty.delegate = t							// 4. 如果我们将闭包的 delegate 改为类 Thing 的一个实例 t
assert p.toString() == 'my name is Tom'			// 5. 那么最终的结果仍不变，因为 name 会被优先解析到闭包的 owner上

// 更改闭包的实现机制后
p.pretty.resolveStrategy = Closure.DELEGATE_FIRST
assert p.toString() == 'my name is Tea'
</pre>
							<p>
								为了说明 <strong>delegate first</strong>、<strong>delegate
									only</strong>、<strong>owner first</strong> 以及 <strong>owner
									only</strong> 之间的区别，我们假设其中一种委托（比如owner）并没有对应的方法或者属性：
							</p>
							<pre class="brush: groovy;">
class Person {
	String name
	int age
	def fetchAge = { age }
}

class Thing {
	String name
}

def p = new Person(name: 'Jeff', age: 30)
def t = new Thing(name: 'ball')

def cl = p.fetchAge
cl.delegate = p
assert cl() == 30

cl.delegate = t
assert cl() == 30

cl.resolveStrategy = Closure.DELEGATE_ONLY
cl.delegate = p
assert cl() == 30

cl.delegate = t
try {
	cl()
	assert false
} catch (MissingPropertyException ex) {
	// "age" is not defined on the delegate
}
</pre>
							<p>
								在这个例子中，我分别定义了两个类，
								<code>Person</code>
								和
								<code>Thing</code>
								。其中二者都有一个
								<code>name</code>
								属性，不同的是
								<code>Person</code>
								还有一个
								<code>age</code>
								属性。
								<code>Person</code>
								类还声明了一个引用的
								<code>age</code>
								属性的闭包。我们可以将默认的 <strong>owner first</strong> 委托机制更改为 <strong>delegate
									only</strong> 委托机制。因为闭包的拥有者是
								<code>Person</code>
								类，所以我们可以通过成功调用闭包，验证出闭包的委托就是
								<code>Person</code>
								类的一个实例。但是如果我们用类
								<code>Thing</code>
								的一个实例作为委托来调用闭包，发现失败了，程序抛出了
								<code>groovy.lang.MissingPropertyException</code>
								异常。尽管闭包是在
								<code>Person</code>
								类中定义的，但是拥有者却没被使用。
							</p>
						</div>

						<div class="sub-item">
							<p>
								<b><code>GString</code> 中的闭包</b>
							</p>
							<pre class="brush: groovy;">
def x = 1
def gs = "x = ${x}"
assert gs == 'x = 1'

x = 2
assert gs == 'x = 2'		// 错误, 修改为如下写法

def x = 1
def gs = "x = ${-> x}"		// 注意此处的不同
assert gs == 'x = 1'

x = 2
assert gs == 'x = 2'

// 同理，对对象的处理
class Person {
    String name
    String toString() { name }          
}
def sam = new Person(name:'Sam')        
def lucy = new Person(name:'Lucy')      
def p = sam                             
def gs = "Name: ${p}"                   
assert gs == 'Name: Sam'                
p = lucy                                
assert gs == 'Name: Sam'        // 注意这里的输出还是 Sam
sam.name = 'Lucy'                       
assert gs == 'Name: Lucy'  


// =====> 修改为如下：
class Person {
    String name
    String toString() { name }
}
def sam = new Person(name:'Sam')
def lucy = new Person(name:'Lucy')
def p = sam

def gs = "Name: ${-> p}"		// 注意此处的不同
assert gs == 'Name: Sam'
p = lucy
assert gs == 'Name: Lucy'
</pre>
						</div>


					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="groovy-semantics"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">语义</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p>
								<b>1. 变量</b>
							</p>
							<pre class="brush: groovy;">
// 1.1 变量定义
String x
def o

// 1.2 变量赋值
x = 1
println x

x = new java.util.Date()
println x

// 1.3 多个赋值 
def (a, b, c) = [10, 20, 'foo']
assert a == 10 && b == 20 && c == 'foo'

def (int i, String j) = [10, 'foo']
assert i == 10 && j == 'foo'

def nums = [1, 3, 5]
def a, b, c
(a, b, c) = nums
assert a == 1 && b == 3 && c == 5

def (_, month, year) = "18th June 2009".split()
assert "In $month of $year" == 'In June of 2009'

// 1.4 溢出和下溢 
def (a, b, c) = [1, 2]
assert a == 1 && b == 2 && c == null

def (a, b) = [1, 2, 3]
assert a == 1 && b == 2

// 1.5 对象解构
class Coordinates {
    double latitude
    double longitude

    double getAt(int idx) {
        if (idx == 0) latitude
        else if (idx == 1) longitude
        else throw new Exception("Wrong coordinate index, use 0 or 1")
    }
}

def coordinates = new Coordinates(latitude: 43.23, longitude: 3.67) 
def (la, lo) = coordinates

assert la == 43.23                                                  
assert lo == 3.67
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>2. 控制结构</b>
							</p>
							<p>
								2.1
								<code>if / else</code>
							</p>
							<pre class="brush: groovy;">
if / else 和 java 无区别
</pre>
							<p>
								2.2
								<code>switch / case</code>
							</p>
							<pre class="brush: groovy;">
// switch / case 和 java 的区别是　Groovy 可以支持任意类型的 case 匹配
/**
 * switch 支持以下类型的比较:
 *   类型值匹配,如果 switch 值是类的实例
 *   正则表达式匹配 switch 值
 *   集合中包含 switch 值
 *   闭包的返回值
 *   如果无值匹配,使用 default
 */
def x = 1.23
def result = ""

switch ( x ) {
    case "foo":
        result = "found foo"
    case [4, 5, 6, 'inList']:
        result = "list"
        break
    case 12..30:
        result = "range"
        break
    case Integer:
        result = "integer"
        break
    case Number:
        result = "number"
        break
    case ~/fo*/: // toString() representation of x matches the pattern?
        result = "foo regex"
        break
    case { it < 0 }: // or { x < 0 }
        result = "negative"
        break
    default:
        result = "default"
}
assert result == "number"
</pre>
							<p>
								2.3
								<code>for</code>
							</p>
							<pre class="brush: groovy;">
// 支持标准 Java / C for 循环: 
String message = ''
for (int i = 0; i < 5; i++) {
    message += 'Hi '
}
assert message == 'Hi Hi Hi Hi Hi '

// Groovy 中有更简单的 for 循环
// iterate over a list
x = 0
for ( i in [0, 1, 2, 3, 4] ) {
    x += i
}
assert x == 10

// iterate over an array
def array = (0..4).toArray()
x = 0
for ( i in array ) {
    x += i
}
assert x == 10

// iterate over a map
def map = ['abc':1, 'def':2, 'xyz':3]
x = 0
for ( e in map ) {
    x += e.value
}
assert x == 6

// iterate over values in a map
x = 0
for ( v in map.values() ) {
    x += v
}
assert x == 6

// iterate over the characters in a string
def text = "abc"
def list = []
for (c in text) {
    list.add(c)
}
assert list == ["a", "b", "c"]
</pre>
							<p>
								2.4
								<code>while</code>
							</p>
							<pre class="brush: groovy;">
def x = 0
def y = 5

while ( y-- > 0 ) {
    x++
}

assert x == 5
</pre>
						</div>

						<div class="sub-item">
							<p>
								<b>3. 异常处理</b> -- 异常处理和 Java 是一样的。 
							</p>
							<pre class="brush: groovy;">
try {
    'moo'.toLong()   // this will generate an exception
    assert false     // asserting that this point should never be reached
} catch ( e ) {
    assert e in NumberFormatException
}


</pre>
						</div>
						
						<div class="sub-item">
							<p>
								<b>4. 断言</b> -- 断言使用 <code>assert</code> 关键字, 和 Java 是一样的。但在 Groovy 中表现非常不同, 不论 JVM 的 <code>-ea</code> 是否打开，断言总是执行的。如果断言是真的,然后什么都没有发生；如果断言是假的,那么它提供了一个可视化表示的子表达式。
							</p>
							<pre class="brush: groovy;">
// 断言包含三个部分，最后一部分为注意的消息，可以不使用
assert [left expression] == [right expression] : (optional message)

try {
    'moo'.toLong()   // this will generate an exception
    assert false     // asserting that this point should never be reached
} catch ( e ) {
    assert e in NumberFormatException
}


</pre>
						</div>
						
						<div class="sub-item">
							<p><b>5. 标签声明</b> -- 任何声明可以被关联到一个标签。 标签不影响代码的语义,可以用来制造 的代码更容易阅读。就像 C 语言中的 <code>goto</code></p>
							<pre class="brush: groovy;">
given:
    println 'given'
    def x = 1
    def y = 2
when:
    println 'when'
    def z = x+y
then:
    println 'then'
    assert z == 3
// 上面的代码执行就像是没有标签一样的

// 此写法只限在循环中
for (def i : 1..9) {
    if (i == 5) {
        break exit
    }
    println i
}
exit: println "for over!"					
</pre>
						</div>
						
						<div class="sub-item">
							<p><b>5. Gpath</b> -- GPath 是 groovy 代码的一个强劲对象导航的结构，名称的选择与 XPath 相似，XPath 是一个用来描述 XML（和等价物）文档的标准，正如 XPath，GPath 的目标是用在表达试：明确的，紧凑易读的表达式。</p>
							<pre class="brush: groovy;">
def xmlText = """
<root>
    <level>
        <sublevel id='1'>
            <keyVal>
                <key>mykey</key>
                <value>value 123</value>
            </keyVal>
        </sublevel>
        <sublevel id='2'>
            <keyVal>
                <key>anotherKey</key>
                <value>42</value>
            </keyVal>
            <keyVal>
                <key>mykey</key>
                <value>fizzbuzz</value>
            </keyVal>
        </sublevel>
    </level>
</root>
"""

def root = new XmlSlurper().parseText(xmlText.stripMargin())
assert root.level.size() == 1 
assert root.level.sublevel.size() == 2 
assert root.level.sublevel.findAll { it.@id == 1 }.size() == 1 
assert root.level.sublevel[1].keyVal[0].key.text() == 'anotherKey'
</pre>
						</div>
						
						<div class="sub-item">
							<p><b>6. 闭包强制转换</b></p>
							<pre class="brush: groovy;">
interface Predicate&lt;T> {
    boolean accept(T obj)
}

abstract class Greeter {
    abstract String getName()
    void greet() {
        println "Hello, $name"
    }
}

Predicate filter = { it.contains 'G' } as Predicate
assert filter.accept('Groovy') == true

Greeter greeter = { 'Groovy' } as Greeter
greeter.greet()
// Groovy 2.2 和可以这样写
Predicate filter2 = { it.contains 'G' }
assert filter2.accept('Groovy') == true

Greeter greeter2 = { 'Groovy' }
greeter2.greet()

// 再看下面的方法
boolean doFilter(String s) { s.contains('G') }

Predicate filter3 = this.&doFilter
assert filter3.accept('Groovy') == true

Greeter greeter3 = GroovySystem.&getVersion
greeter3.greet()
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->


				<!-- item start -->
				<a class="offset" id="groovy-groovyc"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">
							<code>groovyc</code>
						</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below)， or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushGroovy.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushBash.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
