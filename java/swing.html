<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--JavaFX</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>


<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle"
					data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
                     id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">Awt & Swing & JavaFX</h3>
					</div>
					<div class="list-group">
						<a href="#javax-swing-intro" class="list-group-item">Awt & Swing & SWT & JavaFX</a>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#java-awt" aria-expanded="true"  style="border-top: 1px solid #DDDDDD;">
							<code>java.awt</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-awt" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#java-awt-Frame" class="list-group-item">Frame 及父类</a>
							<a href="#java-awt-LayoutManager" class="list-group-item">LayoutManager 及实现类(AWT)</a>
							<a href="#java-awt-MenuComponent" class="list-group-item">MenuComponent 及子类(AWT)</a>
                            <a href="#java-awt-Container" class="list-group-item">Container 的子类(AWT)</a>
                            <a href="#java-awt-Component" class="list-group-item">Component 的子类(AWT)</a>
						</div>

                        <a class="list-group-item active dropdown" data-toggle="collapse"
                           data-parent="#accordion" href="#javax-swing" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
                            <code>javax.swing</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="javax-swing" class="panel-collapse collapse"
                             role="tabpanel">
                            <a href="#javax-swing-JFrame" class="list-group-item">JFrame, JWindow, JDialog</a>
                            <a href="#javax-swing-LayoutManager" class="list-group-item">LayoutManager 及实现类(SWING)</a>
                            <a href="#javax-swing-JComponent" class="list-group-item">JComponent 及子类</a>
                        </div>
                        <a class="list-group-item active dropup" data-toggle="collapse" data-parent="#accordion" href="#javafx-framework" aria-expanded="true"
                           style="border-top: 1px solid #DDDDDD;">
                            <b>JavaFX</b><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="javafx-framework" class="panel-collapse collapse in" role="tabpanel">
                            <a href="#javafx-base" class="list-group-item">Java-FX 基础</a>
                            <a href="#javafx-application-Application" class="list-group-item">Application 及顶级窗口类</a>
                            <a href="#javafx-scene-Scene" class="list-group-item">Scene 及相关类</a>
                            <a href="#javafx-scene-Node" class="list-group-item">图形基类: Node</a>
                            <a href="#javafx-scene-layout-Pane" class="list-group-item">布局类：Pane 及子类</a>
                            <a href="#javafx-scene-control-Control" class="list-group-item">控件类：Control 及相关类</a>
                            <a href="#javafx-fxml" class="list-group-item">使用 FXML 进行布局</a>
                            <a href="#javafx-css" class="list-group-item">使用 CSS 控制样式</a>
                            <a href="#JFoenix-intro" class="list-group-item">JFoenix -- JavaFX 美化</a>
                        </div>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-3"></div>
			<div class="col-md-9" style="float: left;">
				<!-- item start -->
				<a class="offset" id="javax-swing-intro"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Awt & Swing & SWT & JavaFX</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
                        <p><b>AWT</b> 是 Abstract Window ToolKit (抽象窗口工具包)的缩写，这个工具包提供了一套与本地图形界面进行交互的接口。AWT 中的图形函数与操作系统所提供的图形函数之间有着一一对应的关系，我们把它称为peers。 也就是说，当我们利用 AWT 来构件图形用户界面的时候，我们实际上是在利用操作系统所提供的图形库。由于不同操作系统的图形库所提供的功能是不一样的，在一个平台上存在的功能在另外一个平台上则可能不存在。为了实现 Java 语言所宣称的"一次编译，到处运行"的概念，AWT 不得不通过牺牲功能来实现其平台无关性，也就是说，AWT 所提供的图形功能是各种通用型操作系统所提供的图形功能的交集。由于 AWT 是依靠本地方法来实现其功能的，我们通常把 AWT 控件称为重量级控件。 </p>
                        <p><b>AWT</b> 是抽象窗口组件工具包，是 Java 最早的用于编写图形节目应用程序的开发包。</p>
                        <p><b>AWT</b> 和 <b>Swing</b> 之间的基本区别：AWT 是基于本地方法的 C/C++ 程序，其运行速度比较快；Swing 是基于 AWT 的 Java 程序，其运行速度比较慢。对于一个嵌入式应用来说，目标平台的硬件资源往往非常有限，而应用程序的运行速度又是项目中至关重要的因素。在这种矛盾的情况下，简单而高效的 AWT 当然成了嵌入式 Java 的第一选择。而在普通的基于 PC 或者是工作站的标准 Java 应用中，硬件资源对应用程序所造成的限制往往不是项目中的关键因素，所以在标准版的 Java 中则提倡使用 Swing， 也就是通过牺牲速度来实现应用程序的功能。 </p>
                        </div>
                        <div class="sub-item">
                            <p><b>Swing</b> 是在 AWT 的基础上构建的一套新的图形界面系统，它提供了 AWT 所能够提供的所有功能，并且用纯粹的 Java 代码对 AWT 的功能进行了大幅度的扩充。例如说并不是所有的操作系统都提供了对树形控件的支持， Swing 利用了 AWT 中所提供的基本作图方法对树形控件进行模拟。由于 Swing 控件是用 100% 的 Java 代码来实现的，因此在一个平台上设计的树形控件可以在其他平台上使用。由于在 Swing 中没有使用本地方法来实现图形功能，我们通常把 Swing 控件称为轻量级控件。 </p>
                            <p><b>Swing</b> 是为了解决 AWT 存在的问题而新开发的包，它以 AWT 为基础的。</p>
                        </div>
                        <div class="sub-item">
                            <p><b>SWT</b> 是 Standard Widget Toolkit (标准部件工具包)的缩写，是 IBM 创建一个为 Java 设计提供了高效的部件工具包。与 AWT/Swing 有相似的用处，著名的开源 eclipse 就是用 SWT 开发的。</p>
                            <p><b>SWT</b> 的构建者从 AWT 和 Swing 实现中学习了很多经验，他们试图构建一个集二者优点于一体而没有二者的缺点的系统。</p>
                            <p><b>在大部分情况中，决定都是在 Swing 与结合了 JFace 的 SWT 之间进行的</b>。通常来说，每个工具包都非常完整且功能强大，足以构建功能完善的 GUI，但是 Swing 通常要比单独使用 SWT（不使用 JFace 时）更好。Swing 具有内嵌于 Java 技术的优点，是完全可移植的，无可争议地是一种更好的架构。Swing 也具有高级图形应用程序所需要的优点。SWT 具有可以作为本地应用程序实现的优点，这可以提高性能，并利用基于 SWT 的 GUI 来实现本地兼容性。 </p>
                            <p>如果只为一种平台来开发系统，那么 SWT 就具有主机兼容性方面的优点，包括与主机特性的集成，例如在 Windows 上对 ActiveX 控件的使用。</p>
                        </div>
                        <div class="sub-item">
                            <p><b>JavaFx</b> 是 Java 中的最新的界面库，于 2008 年 12 月 05 日发布。<b>有两种编写模式，一种是纯代码编写，一种是 <code>CODE+FXML+CSS</code>。</b></p>
                            <p><b>JavaFX</b> 是 Java 的下一代图形用户界面工具包。JavaFX 是一组图形和媒体 API，我们可以用它们来创建和部署富客户端应用程序。</p>
                            <p>JavaFX API 与 Java SE 运行时环境（JRE）和 Java 开发工具包（JDK）捆绑在一起。 JavaFX 应用程序可以在所有主要的桌面平台上编译和运行。</p>
                            <p><b>JavaFX</b> 允许开发人员快速构建丰富的跨平台应用程序。JavaFX 通过硬件加速图形支持现代 GPU。</p>
                            <p><b>JavaFX</b> 允许开发人员在单个编程接口中组合图形，动画和 UI 控件。</p>
                            <p><b>JavaFX</b> 技术有着良好的前景，包括可以直接调用 Java API 的能力。因为 JavaFX Script 是静态类型，它同样具有结构化代码、重用性和封装性，如包、类、继承和单独编译和发布单元，这些特性使得使用 JavaFX 技术创建和管理大型程序变为可能。</p>
                        </div>
                        <div class="sub-item">
                            <p><b>SWT 、AWT 、SWING 和 JAVAFX 优劣势比较:</b></p>
                            <table class="table table-bordered table-responsive">
                                <thead>
                                <tr>
                                    <th>&nbsp;</th>
                                    <th>Awt</th>
                                    <th>Swing</th>
                                    <th>SWT</th>
                                    <th>JavaFx</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td >优势</td>
                                    <td >1. 运行速度快</td>
                                    <td >1. 多平台</td>
                                    <td >1. 介于Awt和Swing之间</td>
                                    <td >1. 支持控件多</td>
                                </tr>

                                <tr>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                    <td >2. 稳定</td>
                                    <td >&nbsp;</td>
                                    <td >2. 默认控件漂亮</td>
                                </tr>

                                <tr>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                    <td >3. 编写接口简洁</td>
                                </tr>

                                <tr>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                    <td >4. 开发效率高</td>
                                </tr>
                                </tbody>
                                <tbody>
                                <tr>
                                    <td >劣势</td>
                                    <td >1. 夸平台效果不好</td>
                                    <td >1. 运行效率低</td>
                                    <td >1. 介于Awt和Swing之间</td>
                                    <td >1. 运行效率一般</td>
                                </tr>

                                <tr>
                                    <td >&nbsp;</td>
                                    <td >2. 开发效率低</td>
                                    <td >2. 开发效率不高</td>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                </tr>

                                <tr>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                    <td >3. 接口繁琐</td>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                </tr>

                                <tr>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                    <td >4. 默认主题界面不美观</td>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                </tr>

                                <tr>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                    <td >5. 精通耗时长</td>
                                    <td >&nbsp;</td>
                                    <td >&nbsp;</td>
                                </tr>
                                </tbody>
                            </table>
                            <p><b>SWT 、AWT 和 SWING 特性的比较:</b></p>
                            <table class="table table-bordered table-responsive">
                                <thead>
                                    <tr>
                                        <th>功能/角色/外表</th>
                                        <th>AWT</th>
                                        <th>Swing</th>
                                        <th>SWT（风格）</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>显示静态文本</td>
                                        <td>Label</td>
                                        <td>JLabel</td>
                                        <td>Label, CLabel</td>
                                    </tr>
                                    <tr>
                                        <td>显示多行静态文本</td>
                                        <td>Multiple Labels</td>
                                        <td>具有 HTML 内容的 Multiple JLabels 或 JLabel</td>
                                        <td>具有新行的 Multiple Labels 或 Label</td>
                                    </tr>
                                    <tr>
                                        <td>显示多行格式化静态文本</td>
                                        <td>具有不同字体的 Multiple Labels</td>
                                        <td>具有 HTML 内容的 JLabel</td>
                                        <td>具有不同字体的 Multiple Labels</td>
                                    </tr>
                                    <tr>
                                        <td>单行文本输入</td>
                                        <td>TextField</td>
                                        <td>JTextField</td>
                                        <td>Text(SWT.SINGLE)</td>
                                    </tr>
                                    <tr>
                                        <td>多行文本输入</td>
                                        <td>TextArea</td>
                                        <td>JTextArea</td>
                                        <td>Text(SWT.MULTI)</td>
                                    </tr>
                                    <tr>
                                        <td>显示图像</td>
                                        <td>N/A</td>
                                        <td>JLabel</td>
                                        <td>Label</td>
                                    </tr>
                                    <tr>
                                        <td>显示文本和图像</td>
                                        <td>N/A</td>
                                        <td>JLabel</td>
                                        <td>CLabel</td>
                                    </tr>
                                    <tr>
                                        <td>提示弹出帮助</td>
                                        <td>N/A</td>
                                        <td>组件的 setToolTip，JToolTip 子类</td>
                                        <td>控件的 setToolTip</td>
                                    </tr>
                                    <tr>
                                        <td>风格化的文本输入</td>
                                        <td>N/A</td>
                                        <td>JEditorPane</td>
                                        <td>StyledText</td>
                                    </tr>
                                    <tr>
                                        <td>从条目列表中进行选择</td>
                                        <td>List</td>
                                        <td>JList</td>
                                        <td>List</td>
                                    </tr>
                                    <tr>
                                        <td>简单按下具有文本的按钮</td>
                                        <td>Button</td>
                                        <td>JButton</td>
                                        <td>Button(SWT.PUSH)</td>
                                    </tr>
                                    <tr>
                                        <td>简单按下具有文本或图像的按钮</td>
                                        <td>N/A</td>
                                        <td>JButton</td>
                                        <td>Button(SWT.PUSH)</td>
                                    </tr>
                                    <tr>
                                        <td>绘图区域；可能用于定制控件</td>
                                        <td>Canvas</td>
                                        <td>JPanel</td>
                                        <td>Canvas</td>
                                    </tr>
                                    <tr>
                                        <td>选中/取消复选框</td>
                                        <td>CheckBox</td>
                                        <td>JCheckBox</td>
                                        <td>Button(SWT.CHECK)</td>
                                    </tr>
                                    <tr>
                                        <td>单选按钮选择</td>
                                        <td>CheckBoxGroup</td>
                                        <td>ButtonGroup 和 Menu</td>
                                        <td>Group 和 Menu</td>
                                    </tr>
                                    <tr>
                                        <td>从一个下拉列表中选择</td>
                                        <td>Choice</td>
                                        <td>JComboBox</td>
                                        <td>Combo、CCombo</td>
                                    </tr>
                                    <tr>
                                        <td>输入文本或从下拉列表中选择</td>
                                        <td>N/A</td>
                                        <td>JComboBox</td>
                                        <td>Combo、CCombo</td>
                                    </tr>
                                    <tr>
                                        <td>可滚动区域</td>
                                        <td>ScrollPane</td>
                                        <td>JScrollPane</td>
                                        <td>创建 Scrollable 子类</td>
                                    </tr>
                                    <tr>
                                        <td>顶层窗口</td>
                                        <td>Dialog、Frame、Window</td>
                                        <td>JDialog、JFrame、JWindow</td>
                                        <td>具有不同风格的 Shell</td>
                                    </tr>
                                    <tr>
                                        <td>通用窗口</td>
                                        <td>Window</td>
                                        <td>JWindow</td>
                                        <td>Shell</td>
                                    </tr>
                                    <tr>
                                        <td>框架窗口</td>
                                        <td>Frame</td>
                                        <td>JFrame</td>
                                        <td>Shell(SWT.SHELL_TRIM)</td>
                                    </tr>
                                    <tr>
                                        <td>对话框窗口</td>
                                        <td>Dialog</td>
                                        <td>JDialog</td>
                                        <td>Shell(SWT.DIALOG_TRIM)</td>
                                    </tr>
                                    <tr>
                                        <td>菜单</td>
                                        <td>Menu</td>
                                        <td>JMenu</td>
                                        <td>Menu</td>
                                    </tr>
                                    <tr>
                                        <td>MenuItem</td>
                                        <td>MenuItem</td>
                                        <td>JMenuItem</td>
                                        <td>MenuItem</td>
                                    </tr>
                                    <tr>
                                        <td>菜单快捷键</td>
                                        <td>通用击键</td>
                                        <td>与 AWT 相同</td>
                                        <td>依赖于主机的快捷键</td>
                                    </tr>
                                    <tr>
                                        <td>弹出菜单</td>
                                        <td>PopupMenu</td>
                                        <td>JPopupMenu</td>
                                        <td>Menu(SWT.POPUP)</td>
                                    </tr>
                                    <tr>
                                        <td>菜单条</td>
                                        <td>MenuBar</td>
                                        <td>JMenuBar</td>
                                        <td>Menu(SWT.BAR)</td>
                                    </tr>
                                    <tr>
                                        <td>显示插入符号</td>
                                        <td>N/A</td>
                                        <td>Caret</td>
                                        <td>Caret</td>
                                    </tr>
                                    <tr>
                                        <td>Web 浏览器</td>
                                        <td>N/A</td>
                                        <td>JTextPane（HTML 3.2）</td>
                                        <td>Browser（通过嵌入式浏览器）</td>
                                    </tr>
                                    <tr>
                                        <td>Web 页面中的嵌入式控件</td>
                                        <td>Applet</td>
                                        <td>JApplet</td>
                                        <td>主机控件（例如 OLE）</td>
                                    </tr>
                                    <tr>
                                        <td>其他控件的通用容器</td>
                                        <td>Panel</td>
                                        <td>JPanel</td>
                                        <td>Composite</td>
                                    </tr>
                                    <tr>
                                        <td>其他控件的有边界通用容器</td>
                                        <td>Panel（如果是手工画的）</td>
                                        <td>具有 Border 的 JPanel</td>
                                        <td>Composite(SWT.BORDER)</td>
                                    </tr>
                                    <tr>
                                        <td>其他控件的有边界和标题的通用容器</td>
                                        <td>N/A</td>
                                        <td>具有 TitledBorder 的 JPanel</td>
                                        <td>Group</td>
                                    </tr>
                                    <tr>
                                        <td>单选按钮（一个被选中）</td>
                                        <td>Checkbox</td>
                                        <td>JRadioButton</td>
                                        <td>Button(SWT.RADIO)</td>
                                    </tr>
                                    <tr>
                                        <td>单选按钮的控件扩充</td>
                                        <td>CheckboxGroup</td>
                                        <td>RadioButtonGroup</td>
                                        <td>Group</td>
                                    </tr>
                                    <tr>
                                        <td>箭头按钮</td>
                                        <td>N/A</td>
                                        <td>具有图像的 JButton</td>
                                        <td>Button(SWT.ARROW)</td>
                                    </tr>
                                    <tr>
                                        <td>支持文本显示方向</td>
                                        <td>通过 ComponentOrientation</td>
                                        <td>与 AWT 相同</td>
                                        <td>很多组件都可以支持这种风格</td>
                                    </tr>
                                    <tr>
                                        <td>焦点切换</td>
                                        <td>Policy 和 Manager 对象</td>
                                        <td>与 AWT 相同</td>
                                        <td>下一个控件</td>
                                    </tr>
                                    <tr>
                                        <td>定制对话框</td>
                                        <td>Dialog 子类</td>
                                        <td>JDialog 子类</td>
                                        <td>Dialog 子类</td>
                                    </tr>
                                    <tr>
                                        <td>访问系统事件</td>
                                        <td>EventQueue 服务</td>
                                        <td>与 AWT 相同</td>
                                        <td>Display 服务（不如 AWT 健壮）</td>
                                    </tr>
                                    <tr>
                                        <td>系统访问对话框</td>
                                        <td>FileDialog</td>
                                        <td>JColorChooser、JFileChooser</td>
                                        <td>ColorDialog、DirectoryDialog、FileDialog、FontDialog、PrintDialog</td>
                                    </tr>
                                    <tr>
                                        <td>显示简单消息对话框</td>
                                        <td>N/A（必须是 Dialog 子类）</td>
                                        <td>JOptionPane 静态方法</td>
                                        <td>具有很多风格的 MessageBox</td>
                                    </tr>
                                    <tr>
                                        <td>显示简单提示对话框</td>
                                        <td>N/A（必须是 Dialog 子类）</td>
                                        <td>JOptionPane 静态方法</td>
                                        <td>N/A（JFace 中用来实现这种功能的子类）</td>
                                    </tr>
                                    <tr>
                                        <td>布局管理器</td>
                                        <td>BorderLayout、CardLayout、FlowLayout、GridLayout、GridBagLayout</td>
                                        <td>AWT 加上 BoxLayout、CenterLayout、SpringLayout</td>
                                        <td>FillLayout、FormLayout、GridLayout、RowLayout、StackLayout</td>
                                    </tr>
                                    <tr>
                                        <td>基本的绘图控件</td>
                                        <td>Canvas</td>
                                        <td>JPanel</td>
                                        <td>Canvas</td>
                                    </tr>
                                    <tr>
                                        <td>基本绘图</td>
                                        <td>Graphics 和 Graphics2D 对象 —— 基本形状和文本，任意 Shapes 和 Strokes、Bezier 以及文件</td>
                                        <td>与 AWT 相同</td>
                                        <td>GC 对象 —— 基本形状和文本</td>
                                    </tr>
                                    <tr>
                                        <td>绘图转换</td>
                                        <td>Affine，合成</td>
                                        <td>与 AWT 相同</td>
                                        <td>N/A</td>
                                    </tr>
                                    <tr>
                                        <td>离屏绘图（Off screen drawing）</td>
                                        <td>BufferedImage、drawImage</td>
                                        <td>与 AWT 相同</td>
                                        <td>Image、drawImage</td>
                                    </tr>
                                    <tr>
                                        <td>双缓冲区</td>
                                        <td>手工</td>
                                        <td>自动或手工</td>
                                        <td>除非由主机控件提供，否则就是手工</td>
                                    </tr>
                                    <tr>
                                        <td>打印</td>
                                        <td>PrintJob 和 PrintGraphics</td>
                                        <td>与 AWT 相同</td>
                                        <td>向 Printer 设备绘图</td>
                                    </tr>
                                    <tr>
                                        <td>定制颜色</td>
                                        <td>Color</td>
                                        <td>与 AWT 相同</td>
                                        <td>Color</td>
                                    </tr>
                                    <tr>
                                        <td>定制字体</td>
                                        <td>Font、FontMetrics</td>
                                        <td>与 AWT 相同</td>
                                        <td>Font</td>
                                    </tr>
                                    <tr>
                                        <td>光标选择</td>
                                        <td>Cursor</td>
                                        <td>与 AWT 相同</td>
                                        <td>Cursor/td>
                                    </tr>
                                    <tr>
                                        <td>图像特性</td>
                                        <td>从文件中加载，动态创建，可扩充地编辑</td>
                                        <td>与 AWT 相同</td>
                                        <td>从文件中加载，动态创建，基本编辑</td>
                                    </tr>
                                    <tr>
                                        <td>输入自动化</td>
                                        <td>Robot</td>
                                        <td>与 AWT 相同</td>
                                        <td>N/A</td>
                                    </tr>
                                    <tr>
                                        <td>显示工具条</td>
                                        <td>N/A</td>
                                        <td>JToolBar</td>
                                        <td>ToolBar、CoolBar</td>
                                    </tr>
                                    <tr>
                                        <td>显示进度条</td>
                                        <td>N/A</td>
                                        <td>JProgressBar</td>
                                        <td>ProgressBar</td>
                                    </tr>
                                    <tr>
                                        <td>将空间划分成区域</td>
                                        <td>N/A</td>
                                        <td>JSplitPane</td>
                                        <td>Sash 或 SashForm</td>
                                    </tr>
                                    <tr>
                                        <td>显示一个分标签页的区域</td>
                                        <td>N/A</td>
                                        <td>JTabbedPane</td>
                                        <td>TabFolder、CTabFolder</td>
                                    </tr>
                                    <tr>
                                        <td>显示制表信息</td>
                                        <td>N/A</td>
                                        <td>JTable</td>
                                        <td>Table</td>
                                    </tr>
                                    <tr>
                                        <td>格式化表的列</td>
                                        <td>N/A</td>
                                        <td>TableColumn</td>
                                        <td>TableColumn</td>
                                    </tr>
                                    <tr>
                                        <td>显示层次化信息</td>
                                        <td>N/A</td>
                                        <td>JTree</td>
                                        <td>Tree</td>
                                    </tr>
                                    <tr>
                                        <td>从一定范围的值中进行选择</td>
                                        <td>N/A</td>
                                        <td>JSlider</td>
                                        <td>Slider</td>
                                    </tr>
                                    <tr>
                                        <td>从一组离散范围的值中进行选择</td>
                                        <td>N/A</td>
                                        <td>JSpinner</td>
                                        <td>Scale</td>
                                    </tr>
                                    <tr>
                                        <td>对于基本显示的访问</td>
                                        <td>Toolkit、GraphicsConfiguration、GraphicsDevice</td>
                                        <td>与 AWT 相同</td>
                                        <td>Display</td>
                                    </tr>
                                    <tr>
                                        <td>将条目添加到系统托盘（system tray）中</td>
                                        <td>N/A</td>
                                        <td>N/A</td>
                                        <td>Tray</td>
                                    </tr>
                                    <tr>
                                        <td colspan="4"><strong>关键</strong>：N/A —— 不适用。在很多情况中，这种特性都可以通过创建定制控件或控件容器或利用其他定制编程来实现，不过实现的难度会有所不同。</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-awt-Frame"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Frame  及父类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.awt.Component
        java.awt.Container
            java.awt.Window
                java.awt.Frame

public class Frame extends Window implements MenuContainer {
    /** 实现对 Frame 类的可访问性支持 */
    protected class AccessibleAWTFrame extends AccessibleAWTWindow {}

    /** 只是窗口的状态 */
    public static final int NORMAL = 0;          // 窗体处于 "normal" 状态
    public static final int ICONIFIED = 1;       // 此状态位指示将窗体图标化
    public static final int MAXIMIZED_BOTH = 6;  // 此状态位掩码指示将窗体完全最大化
    public static final int MAXIMIZED_HORIZ = 2; // 此状态位指示在水平方向将窗体最大化
    public static final int MAXIMIZED_VERT = 4;  // 此状态位指示在垂直方向将窗体最大化

    /** 构造的 Frame 实例最初是不可见的 */
    public Frame() {}
    public Frame(String title) {}
    public Frame(GraphicsConfiguration gc) {}
    public Frame(String title, GraphicsConfiguration gc) {}
}

/** 所有菜单相关容器的超类 */
public interface MenuContainer {
    Font getFont();
    void remove(MenuComponent comp);
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Frame.html" target="_blank">Frame</a> 是带有标题和边框的顶层窗口。</p>
                            <p>窗体的大小包括为边框指定的所有区域。边框区域的尺寸可以使用 getInsets 方法获得，但是，由于这些尺寸与平台相关，因此在通过调用 pack 或 show 将窗体设置为可显示之前，将无法获得有效的 insets 值。由于窗体的总大小包括了边框区，因此边框实际上遮掩了窗体的部分区域，并将可用于在矩形中呈现和/或显示子部件的区域限制在一个矩形内，该矩形左上角的位置为 (insets.left, insets.top)，宽度为 width - (insets.left + insets.right)，长度为 height - (insets.top + insets.bottom)。 </p>
                            <p>窗体的默认布局为 BorderLayout。 </p>
                            <p>使用 setUndecorated，窗体可以关闭本机装饰（即 Frame 和 Titlebar）。但只有在窗体不是 displayable 时才能这样做。</p>
                            <p>在多屏幕环境中，通过使用 Frame(GraphicsConfiguration) 或 Frame(String title, GraphicsConfiguration) 构造 Frame，可以在不同的屏幕设备上创建 Frame。GraphicsConfiguration 对象是目标屏幕设备的 GraphicsConfiguration 对象之一。</p>
                            <p>在虚拟设备多屏幕环境中（其中桌面区域可以跨越多物理屏幕设备），所有配置的边界都是相对于虚拟坐标系的。虚拟坐标系的原点位于主物理屏幕的左上角。</p>
                            <ol>
                                <li><p><code>static Frame[] 	getFrames()</code> -- 返回一个此应用程序创建的所有 Frame 所组成的数组</p></li>

                                <li class="group"><p><code>MenuBar 	getMenuBar()</code> -- 获取此窗体的菜单栏</p></li>
                                <li><p><code>void 	setMenuBar(MenuBar mb)</code> -- 将此窗体的菜单栏设置为指定的菜单栏</p></li>
                                <li><p><code>void 	remove(MenuComponent m)</code> -- 从此窗体移除指定的菜单栏</p></li>

                                <li class="group"><p><code>int 	getExtendedState()</code> -- 获取此窗体的状态</p></li>
                                <li><p><code>void 	setExtendedState(int state)</code> -- 设置此窗体的状态</p></li>
                                <li><p><code>Image 	getIconImage()</code> -- 返回要作为此窗体图标显示的图像</p></li>
                                <li><p><code>void 	setIconImage(Image image)</code> -- 设置要作为此窗口图标显示的图像</p></li>
                                <li><p><code>Rectangle 	getMaximizedBounds()</code> -- 获取此窗体的最大化边界</p></li>
                                <li><p><code>void 	setMaximizedBounds(Rectangle bounds)</code> -- 设置此窗体的最大化边界</p></li>
                                <li><p><code>String 	getTitle()</code> -- 获得窗体的标题</p></li>
                                <li><p><code>void 	setTitle(String title)</code> -- 将此窗体的标题设置为指定的字符串</p></li>
                                <li><p><code>boolean 	isResizable()</code> -- 指示此窗体是否可由用户调整大小</p></li>
                                <li><p><code>void 	setResizable(boolean resizable)</code> -- 设置此窗体是否可由用户调整大小</p></li>
                                <li><p><code>void 	setUndecorated(boolean undecorated)</code> -- 禁用/启用窗体的装饰(true 将不显示窗口，关闭，最大化，最小化将不可见)</p></li>
                                <li><p><code>boolean 	isUndecorated()</code> -- 指示此窗体是否未装饰</p></li>
                                <li><p><code>void 	addNotify()</code> -- 通过将此窗体连接到本机屏幕资源，使其成为可显示的</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 通过移除与本机屏幕资源的连接，将此窗体设置为不可显示的</p></li>

                                <li class="group"><p><code>protected String 	paramString()</code> -- 返回表示此 Frame 状态的字符串</p></li>

                                <li class="group"><p><code>void 	setBackground(Color bgColor)</code> -- 设置此窗体的背景颜色</p></li>
                                <li><p><code>void 	setOpacity(float opacity)</code> -- 设置透明度(依赖于平台)</p></li>
                                <li><p><code>void 	setShape(Shape shape)</code> -- 设置窗口的形状</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此窗体有关的 AccessibleContext</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Window extends Container implements Accessible {
    /** Window 类型 */
    public enum Type {
        NORMAL,  // 正常窗口
        UTILITY, // 弹出窗口，如下拉菜单，对话框
        POPUP    // 实用程序窗口，通常是一个小窗口，如工具栏或调色板
    }

    /** 实现对 Window 类的可访问性支持 */
    protected class AccessibleAWTWindow extends AccessibleAWTContainer {}

    public Window(Frame owner) {}
    public Window(Window owner) {}
    public Window(Window owner, GraphicsConfiguration gc) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Window.html" target="_blank">Window</a> 对象是一个没有边界和菜单栏的顶层窗口。窗口的默认布局是 BorderLayout。</p>
                            <p>构造窗口时，它必须拥有窗体、对话框或其他作为其所有者定义的窗口。</p>
                            <p>注：顶层窗口（包括 Window、Frame 和 Dialog）的位置和大小受桌面窗口管理系统的控制。对 setLocation、setSize 和 setBounds 的调用是转发到窗口管理系统的请求（不是指令）。将尽所有努力响应这样的请求。但是，在某些情况下，窗口管理系统可以忽略这样的请求，或修改请求的几何结构，以放置和调整 Window 的大小，使之更好地与桌面设置匹配。 </p>
                            <p>应用程序可以随意设置不可见 Window 的大小和位置，但是当 Window 可见时，窗口管理系统可以随后更改它的大小和/或位置。将生成一个或多个 ComponentEvent 来表示新的几何结构。 </p>
                            <ol>
                                <li><p><code>static Window[] 	getOwnerlessWindows()</code> -- 返回此应用程序创建的所有没有所有者的 Window 组成的数组</p></li>
                                <li><p><code>static Window[] 	getWindows()</code> -- 返回此应用程序创建的所有 Window 数组</p></li>

                                <li class="group"><p><code>void 	addPropertyChangeListener(PropertyChangeListener listener)</code> -- 将 PropertyChangeListener 添加到侦听器列表</p></li>
                                <li><p><code>void 	addPropertyChangeListener(String propertyName, PropertyChangeListener listener)</code> -- 将某个特定属性的侦听器列表</p>
                                    <pre class="brush: java;">
/** 包括此窗体的以下属性:
 * this Window's font ("font")
 * this Window's background color ("background")
 * this Window's foreground color ("foreground")
 * this Window's focusability ("focusable")
 * this Window's focus traversal keys enabled state ("focusTraversalKeysEnabled")
 * this Window's Set of FORWARD_TRAVERSAL_KEYS ("forwardFocusTraversalKeys")
 * this Window's Set of BACKWARD_TRAVERSAL_KEYS ("backwardFocusTraversalKeys")
 *  this Window's Set of UP_CYCLE_TRAVERSAL_KEYS ("upCycleFocusTraversalKeys")
 * this Window's Set of DOWN_CYCLE_TRAVERSAL_KEYS ("downCycleFocusTraversalKeys")
 * this Window's focus traversal policy ("focusTraversalPolicy")
 * this Window's focusable Window state ("focusableWindowState")
 * this Window's always-on-top state("alwaysOnTop")
 */
</pre>
                                </li>

                                <li class="group"><p><code>void 	addWindowFocusListener(WindowFocusListener l)</code> -- 添加指定的窗口焦点侦听器</p></li>
                                <li><p><code>void 	removeWindowFocusListener(WindowFocusListener l)</code> -- 移除指定的窗口焦点侦听器，以便不再从此窗口接收窗口事件</p></li>
                                <li><p><code>void 	addWindowStateListener(WindowStateListener l)</code> -- 添加指定的窗口状态侦听器(最大化，最小化等)</p></li>
                                <li><p><code>void 	removeWindowStateListener(WindowStateListener l)</code> -- 移除指定的窗口状态侦听器，以便不再从此窗口接收窗口事件</p></li>
                                <li><p><code>void 	addWindowListener(WindowListener l)</code> -- 添加指定的窗口侦听器(包括以上两项，参见：<a href="docs/docs-java/api/java/awt/event/WindowAdapter.html" target="_blank">WindowAdapter</a>)</p></li>
                                <li><p><code>void 	removeWindowListener(WindowListener l)</code> -- 移除指定的窗口侦听器，以便不再从此窗口接收窗口事件</p></li>
                                <li><p><code>WindowFocusListener[] 	getWindowFocusListeners()</code> -- 返回在此窗口注册的所有窗口焦点侦听器所组成的数组</p></li>
                                <li><p><code>WindowStateListener[] 	getWindowStateListeners()</code> -- 返回在此窗口注册的所有窗口状态侦听器所组成的数组</p></li>
                                <li><p><code>WindowListener[] 	getWindowListeners()</code> -- 返回在此窗口注册的所有窗口侦听器所组成的数组</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前在此 Window 上注册的所有对象所组成的数组</p></li>

                                <li class="group"><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此窗口上的事件</p></li>
                                <li><p><code>protected void 	processWindowEvent(WindowEvent e)</code> -- 处理此窗口上发生的窗口事件</p></li>
                                <li><p><code>protected void 	processWindowFocusEvent(WindowEvent e)</code> -- 处理此窗口上发生的窗口焦点事件</p></li>
                                <li><p><code>protected void 	processWindowStateEvent(WindowEvent e)</code> -- 处理此窗口上发生的窗口状态事件</p></li>

                                <li class="group"><p><code>void 	setSize(Dimension d)</code> -- 设置窗体大小</p></li>
                                <li><p><code>void 	setSize(int width, int height)</code> -- 设置窗体大小</p></li>
                                <li><p><code>void 	setMinimumSize(Dimension minimumSize)</code> -- 将此窗口的最小大小设置为一个常量值</p></li>
                                <li><p><code>Color 	getBackground()</code> -- 获取此窗体的背景色</p></li>
                                <li><p><code>void 	setBackground(Color bgColor)</code> -- 设置背景颜色</p></li>
                                <li><p><code>void 	paint(Graphics g)</code> -- 使用 Graphics 绘制此容器</p></li>

                                <li class="group"><p><code>void 	setBounds(int x, int y, int width, int height)</code> -- 移动组件并调整其大小</p></li>
                                <li><p><code>void 	setBounds(Rectangle r)</code> -- 使用矩形设置此窗体位置和大小</p></li>

                                <li class="group"><p><code>void 	setLocation(int x, int y)</code> -- 设置窗体左上角距离屏幕的左上角的位置</p></li>
                                <li><p><code>void 	setLocation(Point p)</code> -- 设置窗体左上角距离屏幕的左上角的位置</p></li>
                                <li><p><code>void 	setLocationByPlatform(boolean locationByPlatform)</code> -- 设置窗口下次可见时应该出现的位置：本机窗口系统的默认位置，还是当前位置</p></li>
                                <li><p><code>void 	setLocationRelativeTo(Component c)</code> -- 位置为相对于某个组件的位置</p></li>
                                <li><p><code>boolean 	isLocationByPlatform()</code> -- 如果此窗口下次可见时，出现在本机窗口操作系统的默认位置，则返回 true</p></li>

                                <li class="group"><p><code>void 	setVisible(boolean b)</code> -- 设置此窗体可见性</p></li>
                                <li><p><code>void 	pack()</code> -- 调整此窗口的大小，以适合其子组件的首选大小和布局</p></li>
                                <li><p><code>boolean 	isShowing()</code> -- 检查此窗口是否显示在屏幕上</p></li>
                                <li><p><code>void 	dispose()</code> -- 释放由此 Window、其子组件及其拥有的所有子组件所使用的所有本机屏幕资源</p></li>
                                <li><p><code>void 	addNotify()</code> -- 通过创建到本机屏幕资源的连接，使此窗口变得可显示</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 通过移除此 Container 到其本机屏幕资源的连接，使其不可显示</p></li>
                                <li><p><code>void 	toBack()</code> -- 如果此窗口是可视的，则将此窗口置于后方，如果它是焦点窗口或活动窗口，则会导致丢失焦点或活动状态</p></li>
                                <li><p><code>void 	toFront()</code> -- 如果此窗口是可见的，则将此窗口置于前端，并可以将其设为焦点 Window</p></li>

                                <li class="group"><p><code>void 	setCursor(Cursor cursor)</code> -- 设置指定光标的光标图像</p></li>
                                <li><p><code>void 	setIconImage(Image image)</code> -- 设置要作为此窗口图标显示的图像</p></li>
                                <li><p><code>List&lt;Image> 	getIconImages()</code> -- 返回要作为此窗口的图标显示的图像序列</p></li>
                                <li><p><code>void 	setIconImages(List&lt;? extends Image> icons)</code> -- 设置要作为此窗口的图标显示的图像序列</p></li>

                                <li class="group"><p><code>float 	getOpacity()</code> -- 获取透明度值(依赖平台)</p></li>
                                <li><p><code>void 	setOpacity(float opacity)</code> -- 设置透明度(依赖平台)</p></li>
                                <li><p><code>boolean 	isOpaque()</code> -- 指示窗口当前是否不透明</p></li>
                                <li><p><code>Shape 	getShape()</code> -- 返回此窗体的图形</p></li>
                                <li><p><code>void 	setShape(Shape shape)</code> -- 设置此窗体的图形</p></li>
                                <li><p><code>Window.Type 	getType()</code> -- 获取窗体类型</p></li>
                                <li><p><code>void 	setType(Window.Type type)</code> -- 设置此窗体类型</p></li>
                                <li><p><code>Locale 	getLocale()</code> -- 如果设置了区域，则获取与此窗口关联的 Locale 对象</p></li>

                                <li class="group"><p><code>Window[] 	getOwnedWindows()</code> -- 返回包含此窗口当前拥有的所有窗口的数组</p></li>
                                <li><p><code>Window 	getOwner()</code> -- 返回此窗口的所有者</p></li>
                                <li><p><code>Toolkit 	getToolkit()</code> -- 返回此窗体的工具包</p></li>
                                <li><p><code>boolean 	isActive()</code> -- 返回此窗口是否为活动窗口</p></li>
                                <li><p><code>boolean 	isValidateRoot()</code> -- 是否为根窗口</p></li>

                                <li class="group"><p><code>boolean 	getFocusableWindowState()</code> -- 返回如果此窗口满足 isFocusableWindow 中列出的其他要求，其是否可以成为焦点窗口</p></li>
                                <li><p><code>void 	setFocusableWindowState(boolean focusableWindowState)</code> -- 设置如果此窗口满足 isFocusableWindow 中列出的其他要求，其是否可以成为焦点窗口</p></li>
                                <li><p><code>Container 	getFocusCycleRootAncestor()</code> -- 始终返回 null，因为窗口没有祖先；它们表示组件层次结构的顶层</p></li>
                                <li><p><code>void 	setFocusCycleRoot(boolean focusCycleRoot)</code> -- 不执行任何操作，因为窗口必须始终是焦点遍历循环的根</p></li>
                                <li><p><code>boolean 	isFocusCycleRoot()</code> -- 始终返回 true，因为所有窗口必须是焦点遍历循环的根</p></li>

                                <li class="group"><p><code>Component 	getFocusOwner()</code> -- 如果此窗口为焦点窗口，则返回是焦点窗口的子组件</p></li>
                                <li><p><code>Component 	getMostRecentFocusOwner()</code> -- 返回此窗口的子组件，该子组件在此窗口为焦点窗口时将接收焦点</p></li>
                                <li><p><code>boolean 	isFocusableWindow()</code> -- 返回此窗口是否可以成为焦点窗口</p></li>
                                <li><p><code>boolean 	isFocused()</code> -- 返回此窗口是否为焦点窗口</p></li>
                                <li><p><code>boolean 	isAutoRequestFocus()</code> -- 是否可以自动获取焦点</p></li>
                                <li><p><code>void 	setAutoRequestFocus(boolean autoRequestFocus)</code> -- 设置是否自动获取焦点</p></li>
                                <li><p><code>Set&lt;AWTKeyStroke> 	getFocusTraversalKeys(int id)</code> -- 获取此窗口的焦点遍历键</p></li>

                                <li class="group"><p><code>InputContext 	getInputContext()</code> --  获取此窗口的输入上下文</p></li>
                                <li><p><code>Dialog.ModalExclusionType 	getModalExclusionType()</code> -- 返回此窗口的模式排斥类型</p></li>
                                <li><p><code>void 	setModalExclusionType(Dialog.ModalExclusionType exclusionType)</code> -- 指定此窗口的模式排斥类型</p></li>
                                <li><p><code>String 	getWarningString()</code> -- 获取此窗口中显示的警告字符串</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此窗口关联的 AccessibleContext</p></li>

                                <li class="group"><p><code>boolean 	isAlwaysOnTopSupported()</code> -- 返回此窗口是否支持 always-on-top 模式</p></li>
                                <li><p><code>boolean 	isAlwaysOnTop()</code> -- 返回此窗口是否为 always-on-top 窗口</p></li>
                                <li><p><code>void 	setAlwaysOnTop(boolean alwaysOnTop)</code> -- 设置此窗口是否应该始终位于其他窗口上方</p></li>

                                <li class="group"><p><code>void 	createBufferStrategy(int numBuffers)</code> -- 为此组件上的多缓冲创建一个新策略</p></li>
                                <li><p><code>BufferStrategy 	getBufferStrategy()</code> -- 返回此组件使用的 BufferStrategy</p></li>
                                <li><p><code>void 	createBufferStrategy(int num, BufferCapabilities caps)</code> -- 根据所需缓冲区能力为此组件上的多缓冲创建新策略</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Container extends Component {
    /** 用于对可访问性提供默认支持的 Container 内部类 */
    protected class AccessibleAWTContainer extends AccessibleAWTComponent {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Container.html" target="_blank">Container</a> 是一般的 Abstract Window Toolkit(AWT) 容器对象是一个可包含其他 AWT 组件的组件。 </p>
                            <p>添加到容器中的组件放在一个列表中。列表的顺序将定义组件在容器内的正向堆栈顺序。如果将组件添加到容器中时未指定索引，则该索引将被添加到列表尾部（此后它位于堆栈顺序的底部）。 </p>
                            <ol>
                                <li><p><code>Component 	add(Component comp)</code> -- 将指定组件追加到此容器的尾部</p></li>
                                <li><p><code>Component 	add(Component comp, int index)</code> -- 将指定组件添加到此容器的给定位置上</p></li>
                                <li><p><code>void 	add(Component comp, Object constraints)</code> -- 将指定的组件按约束条件添加到此容器(不同的 LayoutManager 使用不同的约束类型，约束条件参照下面的 LayoutManager)</p></li>
                                <li><p><code>void 	add(Component comp, Object constraints, int index)</code> -- 使用指定约束，将指定组件添加到此容器的指定索引所在的位置上</p></li>
                                <li><p><code>Component 	add(String name, Component comp)</code> -- 将指定组件添加到此容器中</p></li>
                                <li><p><code>protected void 	addImpl(Component comp, Object constraints, int index)</code> -- 将指定组件添加到此容器的指定索引所在的位置上</p></li>

                                <li class="group"><p><code>void 	remove(Component comp)</code> -- 从此容器中移除指定组件</p></li>
                                <li><p><code>void 	remove(int index)</code> -- 从此容器中移除 index 指定的组件</p></li>
                                <li><p><code>void 	removeAll()</code> -- 从此容器中移除所有组件</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 通过将这个 Container 连接到本机屏幕资源，使其可以显示</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 通过移除此 Container 到其本机屏幕资源的连接，使其不可显示</p></li>
                                <li><p><code>void 	invalidate()</code> -- 使容器失效</p></li>
                                <li><p><code>void 	validate()</code> -- 验证此容器及其所有子组件</p></li>
                                <li><p><code>protected void 	validateTree()</code> -- 递归继承容器树，对于所有被标记为需要重新计算布局的子树（标记为无效的那些子树）重新计算布局</p></li>

                                <li class="group"><p><code>void 	paint(Graphics g)</code> -- 绘制容器</p></li>
                                <li><p><code>void 	paintComponents(Graphics g)</code> -- 绘制此容器中的每个组件</p></li>
                                <li><p><code>void 	print(Graphics g)</code> -- 打印容器</p></li>
                                <li><p><code>void 	printComponents(Graphics g)</code> -- 打印此容器中的每个组件</p></li>
                                <li><p><code>void 	update(Graphics g)</code> -- 更新容器</p></li>

                                <li class="group"><p><code>void 	setLayout(LayoutManager mgr)</code> -- 设置此容器的布局管理器</p></li>
                                <li><p><code>void 	doLayout()</code> -- 使此容器布置其组件</p></li>

                                <li class="group"><p><code>void 	addContainerListener(ContainerListener l)</code> -- 添加指定容器的侦听器(添加/移除组件到此容器监听)</p></li>
                                <li><p><code>void 	removeContainerListener(ContainerListener l)</code> -- 移除指定容器的侦听器，从而不再接收来自此容器的容器事件</p></li>
                                <li><p><code>ContainerListener[] 	getContainerListeners()</code> -- 返回已在此容器上注册的所有容器侦听器的数组</p></li>
                                <li><p><code>protected void 	processContainerEvent(ContainerEvent e)</code> -- 通过将发生在此容器上的容器事件指派给所有已注册的 ContainerListener 对象来处理这些事件</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理关于此容器的事件</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前已在此 Container 上注册的指定类型的监听器数组</p></li>

                                <li class="group"><p><code>void 	addPropertyChangeListener(PropertyChangeListener listener)</code> -- 将一个 PropertyChangeListener 添加到侦听器列表中</p></li>
                                <li><p><code>void 	addPropertyChangeListener(String propertyName, PropertyChangeListener listener)</code> -- 将某个特定属性的侦听器列表</p></li>

                                <li class="group"><p><code>Component 	findComponentAt(int x, int y)</code> -- 对包含指定位置的可视子组件进行定位</p></li>
                                <li><p><code>Component 	findComponentAt(Point p)</code> -- 对包含指定点的可视子组件进行定位</p></li>
                                <li><p><code>Component 	getComponent(int n)</code> -- 获取此容器中的第 n 个组件</p></li>
                                <li><p><code>Component 	getComponentAt(int x, int y)</code> -- 对包含 x，y 位置的组件进行定位</p></li>
                                <li><p><code>Component 	getComponentAt(Point p)</code> -- 获取包含指定点的组件</p></li>
                                <li><p><code>int 	getComponentCount()</code> -- 获取此面板中的组件数</p></li>
                                <li><p><code>Component[] 	getComponents()</code> -- 获取此容器中的所有组件</p></li>
                                <li><p><code>void 	applyComponentOrientation(ComponentOrientation o)</code> -- 设置此容器和其中包含的所有组件的 ComponentOrientation 属性</p></li>
                                <li><p><code>boolean 	isAncestorOf(Component c)</code> -- 检查该组件是否包含在此容器的组件层次结构中</p></li>
                                <li><p><code>int 	getComponentZOrder(Component comp)</code> -- 返回容器内组件的 z 顺序索引</p></li>
                                <li><p><code>void 	setComponentZOrder(Component comp, int index)</code> -- 将指定组件移动到容器中指定的 z 顺序索引</p></li>

                                <li class="group"><p><code>Set&lt;AWTKeyStroke> 	getFocusTraversalKeys(int id)</code> -- 为此 Container 的给定遍历操作返回焦点遍历键的 Set</p></li>
                                <li><p><code>void 	setFocusTraversalKeys(int id, Set&lt;? extends AWTKeyStroke> keystrokes)</code> -- 为此 Container 的给定遍历操作设置焦点遍历键</p></li>
                                <li><p><code>boolean 	areFocusTraversalKeysSet(int id)</code> -- 返回是否已经为此 Container 明确定义了用于给定焦点遍历操作的焦点遍历键的 Set</p></li>
                                <li><p><code>boolean 	isFocusTraversalPolicySet()</code> -- 返回是否为此 Container 明确设置焦点遍历策略</p></li>
                                <li><p><code>FocusTraversalPolicy 	getFocusTraversalPolicy()</code> -- 返回焦点遍历策略</p></li>
                                <li><p><code>void 	setFocusTraversalPolicy(FocusTraversalPolicy policy)</code> -- 如果此 Container 是一个焦点循环根，则设置将管理此 Container 的子代的键盘遍历的焦点遍历策略</p></li>
                                <li><p><code>void 	setFocusTraversalPolicyProvider(boolean provider)</code> -- 设置是否将用此容器提供焦点遍历策略</p></li>
                                <li><p><code>boolean 	isFocusTraversalPolicyProvider()</code> -- 返回此容器是否提供焦点遍历策略</p></li>
                                <li><p><code>boolean 	isFocusCycleRoot()</code> -- 返回此 Container 是否是某个焦点遍历循环的根</p></li>
                                <li><p><code>void 	setFocusCycleRoot(boolean focusCycleRoot)</code> -- 设置此 Container 是否是某个焦点遍历循环的根</p></li>
                                <li><p><code>boolean 	isFocusCycleRoot(Container container)</code> -- 返回指定的 Container 是否是此 Container 的焦点遍历循环的焦点循环根</p></li>
                                <li><p><code>void 	transferFocusDownCycle()</code> -- 将焦点向下传输一个焦点遍历循环</p></li>

                                <li class="group"><p><code>Dimension 	getMaximumSize()</code> -- 返回此容器的最大大小</p></li>
                                <li><p><code>Dimension 	getPreferredSize()</code> -- 返回此容器的首选大小</p></li>
                                <li><p><code>Dimension 	getMinimumSize()</code> -- 返回此容器的最小大小</p></li>
                                <li><p><code>Insets 	getInsets()</code> -- 确定此容器的 insets，它指示容器边框的大小</p></li>
                                <li><p><code>LayoutManager 	getLayout()</code> -- 获取此容器的布局管理器</p></li>
                                <li><p><code>float 	getAlignmentX()</code> -- 返回沿 x 轴的对齐方式</p></li>
                                <li><p><code>float 	getAlignmentY()</code> -- 返回沿 y 轴的对齐方式</p></li>

                                <li class="group"><p><code>void 	setFont(Font f)</code> -- 设置此容器的字体</p></li>
                                <li><p><code>Point 	getMousePosition(boolean allowChildren)</code> -- 如果 Container 位于鼠标指针下，则返回鼠标指针在此 Container 的坐标中的位置</p></li>
                                <li><p><code>boolean 	isValidateRoot()</code> -- </p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此 Container 的状态的字符串</p></li>

                                <li class="group"><p><code>void 	list(PrintStream out, int indent)</code> -- 将此容器的清单打印到指定输出流，从指定缩排位置开始</p></li>
                                <li><p><code>void 	list(PrintWriter out, int indent)</code> -- 将一个列表打印到指定打印编写器，从指定缩排位置开始</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public abstract class Component implements ImageObserver, MenuContainer, Serializable {
    public static final float TOP_ALIGNMENT = 0.0f;    // 顶部对齐
    public static final float BOTTOM_ALIGNMENT = 1.0f; // 底部对齐
    public static final float CENTER_ALIGNMENT = 0.5f; // 居中对齐
    public static final float LEFT_ALIGNMENT = 0.0f;   // 左对齐
    public static final float RIGHT_ALIGNMENT = 1.0f;  // 右对齐

    protected Component() {}
    protected AccessibleContext accessibleContext = null;

    /** 常见方式的枚举，指示组件的基线可以随大小的更改而更改 */
    public enum BaselineResizeBehavior {
        CONSTANT_ASCENT,  // 指示基线相对于 y 原点保持不变
        CENTER_OFFSET,    // 指示基线与组件的中心保持固定的距离
        CONSTANT_DESCENT, // 指示基线相对于高度保持不变，且不会随着宽度不同而发生更改
        OTHER             // 指示基线调整行为无法使用其他任何常量表示
    }
    /** 用于将屏幕外的画面以位图传输方式传输到一个组件的内部类 */
    protected class BltBufferStrategy extends BufferStrategy {}
    /**  在组件上翻转缓冲区的内部类 */
    protected class FlipBufferStrategy extends BufferStrategy {}
    /** 用来为可访问性提供默认支持的 Component 的内部类 */
    protected abstract class AccessibleAWTComponent extends AccessibleContext implements Serializable,
                                AccessibleComponent {}
}

/** 用于在构造 Image 时，接收有关 Image 信息通知的异步更新接口 */
public interface ImageObserver {
    /** infoflags 参数 */
    int WIDTH = 1;        // 指示基本图像的宽度现在可用
    int HEIGHT = 2;       // 指示基本图像的高度现在可用
    int PROPERTIES = 4;   // 指示该图像的属性现在可用
    int SOMEBITS = 8;     // 指示已提供了绘制图像缩放变体所需的更多像素
    int FRAMEBITS = 16;   // 指示多帧图像（以前绘制的）的另一个完整帧现在可以再次绘制
    int ALLBITS = 32;     // 指示现在已完成了一幅以前绘制的静态图像，并且可以其最终形式再次绘制它
    int ERROR = 64;       // 指示被异步跟踪的图像遇到了错误
    int ABORT = 128;      // 指示被异步跟踪的图像在生成完成前即已中止

    /** 当以前使用异步接口所请求的图像的信息变得可用时就调用此方法 */
    boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height);
}

/** 所有菜单相关容器的超类 */
public interface MenuContainer {
    Font getFont(); // 获取使用的字体
    void remove(MenuComponent comp); // 移除指定的菜单组件
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Component.html" target="_blank">Component</a> 是一个具有图形表示能力的对象，可在屏幕上显示，并可与用户进行交互。</p>
                            <p>Component 类是与菜单不相关的 Abstract Window Toolkit 组件的抽象超类。还可以直接扩展类 Component 来创建一个轻量级组件。轻量级组件是与本机不透明窗口不相关的组件。 </p>
                            <ol>
                                <li><p><code>void 	addComponentListener(ComponentListener l)</code> -- 添加指定的组件侦听器(位置，大小，是否可见)</p></li>
                                <li><p><code>void 	addFocusListener(FocusListener l)</code> -- 添加指定的焦点侦听器</p></li>
                                <li><p><code>void 	addHierarchyBoundsListener(HierarchyBoundsListener l)</code> -- 添加指定的层次结构边界侦听器</p></li>
                                <li><p><code>void 	addHierarchyListener(HierarchyListener l)</code> -- 添加指定的层次结构侦听器</p></li>
                                <li><p><code>void 	addInputMethodListener(InputMethodListener l)</code> -- 添加指定的输入方法侦听器</p></li>
                                <li><p><code>void 	addKeyListener(KeyListener l)</code> -- 添加指定的按键侦听器</p></li>
                                <li><p><code>void 	addMouseListener(MouseListener l)</code> -- 添加指定的鼠标侦听器</p></li>
                                <li><p><code>void 	addMouseMotionListener(MouseMotionListener l)</code> -- 添加指定的鼠标移动侦听器</p></li>
                                <li><p><code>void 	addMouseWheelListener(MouseWheelListener l)</code> -- 添加指定的鼠标滚轮侦听器</p></li>

                                <li class="group"><p><code>void 	removeComponentListener(ComponentListener l)</code> -- 移除指定的组件侦听器</p></li>
                                <li><p><code>void 	removeFocusListener(FocusListener l)</code> -- 移除指定的焦点侦听器</p></li>
                                <li><p><code>void 	removeHierarchyBoundsListener(HierarchyBoundsListener l)</code> -- 移除指定的层次结构边界侦听器</p></li>
                                <li><p><code>void 	removeHierarchyListener(HierarchyListener l)</code> -- 移除指定的层次结构侦听器</p></li>
                                <li><p><code>void 	removeInputMethodListener(InputMethodListener l)</code> -- 移除指定的输入方法侦听器</p></li>
                                <li><p><code>void 	removeKeyListener(KeyListener l)</code> -- 移除指定的按键侦听器</p></li>
                                <li><p><code>void 	removeMouseListener(MouseListener l)</code> -- 移除指定的鼠标侦听器</p></li>
                                <li><p><code>void 	removeMouseMotionListener(MouseMotionListener l)</code> -- 移除指定的鼠标移动侦听器</p></li>
                                <li><p><code>void 	removeMouseWheelListener(MouseWheelListener l)</code> -- 移除指定的鼠标滚轮侦听器</p></li>

                                <li class="group"><p><code>protected void 	processComponentEvent(ComponentEvent e)</code> -- 处理组件上发生的组件事件</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理组件上发生的事件</p></li>
                                <li><p><code>protected void 	processFocusEvent(FocusEvent e)</code> -- 处理组件上发生的焦点事件</p></li>
                                <li><p><code>protected void 	processHierarchyBoundsEvent(HierarchyEvent e)</code> -- 处理组件上发生的层次结构边界事件</p></li>
                                <li><p><code>protected void 	processHierarchyEvent(HierarchyEvent e)</code> -- 处理组件上发生的层次结构事件</p></li>
                                <li><p><code>protected void 	processInputMethodEvent(InputMethodEvent e)</code> -- 处理组件上发生的输入方法事件</p></li>
                                <li><p><code>protected void 	processKeyEvent(KeyEvent e)</code> -- 处理组件上发生的按键事件</p></li>
                                <li><p><code>protected void 	processMouseEvent(MouseEvent e)</code> -- 处理组件上发生的鼠标事件</p></li>
                                <li><p><code>protected void 	processMouseMotionEvent(MouseEvent e)</code> -- 处理组件上发生的鼠标移动事件</p></li>
                                <li><p><code>protected void 	processMouseWheelEvent(MouseWheelEvent e)</code> -- 处理组件上发生的鼠标滚轮事件</p></li>

                                <li class="group"><p><code>void 	addPropertyChangeListener(PropertyChangeListener listener)</code> -- 属性改变监听器</p></li>
                                <li><p><code>void 	addPropertyChangeListener(String propertyName, PropertyChangeListener listener)</code> -- 指定属性改变监听器</p></li>
                                <li><p><code>void 	removePropertyChangeListener(PropertyChangeListener listener)</code> -- 移除一个属性改变监听器</p></li>
                                <li><p><code>void 	removePropertyChangeListener(String propertyName, PropertyChangeListener listener)</code> -- 移除指定属性名的属性改变监听器</p></li>
                                <li><p><code>PropertyChangeListener[] 	getPropertyChangeListeners()</code> -- 返回在此组件上所有已注册的属性更改侦听器的数组</p></li>
                                <li><p><code>PropertyChangeListener[] 	getPropertyChangeListeners(String propertyName)</code> -- 返回与指定属性相关联的所有侦听器的数组</p></li>
                                <li><p><code>protected void 	firePropertyChange(String propertyName, boolean oldValue, boolean newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>protected void 	firePropertyChange(String propertyName, int oldValue, int newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>protected void 	firePropertyChange(String propertyName, Object oldValue, Object newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, byte oldValue, byte newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, char oldValue, char newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, short oldValue, short newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, long oldValue, long newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, float oldValue, float newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, double oldValue, double newValue)</code> -- 通知属性发生改变</p></li>

                                <li><p><code>void 	add(PopupMenu popup)</code> -- 向组件添加指定的弹出菜单</p></li>
                                <li><p><code>void 	addNotify()</code> -- 通过将此 Component 连接到一个本机屏幕资源使其成为可显示的</p></li>

                                <li><p><code>void 	applyComponentOrientation(ComponentOrientation orientation)</code> -- 设置此组件及其包含的所有组件的 ComponentOrientation 属性</p></li>
                                <li><p><code>boolean 	areFocusTraversalKeysSet(int id)</code> -- 返回是否为此 Component 显式定义了给定焦点遍历操作的焦点遍历键 Set</p></li>

                                <li class="group"><p><code>int 	checkImage(Image image, ImageObserver observer)</code> -- 返回指定图像屏幕表示的构造状态</p></li>
                                <li><p><code>int 	checkImage(Image image, int width, int height, ImageObserver observer)</code> -- 返回指定图像屏幕表示的构造状态</p></li>
                                <li><p><code>Image 	createImage(ImageProducer producer)</code> -- 根据指定的图像生成器创建一幅图像</p></li>
                                <li><p><code>Image 	createImage(int width, int height)</code> -- 创建一幅用于双缓冲的、可在屏幕外绘制的图像</p></li>
                                <li><p><code>VolatileImage 	createVolatileImage(int width, int height)</code> -- 创建一幅用于双缓冲的、可变的、可在屏幕外绘制的图像</p></li>
                                <li><p><code>VolatileImage 	createVolatileImage(int width, int height, ImageCapabilities caps)</code> -- 创建一幅具有给定能力的、可变的、可在屏幕外绘制的图像</p></li>

                                <li><p><code>protected AWTEvent 	coalesceEvents(AWTEvent existingEvent, AWTEvent newEvent)</code> -- 将正发送的事件与现有事件组合在一起</p></li>
                                <li><p><code>boolean 	contains(int x, int y)</code> -- 检查组件是否“包含”指定的点</p></li>
                                <li><p><code>boolean 	contains(Point p)</code> -- 检查组件是否“包含”指定的点</p></li>

                                <li><p><code>protected void 	disableEvents(long eventsToDisable)</code> -- 禁用由传递给此组件的指定事件掩码参数所定义的事件</p></li>
                                <li><p><code>protected void 	enableEvents(long eventsToEnable)</code> -- 启用由传递给此组件的指定事件掩码参数所定义的事件</p></li>
                                <li><p><code>void 	dispatchEvent(AWTEvent e)</code> -- 为组件或其子组件之一指派事件</p></li>
                                <li><p><code>void 	doLayout()</code> -- 提示布局管理器布局此组件</p></li>
                                <li><p><code>void 	enableInputMethods(boolean enable)</code> -- 启用或禁用此组件的输入方法支持</p></li>

                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Component 相关的 AccessibleContext</p></li>
                                <li><p><code>float 	getAlignmentX()</code> -- 返回 x 轴的对齐方式</p></li>
                                <li><p><code>float 	getAlignmentY()</code> -- 返回 y 轴的对齐方式</p></li>
                                <li><p><code>Color 	getBackground()</code> -- 获取组件的背景色</p></li>

                                <li><p><code>int 	getBaseline(int width, int height)</code> -- 返回基线</p></li>
                                <li><p><code>Component.BaselineResizeBehavior 	getBaselineResizeBehavior()</code> -- 返回一个指示组件的基线如何随大小发生更改的枚举</p></li>

                                <li><p><code>Rectangle 	getBounds()</code> -- 以 Rectangle 对象的形式获取组件的边界</p></li>
                                <li><p><code>Rectangle 	getBounds(Rectangle rv)</code> -- 将组件的边界存储到“返回值” rv 中并返回 rv</p></li>
                                <li><p><code>ColorModel 	getColorModel()</code> -- 获取用于在输出设备上显示组件的 ColorModel 实例</p></li>
                                <li><p><code>Component 	getComponentAt(int x, int y)</code> -- 确定此组件或其直接子组件之一是否包含（x，y）位置，并且如果是，则返回包含该位置的组件</p></li>
                                <li><p><code>Component 	getComponentAt(Point p)</code> -- 返回包含指定点的组件或子组件</p></li>
                                <li><p><code>ComponentListener[] 	getComponentListeners()</code> -- 返回在此组件上所有已注册的组件侦听器的数组</p></li>
                                <li><p><code>ComponentOrientation 	getComponentOrientation()</code> -- 检索将用于排序此组件内的元素或文本的语言敏感的方向</p></li>
                                <li><p><code>Cursor 	getCursor()</code> -- 获取组件中的光标</p></li>
                                <li><p><code>DropTarget 	getDropTarget()</code> -- 获取与此 Component 相关的 DropTarget</p></li>
                                <li><p><code>Container 	getFocusCycleRootAncestor()</code> -- 返回作为此 Component 焦点遍历循环的焦点循环根的 Container</p></li>
                                <li><p><code>FocusListener[] 	getFocusListeners()</code> -- 返回在此组件上所有已注册的焦点侦听器的数组</p></li>
                                <li><p><code>Set&lt;AWTKeyStroke> 	getFocusTraversalKeys(int id)</code> -- 返回此 Component 的给定遍历操作的焦点遍历键 Set</p></li>
                                <li><p><code>boolean 	getFocusTraversalKeysEnabled()</code> -- 返回是否已为此 Component 启用了焦点遍历键</p></li>
                                <li><p><code>Font 	getFont()</code> -- 获取组件的字体</p></li>
                                <li><p><code>FontMetrics 	getFontMetrics(Font font)</code> -- 获取指定字体的字体规格</p></li>
                                <li><p><code>Color 	getForeground()</code> -- 获取组件的前景色</p></li>
                                <li><p><code>Graphics 	getGraphics()</code> -- 为组件创建一个图形上下文</p></li>
                                <li><p><code>GraphicsConfiguration 	getGraphicsConfiguration()</code> -- 获取与此 Component 相关的 GraphicsConfiguration</p></li>
                                <li><p><code>int 	getHeight()</code> -- 返回组件的当前高度</p></li>
                                <li><p><code>HierarchyBoundsListener[] 	getHierarchyBoundsListeners()</code> -- 返回在此组件上所有已注册的层次结构边界侦听器的数组</p></li>
                                <li><p><code>HierarchyListener[] 	getHierarchyListeners()</code> -- 返回在此组件上所有已注册的层次结构侦听器的数组</p></li>
                                <li><p><code>boolean 	getIgnoreRepaint()</code> -- 是否应该忽略接收操作系统发出的绘制消息</p></li>
                                <li><p><code>InputContext 	getInputContext()</code> -- 获取此组件使用的输入上下文</p></li>
                                <li><p><code>InputMethodListener[] 	getInputMethodListeners()</code> -- 返回在此组件上所有已注册的输入方法侦听器的数组</p></li>
                                <li><p><code>InputMethodRequests 	getInputMethodRequests()</code> -- 获取输入方法请求处理程序，该处理程序支持此组件输入方法发出的请求</p></li>
                                <li><p><code>KeyListener[] 	getKeyListeners()</code> -- 返回在此组件上所有已注册的按键侦听器的数组</p></li>
                                <li><p><code>&lt;T extends EventListener>T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回一个当前在此 Component 上作为 FooListener 注册的所有对象的数组</p></li>
                                <li><p><code>Locale 	getLocale()</code> -- 获取组件的语言环境</p></li>
                                <li><p><code>Point 	getLocation()</code> -- 获取组件的位置，形式是指定组件左上角的一个点</p></li>
                                <li><p><code>Point 	getLocation(Point rv)</code> -- 将组件的 x，y 原点存储到“返回值” rv 中并返回 rv</p></li>
                                <li><p><code>Point 	getLocationOnScreen()</code> -- 获取组件的位置，形式是一个指定屏幕坐标空间中组件左上角的一个点</p></li>
                                <li><p><code>Dimension 	getMaximumSize()</code> -- 获取组件的最大大小</p></li>
                                <li><p><code>Dimension 	getPreferredSize()</code> -- 获取组件的首选大小</p></li>
                                <li><p><code>Dimension 	getMinimumSize()</code> -- 获取组件的最小大小</p></li>
                                <li><p><code>MouseListener[] 	getMouseListeners()</code> -- 返回在此组件上所有已注册的鼠标侦听器的数组</p></li>
                                <li><p><code>MouseMotionListener[] 	getMouseMotionListeners()</code> -- 返回在此组件上所有已注册的鼠标移动侦听器的数组</p></li>
                                <li><p><code>Point 	getMousePosition()</code> -- 如果此 Component 正好位于鼠标指针下，则返回鼠标指针在该 Component 的坐标空间中的位置</p></li>
                                <li><p><code>MouseWheelListener[] 	getMouseWheelListeners()</code> -- 返回在此组件上所有已注册的鼠标滚轮侦听器的数组</p></li>
                                <li><p><code>String 	getName()</code> -- 获取组件的名称</p></li>
                                <li><p><code>Container 	getParent()</code> -- 获取此组件的父级</p></li>


                                <li><p><code>Dimension 	getSize()</code> -- 以 Dimension 对象的形式返回组件的大小</p></li>
                                <li><p><code>Dimension 	getSize(Dimension rv)</code> -- 将组件的宽度/高度存储到“返回值”rv 中并返回 rv</p></li>
                                <li><p><code>Toolkit 	getToolkit()</code> -- 获取此组件的工具包</p></li>
                                <li><p><code>Object 	getTreeLock()</code> -- 获取此组件用于 AWT 组件树和布局操作的锁定对象</p></li>
                                <li><p><code>int 	getWidth()</code> -- 返回组件的当前宽度</p></li>
                                <li><p><code>int 	getX()</code> -- 返回组件原点的当前 x 坐标</p></li>
                                <li><p><code>int 	getY()</code> -- 返回组件原点的当前 y 坐标</p></li>
                                <li><p><code>boolean 	hasFocus()</code> -- 如果此 Component 是焦点所有者，则返回 true</p></li>
                                <li><p><code>boolean 	imageUpdate(Image img, int infoflags, int x, int y, int w, int h)</code> -- 图像已改变时重绘组件</p></li>
                                <li><p><code>void 	invalidate()</code> -- 使此组件无效</p></li>
                                <li><p><code>boolean 	isBackgroundSet()</code> -- 返回是否已为此组件显示地设置了背景色</p></li>
                                <li><p><code>boolean 	isCursorSet()</code> -- 返回是否已为此组件显示地设置了光标</p></li>
                                <li><p><code>boolean 	isDisplayable()</code> -- 确定此组件是否可以显示</p></li>
                                <li><p><code>boolean 	isDoubleBuffered()</code> -- 如果将此组件绘制到一个随后复制到屏幕上的屏幕外图像（“缓冲区”），则返回 true</p></li>
                                <li><p><code>boolean 	isEnabled()</code> -- 确定此组件是否已启用</p></li>
                                <li><p><code>boolean 	isFocusable()</code> -- 返回此 Component 是否可以获得焦点</p></li>
                                <li><p><code>boolean 	isFocusCycleRoot(Container container)</code> -- 返回指定的 Container 是否为此 Component 焦点遍历循环的焦点循环根</p></li>
                                <li><p><code>boolean 	isFocusOwner()</code> -- 如果此 Component 是焦点所有者，则返回 true</p></li>
                                <li><p><code>boolean 	isFontSet()</code> -- 返回是否已为此组件显示地设置了字体</p></li>
                                <li><p><code>boolean 	isForegroundSet()</code> -- 返回是否已为此组件显式地设置了前景色</p></li>
                                <li><p><code>boolean 	isLightweight()</code> -- 轻量级组件没有本机工具包同位体</p></li>
                                <li><p><code>boolean 	isMaximumSizeSet()</code> -- 如果已将最大大小设置为非 null 值，则返回 true</p></li>
                                <li><p><code>boolean 	isPreferredSizeSet()</code> -- 如果已将首选大小设置为非 null 值，则返回 true</p></li>
                                <li><p><code>boolean 	isMinimumSizeSet()</code> -- 是否调用了 setMinimumSize</p></li>
                                <li><p><code>boolean 	isOpaque()</code> -- 如果组件是完全不透明的，则返回 true</p></li>
                                <li><p><code>boolean 	isShowing()</code> -- 确定此组件是否在屏幕上显示</p></li>
                                <li><p><code>boolean 	isValid()</code> -- 确定组件是否有效</p></li>
                                <li><p><code>boolean 	isVisible()</code> -- 确定此组件在其父容器可见时是否应该可见</p></li>
                                <li><p><code>void 	list()</code> -- 将组件列表打印到标准系统输出流 System.out</p></li>
                                <li><p><code>void 	list(PrintStream out)</code> -- 将组件列表打印到指定的输出流</p></li>
                                <li><p><code>void 	list(PrintStream out, int indent)</code> -- 将列表从指定的缩排开始打印到指定的打印流</p></li>
                                <li><p><code>void 	list(PrintWriter out)</code> -- 将列表打印到指定的打印编写器</p></li>
                                <li><p><code>void 	list(PrintWriter out, int indent)</code> -- 将列表从指定的缩排开始打印到指定的打印编写器</p></li>
                                <li><p><code>void 	paint(Graphics g)</code> -- 绘制此组件</p></li>
                                <li><p><code>void 	paintAll(Graphics g)</code> -- 绘制此组件及其所有子组件</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回此组件状态的字符串表示形式</p></li>
                                <li><p><code>boolean 	prepareImage(Image image, ImageObserver observer)</code> -- 准备一幅在此组件上呈现的图像</p></li>
                                <li><p><code>boolean 	prepareImage(Image image, int width, int height, ImageObserver observer)</code> -- 以指定的宽度和高度准备一幅在此组件上呈现的图像</p></li>
                                <li><p><code>void 	print(Graphics g)</code> -- 打印此组件</p></li>
                                <li><p><code>void 	printAll(Graphics g)</code> -- 打印此组件及其所有子组件</p></li>



                                <li><p><code>void 	remove(MenuComponent popup)</code> -- 从组件移除指定的弹出菜单</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 通过销毁此 Component 的本机屏幕资源使其成为不可显示的</p></li>

                                <li><p><code>void 	repaint()</code> -- 重绘此组件</p></li>
                                <li><p><code>void 	repaint(int x, int y, int width, int height)</code> -- 重绘组件的指定矩形区域</p></li>
                                <li><p><code>void 	repaint(long tm)</code> --  在 tm 毫秒内重绘组件</p></li>
                                <li><p><code>void 	repaint(long tm, int x, int y, int width, int height)</code> -- 在 tm 毫秒内重绘组件的指定矩形区域</p></li>

                                <li><p><code>void 	requestFocus()</code> -- 请求此 Component 获取输入焦点</p></li>
                                <li><p><code>protected boolean 	requestFocus(boolean temporary)</code> -- 请求此 Component 获取输入焦点，并且此 Component 的顶层祖先成为获得焦点的 Window</p></li>
                                <li><p><code>boolean 	requestFocusInWindow()</code> -- 如果此 Component 的顶层祖先已经是获得焦点的 Window，则请求此 Component 获取输入焦点</p></li>
                                <li><p><code>protected boolean 	requestFocusInWindow(boolean temporary)</code> -- 如果此 Component 的顶层祖先已经是获得焦点的 Window，则请求此 Component 获取输入焦点</p></li>

                                <li><p><code>void 	revalidate()</code> -- </p></li>
                                <li><p><code>void 	setBackground(Color c)</code> -- 设置组件的背景色</p></li>
                                <li><p><code>void 	setBounds(int x, int y, int width, int height)</code> -- 移动组件并调整其大小</p></li>
                                <li><p><code>void 	setBounds(Rectangle r)</code> -- 移动组件并调整其大小，使其符合新的有界矩形 r</p></li>
                                <li><p><code>void 	setComponentOrientation(ComponentOrientation o)</code> -- 设置语言敏感的方向，用于排序此组件内的元素或文本</p></li>
                                <li><p><code>void 	setCursor(Cursor cursor)</code> -- 为指定的光标设置光标图像</p></li>
                                <li><p><code>void 	setDropTarget(DropTarget dt)</code> -- 将组件与 DropTarget 相关联</p></li>
                                <li><p><code>void 	setEnabled(boolean b)</code> -- 启用或禁用此组件</p></li>
                                <li><p><code>void 	setFocusable(boolean focusable)</code> -- 将此 Component 的焦点状态设置为指定值</p></li>
                                <li><p><code>void 	setFocusTraversalKeys(int id, Set&lt;? extends AWTKeyStroke> keystrokes)</code> -- 为此 Component 的给定遍历操作设置焦点遍历键</p></li>
                                <li><p><code>void 	setFocusTraversalKeysEnabled(boolean focusTraversalKeysEnabled)</code> -- 设置是否为此 Component 启用焦点遍历键</p></li>
                                <li><p><code>void 	setFont(Font f)</code> -- 设置组件的字体</p></li>
                                <li><p><code>void 	setForeground(Color c)</code> -- 设置组件的前景色</p></li>
                                <li><p><code>void 	setIgnoreRepaint(boolean ignoreRepaint)</code> -- 设置是否应该忽略从操作系统接受的绘制消息</p></li>
                                <li><p><code>void 	setLocale(Locale l)</code> -- 设置组件的语言环境</p></li>
                                <li><p><code>void 	setLocation(int x, int y)</code> -- 将组件移到新位置</p></li>
                                <li><p><code>void 	setLocation(Point p)</code> -- 将组件移到新位置</p></li>
                                <li><p><code>void 	setMaximumSize(Dimension maximumSize)</code> -- 将组件的最大大小设置为常量值</p></li>
                                <li><p><code>void 	setPreferredSize(Dimension preferredSize)</code> -- 将组件的首选大小设置为常量值</p></li>
                                <li><p><code>void 	setMinimumSize(Dimension minimumSize)</code> -- 将组件的最小大小设置为常量值</p></li>
                                <li><p><code>void 	setName(String name)</code> -- 将组件的名称设置为指定的字符串</p></li>
                                <li><p><code>void 	setSize(Dimension d)</code> -- 调整组件的大小</p></li>
                                <li><p><code>void 	setSize(int width, int height)</code> -- 调整组件的大小</p></li>
                                <li><p><code>void 	setVisible(boolean b)</code> -- 显示或隐藏此组件</p></li>
                                <li><p><code>String 	toString()</code> -- 返回此组件及其值的字符串表示形式</p></li>
                                <li><p><code>void 	transferFocus()</code> -- 将焦点转移到下一个组件</p></li>
                                <li><p><code>void 	transferFocusBackward()</code> -- 将焦点转移到前一个组件</p></li>
                                <li><p><code>void 	transferFocusUpCycle()</code> -- 将焦点向上转移一个焦点遍历循环</p></li>
                                <li><p><code>void 	update(Graphics g)</code> -- 更新组件</p></li>
                                <li><p><code>void 	validate()</code> -- 确保组件具有有效的布局</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-awt-LayoutManager"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">LayoutManager 及实现类(AWT)</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface LayoutManager {
    void layoutContainer(Container parent); // 指定布局容器
    void addLayoutComponent(String name, Component comp); // 添加组件到容器，并关联名字
    void removeLayoutComponent(Component comp); // 从容器移除指定组件
    Dimension minimumLayoutSize(Container parent); // 给定指定容器所包含的组件，计算该容器的最小大小维数
    Dimension preferredLayoutSize(Container parent); // 给定指定容器所包含的组件，计算该容器的首选大小维数
}

public interface LayoutManager2 extends LayoutManager {
    void addLayoutComponent(Component comp, Object constraints); // 使用指定约束对象，将指定组件添加到布局
    float getLayoutAlignmentX(Container target); // 返回指定容器沿 X 轴的对齐方式
    float getLayoutAlignmentY(Container target); // 返回指定容器沿 Y 轴的对齐方式
    void invalidateLayout(Container target); // 使容器失效
    Dimension maximumLayoutSize(Container target); // 给定指定容器的组件，计算该容器的最大大小维数
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/LayoutManager.html" target="_blank">LayoutManager</a> 定义如何布置 Container 类的接口。</p>
                            <p>Swing 的绘制架构假定 JComponent 的子组件不发生重叠。如果 JComponent 的 LayoutManager 允许子组件重叠，则 JComponent 必须重写 isOptimizedDrawingEnabled 以返回 false。 </p>
                            <p>LayoutManager & LayoutManager2 的常见实现类(<code>javax.swing</code> 包下的类这里没有列出，参见: <a href="#javax-swing-LayoutManager">SWING 中的 LayoutManager 实现类</a>)：</p>
                            <ul>
                                <li><p><a href="#BorderLayout">BorderLayout</a> -- 是边框布局。分为五个区域：NORTH、SOUTH、EAST、WEST、CENTER。NORTH 和 SOUTH 组件可以在水平方向上拉伸；而 EAST 和 WEST 组件可以在垂直方向上拉伸；CENTER 组件可同时在水平和垂直方向上拉伸，从而填充所有剩余空间。</p></li>
                                <li><p><a href="#FlowLayout">FlowLayout</a> -- 是流式布局，类似于段落中的文本行。从左到右或从右到左一次排列组件，到达边界从下一行开始排列。</p></li>
                                <li><p><a href="#GridLayout">GridLayout</a> -- 矩形网格形式对容器的组件进行布置。容器被分成大小相等的矩形，一个矩形中放置一个组件。</p></li>
                                <li><p><a href="#GridBagLayout">GridBagLayout</a> -- 是一个灵活的布局管理器(类似于单元格可以合并)，它不要求组件的大小相同便可以将组件垂直、水平或沿它们的基线对齐。每个 GridBagLayout 对象维持一个动态的矩形单元网格，每个组件占用一个或多个这样的单元，该单元被称为显示区域。 </p></li>
                                <li><p><a href="#CardLayout">CardLayout</a> -- 将容器中的每个组件看作一张卡片。一次只能看到一张卡片，容器则充当卡片的堆栈。当容器第一次显示时，第一个添加到 CardLayout 对象的组件为可见组件。 </p></li>
                            </ul>
                        </div>

                        <a id="BorderLayout" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class BorderLayout implements LayoutManager2, Serializable {
    /** 每个区域最多只能包含一个组件(Component) */
    public static final String NORTH  = "North";
    public static final String SOUTH  = "South";
    public static final String EAST   = "East";
    public static final String WEST   = "West";
    public static final String CENTER = "Center";

    /** 不同的 ComponentOrientation 会将以下常量映射到上面的不同区域 */
    public static final String BEFORE_FIRST_LINE = "First";
    public static final String AFTER_LAST_LINE = "Last";
    public static final String BEFORE_LINE_BEGINS = "Before";
    public static final String AFTER_LINE_ENDS = "After";

    public static final String PAGE_START = BEFORE_FIRST_LINE;
    public static final String PAGE_END = AFTER_LAST_LINE;
    public static final String LINE_START = BEFORE_LINE_BEGINS;
    public static final String LINE_END = AFTER_LINE_ENDS;

    public BorderLayout() {}
    public BorderLayout(int hgap, int vgap) {} // 构造一个具有指定组件间距的边框布局
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/BorderLayout.html" target="_blank">BorderLayout</a> 是边框布局，也是 Frame 的默认布局，它可以对容器组件进行安排，并调整其大小，使其符合下列五个区域：北、南、东、西、中。<b>每个区域最多只能包含一个组件</b>，并通过相应的常量进行标识：NORTH、SOUTH、EAST、WEST、CENTER。</p>
                            <p class=""><img src="images/Swing-BorderLayout.jpeg" class="center-block img-responsive"></p>
                            <p>为了方便起见，BorderLayout 将缺少字符串说明的情况解释为常量 CENTER。 </p>
                            <p>此外，BorderLayout 支持相对定位常量 PAGE_START、PAGE_END、LINE_START 和 LINE_END。在 ComponentOrientation 设置为 ComponentOrientation.LEFT_TO_RIGHT 的容器中，这些常量分别映射到 NORTH、SOUTH、WEST 和 EAST。 </p>
                            <p>为了与以前的版本兼容，BorderLayout 还包括相对定位常量 BEFORE_FIRST_LINE、AFTER_LAST_LINE、BEFORE_LINE_BEGINS 和 AFTER_LINE_ENDS。这些常量分别等同于 PAGE_START、PAGE_END、LINE_START 和 LINE_END。为了与其他组件使用的相对定位常量一致，应优先使用后一组常量。</p>
                            <p>将绝对定位常量与相对定位常量混合会产生无法预料的结果。如果两种类型的常量都使用，则优先采用相对常量。例如，如果同时使用 NORTH 和 PAGE_START 常量在方向性为 LEFT_TO_RIGHT 的容器中添加组件，则只体现 PAGE_START 布局。 </p>
                            <p><b>根据其首选大小和容器大小的约束 (constraints) 对组件进行布局。NORTH 和 SOUTH 组件可以在水平方向上拉伸；而 EAST 和 WEST 组件可以在垂直方向上拉伸；CENTER 组件可同时在水平和垂直方向上拉伸，从而填充所有剩余空间。</b> </p>
                            <ol>
                                <li><p><code>void 	addLayoutComponent(Component comp, Object constraints)</code> -- 使用指定的约束对象将指定组件添加到布局中(constraints 为其常量值)</p></li>
                                <li><p><code>void 	removeLayoutComponent(Component comp)</code> -- 从此边框布局中移除指定组件</p></li>
                                <li><p><code>Object 	getConstraints(Component comp)</code> -- 获取指定组件的约束</p></li>
                                <li><p><code>Component 	getLayoutComponent(Container target, Object constraints)</code> -- 基于目标 Container 的组件方向，返回给定约束位置对应的组件</p></li>
                                <li><p><code>Component 	getLayoutComponent(Object constraints)</code> -- 获取使用给定约束添加的组件</p></li>

                                <li class="group"><p><code>int 	getHgap()</code> -- 返回组件之间的水平间距</p></li>
                                <li><p><code>int 	getVgap()</code> -- 返回组件之间的垂直间距</p></li>
                                <li><p><code>void 	setHgap(int hgap)</code> -- 设置组件之间的水平间距</p></li>
                                <li><p><code>void 	setVgap(int vgap)</code> -- 设置组件之间的垂直间距</p></li>

                                <li class="group"><p><code>float 	getLayoutAlignmentX(Container parent)</code> -- 返回沿 x 轴的对齐方式</p></li>
                                <li><p><code>float 	getLayoutAlignmentY(Container parent)</code> -- 返回沿 y 轴的对齐方式</p></li>

                                <li class="group"><p><code>void 	invalidateLayout(Container target)</code> -- 使布局无效，指示如果布局管理器缓存了信息，则应该将其丢弃</p></li>
                                <li><p><code>void 	layoutContainer(Container target)</code> -- 使用此边框布局对容器参数进行布局</p></li>

                                <li class="group"><p><code>Dimension 	maximumLayoutSize(Container target)</code> -- 在给出指定目标容器中的组件的前提下，返回此布局的最大尺寸</p></li>
                                <li><p><code>Dimension 	preferredLayoutSize(Container target)</code> -- 基于容器中的组件，使用此布局管理器确定 target 容器的首选大小</p></li>
                                <li><p><code>Dimension 	minimumLayoutSize(Container target)</code> -- 使用此布局管理器确定 target 容器的最小大小</p></li>

                                <li class="group"><p><code>String 	toString()</code> -- 返回此边框布局的状态的字符串表示形式</p></li>
                            </ol>
                        </div>

                        <a id="FlowLayout" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class FlowLayout implements LayoutManager, Serializable {

    public static final int LEFT     = 0; // 指示每一行组件都应该是左对齐的
    public static final int CENTER   = 1; // 默认，指示每一行组件都应该是居中的
    public static final int RIGHT    = 2; // 指示每一行组件都应该是右对齐的
    public static final int LEADING  = 3; // 指示每一行组件都应该与容器方向的开始边对齐
    public static final int TRAILING = 4; // 指示每行组件都应该与容器方向的结束边对齐


    public FlowLayout() {} // 居中对齐，水平和垂直间隙为 5
    public FlowLayout(int align) {]
    public FlowLayout(int align, int hgap, int vgap) {} // 指定的对齐方式以及指定的水平和垂直间隙
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/FlowLayout.html" target="_blank">FlowLayout</a> 是流式布局，这非常类似于段落中的文本行。从左到右或从右到左一次排列组件，到达边界从下一行开始排列。</p>
                            <p>流布局把每个组件都假定为它的自然（首选）大小。 </p>
                            <ol>
                                <li><p><code>int 	getAlignment()</code> -- 获取此布局的对齐方式</p></li>
                                <li><p><code>void 	setAlignment(int align)</code> -- 设置此布局的对齐方式</p></li>
                                <li><p><code>int 	getHgap()</code> -- 获取组件之间以及组件与 Container 的边之间的水平间隙</p></li>
                                <li><p><code>void 	setHgap(int hgap)</code> -- 设置组件之间以及组件与 Container 的边之间的水平间隙</p></li>
                                <li><p><code>int 	getVgap()</code> -- 获取组件之间以及组件与 Container 的边之间的垂直间隙</p></li>
                                <li><p><code>void 	setVgap(int vgap)</code> -- 设置组件之间以及组件与 Container 的边之间的垂直间隙</p></li>

                                <li class="group"><p><code>boolean 	getAlignOnBaseline()</code> -- 如果组件将沿其基线垂直对齐，则返回 true</p></li>
                                <li><p><code>void 	setAlignOnBaseline(boolean alignOnBaseline)</code> -- 设置组件是否应该沿着其基线垂直对齐</p></li>

                                <li class="group"><p><code>void 	addLayoutComponent(String name, Component comp)</code> -- 将指定的组件添加到布局中</p></li>
                                <li><p><code>void 	removeLayoutComponent(Component comp)</code> -- 从布局中移除指定的组件</p></li>
                                <li><p><code>void 	layoutContainer(Container target)</code> -- 布置该容器</p></li>

                                <li class="group"><p><code>Dimension 	minimumLayoutSize(Container target)</code> -- 布置指定容器的子组件的最小维数</p></li>
                                <li><p><code>Dimension 	preferredLayoutSize(Container target)</code> -- 布置指定容器的子组件的首选维数</p></li>

                                <li class="group"><p><code>String 	toString()</code> -- 返回此 FlowLayout 对象及其值的字符串表示形式</p></li>
                            </ol>
                        </div>

                        <a id="GridLayout" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class GridLayout implements LayoutManager, Serializable {
    public GridLayout() {} // 单行无间距
    public GridLayout(int rows, int cols) {}
    public GridLayout(int rows, int cols, int hgap, int vgap) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/GridLayout.html" target="_blank">GridLayout</a> 以矩形网格形式对容器的组件进行布置。容器被分成大小相等的矩形，一个矩形中放置一个组件。</p>
                            <p><b>通过构造方法或 setRows 和 setColumns 方法将行数和列数都设置为非零值时，指定的列数将被忽略。列数通过指定的行数和布局中的组件总数来确定。因此，例如，如果指定了三行和两列，在布局中添加了九个组件，则它们将显示为三行三列。仅当将行数设置为零时，指定列数才对布局有效。</b></p>
                            <ol>
                                <li><p><code>int 	getColumns()</code> -- 获取此布局中的列数</p></li>
                                <li><p><code>void 	setColumns(int cols)</code> -- 将此布局中的列数设置为指定值</p></li>
                                <li><p><code>int 	getRows()</code> -- 获取此布局中的行数</p></li>
                                <li><p><code>void 	setRows(int rows)</code> -- 将此布局中的行数设置为指定值</p></li>

                                <li class="group"><p><code>int 	getHgap()</code> -- 获取组件之间的水平间距</p></li>
                                <li><p><code>void 	setHgap(int hgap)</code> -- 将组件之间的水平间距设置为指定值</p></li>
                                <li><p><code>int 	getVgap()</code> -- 获取组件之间的垂直间距</p></li>
                                <li><p><code>void 	setVgap(int vgap)</code> -- 将组件之间的垂直间距设置为指定值</p></li>

                                <li class="group"><p><code>void 	addLayoutComponent(String name, Component comp)</code> -- 将具有指定名称的指定组件添加到布局</p></li>
                                <li><p><code>void 	removeLayoutComponent(Component comp)</code> -- 从布局移除指定组件</p></li>

                                <li class="group"><p><code>void 	layoutContainer(Container parent)</code> -- 使用此布局布置指定容器</p></li>
                                <li><p><code>Dimension 	minimumLayoutSize(Container parent)</code> -- 使用此网络布局确定最小大小的容器参数</p></li>
                                <li><p><code>Dimension 	preferredLayoutSize(Container parent)</code> -- 使用此网格布局确定容器参数的首选大小</p></li>

                                <li class="group"><p><code>String 	toString()</code> -- 返回此网格布局的值的字符串表示形式</p></li>
                            </ol>
                        </div>

                        <a id="GridBagLayout" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class GridBagLayout implements LayoutManager2, Serializable {
    public int columnWidths[];      // 保存对列最小宽度的重写
    public double columnWeights[];  // 保存对列权重的重写
    public int rowHeights[];        // 保存对行最小高度的重写
    public double rowWeights[];     // 保存对行权重的重写

    protected static final int MAXGRIDSIZE = 512;
    protected static final int MINSIZE = 1;
    protected static final int PREFERREDSIZE = 2;

    protected Hashtable&lt;Component,GridBagConstraints> comptable;
    protected GridBagConstraints defaultConstraints;
    protected GridBagLayoutInfo layoutInfo;
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/GridBagLayout.html" target="_blank">GridBagLayout</a> 是一个灵活的布局管理器(类似于单元格可以合并)，它不要求组件的大小相同便可以将组件垂直、水平或沿它们的基线对齐。每个 GridBagLayout 对象维持一个动态的矩形单元网格，每个组件占用一个或多个这样的单元，该单元被称为显示区域。</p>
                            <p>每个由 GridBagLayout 管理的组件都与 GridBagConstraints 的实例相关联。Constraints 对象指定组件的显示区域在网格中的具体放置位置，以及组件在其显示区域中的放置方式。除了 Constraints 对象之外，GridBagLayout 还考虑每个组件的最小大小和首选大小，以确定组件的大小。 </p>
                            <p>网格的总体方向取决于容器的 ComponentOrientation 属性。对于水平的从左到右的方向，网格坐标 (0,0) 位于容器的左上角，其中 X 向右递增，Y 向下递增。对于水平的从右到左的方向，网格坐标 (0,0) 位于容器的右上角，其中 X 向左递增，Y 向下递增。 </p>
                            <ol>
                                <li><p><code>void 	addLayoutComponent(Component comp, Object constraints)</code> -- 使用指定 constraints 对象将指定组件添加到布局中(constraints 参数必须是 GridBagConstraints 的实例)</p>
                                    <pre class="brush: java;">
public class GridBagConstraints implements Cloneable, Serializable {
    /** fill 字段使用常量 */
    public static final int NONE = 0;        // 默认值，不伸升组件
    public static final int BOTH = 1;        // 横纵向都拉伸
    public static final int HORIZONTAL = 2;  // 横向都拉伸
    public static final int VERTICAL = 3;    // 纵向都拉伸

    // 用于 gridwidth, gridheight 字段值, 指定此组件是其行或列中的最后一个组件
    public static final int REMAINDER = 0;
    // 用于 gridwidth, gridheight 表示倒数第二个组件，用于 gridx, gridy 表示紧跟在以前添加的组件之后
    public static final int RELATIVE = -1;

    /** 用于 anthor 字段常量值，绝对位置 */
    public static final int NORTH = 11;       // 上
    public static final int SOUTH = 15;       // 下
    public static final int WEST = 17;        // 左
    public static final int EAST = 13;        // 右
    public static final int CENTER = 10;      // 中
    public static final int NORTHWEST = 18;   // 左上
    public static final int SOUTHWEST = 16;   // 左下
    public static final int NORTHEAST = 12;   // 右上
    public static final int SOUTHEAST = 14;   // 右下

    /** 用于 anthor 字段常量值，相对于方向的值(根据 ComponentOrientation 映射) */
    public static final int PAGE_START = 19;  // 映射到 上
    public static final int PAGE_END = 20;    // 映射到 下
    public static final int LINE_START = 21;  // 映射到 左/右
    public static final int LINE_END = 22;    // 映射到 右/左
    public static final int FIRST_LINE_START = 23;   // 映射到 左上/右上
    public static final int FIRST_LINE_END = 24;     // 映射到 右上/左上
    public static final int LAST_LINE_START = 25;    // 映射到 左下/右下
    public static final int LAST_LINE_END = 26;      // 映射到 右下/左下

    /** 用于 anthor 字段常量值，相对于基线的值 */
    public static final int BASELINE = 0x100;
    public static final int BASELINE_LEADING = 0x200;
    public static final int BASELINE_TRAILING = 0x300;
    public static final int ABOVE_BASELINE = 0x400;
    public static final int ABOVE_BASELINE_LEADING = 0x500;
    public static final int ABOVE_BASELINE_TRAILING = 0x600;
    public static final int BELOW_BASELINE = 0x700;
    public static final int BELOW_BASELINE_LEADING = 0x800;
    public static final int BELOW_BASELINE_TRAILING = 0x900;

    public int fill;       // 指定当组件大小小于单元格大小时的拉伸操作(参见常量)
    public int anchor;     // 指定当组件大小小于单元格大小时的位置(参见常量)
    public int gridwidth;  // 指定组件占用某一行的单元格数量
    public int gridheight; // 指定组件占用某一列的单元格数量
    public int gridx;      // 组件单元格的 x 坐标(如果此数大于已有的横向单元格数量，那么单元横向格数量将会 + 1)
    public int gridy;      // 组件单元格的 y 坐标(如果此数大于已有的纵向单元格数量，那么单元纵向格数量将会 + 1)
    public Insets insets;  // 组件的外部填充(margin)，可以分别指定其上下左右的边距
    public int ipadx;      // 组件 X 方向的内部填充(padding)
    public int ipady;      // 组件 Y 方向的内部填充(padding)
    public double weightx; // X 方向的重力指数
    public double weighty; // Y 方向的重力指数

    public GridBagConstraints () {}

    public GridBagConstraints(int gridx, int gridy, int gridwidth, int gridheight, double weightx,
            double weighty, int anchor, int fill, Insets insets, int ipadx, int ipady) {}
}
</pre>
                                </li>
                                <li><p><code>void 	addLayoutComponent(String name, Component comp)</code> -- 此方法为空方法</p></li>
                                <li><p><code>void 	removeLayoutComponent(Component comp)</code> -- 从此布局移除指定组件</p></li>

                                <li class="group"><p><code>GridBagConstraints 	getConstraints(Component comp)</code> -- 获取指定组件的约束</p></li>
                                <li><p><code>void 	setConstraints(Component comp, GridBagConstraints constraints)</code> -- 设置此布局中指定组件的约束条件</p></li>

                                <li class="group"><p><code>protected void 	adjustForGravity(GridBagConstraints constraints, Rectangle r)</code> -- 根据约束几何结构和填充将 x、y、宽度和高度四个字段调整为正确值</p></li>
                                <li><p><code>protected void 	AdjustForGravity(GridBagConstraints constraints, Rectangle r)</code> -- 应使用上面方法</p></li>
                                <li><p><code>protected void 	arrangeGrid(Container parent)</code> -- 布置网格</p></li>
                                <li><p><code>protected void 	ArrangeGrid(Container parent)</code> -- 应使用上面方法</p></li>

                                <li class="group"><p><code>float 	getLayoutAlignmentX(Container parent)</code> -- 返回沿 X 轴的对齐方式</p></li>
                                <li><p><code>float 	getLayoutAlignmentY(Container parent)</code> -- 返回沿 y 轴的对齐方式</p></li>
                                <li><p><code>int[][] 	getLayoutDimensions()</code> -- 确定布局网格的列宽度和行高度</p></li>
                                <li><p><code>Point 	getLayoutOrigin()</code> -- 在目标容器的图形坐标空间确定布局区域的原点</p></li>
                                <li><p><code>double[][] 	getLayoutWeights()</code> -- 确定布局网格的行与列的权重</p></li>
                                <li><p><code>protected Dimension 	getMinSize(Container parent, GridBagLayoutInfo info)</code> -- 基于 getLayoutInfo 中的信息计算其所有者的最小大小</p></li>
                                <li><p><code>protected Dimension 	GetMinSize(Container parent, GridBagLayoutInfo info)</code> -- 应使用上面方法</p></li>
                                <li><p><code>Point 	location(int x, int y)</code> -- 确定在布局网格中哪个单元包含由 (x, y) 指定的点</p></li>

                                <li class="group"><p><code>Dimension 	maximumLayoutSize(Container target)</code> -- 在给出指定目标容器中的组件的前提下，返回此布局的最大维数</p></li>
                                <li><p><code>Dimension 	minimumLayoutSize(Container parent)</code> -- 使用此网格包布局确定 parent 容器的最小大小</p></li>
                                <li><p><code>Dimension 	preferredLayoutSize(Container parent)</code> -- 使用此网络包布局确定 parent 容器的首选大小</p></li>

                                <li class="group"><p><code>protected GridBagLayoutInfo 	getLayoutInfo(Container parent, int sizeflag)</code> -- 为当前受管子级的集合填充 GridBagLayoutInfo 的实例</p></li>
                                <li><p><code>protected GridBagLayoutInfo 	GetLayoutInfo(Container parent, int sizeflag)</code> -- 应使用上面方法</p></li>
                                <li><p><code>protected GridBagConstraints 	lookupConstraints(Component comp)</code> -- 检索指定组件的约束</p></li>

                                <li class="group"><p><code>void 	layoutContainer(Container parent)</code> -- 使用此网格包布局布置指定容器</p></li>
                                <li><p><code>void 	invalidateLayout(Container target)</code> -- 使布局失效，指示如果布局管理器缓存了信息，则应该将其丢弃</p></li>
                                <li><p><code>String 	toString()</code> -- 返回此网格包布局的值的字符串表示形式</p></li>
                            </ol>
                            <p><b>GridBagLayout 实例:</b></p>
                            <p><img src="images/GridBagLayout.png" class="img-responsive center-block"></p>
                            <div class="panel panel-default">
                                <div class="panel-heading">
                                    <a data-toggle="collapse" data-parent="#accordion" href="#GridBasLayout-Example" aria-expanded="false" class="code-header collapsed">
                                        <span class="glyphicon glyphicon-plus"></span> View Code
                                    </a>
                                </div>
                                <div id="GridBasLayout-Example" class="panel-collapse collapse" style="height: 0px;" aria-expanded="false">
                                    <pre class="brush: java;">
public class GridBagPanel extends Panel {
    private GridBagConstraints c;
    private GridBagLayout mLayout;

    public GridBagPanel() {
        c = new GridBagConstraints();
        mLayout = new GridBagLayout();
        setLayout(mLayout);
    }

    public Panel example() {
        c.ipadx = 20; // 指定每个组件 X 方向的填充
        c.ipady = 10; // 指定每个组件 Y 方向的填充
        c.insets = new Insets(5, 5, 5,5); // 指定每个组件外边距

        c.fill = GridBagConstraints.BOTH; // 横纵向都拉伸组件
        c.weightx = 1.0; // x 方向比重设置为 1
        addCompent(new Button("Button1"));
        addCompent(new Button("Button2"));
        addCompent(new Button("Button3"));

        c.gridwidth = GridBagConstraints.REMAINDER; // 在行的最后位置
        addCompent(new Button("Button4"));

        c.weightx = 0.0; // 重置 X 方向比重
        addCompent(new Button("Button5"));

        c.gridwidth = GridBagConstraints.RELATIVE; // 在行的倒数第二位
        addCompent(new Button("Button6"));

        c.gridwidth = GridBagConstraints.REMAINDER; // 在行的最后位置
        addCompent(new Button("Button7"));

        c.gridwidth = 1; // 重置为默认
        c.gridheight = 2; // 这里占用两行，因此后面可以添加两个单行的组件
        c.weighty = 1.0;
        addCompent(new Button("Button8"));

        c.weighty = 0.0; // 重置为默认
        c.gridwidth = GridBagConstraints.REMAINDER; // 在行的最后位置
        c.gridheight = 1; // 重置为默认
        addCompent(new Button("Button9"));
        addCompent(new Button("Button10"));

        addCompent(new Button("Button11"));

        return this;
    }

    public void addCompent(Component component) {
        mLayout.setConstraints(component, c);
        add(component);
    }
}
</pre>
                                </div>
                            </div>
                        </div>

                        <a id="CardLayout" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class CardLayout implements LayoutManager2, Serializable {
    public CardLayout() {}
    public CardLayout(int hgap, int vgap) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/CardLayout.html" target="_blank">CardLayout</a> 容器中的每个组件看作一张卡片(类似 Android 的 Gallery 组件)。一次只能看到一张卡片，容器则充当卡片的堆栈。当容器第一次显示时，第一个添加到 CardLayout 对象的组件为可见组件。 </p>
                            <p>卡片的顺序由组件对象本身在容器内部的顺序决定。CardLayout 定义了一组方法，这些方法允许应用程序按顺序地浏览这些卡片，或者显示指定的卡片。</p>
                            <ol>
                                <li><p><code>void 	addLayoutComponent(Component comp, Object constraints)</code> -- 将指定的组件添加到此卡片布局的内部名称表(constraints 是 String 的实例)</p></li>
                                <li><p><code>void 	removeLayoutComponent(Component comp)</code> -- 从布局中移除指定的组件</p></li>
                                <li><p><code>void 	layoutContainer(Container parent)</code> -- 使用此卡片布局布置指定的容器</p></li>
                                <li><p><code>void 	invalidateLayout(Container target)</code> -- 使布局无效，指示如果布局管理器缓存了信息，则应该将其丢弃</p></li>

                                <li class="group"><p><code>void 	first(Container parent)</code> -- 翻转到容器的第一张卡片</p></li>
                                <li><p><code>void 	previous(Container parent)</code> -- 翻转到指定容器的前一张卡片</p></li>
                                <li><p><code>void 	next(Container parent)</code> -- 翻转到指定容器的下一张卡片</p></li>
                                <li><p><code>void 	last(Container parent)</code> -- 翻转到容器的最后一张卡片</p></li>
                                <li><p><code>void 	show(Container parent, String name)</code> -- 翻转到使用 addLayoutComponent 添加到此布局的具有指定 name 的组件</p></li>

                                <li class="group"><p><code>int 	getHgap()</code> -- 获取组件之间的水平间距</p></li>
                                <li><p><code>void 	setHgap(int hgap)</code> -- 设置组件之间的水平间距</p></li>
                                <li><p><code>int 	getVgap()</code> -- 获取组件之间的垂直间距</p></li>
                                <li><p><code>void 	setVgap(int vgap)</code> -- 设置组件之间的垂直间距</p></li>

                                <li class="group"><p><code>float 	getLayoutAlignmentX(Container parent)</code> -- 返回沿 x 轴的对齐方式</p></li>
                                <li><p><code>float 	getLayoutAlignmentY(Container parent)</code> -- 返回沿 y 轴的对齐方式</p></li>

                                <li class="group"><p><code>Dimension 	maximumLayoutSize(Container target)</code> -- 给出指定目标容器中的组件，返回此布局的最大尺寸</p></li>
                                <li><p><code>Dimension 	preferredLayoutSize(Container parent)</code> -- 使用此卡片布局确定容器参数的首选大小</p></li>
                                <li><p><code>Dimension 	minimumLayoutSize(Container parent)</code> -- 计算指定面板大小的最小值</p></li>

                                <li class="group"><p><code>String 	toString()</code> -- 返回此卡片布局状态的字符串表示形式</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-awt-MenuComponent"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">MenuComponent 及子类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
MenuComponent
 ├ MenuBar implements MenuContainer -- 整个菜单栏
 └ MenuItem  -- 单个菜单项
    ├ Menu implements MenuContainer -- 一组(一列)菜单栏
    ├   └ PopupMenu -- 弹出式菜单(点击可以弹出下一级菜单)
    └ CheckboxMenuItem implements ItemSelectable -- 复选框菜单

public abstract class MenuComponent implements Serializable {
    /**  用于为可访问性提供默认支持的 MenuComponent 的内部类 */
    protected abstract class AccessibleAWTMenuComponent extends AccessibleContext
        implements Serializable, AccessibleComponent, AccessibleSelection {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/MenuComponent.html" target="_blank">MenuComponent</a> 是所有与菜单相关的组件的超类。在这一方面，类 MenuComponent 与 AWT 组件的抽象超类 Component 相似。 </p>
                            <p>菜单组件接收并处理 AWT 事件，就像组件通过方法 processEvent 执行的操作一样。</p>
                            <ol>
                                <li><p><code>Font 	getFont()</code> -- 获取用于此菜单组件的字体</p></li>
                                <li><p><code>void 	setFont(Font f)</code> -- 将用于此菜单组件的字体设置为指定字体</p></li>
                                <li><p><code>String 	getName()</code> -- 获取该菜单组件的名称</p></li>
                                <li><p><code>void 	setName(String name)</code> -- 将该组件的名称设置为指定字符串</p></li>

                                <li class="group"><p><code>void 	dispatchEvent(AWTEvent e)</code> -- 将事件传递给此组件或其子组件之一</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理发生在此菜单组件上的事件</p></li>

                                <li class="group"><p><code>MenuContainer 	getParent()</code> -- 返回此菜单组件的父容器</p></li>
                                <li><p><code>protected Object 	getTreeLock()</code> -- 获取此组件的锁定对象</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此 MenuComponent 状态的字符串</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 移除该菜单组件的同位体</p></li>

                                <li class="group"><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 MenuComponent 关联的 AccessibleContext</p></li>
                                <li><p><code>String 	toString()</code> -- 返回此菜单组件的表示形式</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class MenuBar extends MenuComponent implements MenuContainer, Accessible {
    /** 菜单栏的内部类，用于为可访问性提供默认支持 */
    protected class AccessibleAWTMenuBar extends AccessibleAWTMenuComponent {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/MenuBar.html" target="_blank">MenuBar</a> 类封装绑定到框架的菜单栏的平台概念。为了将该菜单栏与 Frame 对象关联，可以调用该框架的 setMenuBar 方法。 </p>
                            <ol>
                                <li><p><code>Menu 	add(Menu m)</code> -- 将指定的菜单添加到菜单栏</p></li>
                                <li><p><code>void 	remove(int index)</code> -- 从此菜单栏移除指定索引处的菜单</p></li>
                                <li><p><code>void 	remove(MenuComponent m)</code> -- 从此菜单栏移除指定的菜单组件</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建该菜单栏的同位体</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 移除该菜单栏的同位体</p></li>

                                <li class="group"><p><code>MenuItem 	getShortcutMenuItem(MenuShortcut s)</code> -- 获取与指定 MenuShortcut 对象关联的 MenuItem 的实例</p></li>
                                <li><p><code>void 	deleteShortcut(MenuShortcut s)</code> -- 删除指定的菜单快捷方式</p></li>
                                <li><p><code>Enumeration&lt;MenuShortcut> 	shortcuts()</code> -- 获取此菜单栏正在管理的所有菜单快捷方式的枚举</p></li>

                                <li class="group"><p><code>Menu 	getMenu(int i)</code> -- 获取指定的菜单</p></li>
                                <li><p><code>int 	getMenuCount()</code> -- 获取该菜单栏上的菜单数</p></li>
                                <li><p><code>Menu 	getHelpMenu()</code> -- 获取该菜单栏上的帮助菜单</p></li>
                                <li><p><code>void 	setHelpMenu(Menu m)</code> -- 将指定的菜单设置为此菜单栏的帮助菜单</p></li>

                                <li class="group"><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此菜单栏关联的 AccessibleContext</p></li>

                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class MenuItem extends MenuComponent implements Accessible {
    /** 用于为可访问性提供默认支持的 MenuItem 的内部类 */
    protected class AccessibleAWTMenuItem extends AccessibleAWTMenuComponent
        implements AccessibleAction, AccessibleValue {}

    public MenuItem() {}
    public MenuItem(String label) {}
    public MenuItem(String label, MenuShortcut s) {} // 创建具有关联的键盘快捷方式的菜单项
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/MenuItem.html" target="_blank">MenuItem</a> 菜单中的所有项必须属于类 MenuItem 或其子类之一。</p>
                            <p>默认的 MenuItem 对象包含一个简单的加标签的菜单项。 </p>
                            <p>选择菜单项时，AWT 发送一个动作事件到该菜单项。由于该事件是一个 ActionEvent 实例，processEvent 方法会检查该事件，并将它传递到 processActionEvent。后一方法将该事件重定向到任何 ActionListener 对象，该对象已在由此菜单项生成的动作事件中注册权益。</p>
                            <ol>
                                <li><p><code>void 	addActionListener(ActionListener l)</code> -- 添加指定的动作侦听器，以从此菜单项接收动作事件</p></li>
                                <li><p><code>void 	removeActionListener(ActionListener l)</code> -- 移除指定的动作侦听器</p></li>
                                <li><p><code>ActionListener[] 	getActionListeners()</code> -- 返回在此菜单项上注册的所有动作侦听器组成的数组</p></li>

                                <li class="group"><p><code>protected void 	processActionEvent(ActionEvent e)</code> -- 处理此菜单项上发生的动作事件</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此菜单项上的事件</p></li>
                                <li><p><code>protected void 	disableEvents(long eventsToDisable)</code> -- 禁止将事件提交到将由指定事件掩码参数定义的事件的菜单项</p></li>
                                <li><p><code>protected void 	enableEvents(long eventsToEnable)</code> -- 允许将事件提交到将由指定事件掩码参数定义的事件的菜单项</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前在此 MenuItem 上注册为 FooListener 的所有对象组成的数组</p></li>

                                <li class="group"><p><code>String 	getActionCommand()</code> -- 获取由此菜单项引发的动作事件的命令名</p></li>
                                <li><p><code>void 	setActionCommand(String command)</code> -- 设置由此菜单项引发的动作事件的命令名</p></li>
                                <li><p><code>String 	getLabel()</code> -- 获取此菜单项的标签</p></li>
                                <li><p><code>void 	setLabel(String label)</code> -- 将此菜单项的标签设置为指定标签</p></li>
                                <li><p><code>MenuShortcut 	getShortcut()</code> -- 获取与此菜单项关联的 MenuShortcut 对象</p></li>
                                <li><p><code>boolean 	isEnabled()</code> -- 检查是否启用了此菜单项</p></li>
                                <li><p><code>void 	setEnabled(boolean b)</code> -- 设置是否可以选择此菜单项</p></li>
                                <li><p><code>void 	setShortcut(MenuShortcut s)</code> -- 设置与此菜单项关联的 MenuShortcut 对象</p></li>
                                <li><p><code>void 	deleteShortcut()</code> -- 删除与此菜单项关联的任何 MenuShortcut 对象</p></li>

                                <li class="group"><p><code>String 	paramString()</code> -- 返回表示此 MenuItem 状态的字符串</p></li>
                                <li><p><code>void 	addNotify()</code> -- 创建该菜单项的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此菜单项关联的 AccessibleContext</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Menu extends MenuItem implements MenuContainer, Accessible {
    /** 菜单的内部类，用于为可访问性提供默认支持 */
    protected class AccessibleAWTMenu extends AccessibleAWTMenuItem {}

    public Menu() {}
    public Menu(String label) {}
    public Menu(String label, boolean tearOff) {} // 指示该菜单是否可以分离(AWT 的所有实现都不支持分离功能)
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Menu.html" target="_blank">Menu</a> 对象是从菜单栏部署的下拉式菜单组件。 </p>
                            <p>菜单可以是任意分离式 菜单。可以打开分离式菜单，并从其父菜单栏或菜单中拖开。释放鼠标按钮之后，它仍然在屏幕上。分离菜单的机制与平台有关，因为分离式菜单的外观由其同位体确定。对于不支持分离式菜单的平台，分离属性会被忽略。 </p>
                            <p>菜单中的每一项都必须属于 MenuItem 类。它可以是 MenuItem 的一个实例、子菜单（Menu 的一个实例）、或复选框（CheckboxMenuItem 的一个实例）。 </p>
                            <ol>
                                <li><p><code>MenuItem 	add(MenuItem mi)</code> -- 将指定的菜单项添加到此菜单</p></li>
                                <li><p><code>void 	add(String label)</code> -- 调用 <code>add(new MenuItem(label))</code></p></li>
                                <li><p><code>void 	insert(MenuItem menuitem, int index)</code> -- 将菜单项插入到此菜单的指定位置</p></li>
                                <li><p><code>void 	insert(String label, int index)</code> -- 调用 <code>insert(new MenuItem(label), index)</code></p></li>
                                <li><p><code>void 	insertSeparator(int index)</code> -- 将一个分隔线插入到此菜单的指定位置</p></li>
                                <li><p><code>void 	addSeparator()</code> -- 将一个分隔线添加到菜单的当前位置</p></li>

                                <li class="group"><p><code>void 	remove(int index)</code> -- 从此菜单移除指定索引处的菜单项</p></li>
                                <li><p><code>void 	remove(MenuComponent item)</code> -- 从此菜单移除指定的菜单项</p></li>
                                <li><p><code>void 	removeAll()</code> -- 从此菜单移除所有项</p></li>
                                <li><p><code>MenuItem 	getItem(int index)</code> -- 获取此菜单的指定索引处的项</p></li>
                                <li><p><code>int 	getItemCount()</code> -- 获取此菜单中的项数</p></li>

                                <li><p><code>void 	addNotify()</code> -- 创建该菜单的同位体</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 移除该菜单的同位体</p></li>

                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此菜单关联的 AccessibleContext</p></li>
                                <li><p><code>boolean 	isTearOff()</code> -- 指示此菜单是否为分离式菜单(AWT 的所有实现都不支持分离功能)</p></li>
                                <li><p><code>String 	paramString()</code> -- 返回表示此 Menu 状态的字符串</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class PopupMenu extends Menu {
    /** 用于为可访问性提供默认支持的 PopupMenu 的内部类 */
    protected class AccessibleAWTPopupMenu extends AccessibleAWTMenu {}

    public PopupMenu() {}
    public PopupMenu(String label) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/PopupMenu.html" target="_blank">PopupMenu</a> 实现能够在组件中的指定位置上动态弹出的菜单。</p>
                            <p>正如继承层次关系所暗示的那样，任何可以使用 Menu 的地方都可以使用 PopupMenu。但是，如果使用像 Menu 这样的 PopupMenu（例如，将其添加到 MenuBar），则不能调用该 PopupMenu 的 show。 </p>
                            <ol>
                                <li><p><code>void 	addNotify()</code> -- 创建弹出式菜单的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 PopupMenu 关联的 AccessibleContext</p></li>
                                <li><p><code>MenuContainer 	getParent()</code> -- 返回此菜单组件的父容器</p></li>
                                <li><p><code>void 	show(Component origin, int x, int y)</code> -- 在相对于初始组件的 x、y 位置上显示弹出式菜单</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class CheckboxMenuItem extends MenuItem implements ItemSelectable, Accessible {
    /** 用来为可访问性提供默认支持的 CheckboxMenuItem 的内部类 */
    protected class AccessibleAWTCheckboxMenuItem extends AccessibleAWTMenuItem
                implements AccessibleAction, AccessibleValue{}

    public CheckboxMenuItem() {}
    public CheckboxMenuItem(String label) {}
    public CheckboxMenuItem(String label, boolean state) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/CheckboxMenuItem.html" target="_blank">CheckboxMenuItem</a> 表示一个可包括在菜单中的复选框。</p>
                            <p>当选定一个复选框菜单项时，AWT 将一个项事件发送到该项。因为该事件是 ItemEvent 的一个实例，所以 processEvent 方法检查该事件，同时将它传递给 processItemEvent。后一种方法将该事件重定向到任何为关注此菜单项生成的项事件而注册的 ItemListener 对象。 </p>
                            <ol>
                                <li><p><code>void 	addItemListener(ItemListener l)</code> -- 添加指定的动作侦听器，以从此菜单项接收动作事件</p></li>
                                <li><p><code>void 	removeItemListener(ItemListener l)</code> -- 移除指定的动作侦听器</p></li>
                                <li><p><code>ItemListener[] 	getItemListeners()</code> -- 返回在此菜单项上注册的所有动作侦听器组成的数组</p></li>

                                <li class="group"><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此菜单项上的事件</p></li>
                                <li><p><code>protected void 	processItemEvent(ItemEvent e)</code> -- </p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前在此 MenuItem 上注册为 FooListener 的所有对象组成的数组</p></li>

                                <li class="group"><p><code>boolean 	getState()</code> -- 获取复选框的状态</p></li>
                                <li><p><code>void 	setState(boolean b)</code> -- 将此复选框菜单项设置为指定的状态</p></li>
                                <li><p><code>Object[] 	getSelectedObjects()</code> -- 返回数组(长度为 1)，它包含复选框菜单项的标签;如果没有选中复选框，则返回 null</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建该菜单项的同位体</p></li>
                                <li><p><code>String 	paramString()</code> -- 返回表示此 MenuItem 状态的字符串</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此菜单项关联的 AccessibleContext</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->

                <a class="offset" id="java-awt-Container"></a>
                <div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Container 的子类</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public class Panel extends Container implements Accessible {
    /** 此类实现 Panel 类的可访问性支持 */
    protected class AccessibleAWTPanel extends AccessibleAWTContainer {}

    public Panel() {} // 默认布局管理器是 FlowLayout
    public Panel(LayoutManager layout) {} // 创建具有指定布局管理器的新面板
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Panel.html" target="_blank">Panel</a> 是最简单的容器类。应用程序可以将其他组件放在面板提供的空间内，这些组件包括其他面板。 </p>
                            <p>Panel 的默认布局管理器是 FlowLayout 布局管理器。</p>
                            <p><code>Window</code> 也是 Container 的子类，<code>Frame</code> 是 Window 的子类。</p>
                            <ol>
                                <li><p><code>void 	addNotify()</code> -- 创建 Panel 的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与 Panel 相关的 AccessibleContext</p></li>
                            </ol>
                        </div>



                        <div class="sub-item">
                            <pre class="brush: java;">
public class ScrollPane extends Container implements Accessible {
    /** 可访问性支持 */
    protected class AccessibleAWTScrollPane extends AccessibleAWTContainer {}

    /** 滚动条显示模式 */
    public static final int SCROLLBARS_AS_NEEDED = 0; // 默认,子组件的大小超过了滚动窗格尺寸时显示
    public static final int SCROLLBARS_ALWAYS = 1;    // 总是显示
    public static final int SCROLLBARS_NEVER = 2;     // 永不显示

    public ScrollPane() {}
    public ScrollPane(int scrollbarDisplayPolicy) {} // 指定滚动条显示模式
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/ScrollPane.html" target="_blank">ScrollPane</a> 实现用于单个子组件的自动水平和/或垂直滚动的容器类。</p>
                            <p>ScrollPane 不可设置布局，只能容纳一个组件，添加新的组件会将原来的组件移除。</p>
                            <ol>
                                <li><p><code>int 	getScrollbarDisplayPolicy()</code> -- 返回滚动条的显示策略</p></li>

                                <li class="group"><p><code>Dimension 	getViewportSize()</code> -- 返回滚动条窗格视口的当前大小</p></li>
                                <li><p><code>int 	getHScrollbarHeight()</code> -- 返回水平滚动条占用的高度，它与当前是否由滚动窗格显示无关</p></li>
                                <li><p><code>int 	getVScrollbarWidth()</code> -- 返回垂直滚动条占用的宽度，它与当前是否由滚动窗格显示无关</p></li>
                                <li><p><code>Adjustable 	getHAdjustable()</code> -- 返回表示水平滚动条状态的 ScrollPaneAdjustable 对象</p></li>
                                <li><p><code>Adjustable 	getVAdjustable()</code> -- 返回表示垂直滚动条状态的 ScrollPaneAdjustable 对象</p></li>

                                <li class="group"><p><code>Point 	getScrollPosition()</code> -- 返回子组件中的当前 x,y 位置，子组件显示在滚动窗格视口的 0,0 位置</p></li>
                                <li><p><code>void 	setScrollPosition(int x, int y)</code> -- 滚动到子组件中的指定位置</p></li>
                                <li><p><code>void 	setScrollPosition(Point p)</code> -- 滚动到子组件中的指定位置</p></li>

                                <li class="group"><p><code>boolean 	isWheelScrollingEnabled()</code> -- 指示是否进行滚动来响应鼠标滚轮</p></li>
                                <li><p><code>void 	setWheelScrollingEnabled(boolean handleWheel)</code> -- 启用/禁用对鼠标滚轮滚动的移动响应</p></li>

                                <li class="group"><p><code>protected void 	addImpl(Component comp, Object constraints, int index)</code> -- 将指定的组件添加到此滚动窗格容器</p></li>
                                <li><p><code>void 	doLayout()</code> -- 通过将子组件的大小调整为其首选大小来布置此容器</p></li>
                                <li><p><code>void 	printComponents(Graphics g)</code> -- 显示此滚动窗格中的组件</p></li>
                                <li><p><code>protected boolean 	eventTypeEnabled(int type)</code> -- 如果启用滚轮滚动，则对 MouseWheelEvents 返回 true</p></li>
                                <li><p><code>protected void 	processMouseWheelEvent(MouseWheelEvent e)</code> -- 处理通过滚动适当量而传递给此 ScrollPane 的鼠标滚轮事件</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建滚动窗格的同位体</p></li>
                                <li><p><code>void 	setLayout(LayoutManager mgr)</code> -- 设置此容器的布局管理器(不允许，抛出异常)</p></li>
                                <li><p><code>String 	paramString()</code> -- 返回表示此 ScrollPane 的状态的字符串</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 ScrollPane 相关的 AccessibleContext</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Applet extends Panel {
    /** 可访问性支持 */
    protected class AccessibleApplet extends AccessibleAWTPanel {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Applet.html" target="_blank">Applet</a> 是一种不能单独运行但可嵌入在其他应用程序中的小程序。 </p>
                            <p>Applet 类必须是任何嵌入 Web 页或可用 Java Applet Viewer 查看的 applet 的超类。Applet 类提供了 applet 及其运行环境之间的标准接口。</p>
                            <ol>
                                <li><p><code>static AudioClip 	newAudioClip(URL url)</code> -- 从给定 URL 处获取音频剪辑</p></li>

                                <li class="group"><p><code>void 	play(URL url)</code> -- 播放指定绝对 URL 处的音频剪辑</p></li>
                                <li><p><code>void 	play(URL url, String name)</code> -- 播放音频剪辑，给定了 URL 及与之相对的说明符</p></li>
                                <li><p><code>AudioClip 	getAudioClip(URL url)</code> -- 返回 URL 参数指定的 AudioClip 对象</p></li>
                                <li><p><code>AudioClip 	getAudioClip(URL url, String name)</code> -- 返回 URL 和 name 参数指定的 AudioClip 对象</p></li>

                                <li class="group"><p><code>Image 	getImage(URL url)</code> -- 返回能被绘制到屏幕上的 Image 对象</p></li>
                                <li><p><code>Image 	getImage(URL url, String name)</code> -- 返回能被绘制到屏幕上的 Image 对象</p></li>

                                <li class="group"><p><code>AppletContext 	getAppletContext()</code> -- 确定此 applet 的上下文，上下文允许 applet 查询和影响它所运行的环境</p></li>
                                <li><p><code>String 	getAppletInfo()</code> -- 返回有关此 applet 的信息</p></li>
                                <li><p><code>URL 	getCodeBase()</code> -- 获得基 URL</p></li>
                                <li><p><code>URL 	getDocumentBase()</code> -- 获取嵌入此 applet 的文档的 URL</p></li>
                                <li><p><code>String 	getParameter(String name)</code> -- 返回 HTML 标记中指定参数的值</p></li>
                                <li><p><code>String[][] 	getParameterInfo()</code> -- 返回此 applet 理解的关于参数的信息</p></li>

                                <li class="group"><p><code>Locale 	getLocale()</code> -- 获取 applet 的语言环境</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Applet 关联的 AccessibleContext</p></li>
                                <li><p><code>boolean 	isActive()</code> -- 确定 applet 是否处于活动状态</p></li>
                                <li><p><code>boolean 	isValidateRoot()</code> -- </p></li>

                                <li class="group"><p><code>void 	resize(Dimension d)</code> -- 请求调整此 applet 的大小</p></li>
                                <li><p><code>void 	resize(int width, int height)</code> -- 请求调整此 applet 的大小</p></li>

                                <li class="group"><p><code>void 	setStub(AppletStub stub)</code> -- 设置此 applet 的 stub</p></li>
                                <li><p><code>void 	showStatus(String msg)</code> -- 请求将参数字符串显示在“状态窗口”中</p></li>

                                <li class="group"><p><code>void 	init()</code> -- 由浏览器或 applet viewer 调用，通知此 applet 它已经被加载到系统中</p></li>
                                <li><p><code>void 	start()</code> -- 由浏览器或 applet viewer 调用，通知此 applet 它应该开始执行</p></li>
                                <li><p><code>void 	stop()</code> -- 由浏览器或 applet viewer 调用，通知此 applet 它应该终止执行</p></li>
                                <li><p><code>void 	destroy()</code> --  由浏览器或 applet viewer 调用，通知此 applet 它正在被回收，它应该销毁分配给它的任何资源</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-awt-Component"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Component 及子类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public class Label extends Component implements Accessible {
    /** 可访问性支持 */
    protected class AccessibleAWTLabel extends AccessibleAWTComponent {}

    public static final int LEFT        = 0; // 左对齐
    public static final int CENTER      = 1; // 居中
    public static final int RIGHT       = 2; // 右对齐

    public Label() () // 无标题，左对齐
    public Label(String text) {}
    public Label(String text, int alignment) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Label.html" target="_blank">Label</a> 对象是一个可在容器中放置文本的组件。一个标签只显示一行只读文本。文本可由应用程序更改，但是用户不能直接对其进行编辑。</p>
                            <ol>
                                <li><p><code>int 	getAlignment()</code> -- 获取此标签的当前对齐方式</p></li>
                                <li><p><code>void 	setAlignment(int alignment)</code> -- 设置此标签的当前对齐方式</p></li>
                                <li><p><code>String 	getText()</code> -- 获取此标签的文本</p></li>
                                <li><p><code>void 	setText(String text)</code> -- 设置此标签的文本</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建此标签的同位体</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回一个表示此 Label 状态的字符串</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此标签相关的 AccessibleContext</p></li>

                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Button extends Component implements Accessible {
    /** 可访问性支持 */
    protected class AccessibleAWTButton extends AccessibleAWTComponent implements AccessibleAction,
                                AccessibleValue {}

    public Button() {}
    public Button(String label) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Button.html" target="_blank">Button</a> 当按下该按钮时，应用程序能执行某项动作。</p>
                            <p>用鼠标单击按钮这一动作与 ActionEvent 的一个实例相关，在按下鼠标和释放按钮的时候都会用到该类。如果应用程序希望知道何时按钮作为一个单独动作被按下但未释放，它可以特殊化 processMouseEvent，或者通过调用 addMouseListener 将自身注册为鼠标事件的侦听器。这两种方法都是由所有组件的抽象超类 Component 定义的。 </p>
                            <p>当按下按钮并释放时，AWT 通过调用按钮的 processEvent，将 ActionEvent 的一个实例发送给按钮。按钮的 processEvent 方法接收按钮的所有事件；同时，它通过调用自身的 processActionEvent 方法传递一个动作事件。后一种方法将动作事件传递给为关注此按钮生成的动作事件而注册的任何动作侦听器。 </p>
                            <p>如果应用程序想要执行基于按下并释放按钮的某个动作，则它应该实现 ActionListener 并注册新的侦听器，以便通过调用按钮的 addActionListener 方法来接收发自此按钮的事件。应用程序可以按消息传递协议使用按钮的动作命令。 </p>
                            <ol>
                                <li><p><code>void 	addActionListener(ActionListener l)</code> -- 添加指定的动作侦听器</p></li>
                                <li><p><code>void 	removeActionListener(ActionListener l)</code> -- 移除指定的动作侦听器</p></li>
                                <li><p><code>ActionListener[] 	getActionListeners()</code> -- 返回在此按钮上注册的所有动作侦听器的一个数组</p></li>

                                <li class="group"><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前在此 Button 上注册为 FooListener 的所有对象的数组</p></li>
                                <li><p><code>protected void 	processActionEvent(ActionEvent e)</code> -- 处理发生在此按钮上的动作事件，方法是将这些事件指派给所有已注册的 ActionListener 对象</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此按钮上的事件</p></li>

                                <li class="group"><p><code>String 	getLabel()</code> -- 获取此按钮的标签</p></li>
                                <li><p><code>void 	setLabel(String label)</code> -- 将按钮的标签设置为指定的字符串</p></li>
                                <li><p><code>String 	getActionCommand()</code> -- 返回此按钮激发的动作事件的命令名称</p></li>
                                <li><p><code>void 	setActionCommand(String command)</code> -- 设置此按钮激发的动作事件的命令名称</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建按钮的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Button 相关的 AccessibleContext</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回此 Button 状态的字符串表示形式</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <div class="split-item">
                                <pre class="brush: java;">
public class TextComponent extends Component implements Accessible {
    /** 可访问性支持 */
    protected class AccessibleAWTTextComponent extends AccessibleAWTComponent implements AccessibleText,
                                    TextListener {}

    protected TextListener textListener;
}
</pre>
                                <p><a href="docs/docs-java/api/java/awt/TextComponent.html" target="_blank">TextComponent</a> 是所有允许编辑文本的组件的超类。</p>
                                <p>文本组件具体化文本字符串。TextComponent 类定义了一组判断此文本是否可编辑的方法。如果组件是可编辑的，则该类还定义了另一组支持文件插入符的方法。 </p>
                                <p>此外，该类定义了用于维护文本当前选择 的方法。文本选择是组件文本的子字符串，是编辑操作的目标。它也被称为选定文本。</p>
                                <ol>
                                    <li><p><code>String 	getText()</code> -- 返回此文本组件表示的文本</p></li>
                                    <li><p><code>void 	setText(String t)</code> -- 将此文本组件显示的文本设置为指定文本</p></li>
                                    <li><p><code>boolean 	isEditable()</code> -- 指示此文本组件是否可编辑</p></li>
                                    <li><p><code>void 	setEditable(boolean b)</code> -- 设置判断此文本组件是否可编辑的标志</p></li>

                                    <li class="group"><p><code>String 	getSelectedText()</code> -- 返回此文本组件所表示文本的选定文本</p></li>
                                    <li><p><code>int 	getSelectionStart()</code> -- 获取此文本组件中选定文本的开始位置</p></li>
                                    <li><p><code>int 	getSelectionEnd()</code> -- 获取此文本组件中选定文本的结束位置</p></li>
                                    <li><p><code>int 	getCaretPosition()</code> -- 返回文本插入符的位置</p></li>
                                    <li><p><code>void 	setCaretPosition(int position)</code> -- 设置文本插入符的位置</p></li>
                                    <li><p><code>void 	select(int selectionStart, int selectionEnd)</code> -- 选择指定开始位置和结束位置之间的文本</p></li>
                                    <li><p><code>void 	setSelectionStart(int selectionStart)</code> -- 将此文本组件的选定开始位置设置为指定位置</p></li>
                                    <li><p><code>void 	setSelectionEnd(int selectionEnd)</code> -- 将此文本组件的选定结束位置设置为指定位置</p></li>
                                    <li><p><code>void 	selectAll()</code> -- 选择此文本组件中的所有文本</p></li>

                                    <li class="group"><p><code>Color 	getBackground()</code> -- 获得此文本组件的背景色</p></li>
                                    <li><p><code>void 	setBackground(Color c)</code> -- 设置此文本组件的背景色</p></li>
                                    <li><p><code>void 	enableInputMethods(boolean enable)</code> -- 启用或禁用此文本组件的输入法支持</p></li>
                                    <li><p><code>InputMethodRequests 	getInputMethodRequests()</code> -- 获取输入方法请求处理程序</p></li>

                                    <li class="group"><p><code>void 	addTextListener(TextListener l)</code> -- 添加指定的文本事件侦听器</p></li>
                                    <li><p><code>void 	removeTextListener(TextListener l)</code> -- 移除指定的文本事件侦听器</p></li>
                                    <li><p><code>TextListener[] 	getTextListeners()</code> -- 返回在此文本组件上所有已注册文本侦听器的数组</p></li>

                                    <li class="group"><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前已在此 TextComponent 上注册为 FooListener 的所有对象的数组</p></li>
                                    <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此文本组件上发生的事件</p></li>
                                    <li><p><code>protected void 	processTextEvent(TextEvent e)</code> -- 处理发生在此文本组件上的文本事件</p></li>

                                    <li class="group"><p><code>void 	addNotify()</code> -- 通过将此 Component 连接到一个本机屏幕资源，使其成为可显示的</p></li>
                                    <li><p><code>void 	removeNotify()</code> -- 移除 TextComponent 的同位体</p></li>
                                    <li><p><code>protected String 	paramString()</code> -- 返回表示此 TextComponent 状态的字符串</p></li>
                                    <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 TextComponent 关联的 AccessibleContext</p></li>
                                </ol>
                            </div>

                            <div class="split-item">
                                <pre class="brush: java;">
public class TextField extends TextComponent {
    /** 可访问性支持 */
    protected class AccessibleAWTTextField extends AccessibleAWTTextComponent {}

    public TextField() {} // 创建 0 列的文本框
    public TextField(int columns) {}
    public TextField(String text) {}
    public TextField(String text, int columns) {}
}
</pre>
                                <p><a href="docs/docs-java/api/java/awt/TextField.html" target="_blank">TextField</a> 是允许编辑单行文本的文本组件。</p>
                                <p>每次用户在文本字段中键入一个键时，就有一个或更多键事件被发送到该文本字段。</p>
                                <ol>
                                    <li><p><code>void 	addActionListener(ActionListener l)</code> -- 添加指定的操作侦听器</p></li>
                                    <li><p><code>void 	removeActionListener(ActionListener l)</code> -- 移除指定的操作侦听器</p></li>
                                    <li><p><code>ActionListener[] 	getActionListeners()</code> -- 返回此文本字段上已注册的所有操作侦听器的数组</p></li>

                                    <li class="group"><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前已在此 TextField 上注册为 FooListener 的所有对象的数组</p></li>
                                    <li><p><code>protected void 	processActionEvent(ActionEvent e)</code> -- 处理发生在此文本字段上的操作事件</p></li>
                                    <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此文本字段上的事件</p></li>

                                    <li class="group"><p><code>void 	setText(String t)</code> -- 将此文本组件显示的文本设置为指定文本</p></li>
                                    <li><p><code>Dimension 	getMinimumSize()</code> --  获取此文本字段的最小尺寸</p></li>
                                    <li><p><code>Dimension 	getMinimumSize(int columns)</code> -- 获取具有指定列数的文本字段的最小尺寸</p></li>
                                    <li><p><code>Dimension 	getPreferredSize()</code> -- 获取此文本字段的首选大小</p></li>
                                    <li><p><code>Dimension 	getPreferredSize(int columns)</code> -- 获取具有指定列数的文本字段的首选大小</p></li>

                                    <li class="group"><p><code>int 	getColumns()</code> -- 获取此文本字段中的列数</p></li>
                                    <li><p><code>void 	setColumns(int columns)</code> -- 设置此文本字段中的列数</p></li>
                                    <li><p><code>char 	getEchoChar()</code> -- 获取用于回显的字符</p></li>
                                    <li><p><code>boolean 	echoCharIsSet()</code> -- 指示此文本字段是否有一个回显字符集</p></li>
                                    <li><p><code>void 	setEchoChar(char c)</code> -- 设置此文本字段的回显字符</p></li>

                                    <li class="group"><p><code>void 	addNotify()</code> -- 创建 TextField 的同位体</p></li>
                                    <li><p><code>protected String 	paramString()</code> -- 返回表示此 TextField 状态的字符串</p></li>
                                    <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 TextField 关联的 AccessibleContext</p></li>
                                </ol>
                            </div>

                            <div class="split-item">
                                <pre class="brush: java;">
public class TextArea extends TextComponent {
    /** 可访问性支持 */
    protected class AccessibleAWTTextArea extends AccessibleAWTTextComponent {}

    /** 滚动条样式 */
    public static final int SCROLLBARS_BOTH = 0;            // 显示垂直和水平滚动条
    public static final int SCROLLBARS_VERTICAL_ONLY = 1;   // 显示垂直滚动条
    public static final int SCROLLBARS_HORIZONTAL_ONLY = 2; // 显示水平滚动条
    public static final int SCROLLBARS_NONE = 3;            // 不显示任何滚动条

    public TextArea() {} // 默认滚动条样式为 SCROLLBARS_BOTH
    public TextArea(int rows, int columns) {}
    public TextArea(String text) {}
    public TextArea(String text, int rows, int columns) {}
    public TextArea(String text, int rows, int columns, int scrollbars) {}
}
</pre>
                                <p><a href="docs/docs-java/api/java/awt/TextArea.html" target="_blank">TextArea</a> 是显示文本的多行区域。可以将它设置为允许编辑或只读。 </p>
                                <ol>
                                    <li><p><code>int 	getRows()</code> -- 返回此文本区的行数</p></li>
                                    <li><p><code>void 	setRows(int rows)</code> -- 设置此文本区的行数</p></li>
                                    <li><p><code>int 	getColumns()</code> -- 返回此文本区中的列数</p></li>
                                    <li><p><code>void 	setColumns(int columns)</code> -- 设置此文本区的列数</p></li>

                                    <li class="group"><p><code>Dimension 	getMinimumSize()</code> -- 确定此文本区的最小大小</p></li>
                                    <li><p><code>Dimension 	getMinimumSize(int rows, int columns)</code> -- 确定具有指定行数和列数的文本区的最小大小</p></li>
                                    <li><p><code>Dimension 	getPreferredSize()</code> -- 确定此文本区的首选大小</p></li>
                                    <li><p><code>Dimension 	getPreferredSize(int rows, int columns)</code> -- 确定具有指定行数和列数的文本区的首选大小</p></li>

                                    <li class="group"><p><code>void 	insert(String str, int pos)</code> -- 在此文本区的指定位置插入指定文本</p></li>
                                    <li><p><code>void 	replaceRange(String str, int start, int end)</code> -- 用指定替换文本替换指定开始位置与结束位置之间的文本</p></li>

                                    <li class="group"><p><code>void 	append(String str)</code> -- 将给定文本追加到文本区的当前文本</p></li>
                                    <li><p><code>int 	getScrollbarVisibility()</code> -- 返回指示文本区使用何种滚动条的枚举值</p></li>

                                    <li class="group"><p><code>void 	addNotify()</code> -- 创建 TextArea 的同位体</p></li>
                                    <li><p><code>protected String 	paramString()</code> -- 返回表示此 TextArea 状态的字符串</p></li>
                                    <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 返回与此 TextArea 相关的 AccessibleContext</p></li>
                                </ol>
                            </div>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Scrollbar extends Component implements Adjustable, Accessible {
    /** 可访问性支持 */
    protected class AccessibleAWTScrollBar extends AccessibleAWTComponent implements AccessibleValue {}

    /** 方向 */
    public static final int HORIZONTAL = 0;
    public static final int VERTICAL   = 1;

    public Scrollbar() {} // 纵向，初始值为 0, 可见量(滑块长度)为 10, 最小值为 0, 最大值为 100
    public Scrollbar(int orientation) {}
    public Scrollbar(int orientation, int value, int visible, int minimum, int maximum) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Scrollbar.html" target="_blank">Scrollbar</a> 描述了一个滚动条，这是大家都很熟悉的用户界面对象。滚动条提供了一个允许用户在一定范围的值中进行选择的便捷方式。</p>
                            <p>注：我们建议只对值的选择使用 Scrollbar(比如调节音量，类似 Android 中的 SeekBar)。如果想在容器中实现一个可滚动的组件，那么建议您使用 ScrollPane。如果使用 Scrollbar 来实现这一目的，那么可能会遇到绘制、键处理、大小调整和定位问题。 </p>
                            <ol>
                                <li><p><code>int 	getOrientation()</code> -- 返回此滚动条的方向</p></li>
                                <li><p><code>void 	setOrientation(int orientation)</code> -- 设置此滚动条的方向</p></li>
                                <li><p><code>int 	getValue()</code> -- 获取此滚动条的当前值</p></li>
                                <li><p><code>void 	setValue(int newValue)</code> -- 将此滚动条的值设置为指定值</p></li>
                                <li><p><code>int 	getVisibleAmount()</code> -- 获取此滚动条的可见量</p></li>
                                <li><p><code>void 	setVisibleAmount(int newAmount)</code> -- 设置此滚动条的可见量</p></li>
                                <li><p><code>int 	getMinimum()</code> -- 获取此滚动条的最小值</p></li>
                                <li><p><code>void 	setMinimum(int newMinimum)</code> -- 设置此滚动条的最小值</p></li>
                                <li><p><code>int 	getMaximum()</code> -- 获取此滚动条的最大值</p></li>
                                <li><p><code>void 	setMaximum(int newMaximum)</code> -- 设置此滚动条的最大值</p></li>
                                <li><p><code>void 	setValues(int value, int visible, int minimum, int maximum)</code> -- 设置此滚动条的四个属性值(参见构造方法)</p></li>

                                <li class="group"><p><code>int 	getBlockIncrement()</code> -- 获取此滚动条的块增量(点击三角形滑块移动数量)</p></li>
                                <li><p><code>void 	setBlockIncrement(int v)</code> -- 设置此滚动条的块增量</p></li>
                                <li><p><code>int 	getUnitIncrement()</code> -- 获取此滚动条的单位增量(比如其值可以只为偶数)</p></li>
                                <li><p><code>void 	setUnitIncrement(int v)</code> -- 设置此滚动条的单位增量</p></li>

                                <li class="group"><p><code>boolean 	getValueIsAdjusting()</code> -- 如果该值作为用户执行动作的结果正处于更改过程中，则返回 true</p></li>
                                <li><p><code>void 	setValueIsAdjusting(boolean b)</code> -- 设置 valueIsAdjusting 属性</p></li>

                                <li class="group"><p><code>void 	addAdjustmentListener(AdjustmentListener l)</code> -- 添加指定的调整侦听器</p></li>
                                <li><p><code>void 	removeAdjustmentListener(AdjustmentListener l)</code> -- 移除指定的调整侦听器</p></li>
                                <li><p><code>AdjustmentListener[] 	getAdjustmentListeners()</code> -- 返回在此滚动条上所有已注册调整侦听器组成的数组</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回目前已在此 Scrollbar 上注册为 FooListener 的所有对象组成的数组</p></li>

                                <li class="group"><p><code>protected void 	processAdjustmentEvent(AdjustmentEvent e)</code> -- 处理此滚动条上发生的调整事件</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理在滚动条上发生的事件</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建 Scrollbar 的同位体</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此 Scrollbar 当前状态的字符串表示形式</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Scrollbar 相关的 AccessibleContext</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Checkbox extends Component implements ItemSelectable, Accessible {
    protected class AccessibleAWTCheckbox extends AccessibleAWTComponent implements ItemListener,
                                AccessibleAction, AccessibleValue {}
    public Checkbox() {}
    public Checkbox(String label) {}
    public Checkbox(String label, boolean state) {}
    public Checkbox(String label, boolean state, CheckboxGroup group) {} // 加入一个 Group 变成单选框
    public Checkbox(String label, CheckboxGroup group, boolean state) {} // 同上
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Checkbox.html" target="_blank">Checkbox</a> 是复选框。一个可处于“开”(true) 或“关”(false) 状态的图形组件。单击复选框可将其状态从“开”更改为“关”，或从“关”更改为“开”。 </p>
                            <p>作为选择，可使用 CheckboxGroup 类将一些复选框组成一组，作为单个对象来控制。在一个复选框组中，在任何给定时间，最多只能有一个按钮处于“开”状态。单击并打开一个复选框会强迫同组中其他原来处于打开状态的复选框变为“关”状态。 </p>
                            <ol>
                                <li><p><code>void 	addItemListener(ItemListener l)</code> -- 添加指定的项侦听器</p></li>
                                <li><p><code>void 	removeItemListener(ItemListener l)</code> -- 移除此项侦听器</p></li>
                                <li><p><code>ItemListener[] 	getItemListeners()</code> -- 返回已在此复选框上注册的所有项侦听器所组成的数组</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回目前已在此 Checkbox 上注册为 FooListener 的所有对象组成的数组</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理关于此复选框的事件</p></li>
                                <li><p><code>protected void 	processItemEvent(ItemEvent e)</code> -- 处理发生在此复选框上的项事件</p></li>

                                <li class="group"><p><code>boolean 	getState()</code> -- 确定此复选框是状态</p></li>
                                <li><p><code>void 	setState(boolean state)</code> -- 将此复选框的状态设置为指定状态</p></li>
                                <li><p><code>CheckboxGroup 	getCheckboxGroup()</code> -- 确定此复选框的组</p></li>
                                <li><p><code>void 	setCheckboxGroup(CheckboxGroup g)</code> -- 将此复选框的组设置为指定复选框组</p></li>
                                <li><p><code>String 	getLabel()</code> -- 获取此复选框的标签</p></li>
                                <li><p><code>void 	setLabel(String label)</code> -- 将此复选框的标签设置为字符串参数</p></li>

                                <li class="group"><p><code>Object[] 	getSelectedObjects()</code> -- 返回包含复选框标签的数组 (length 1)，如果没有选定复选框，则返回 null</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建 Checkbox 的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Checkbox 相关的 AccessibleContext</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此 Checkbox 的状态的字符串</p></li>

                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Choice extends Component implements ItemSelectable, Accessible {
    protected class AccessibleAWTChoice extends AccessibleAWTComponent implements AccessibleAction {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Choice.html" target="_blank">Choice</a> 表示一个弹出式选择菜单。类似于 Android 中的 Spinner。 </p>
                            <p>一些本机平台不支持任意调整 Choice 组件的大小，setSize()/getSize() 的行为受到这类限制的约束。</p>
                            <ol>
                                <li><p><code>void 	addItem(String item)</code> -- 将一个项添加到此 Choice 菜单中</p></li>
                                <li><p><code>void 	add(String item)</code> -- 同上</p></li>
                                <li><p><code>void 	insert(String item, int index)</code> -- 将菜单项插入此选择的指定位置上</p></li>
                                <li><p><code>void 	remove(int position)</code> -- 从选择菜单的指定位置上移除一个项</p></li>
                                <li><p><code>void 	remove(String item)</code> -- 移除 Choice 菜单中第一个出现的 item</p></li>
                                <li><p><code>void 	removeAll()</code> -- 从选择菜单中移除所有的项</p></li>

                                <li class="group"><p><code>void 	select(int pos)</code> -- 将此 Choice 菜单中的选定项设置为指定位置上的项</p></li>
                                <li><p><code>void 	select(String str)</code> -- 将此 Choice 菜单中的选定项设置为其名称等于指定字符串的项</p></li>
                                <li><p><code>int 	getSelectedIndex()</code> -- 返回当前选定项的索引</p></li>
                                <li><p><code>String 	getSelectedItem()</code> -- 获取当前选择的字符串表示形式</p></li>
                                <li><p><code>String 	getItem(int index)</code> -- 获取此 Choice 菜单中指定索引上的字符串</p></li>

                                <li class="group"><p><code>int 	getItemCount()</code> -- 返回此 Choice 菜单中项的数量</p></li>
                                <li><p><code>Object[] 	getSelectedObjects()</code> -- 返回包含当前选定项的数组（长度为 1）</p></li>

                                <li class="group"><p><code>void 	addItemListener(ItemListener l)</code> -- 添加指定的项侦听器</p></li>
                                <li><p><code>void 	removeItemListener(ItemListener l)</code> -- 移除指定的项侦听器</p></li>
                                <li><p><code>ItemListener[] 	getItemListeners()</code> -- 返回已在此选择上注册的所有项侦听器组成的数组</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回目前已在此 Choice 上注册为 FooListener 的所有对象组成的数组</p></li>

                                <li class="group"><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理关于此选择的事件</p></li>
                                <li><p><code>protected void 	processItemEvent(ItemEvent e)</code> -- 处理发生在此 Choice 菜单上的项事件</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建 Choice 的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Choice 相关的 AccessibleContext</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此 Choice 菜单的状态的字符串</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class List extends Component implements ItemSelectable, Accessible {
    protected class AccessibleAWTList extends AccessibleAWTComponent implements AccessibleSelection,
                                ItemListener, ActionListener {}

    public List() {} // 0 行，不允许多选
    public List(int rows) {}
    public List(int rows, boolean multipleMode) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/List.html" target="_blank">List</a> 组件为用户提供了一个可滚动的文本项列表。可设置此 list，使其允许用户进行单项或多项选择。</p>
                            <p>如果 List 允许进行多项选择，则单击已选中的项时，将取消选中该项。</p>
                            <ol>
                                <li><p><code>void 	add(String item)</code> -- 向滚动列表的末尾添加指定的项</p></li>
                                <li><p><code>void 	add(String item, int index)</code> -- 向滚动列表中索引指示的位置添加指定的项</p></li>
                                <li><p><code>void 	replaceItem(String newValue, int index)</code> -- 使用新字符串替换滚动列表中指定索引处的项</p></li>
                                <li><p><code>void 	remove(int position)</code> -- 从此滚动列表中移除指定位置处的项</p></li>
                                <li><p><code>void 	remove(String item)</code> -- 从列表中移除项的第一次出现</p></li>
                                <li><p><code>void 	removeAll()</code> -- 从此列表中移除所有项</p></li>

                                <li class="group"><p><code>void 	select(int index)</code> -- 选择滚动列表中指定索引处的项</p></li>
                                <li><p><code>void 	deselect(int index)</code> -- 取消选择指定索引处的项</p></li>
                                <li><p><code>String 	getSelectedItem()</code> -- 获取此滚动列表中选中的项</p></li>
                                <li><p><code>String[] 	getSelectedItems()</code> -- 获取此滚动列表中选中的项</p></li>
                                <li><p><code>int 	getSelectedIndex()</code> -- 获取列表中选中项的索引</p></li>
                                <li><p><code>int[] 	getSelectedIndexes()</code> -- 获取列表中选中的索引</p></li>
                                <li><p><code>Object[] 	getSelectedObjects()</code> -- 获取对象数组中此滚动列表的选中项</p></li>
                                <li><p><code>boolean 	isIndexSelected(int index)</code> -- 确定是否已选中此滚动列表中的指定项</p></li>

                                <li class="group"><p><code>boolean 	isMultipleMode()</code> -- 确定此列表是否允许进行多项选择</p></li>
                                <li><p><code>void 	setMultipleMode(boolean b)</code> -- 设置是否允许进行多项选择</p></li>

                                <li class="group"><p><code>int 	getItemCount()</code> -- 获取列表中的项数</p></li>
                                <li><p><code>String 	getItem(int index)</code> -- 获取与指定索引关联的项</p></li>
                                <li><p><code>String[] 	getItems()</code> -- 获取列表中的项</p></li>
                                <li><p><code>void 	makeVisible(int index)</code> -- 使指定索引处的项可视</p></li>
                                <li><p><code>int 	getVisibleIndex()</code> -- 获取上次由 makeVisible 方法使其可视的项的索引</p></li>
                                <li><p><code>int 	getRows()</code> -- 获取此列表中的可视行数</p></li>

                                <li class="group"><p><code>void 	addActionListener(ActionListener l)</code> -- 添加指定的动作侦听器以从此列表接收动作事件</p></li>
                                <li><p><code>void 	removeActionListener(ActionListener l)</code> -- 移除指定的动作侦听器</p></li>
                                <li><p><code>ActionListener[] 	getActionListeners()</code> -- 返回已在此列表上注册的所有动作侦听器的数组</p></li>
                                <li><p><code>void 	addItemListener(ItemListener l)</code> -- 添加指定的项侦听器以接收此列表的项事件</p></li>
                                <li><p><code>void 	removeItemListener(ItemListener l)</code> -- 移除指定的项侦听器</p></li>
                                <li><p><code>ItemListener[] 	getItemListeners()</code> -- 返回已在此列表上注册的所有项侦听器的数组</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回目前已在此 List 上注册为 FooListener 的所有对象的数组</p></li>

                                <li class="group"><p><code>protected void 	processActionEvent(ActionEvent e)</code> -- 处理发生在此列表上的动作事件</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此滚动列表的进程事件</p></li>
                                <li><p><code>protected void 	processItemEvent(ItemEvent e)</code> -- 处理发生在此列表上的项事件</p></li>

                                <li class="group"><p><code>Dimension 	getMinimumSize()</code> -- 确定此滚动列表的最小大小</p></li>
                                <li><p><code>Dimension 	getMinimumSize(int rows)</code> -- 获取具有指定行数的列表的最少维数</p></li>
                                <li><p><code>Dimension 	getPreferredSize()</code> -- 获取此滚动列表的首选大小</p></li>
                                <li><p><code>Dimension 	getPreferredSize(int rows)</code> -- 获取具有指定行数的列表的首选维数</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建列表的同位体</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 移除此列表的同位体</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此滚动列表状态的参数字符串</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 List 关联的 AccessibleContext</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Canvas extends Component implements Accessible {
    protected class AccessibleAWTCanvas extends AccessibleAWTComponent {}

    public Canvas() {}
    public Canvas(GraphicsConfiguration config) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Canvas.html" target="_blank">Canvas</a> 组件表示屏幕上一个空白矩形区域，应用程序可以在该区域内绘图，或者可以从该区域捕获用户的输入事件。 </p>
                            <p>应用程序必须为 Canvas 类创建子类，以获得有用的功能（如创建自定义组件）。必须重写 paint 方法，以便在 canvas 上执行自定义图形。</p>
                            <ol>
                                <li><p><code>void 	paint(Graphics g)</code> -- 绘制此 canvas</p></li>
                                <li><p><code>void 	update(Graphics g)</code> -- 更新此 canvas</p></li>

                                <li class="group"><p><code>void 	createBufferStrategy(int numBuffers)</code> -- 创建一个新的策略，用于对此组件的多缓冲</p></li>
                                <li><p><code>void 	createBufferStrategy(int numBuffers, BufferCapabilities caps)</code> -- 创建一个新的策略，使用所需的缓冲区能力对此组件进行多缓冲</p></li>
                                <li><p><code>BufferStrategy 	getBufferStrategy()</code> -- 返回由此组件使用的多缓冲策略</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建 canvas 的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Canvas 相关的 AccessibleContext</p></li>
                            </ol>

                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-awt-"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">...</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-java/api/java/awt/.html" target="_blank"></a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-swing-JFrame"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">JFrame</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.awt.Component
        java.awt.Container
            java.awt.Window
                java.awt.Frame
                    javax.swing.JFrame

public class JFrame extends Frame implements WindowConstants, Accessible, RootPaneContainer {
    /** 可访问性支持 */
    protected class AccessibleJFrame extends AccessibleAWTFrame {}

    public static final int EXIT_ON_CLOSE = 3; // 退出应用程序后的默认窗口关闭操作

    protected JRootPane rootPane; // JRootPane 实例管理此窗体的 contentPane 和可选的 menuBar
    protected boolean rootPaneCheckingEnabled = false; // 是否 对 add 和 setLayout 的调用转发到 contentPane
    protected AccessibleContext accessibleContext = null; // 可访问的上下文属性

    public JFrame() {}
    public JFrame(GraphicsConfiguration gc) {}
    public JFrame(String title) {}
    public JFrame(String title, GraphicsConfiguration gc) {}
}

/** 点击关闭按钮的默认操作 */
public interface WindowConstants {
    public static final int DO_NOTHING_ON_CLOSE = 0; // 无操作
    public static final int HIDE_ON_CLOSE = 1;       // 隐藏窗口
    public static final int DISPOSE_ON_CLOSE = 2;    // 移除窗口
    public static final int EXIT_ON_CLOSE = 3;       // 退出应用程序
}

/** 根窗口容器，其实现类有：JApplet, JDialog, JFrame, JInternalFrame, JWindow */
public interface RootPaneContainer {
    JRootPane getRootPane(); /** 返回此组件的单个 JRootPane 子组件 */

    /** 应用程序应将子组件添加到 contentPane，设置它的布局管理器 */
    Container getContentPane();
    void setContentPane(Container contentPane);

    /** 管理 contentPane 的 Container，在某些情况下为菜单栏 */
    JLayeredPane getLayeredPane();
    void setLayeredPane(JLayeredPane layeredPane);

    /** 始终为 rootPane 的第一个子组件，rootPanes 布局管理器确保它始终与 rootPane 一样大 */
    Component getGlassPane();
    void setGlassPane(Component glassPane);
}
</pre>
                            <p><a href="docs/docs-java/api/javax/swing/JFrame.html" target="_blank">JFrame</a> 此类继承自 <code>java.awt.Frame</code>, 添加了对 JFC/Swing 组件架构的支持。Frame 参考： <a href="#java-awt-Frame">Frame  及父类</a></p>
                            <p>JFrame 类与 Frame 轻微不兼容。与其他所有 JFC/Swing 顶层容器一样，JFrame 包含一个 JRootPane 作为其唯一的子容器。根据规定，根窗格所提供的内容窗格应该包含 JFrame 所显示的所有非菜单组件。这不同于 AWT Frame。为了方便地使用 add 及其变体，已经重写了 remove 和 setLayout，以在必要时将其转发到 contentPane。</p>
                            <p>默认的内容窗格上会设置有 BorderLayout 管理器。</p>
                            <ol>
                                <li><p><code>protected void 	addImpl(Component comp, Object constraints, int index)</code> -- 添加指定的子 Component</p></li>
                                <li><p><code>protected JRootPane 	createRootPane()</code> -- 由构造方法调用，以创建默认的 rootPane</p></li>
                                <li><p><code>protected void 	frameInit()</code> -- 由构造方法调用，以适当地初始化 JFrame</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获得与此 JFrame 关联的 AccessibleContext</p></li>
                                <li><p><code>Container 	getContentPane()</code> -- 返回此窗体的 contentPane 对象</p></li>
                                <li><p><code>int 	getDefaultCloseOperation()</code> -- 返回用户在此窗体上发起 "close" 时执行的操作</p></li>
                                <li><p><code>Component 	getGlassPane()</code> -- 返回此窗体的 glassPane 对象</p></li>
                                <li><p><code>Graphics 	getGraphics()</code> -- 为组件创建一个图形上下文</p></li>
                                <li><p><code>JMenuBar 	getJMenuBar()</code> --  返回此窗体上设置的菜单栏</p></li>
                                <li><p><code>JLayeredPane 	getLayeredPane()</code> -- 返回此窗体的 layeredPane 对象</p></li>
                                <li><p><code>JRootPane 	getRootPane()</code> -- 返回此窗体的 rootPane 对象</p></li>
                                <li><p><code>TransferHandler 	getTransferHandler()</code> -- 获取 transferHandler 属性</p></li>
                                <li><p><code>static boolean 	isDefaultLookAndFeelDecorated()</code> -- 是否创建的 JFrame 应该由当前外观为其提供 Window 装饰</p></li>
                                <li><p><code>protected boolean 	isRootPaneCheckingEnabled()</code> -- 返回是否将对 add 和 setLayout 的调用转发到 contentPane</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回此 JFrame 的字符串表示形式</p></li>
                                <li><p><code>protected void 	processWindowEvent(WindowEvent e)</code> -- 处理此组件上发生的窗口事件</p></li>
                                <li><p><code>void 	remove(Component comp)</code> -- 从该容器中移除指定组件</p></li>
                                <li><p><code>void 	repaint(long time, int x, int y, int width, int height)</code> -- 在 time 毫秒内重绘此组件的指定矩形区域</p></li>
                                <li><p><code>void 	setContentPane(Container contentPane)</code> -- 设置 contentPane</p></li>
                                <li><p><code>void 	setDefaultCloseOperation(int operation)</code> -- 设置用户在此窗体上发起 "close" 时默认执行的操作。</p></li>
                                <li><p><code>static void 	setDefaultLookAndFeelDecorated(boolean defaultLookAndFeelDecorated)</code> -- 提供一个关于新创建的 JFrame 是否应该具有当前外观为其提供的 Window 装饰</p></li>
                                <li><p><code>void 	setGlassPane(Component glassPane)</code> -- 设置 glassPane</p></li>
                                <li><p><code>void 	setIconImage(Image image)</code> -- 设置要作为此窗口图标显示的图像</p></li>
                                <li><p><code>void 	setJMenuBar(JMenuBar menubar)</code> -- 设置此窗体的菜单栏</p></li>
                                <li><p><code>void 	setLayeredPane(JLayeredPane layeredPane)</code> -- 设置 layeredPane</p></li>
                                <li><p><code>void 	setLayout(LayoutManager manager)</code> -- 设置 LayoutManager</p></li>
                                <li><p><code>protected void 	setRootPane(JRootPane root)</code> -- 设置 rootPane</p></li>
                                <li><p><code>protected void 	setRootPaneCheckingEnabled(boolean enabled)</code> -- 设置是否将对 add 和 setLayout 的调用转发到 contentPane</p></li>
                                <li><p><code>void 	setTransferHandler(TransferHandler newHandler)</code> -- 设置 transferHandler 属性</p></li>
                                <li><p><code>void 	update(Graphics g)</code> -- 调用 <code>paint(g)</code></p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.awt.Component
        java.awt.Container
            java.awt.Window
                javax.swing.JWindow

public class JWindow extends Window implements Accessible, RootPaneContainer {

}
</pre>
                            <p><a href="docs/docs-java/api/javax/swing/JWindow.html" target="_blank">JWindow</a> </p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.awt.Component
        java.awt.Container
            java.awt.Window
                java.awt.Dialog
                    javax.swing.JDialog

public class JDialog extends Dialog implements WindowConstants, Accessible, RootPaneContainer {

}
</pre>
                            <p><a href="docs/docs-java/api/javax/swing/JDialog.html" target="_blank">JDialog</a> </p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-swing-LayoutManager"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">...</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <p>LayoutManager / LayoutManager2 定义如何布置 Container 类的接口。此接口定义在 <code>java.awt</code> 包中。</p>
                            <p>LayoutManager / LayoutManager2 的实现类:(<code>java.awt</code> 包中的部分实现类查看: <a href="#java-awt-LayoutManager">AWT 下的 LayoutManager 实现类</a>)</p>
                            <ul>
                                <li><p><a href="#GroupLayout">GroupLayout</a> -- </p></li>
                                <li><p><a href="#DefaultMenuLayout">DefaultMenuLayout</a> -- </p></li>
                                <li><p><a href="#MetalScrollBarUI">MetalScrollBarUI</a> -- </p></li>
                                <li><p><a href="#BasicScrollBarUI">BasicScrollBarUI</a> -- </p></li>
                                <li><p><a href="#OverlayLayout">OverlayLayout</a> -- </p></li>
                                <li><p><a href="#ScrollPaneLayout">ScrollPaneLayout</a> -- </p></li>
                                <li><p><a href="#SpringLayout">SpringLayout</a> -- </p></li>
                                <li><p><a href="#SynthScrollBarUI">SynthScrollBarUI</a> -- </p></li>
                                <li><p><a href="#ViewportLayout">ViewportLayout</a> -- </p></li>
                            </ul>
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-java/api/javax/swing/.html" target="_blank"></a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-swing-JComponent"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">JComponent 及子类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.awt.Component
        java.awt.Container
            javax.swing.JComponent

public abstract class JComponent extends Container implements Serializable {

}
</pre>
                            <p><a href="docs/docs-java/api/javax/swing/JComponent.html" target="_blank">JComponent</a> 是除顶层容器外所有 Swing 组件的基类。</p>
                            <p>要使用继承自 JComponent 的组件，必须将该组件置于一个根为顶层 Swing 容器的包含层次结构中。顶层 Swing 容器（如 JFrame、JDialog 和 JApplet）是专门为其他 Swing 组件提供绘制自身场所的组件。</p>
                            <p>此类的子类不同于 <code>java.awt.Component</code> 的子类, 此类继承自 <code>java.awt.Container</code> 类，而 <code>java.awt.Component</code> 的子类都不是继承<code>java.awt.Container</code> 类。</p>
                            <p>JComponent 类提供： </p>
                            <ul>
                                <li><p>使用 Swing 架构的标准组件和自定义组件的基类；</p></li>
                                <li><p>可由程序员指定，或者由用户在运行时选择（可选）的“可插入外观”(L&F)。每个组件的外观都由 UI 委托 提供，UI 委托是一个继承自 ComponentUI 的对象；</p></li>
                                <li><p>全面的键击处理；</p></li>
                                <li><p>对工具提示的支持：光标停留在组件时所弹出的简短描述；</p></li>
                                <li><p>可访问性支持。JComponent 包含 Accessible 接口中的所有方法，但是它实际上不实现该接口。由扩展 JComponent 的每个类负责实现该接口；</p></li>
                                <li><p>对特定于组件属性的支持。通过 putClientProperty(java.lang.Object, java.lang.Object) 和 getClientProperty(java.lang.Object) 方法，可以将“名称-对象”对与继承自 JComponent 的任意对象进行关联；</p></li>
                                <li><p>用于绘制的基础设施，包括双缓冲和对边框的支持。</p></li>
                            </ul>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-swing-"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">...</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-java/api/javax/swing/.html" target="_blank"></a> </p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javafx-base"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">JavaFx 基础</h3>
                    </div>
                    <div class="panel-body">

                        <p>JavaFX 主要包括以下包：</p>
                        <ul>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/application/package-summary.html" target="_blank">javafx.application</a> -- 应用程序包，包括: <code>Application</code>, <code>Platform</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/stage/package-summary.html" target="_blank">javafx.stage</a> -- 顶级容器类，包括: <code>Window</code>, <code>Stage</code>, <code>PopupWindow</code>, <code>Popup</code>, <code>FileChooser</code>, <code>DirectoryChooser</code>, <code>Screen</code>, <code>WindowBuilder</code>, <code>WindowEvent</code>, <code>StageBuilder</code>, <code>Modality</code>, <code>StageStyle</code>, <code>PopupBuilder</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/fxml/package-summary.html" target="_blank">javafx.fxml</a> -- FXML 文件加载，包括: <code>FXMLLoader</code>, <code>JavaFXBuilderFactory</code> 和一个注解类: <code>FXML</code></p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/animation/package-summary.html" target="_blank">javafx.animation</a> -- 动画类，常见动画其插值器，包括: <code>Animation</code>, <code>Transition</code>, <code>TranslateTransition</code>, <code>ScaleTransition</code>, <code>StrokeTransition</code>, <code>RotateTransition</code>, <code>FillTransition</code>, <code>FadeTransition</code>, <code>PathTransition</code>, <code>PauseTransition</code>, <code>ParallelTransition</code>, <code>SequentialTransition</code>, <code>Interpolator</code>, <code>AnimationBuilder</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/geometry/package-summary.html" target="_blank">javafx.geometry</a> -- 提供用于定义和执行与二维几何相关的对象的操作的 2D 类集合，包括: <code>Insets</code>, <code>Bounds</code>, <code>Point2D</code>, <code>Point3D</code>, <code>Rectangle2D</code>, <code>BoundingBox</code>, <code>Dimension2D</code>, <code>Side</code>, <code>VPos</code>, <code>HPos</code>, <code>Pos</code>, <code>Orientation</code>, <code>HorizontalDirection</code>, <code>VerticalDirection</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/util/converter/package-summary.html" target="_blank">javafx.util.converter</a> -- String 类和常用的类型转换工具类，都是 <code>javafx.util.StringConverter</code> 的直接或间接子类，包括： <code>DefaultStringConverter</code>,  <code>FormatStringConverter</code>, <code>CharacterStringConverter</code>, <code>NumberStringConverter</code>, <code>BooleanStringConverter</code> <code>ByteStringConverter</code>, <code>ShortStringConverter</code>, <code>IntegerStringConverter</code>, <code>LongStringConverter</code>, <code>FloatStringConverter</code>, <code>DoubleStringConverter</code>, <code>BigIntegerStringConverter</code>, <code>BigDecimalStringConverter</code>, <code>CurrencyStringConverter</code>, <code>DateStringConverter</code>, <code>TimeStringConverter</code>, <code>DateTimeStringConverter</code>, <code>PercentageStringConverter</code></p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/package-summary.html" target="_blank">javafx.scene</a> -- JavaFX 库的 UI 元素的基本实现，包括: <code>Scene</code>, <code>Node</code>, <code>Parent</code>, <code>Group</code>, <code>Camera</code>, <code>Cursor</code>, <code>SceneBuilder</code>, <code>NodeBuilder</code>, <code>ParentBuilder</code>, <code>SnapshotResult</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/layout/package-summary.html" target="_blank">javafx.scene.layout</a> -- JavaFX 库的部分容器类实现，主要是 Pane 及子类，构造器和几个约束，包括: <code>Region</code>, <code>Pane</code>, <code>HBox</code>, <code>VBox</code>, <code>AnchorPane</code>, <code>BorderPane</code>, <code>FlowPane</code>, <code>GridPane</code>, <code>TilePane</code>, <code>ConstraintsBase</code>, <code>PaneBuilder</code>, <code>FlowPaneBuilder</code>, <code>BorderPaneBuilder</code>, <code>GridPaneBuilder</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/control/package-summary.html" target="_blank">javafx.scene.control</a> -- 控件类，菜单，控件构造器，其中多数控件类都是继承子 Control 类，包括: <code>Control</code>, <code>Label</code>, <code>Button</code>, <code>MenuBar</code>, <code>Menu</code>, <code>ListView</code>, <code>ScrollBar</code>, <code>Slider</code>, <code>Tab</code>, <code>TableRow</code>, <code>TableColumn</code>, <code>ToolBar</code>, <code>Tooltip</code>, <code>TreeView</code>, <code>ControlBuilder</code>, <code>ButtonBuilder</code>, <code>TreeViewBuilder</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/shape/package-summary.html" target="_blank">javafx.scene.shape</a> -- 基本图形和其构造器，图形都是 Shape 的子类，包括: <code>Shape</code>, <code>ShapeBuilder</code>, <code>Rectangle</code>, <code>RectangleBuilder</code>, <code>Circle</code>, <code>CircleBuilder</code>, <code>Line</code>, <code>LineBuilder</code>, <code>Arc</code>, <code>ArcBuilder</code>, <code>Path</code>, <code>PathBuilder</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/paint/package-summary.html" target="_blank">javafx.scene.paint</a> -- 绘图的画笔和渐变，多数是 Paint 的子类，包括： <code>Paint</code>,  <code>Color</code>, <code>ImagePattern</code>, <code>ImagePatternBuilder</code>, <code>LinearGradient</code>, <code>LinearGradientBuilder</code>, <code>RadialGradient</code>, <code>RadialGradientBuilder</code>, <code>Stop</code>, <code>StopBuilder</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/text/package-summary.html" target="_blank">javafx.scene.text</a> -- 字体和文本绘制，包括: <code>Font</code>, <code>FontBuilder</code>, <code>Text</code>, <code>TextBuilder</code>, <code>TextAlignment</code>, <code>FontWeight</code>, <code>TextBoundsType</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/effect/package-summary.html" target="_blank">javafx.scene.effect</a> -- 图形处理，各种效果，多数是 Effect 的子类，包括: <code>Effect</code>, <code>Blend</code>, <code>Bloom</code>, <code>BoxBlur</code>, <code>ColorAdjust</code>, <code>DropShadow</code>, <code>GaussianBlur</code>, <code>Glow</code>, <code>InnerShadow</code>, <code>Lighting</code>, <code>MotionBlur</code>, <code>Reflection</code>, <code>BlendMode</code>, <code>BlurType</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/image/package-summary.html" target="_blank">javafx.scene.image</a> -- 提供用于加载和显示图像的一组类，包括: <code>Image</code>, <code>ImageView</code>, <code>PixelFormat</code>, <code>WritableImage</code>, <code>WritablePixelFormat</code>, <code>ImageViewBuilder</code>, <code>PixelFormat.Type</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/input/package-summary.html" target="_blank">javafx.scene.input</a> -- 输入事件，包括键盘输入，鼠标事件，滑动事件..., 包括: <code>KeyEvent</code>, <code>MouseEvent</code>, <code>DragEvent</code>, <code>Clipboard</code>, <code>InputMethodEvent</code>, <code>Clipboard</code>, <code>ScrollEvent</code>, <code>KeyCode</code>, <code>MouseButton</code>, <code>TransferMode</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/media/package-summary.html" target="_blank">javafx.scene.media</a> -- 多媒体播放和控制，包括: <code>MediaPlayer</code>, <code>MediaView</code>, <code>Media</code>, <code>AudioTrack</code>, <code>VideoTrack</code>, <code>AudioClip</code>, <code>EqualizerBand</code>, <code>MediaPlayer.Status</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/transform/package-summary.html" target="_blank">javafx.scene.transform</a> -- 矩阵变换操作，多是 Transform 的子类，包括: <code>Transform</code>, <code>Translate</code>, <code>Rotate</code>, <code>Scale</code>, <code>Shear</code>, <code>Affine</code>, <code>RotateBuilder</code>, <code>TranslateBuilder</code>, <code>ScaleBuilder</code> ...</p></li>
                            <li><p><a href="docs/docs-java/api-javafx8/javafx/scene/web/package-summary.html" target="_blank">javafx.scene.web</a> -- WEB 操作，网页加载和 HTML 编辑，包括: <code>WebView</code>, <code>HTMLEditor</code>, <code>WebEvent</code>, <code>WebHistory</code>, <code>WebEngine</code>, <code>PromptData</code>, <code>PopupFeatures</code>, <code>WebViewBuilder</code> ...</p></li>
                        </ul>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javafx-application-Application"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Application 及顶级窗口类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    javafx.application.Application

public abstract class Application {
    /** 可以检索此应用程序的参数 */
    public static abstract class Parameters {
        public Parameters() {}
        public abstract List&lt;String> getRaw();
        public abstract List&lt;String> getUnnamed();
        public abstract Map&lt;String, String> getNamed();
    }

    /** 提供了两种样式： */
    public static final String STYLESHEET_CASPIAN = "CASPIAN"; // JavaFX 2.x"s CASPIAN Look and Feel
    public static final String STYLESHEET_MODENA = "MODENA";   // JavaFX 8"s Modena Look and Feel
}
                                </pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/application/Application.html" target="_blank">Application</a> 是应用程序，JavaFX 应用程序扩展的应用程序类。</p>
                            <ol>
                                <li><p><code>static void 	launch(Class&lt;? extends Application> appClass, String... args)</code> -- 启动指定的 Application(此方法可在非 Application 子类中调用)</p></li>
                                <li><p><code>static void 	launch(String... args)</code> -- 运行应用程序(一般在 Appcation 的子类中的 main 方法中调用，否则会抛出运行时异常)</p>
                                    <pre class="brush: java;">
public class MyApplication extends Application {
    @Override
    public void start(Stage primaryStage) throws Exception {
        primaryStage.setTitle("JavaFx");
        primaryStage.show();
    }

    public static void main(String[] args) {
        Application.launch(args); // 此类继承子 Application, 否则报运行时异常
        // Application.launch(MyApplication.class, args); // 可以在非 Application 子类调用
    }
}
</pre>
                                </li>

                                <li class="group"><p><code>static void setUserAgentStylesheet(String url)</code> -- 设置整个应用程序使用的用户代理样式表</p></li>
                                <li><p><code>static String getUserAgentStylesheet()</code> -- 获取整个应用程序使用的用户代理样式表</p>
                                    <pre class="brush: java;">
/** JDK 默认提供了两种样式,其内容可解压：$JAVA_HOME/jre/lib/ext/jfxrt.jar
 * STYLESHEET_CASPIAN -- /com/sun/javafx/scene/control/skin/caspian/caspian.css
 * STYLESHEET_MODENA -- /com/sun/javafx/scene/control/skin/modena/modena.css
 */
Application.setUserAgentStylesheet(Application.STYLESHEET_CASPIAN);
Application.setUserAgentStylesheet(Application.STYLESHEET_MODENA);

/** 可以使用 css 文件作为全局样式(css 的定义参照: 使用 CSS 控制样式一节) */
Application.setUserAgentStylesheet(getClass().getResource("common.css").toExternalForm());
</pre>
                                </li>

                                <li class="group"><p><code>abstract void 	start(<a href="#Stage">Stage</a> primaryStage)</code> -- <a href="#Stage">Stage</a> 是 Window 的子类，可以在此方法中显示窗口</p>
                                    <pre class="brush: java;">
@Override
public void start(Stage primaryStage) throws Exception {
    Pane root = FXMLLoader.load(getClass().getResource("/layout/login.fxml")); // 加载 fxml 布局文件
    primaryStage.setScene(new Scene(root));
    primaryStage.show(); // 显示窗口
}
</pre>
                                </li>

                                <li class="group"><p><code>void 	init()</code> -- 初始化回调，空实现，此方法执行在 start 前</p></li>
                                <li><p><code>void 	stop()</code> -- 关闭 Application 回调，空实现</p></li>

                                <li class="group"><p><code>HostServices 	getHostServices()</code> -- <code>HostServices</code> 类为应用程序提供主机服务，包括获取应用程序的代码库和文档库、在浏览器中显示网页、以及如果应用程序在浏览器中运行，则使用JavaScript与封闭的网页进行通信的方法。</p></li>
                                <li><p><code>Application.Parameters 	getParameters()</code> -- 可以检索此应用程序的参数，包括命令行上传递的任何参数，可以在 <code>init()</code> 方法中或在此后的任何时间调用</p></li>
                                <li><p><code>final void 	notifyPreloader(Preloader.PreloaderNotification info)</code> -- 用应用程序生成的通知通知预加载器，主要用于应用程序希望预加载程序在长期应用程序初始化步骤期间显示进度的情况</p></li>
                            </ol>
                        </div>

                        <a id="Stage" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    javafx.stage.Window
        javafx.stage.Stage

public class Stage extends Window {
    public Stage() {}
    /** StageStyle 为窗体样式，参见 initStyle(StageStyle) 方法 */
    public Stage(StageStyle style) {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/stage/Stage.html" target="_blank">Stage</a> 是顶级 JavaFX 容器。</p>
                            <p>必须在 JavaFX 应用程序线程上构造和修改阶段对象。</p>
                            <p>许多 Stage 属性都是只读的，因为它们可以由底层平台从外部更改，因此不能绑定。</p>
                            <ol>
                                <li><p><code>void 	setTitle(String value)</code> -- 设置窗体标题</p></li>
                                <li><p><code>String 	getTitle()</code> -- 获取窗体标题</p></li>
                                <li><p><code>StringProperty 	titleProperty()</code> -- </p></li>

                                <li class="group"><p><code>void 	show()</code> -- 显示窗体</p></li>
                                <li><p><code>void 	showAndWait()</code> -- 临时阻止当前事件的处理，并启动嵌套事件循环来处理其他事件(primaryStage 不可调用)</p></li>
                                <li><p><code>void 	close()</code> -- 关闭窗体</p></li>
                                <li><p><code>void 	setScene(Scene value)</code> -- 设置 Stage 的场景(参见: <a href="#javafx-scene-Scene">Scene 及相关类</a>)</p></li>

                                <li class="group"><p><code>void 	initStyle(StageStyle style)</code> -- 初始化窗体样式(必须在 <code>show()</code> 方法前调用)</p></li>
                                <li><p><code>StageStyle 	getStyle()</code> -- 获取窗体样式</p>
                                    <pre class="brush: java;">
public enum StageStyle {
    DECORATED,          // 正常窗口，默认
    UNDECORATED,        // 无边框窗口
    TRANSPARENT,        // 透明背景，无边框
    UTILITY,            //
    UNIFIED             //
}
</pre>
                                </li>

                                <li class="group"><p><code>boolean 	isFullScreen()</code> -- 是否为全屏</p></li>
                                <li><p><code>void 	setFullScreen(boolean value)</code> -- 设置是否全屏</p></li>
                                <li><p><code>ReadOnlyBooleanProperty 	fullScreenProperty()</code> -- 属性形式读取和修改标题</p></li>

                                <li class="group"><p><code>boolean isMaximized()</code> -- 是否最大化</p></li>
                                <li><p><code>void setMaximized(boolean value)</code> -- 设置最大化</p></li>
                                <li><p><code>ReadOnlyBooleanProperty maximizedProperty()</code> -- 属性形式读写最大化</p></li>

                                <li class="group"><p><code>boolean 	isResizable()</code> -- 是否可调节大小</p></li>
                                <li><p><code>void 	setResizable(boolean value)</code> -- 设置是否可调节大小(如果为 false, 那么无法全屏，也无最大化按钮)</p></li>
                                <li><p><code>BooleanProperty 	resizableProperty()</code> -- 属性形式读写调节大小</p></li>

                                <li class="group"><p><code>boolean 	isIconified()</code> -- </p></li>
                                <li><p><code>void 	setIconified(boolean value)</code> -- </p></li>
                                <li><p><code>ReadOnlyBooleanProperty 	iconifiedProperty()</code> -- </p>

                                <li class="group"><p><code>String getFullScreenExitHint()</code> -- </p></li>
                                <li><p><code>void setFullScreenExitHint(String value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;String> fullScreenExitHintProperty()</code> -- </p></li>

                                <li class="group"><p><code>KeyCombination getFullScreenExitKeyCombination()</code> -- </p></li>
                                <li><p><code>void setFullScreenExitKeyCombination(KeyCombination keyCombination)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;KeyCombination> fullScreenExitKeyProperty()</code> -- </p></li>

                                <li class="group"><p><code>void setAlwaysOnTop(boolean value)</code> -- </p>
                                <li><p><code>boolean isAlwaysOnTop()</code> -- </p>
                                <li><p><code>ReadOnlyBooleanProperty alwaysOnTopProperty()</code> -- </p>

                                <li class="group"><p><code>ObservableList&lt;Image> 	getIcons()</code> -- </p></li>

                                <li class="group"><p><code>void 	initModality(Modality modality)</code> -- </p></li>
                                <li><p><code>Modality 	getModality()</code> -- </p></li>
                                <li><p><code>void 	initOwner(Window owner)</code> -- </p></li>
                                <li><p><code>Window 	getOwner()</code> -- </p></li>

                                <li class="group"><p><code>double 	getMaxHeight()</code> -- 获取最大高度</p></li>
                                <li><p><code>void 	setMaxHeight(double value)</code> -- 设置最大高度</p></li>
                                <li><p><code>DoubleProperty 	maxHeightProperty()</code> -- 属性形式读写最大高度</p></li>

                                <li class="group"><p><code>double 	getMaxWidth()</code> -- 获取最大宽度</p></li>
                                <li><p><code>void 	setMaxWidth(double value)</code> -- 设置最大宽度</p></li>
                                <li><p><code>DoubleProperty 	maxWidthProperty()</code> -- 属性形式读写最大宽度</p></li>

                                <li class="group"><p><code>double 	getMinHeight()</code> -- 获取最小高度</p></li>
                                <li><p><code>void 	setMinHeight(double value)</code> -- 设置最小高度</p></li>
                                <li><p><code>DoubleProperty 	minHeightProperty()</code> -- 属性形式读写最小高度</p></li>

                                <li class="group"><p><code>double 	getMinWidth()</code> -- 获取最小宽度</p></li>
                                <li><p><code>void 	setMinWidth(double value)</code> -- 设置最大小宽度</p></li>
                                <li><p><code>DoubleProperty 	minWidthProperty()</code> -- 属性形式读写最小宽度</p></li>

                                <li class="group"><p><code>void 	toBack()</code> -- </p></li>
                                <li><p><code>void 	toFront()</code> -- </p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    javafx.stage.Window

public class Window implements EventTarget {

}

public interface EventTarget {
    EventDispatchChain buildEventDispatchChain(EventDispatchChain tail);
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/stage/Window.html" target="_blank">Window</a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javafx-scene-Scene"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Scene 及相关类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    javafx.scene.Scene

@DefaultProperty("root")
public class Scene implements EventTarget {
    public Scene(Parent root) {}
    public Scene(Parent root, double width, double height) {}
    public Scene(Parent root, Paint fill) {}
    public Scene(Parent root, double width, double height, Paint fill) {}
    public Scene(Parent root, double width, double height, boolean depthBuffer) {}
    public Scene(Parent root, double w, double h, boolean depthBuffer, SceneAntialiasing anti) {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/Scene.html" target="_blank">Scene</a> </p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/" target="_blank"></a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javafx-scene-Node"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">控件基类: Node</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
Node
 ├─ Canvas, ImageView, MediaView
 ├─ Shape
 │   └─ Arc, Line, Circle, Rectangle, Path, SVGPath, Polygon, Polyline, CubicCurve, QuadCurve, EllipseText
 └─ Parent
      ├─ WebView, Group
      └─ Region
          ├─ Axis
          │   ├─ CategoryAxis
          │   └─ ValueAxis
          │       └─ NumberAxis
          ├─ Chart
          │   ├─ PieChart
          │   └─ XYChart
          │       └─ AreaChart
          │           └─ BarChart, BubbleChart, LineChart, ScatterChart, StackedAreaChart, StackedBarChart
          ├─ Pane
          │   └─ AnchorPane, BorderPane, FlowPane, GridPane, HBox, VBox, StackPane, TilePane
          └─ Control
              ├─ Accordion, ChoiceBox, HTMLEditor, ListView, MenuBar, Pagination, ScrollBar,
              ├─ ScrollPane, Separator, Slider, SplitPane, TableView, TabPane, ToolBar, TreeView
              ├─ ComboBoxBas
              │   └─ ComboBox, ColorPicker
              ├─ ProgressIndicator
              │   └─ ProgressBar
              ├─ TextInputControl
              │   ├─ TextArea
              │   └─ TextField
              │       └─ PasswordField
              └─ Labeled
                  ├─ Label, TitledPane
                  ├─ ButtonBase
                  │    ├─ Hyperlink, Button, CheckBox
                  │    ├─ MenuButton
                  │    │   └─ SplitMenuButton
                  │    └─ ToggleButton
                  │        └─ RadioButton
                  └─ Cell
                      └─ IndexedCell
                          ├─ TableRow
                          ├─ ListCell
                          │   └─ CheckBoxListCell, ChoiceBoxListCell, ComboBoxListCell, TextFieldListCell
                          ├─ TableCell
                          │   ├─ CheckBoxTableCell, ChoiceBoxTableCell, ComboBoxTableCell,
                          │   └─ ProgressBarTableCell, TextFieldTableCell
                          └─ TreeCell
                              └─ CheckBoxTreeCell, ChoiceBoxTreeCell, ComboBoxTreeCell, TextFieldTreeCell
java.lang.Object
    javafx.scene.Node

public abstract class Node implements EventTarget, Styleable {
    public static final double BASELINE_OFFSET_SAME_AS_HEIGHT = Double.NEGATIVE_INFINITY;

    protected Node() {}
}

public interface Styleable {
    String getId();
    String getStyle();
    String getTypeSelector();
    Styleable getStyleableParent();
    ObservableList&lt;String> getStyleClass();
    List&lt;CssMetaData&lt;? extends Styleable, ?>> getCssMetaData();
    ObservableSet&lt;PseudoClass> getPseudoClassStates();
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/Node.html" target="_blank">Node</a> 类是所有控件和图形类的基类。</p>
                            <p>Node 是节点，只有一个节点将没有父节点，这被称为“根”节点。其它每个节点都有零个或一个父项，并且每个节点要么是具有零个子项的“叶子”，要么是具有零个或多个子项的“分支”。</p>
                            <p>Node 类定义了传统的计算机图形“局部”坐标系，其中 x 轴向右增加，y 轴向下增加。形状的具体节点类提供了用于定义该局部坐标空间中形状的几何形状和位置的变量。</p>
                            <p>任何节点都可以有应用于它的转换。这些包括平移、旋转、缩放或剪切。</p>
                            <ol>
                                <li><p><code>static List&lt;CssMetaData&lt;? extends Styleable, ?>> getClassCssMetaData()</code> -- 与此类关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>boolean 	isVisible()</code> -- 节点是否可见</p></li>
                                <li><p><code>void 	setVisible(boolean value)</code> -- 设置节点可见性</p></li>
                                <li><p><code>BooleanProperty 	visibleProperty()</code> -- 属性形式读写节点可见性</p></li>

                                <li class="group"><p><code>double 	getOpacity()</code> -- 获取透明度</p></li>
                                <li><p><code>void 	setOpacity(double value)</code> -- 设置透明度</p></li>
                                <li><p><code>DoubleProperty 	opacityProperty()</code> -- 属性形式读写透明度</p></li>

                                <li class="group"><p><code>boolean 	isDisable()</code> -- 是否关闭节点</p></li>
                                <li><p><code>void 	setDisable(boolean value)</code> -- 设置是否关闭节点</p></li>
                                <li><p><code>BooleanProperty 	disableProperty()</code> -- 属性形式读写是否关闭节点</p></li>

                                <li class="group"><p><code>boolean 	isDisabled()</code> -- 节点是否已经关闭</p></li>
                                <li><p><code>protected void 	setDisabled(boolean value)</code> -- 设置节点是否已经关闭</p></li>
                                <li><p><code>ReadOnlyBooleanProperty 	disabledProperty()</code> -- 属性形式读节点是否已经关闭</p></li>

                                <li class="group"><p><code>String 	getId()</code> -- 获取 ID</p></li>
                                <li><p><code>void 	setId(String value)</code> -- 设置 ID</p></li>
                                <li><p><code>StringProperty 	idProperty()</code> -- 属性形式读写 ID</p></li>

                                <li class="group"><p><code>String 	getStyle()</code> -- 获取样式</p></li>
                                <li><p><code>void 	setStyle(String value)</code> -- 设置样式</p></li>
                                <li><p><code>StringProperty 	styleProperty()</code> -- 属性形式读写样式</p></li>

                                <li class="group"><p><code>Node 	lookup(String selector)</code> -- 使用选择器获取第一个子节点</p></li>
                                <li><p><code>Set&lt;Node> 	lookupAll(String selector)</code> -- 使用选择器获取所有节点</p></li>

                                <li class="group"><p><code>Styleable 	getStyleableParent()</code> -- 获取该样式的父级(布局节点)</p></li>
                                <li><p><code>String 	getTypeSelector()</code> -- 获取类型选择器(一般都是类名)</p></li>

                                <li class="group"><p><code>void 	autosize()</code> -- 如果节点是可调整大小的，则将其布局边界设置为其当前优选的宽度和高度</p></li>
                                <li><p><code>boolean 	isResizable()</code> -- 节点是否可改变大小(false)</p></li>
                                <li><p><code>void 	resize(double width, double height)</code> -- 如果节点是可调整大小的，重置组件大小(空实现，看子类)</p></li>
                                <li><p><code>void 	relocate(double x, double y)</code> -- 将该节点重新定位到父节点中的X、Y位置</p></li>
                                <li><p><code>void 	resizeRelocate(double x, double y, double width, double height)</code> -- 调用 resize() 和 relocate() 两个方法</p></li>

                                <li class="group"><p><code>double 	getLayoutX()</code> -- 获取定位点距离父节点的左边宽距离(如：矩形为左上角，圆形为中点)</p></li>
                                <li><p><code>void 	setLayoutX(double value)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	layoutXProperty()</code> -- </p></li>

                                <li class="group"><p><code>double 	getLayoutY()</code> -- 获取定位点距离父节点的顶部宽距离(如：矩形为左上角，圆形为中点)</p></li>
                                <li><p><code>void 	setLayoutY(double value)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	layoutYProperty()</code> -- </p></li>

                                <li class="group"><p><code>Bounds 	getLayoutBounds()</code> -- 获取布局边界</p></li>
                                <li><p><code>ReadOnlyObjectProperty&lt;Bounds> 	layoutBoundsProperty()</code> -- 属性形式读布局边界</p></li>

                                <li class="group"><p><code>boolean 	contains(double localX, double localY)</code> -- </p></li>
                                <li><p><code>boolean 	contains(Point2D localPoint)</code> -- </p></li>

                                <li class="group"><p><code>double 	maxHeight(double width)</code> -- </p></li>
                                <li><p><code>double 	maxWidth(double height)</code> -- </p></li>
                                <li><p><code>double 	prefHeight(double width)</code> -- </p></li>
                                <li><p><code>double 	prefWidth(double height)</code> -- </p></li>
                                <li><p><code>double 	minHeight(double width)</code> -- </p></li>
                                <li><p><code>double 	minWidth(double height)</code> -- </p></li>

                                <li class="group"><p><code>double 	getTranslateX()</code> -- </p></li>
                                <li><p><code>void 	setTranslateX(double value)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	translateXProperty()</code> -- </p></li>

                                <li class="group"><p><code>double 	getTranslateY()</code> -- </p></li>
                                <li><p><code>void 	setTranslateY(double value)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	translateYProperty()</code> -- </p></li>

                                <li class="group"><p><code>double 	getTranslateZ()</code> -- </p></li>
                                <li><p><code>void 	setTranslateZ(double value)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	translateZProperty()</code> -- </p></li>

                                <li class="group"><p><code>double 	getScaleX()</code> -- </p></li>
                                <li><p><code>void 	setScaleX(double value)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	scaleXProperty()</code> -- </p></li>

                                <li class="group"><p><code>double 	getScaleY()</code> -- </p></li>
                                <li><p><code>void 	setScaleY(double value)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	scaleYProperty()</code> -- </p></li>

                                <li class="group"><p><code>double 	getScaleZ()</code> -- </p></li>
                                <li><p><code>void 	setScaleZ(double value)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	scaleZProperty()</code> -- </p></li>

                                <li class="group"><p><code>Point3D 	getRotationAxis()</code> -- </p></li>
                                <li><p><code>void 	setRotationAxis(Point3D value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;Point3D> 	rotationAxisProperty()</code> -- </p></li>

                                <li class="group"><p><code>double 	getRotate()</code> -- </p></li>
                                <li><p><code>void 	setRotate(double value)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	rotateProperty()</code> -- </p></li>

                                <li class="group"><p><code>BlendMode 	getBlendMode()</code> -- </p></li>
                                <li><p><code>void 	setBlendMode(BlendMode value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;BlendMode> 	blendModeProperty()</code> -- </p></li>

                                <li class="group"><p><code>Object 	getUserData()</code> -- </p></li>
                                <li><p><code>void 	setUserData(Object value)</code> -- </p></li>

                                <li class="group"><p><code>boolean 	isPickOnBounds()</code> -- </p></li>
                                <li><p><code>void 	setPickOnBounds(boolean value)</code> -- </p></li>
                                <li><p><code>BooleanProperty 	pickOnBoundsProperty()</code> -- </p></li>

                                <li class="group"><p><code>Parent 	getParent()</code> -- </p></li>
                                <li><p><code>ReadOnlyObjectProperty&lt;Parent> 	parentProperty()</code> -- </p></li>

                                <li class="group"><p><code>Scene 	getScene()</code> -- </p></li>
                                <li><p><code>ReadOnlyObjectProperty&lt;Scene> 	sceneProperty()</code> -- </p></li>

                                <li class="group"><p><code>Effect 	getEffect()</code> -- </p></li>
                                <li><p><code>void 	setEffect(Effect value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;Effect> 	effectProperty()</code> -- </p></li>

                                <li class="group"><p><code>CacheHint 	getCacheHint()</code> -- </p></li>
                                <li><p><code>void 	setCacheHint(CacheHint value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;CacheHint> 	cacheHintProperty()</code> -- </p></li>

                                <li class="group"><p><code>boolean 	isCache()</code> -- </p></li>
                                <li><p><code>void 	setCache(boolean value)</code> -- </p></li>
                                <li><p><code>BooleanProperty 	cacheProperty()</code> -- </p></li>

                                <li class="group"><p><code>boolean 	isFocused()</code> -- </p></li>
                                <li><p><code>protected void 	setFocused(boolean value)</code> -- </p></li>
                                <li><p><code>ReadOnlyBooleanProperty 	focusedProperty()</code> -- </p></li>
                                <li><p><code>void 	requestFocus()</code> -- </p></li>

                                <li class="group"><p><code>boolean 	isFocusTraversable()</code> -- </p></li>
                                <li><p><code>void 	setFocusTraversable(boolean value)</code> -- </p></li>
                                <li><p><code>BooleanProperty 	focusTraversableProperty()</code> -- </p></li>

                                <li class="group"><p><code>boolean 	isPressed()</code> -- </p></li>
                                <li><p><code>protected void 	setPressed(boolean value)</code> -- </p></li>
                                <li><p><code>ReadOnlyBooleanProperty 	pressedProperty()</code> -- </p></li>

                                <li class="group"><p><code>boolean 	isMouseTransparent()</code> -- </p></li>
                                <li><p><code>void 	setMouseTransparent(boolean value)</code> -- </p></li>
                                <li><p><code>BooleanProperty 	mouseTransparentProperty()</code> -- </p></li>

                                <li class="group"><p><code>Node 	getClip()</code> -- </p></li>
                                <li><p><code>void 	setClip(Node value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;Node> 	clipProperty()</code> -- </p></li>

                                <li class="group"><p><code>Cursor 	getCursor()</code> -- </p></li>
                                <li><p><code>void 	setCursor(Cursor value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;Cursor> 	cursorProperty()</code> -- </p></li>

                                <li class="group"><p><code>boolean 	isHover()</code> -- </p></li>
                                <li><p><code>protected void 	setHover(boolean value)</code> -- </p></li>
                                <li><p><code>ReadOnlyBooleanProperty 	hoverProperty()</code> -- </p></li>

                                <li class="group"><p><code>boolean 	isManaged()</code> -- </p></li>
                                <li><p><code>void 	setManaged(boolean value)</code> -- </p></li>
                                <li><p><code>BooleanProperty 	managedProperty()</code> -- </p></li>

                                <li class="group"><p><code>boolean 	hasProperties()</code> -- </p></li>
                                <li><p><code>ObservableMap&lt;Object,Object> 	getProperties()</code> -- </p></li>

                                <li class="group"><p><code>InputMethodRequests 	getInputMethodRequests()</code> -- </p></li>
                                <li><p><code>void 	setInputMethodRequests(InputMethodRequests value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;InputMethodRequests> 	inputMethodRequestsProperty()</code> -- </p></li>

                                <li class="group"><p><code>DepthTest 	getDepthTest()</code> -- </p></li>
                                <li><p><code>void 	setDepthTest(DepthTest value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;DepthTest> 	depthTestProperty()</code> -- </p></li>

                                <li class="group"><p><code>String getAccessibleText()</code> -- </p></li>
                                <li><p><code>void setAccessibleText(String value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;String> accessibleTextProperty()</code> -- </p></li>

                                <li class="group"><p><code>String getAccessibleHelp()</code> -- </p></li>
                                <li><p><code>void setAccessibleHelp(String value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;String> accessibleHelpProperty()</code> -- </p></li>

                                <li class="group"><p><code>AccessibleRole getAccessibleRole()</code> -- </p></li>
                                <li><p><code>void setAccessibleRole(AccessibleRole value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;AccessibleRole> accessibleRoleProperty()</code> -- </p></li>

                                <li class="group"><p><code>String getAccessibleRoleDescription()</code> -- </p></li>
                                <li><p><code>void setAccessibleRoleDescription(String value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;String> accessibleRoleDescriptionProperty()</code> -- </p></li>

                                <li class="group"><p><code>Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters)</code> -- </p></li>
                                <li><p><code>void executeAccessibleAction(AccessibleAction action, Object... parameters)</code> -- </p></li>
                                <li><p><code>void notifyAccessibleAttributeChanged(AccessibleAttribute attributes)</code> -- </p></li>

                                <li class="group"><p><code>void setNodeOrientation(NodeOrientation orientation)</code> -- </p></li>
                                <li><p><code>NodeOrientation getNodeOrientation()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;NodeOrientation> nodeOrientationProperty()</code> -- </p></li>

                                <li class="group"><p><code>NodeOrientation getEffectiveNodeOrientation()</code> -- </p></li>
                                <li><p><code>ReadOnlyObjectProperty&lt;NodeOrientation> effectiveNodeOrientationProperty()</code> -- </p></li>

                                <li class="group"><p><code>Bounds 	getBoundsInLocal()</code> -- </p></li>
                                <li><p><code>Bounds 	getBoundsInParent()</code> -- </p></li>
                                <li><p><code>ReadOnlyObjectProperty&lt;Bounds> 	boundsInLocalProperty()</code> -- </p></li>
                                <li><p><code>ReadOnlyObjectProperty&lt;Bounds> 	boundsInParentProperty()</code> -- </p></li>
                                <li><p><code>boolean 	intersects(Bounds localBounds)</code> -- </p></li>
                                <li><p><code>boolean 	intersects(double localX, double localY, double localWidth, double localHeight)</code> -- </p></li>

                                <li class="group"><p><code>void 	snapshot(Callback&lt;SnapshotResult,java.lang.Void> callback, SnapshotParameters params, WritableImage image)</code> -- </p></li>
                                <li><p><code>WritableImage 	snapshot(SnapshotParameters params, WritableImage image)</code> -- </p></li>

                                <li class="group"><p><code>ObservableSet&lt;PseudoClass> getPseudoClassStates()</code> -- </p></li>
                                <li><p><code>void pseudoClassStateChanged(PseudoClass pseudoClass, boolean active)</code> -- </p></li>

                                <li class="group"><p><code>Dragboard 	startDragAndDrop(TransferMode... transferModes)</code> -- </p></li>
                                <li><p><code>void 	startFullDrag()</code> -- </p></li>

                                <li class="group"><p><code>void 	toBack()</code> -- </p></li>
                                <li><p><code>void 	toFront()</code> -- </p></li>

                                <li class="group"><p><code>double 	getBaselineOffset()</code> -- </p></li>
                                <li><p><code>Orientation 	getContentBias()</code> -- </p></li>
                                <li><p><code>ObservableList&lt;.String> 	getStyleClass()</code> -- </p></li>
                                <li><p><code>ObservableList&lt;Transform> 	getTransforms()</code> -- </p></li>
                                <li><p><code>List&lt;CssMetaData&lt;? extends Styleable,?>> 	getCssMetaData()</code> -- </p></li>

                                <li class="group"><p><code>Bounds 	localToParent(Bounds localBounds)</code> -- </p></li>
                                <li><p><code>Point2D 	localToParent(double localX, double localY)</code> -- </p></li>
                                <li><p><code>Point2D 	localToParent(Point2D localPoint)</code> -- </p></li>
                                <li><p><code>Point3D 	localToParent(double x, double y, double z)</code> -- </p></li>
                                <li><p><code>Point3D 	localToParent(Point3D localPoint)</code> -- </p></li>
                                <li><p><code>Transform 	getLocalToParentTransform()</code> -- </p></li>
                                <li><p><code>ReadOnlyObjectProperty&lt;Transform> 	localToParentTransformProperty()</code> -- </p></li>

                                <li class="group"><p><code>Bounds 	parentToLocal(Bounds parentBounds)</code> -- </p></li>
                                <li><p><code>Point2D 	parentToLocal(double parentX, double parentY)</code> -- </p></li>
                                <li><p><code>Point2D 	parentToLocal(Point2D parentPoint)</code> -- </p></li>
                                <li><p><code>Point3D 	parentToLocal(double parentX, double parentY, double parentZ)</code> -- </p></li>
                                <li><p><code>Point3D 	parentToLocal(Point3D parentPoint)</code> -- </p></li>

                                <li class="group"><p><code>Bounds 	localToScene(Bounds localBounds)</code> -- </p></li>
                                <li><p><code>Bounds 	localToScene(Bounds localBounds, boolean rootScene)</code> -- </p></li>
                                <li><p><code>Point2D 	localToScene(double localX, double localY)</code> -- </p></li>
                                <li><p><code>Point2D 	localToScene(double x, double y, boolean rootScene)</code> -- </p></li>
                                <li><p><code>Point2D 	localToScene(Point2D localPoint)</code> -- </p></li>
                                <li><p><code>Point2D 	localToScene(Point2D localPoint, boolean rootScene)</code> -- </p></li>
                                <li><p><code>Point3D 	localToScene(double x, double y, double z)</code> -- </p></li>
                                <li><p><code>Point3D 	localToScene(double x, double y, double z, boolean rootScene)</code> -- </p></li>
                                <li><p><code>Point3D 	localToScene(Point3D localPoint)</code> -- </p></li>
                                <li><p><code>Point3D 	localToScene(Point3D localPoint, boolean rootScene)</code> -- </p></li>
                                <li><p><code>Transform 	getLocalToSceneTransform()</code> -- </p></li>
                                <li><p><code>ReadOnlyObjectProperty&lt;Transform> 	localToSceneTransformProperty()</code> -- </p></li>

                                <li class="group"><p><code>Bounds 	sceneToLocal(Bounds sceneBounds))</code> -- </p></li>
                                <li><p><code>Bounds 	sceneToLocal(Bounds bounds, boolean rootScene))</code> -- </p></li>
                                <li><p><code>Point2D 	sceneToLocal(double sceneX, double sceneY))</code> -- </p></li>
                                <li><p><code>Point2D 	sceneToLocal(double x, double y, boolean rootScene))</code> -- </p></li>
                                <li><p><code>Point2D 	sceneToLocal(Point2D scenePoint))</code> -- </p></li>
                                <li><p><code>Point2D 	sceneToLocal(Point2D point, boolean rootScene))</code> -- </p></li>
                                <li><p><code>Point3D 	sceneToLocal(double sceneX, double sceneY, double sceneZ))</code> -- </p></li>
                                <li><p><code>Point3D 	sceneToLocal(Point3D scenePoint))</code> -- </p></li>

                                <li class="group"><p><code>Bounds 	localToScreen(Bounds localBounds)</code> -- </p></li>
                                <li><p><code>Point2D 	localToScreen(double localX, double localY)</code> -- </p></li>
                                <li><p><code>Point2D 	localToScreen(double localX, double localY, double localZ)</code> -- </p></li>
                                <li><p><code>Point2D 	localToScreen(Point2D localPoint)</code> -- </p></li>
                                <li><p><code>Point2D 	localToScreen(Point3D localPoint)</code> -- </p></li>

                                <li class="group"><p><code>Bounds 	screenToLocal(Bounds screenBounds)</code> -- </p></li>
                                <li><p><code>Point2D 	screenToLocal(double screenX, double screenY)</code> -- </p></li>
                                <li><p><code>Point2D 	screenToLocal(Point2D screenPoint)</code> -- </p></li>

                                <li class="group"><p><code>void applyCss()</code> -- </p></li>
                                <li><p><code>double computeAreaInScreen()</code> -- </p></li>
                                <li><p><code>boolean 	usesMirroring()</code> -- </p></li>

                                <li class="group"><p><code>EventDispatcher 	getEventDispatcher()</code> -- </p></li>
                                <li><p><code>void 	setEventDispatcher(EventDispatcher value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventDispatcher> 	eventDispatcherProperty()</code> -- </p></li>

                                <li class="group"><p><code>void 	fireEvent(Event event)</code> -- </p></li>
                                <li><p><code>protected &lt;T extends Event> void 	setEventHandler(EventType&lt;T> eventType, EventHandler&lt;? super T> eventHandler)</code> -- </p></li>
                                <li><p><code>EventDispatchChain 	buildEventDispatchChain(EventDispatchChain tail)</code> -- </p></li>

                                <li class="group"><p><code>&lt;T extends Event> void 	addEventFilter(EventType&lt;T> eventType, EventHandler&lt;? super T> eventFilter)</code> -- 添加指定类型的事件过滤器, 当节点在事件交付的 <b>捕获阶段</b> 接收指定类型的事件时，调用该过滤器</p></li>
                                <li><p><code>&lt;T extends Event> void 	removeEventFilter(EventType&lt;T> eventType, EventHandler&lt;? super T> eventFilter)</code> -- 移除指定类型的事件处理器</p></li>
                                <li><p><code>&lt;T extends Event> void 	addEventHandler(EventType&lt;T> eventType, EventHandler&lt;? super T> eventHandler)</code> -- 添加指定类型的事件处理器, 当节点在事件传递的 <b>冒泡阶段</b> 接收指定类型的事件时，调用该处理程序</p></li>
                                <li><p><code>&lt;T extends Event> void 	removeEventHandler(EventType&lt;T> eventType, EventHandler&lt;? super T> eventHandler)</code> -- 移除指定类型的事件处理器</p></li>

                                <li class="group"><p><code>void 	setOnContextMenuRequested(EventHandler&lt;? super ContextMenuEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnDragDetected(EventHandler&lt;? super MouseEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnDragDone(EventHandler&lt;? super DragEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnDragDropped(EventHandler&lt;? super DragEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnDragEntered(EventHandler&lt;? super DragEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnDragExited(EventHandler&lt;? super DragEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnDragOver(EventHandler&lt;? super DragEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnInputMethodTextChanged(EventHandler&lt;? super InputMethodEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnKeyPressed(EventHandler&lt;? super KeyEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnKeyReleased(EventHandler&lt;? super KeyEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnKeyTyped(EventHandler&lt;? super KeyEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnMouseClicked(EventHandler&lt;? super MouseEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnMouseDragEntered(EventHandler&lt;? super MouseDragEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnMouseDragExited(EventHandler&lt;? super MouseDragEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnMouseDragged(EventHandler&lt;? super MouseEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnMouseDragOver(EventHandler&lt;? super MouseDragEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnMouseDragReleased(EventHandler&lt;? super MouseDragEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnMouseEntered(EventHandler&lt;? super MouseEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnMouseExited(EventHandler&lt; super MouseEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnMouseMoved(EventHandler&lt;? super MouseEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnMousePressed(EventHandler&lt;? super MouseEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnMouseReleased(EventHandler&lt;? super MouseEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnRotate(EventHandler&lt;? super RotateEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnRotationFinished(EventHandler&lt;? super RotateEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnRotationStarted(EventHandler&lt;? super RotateEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnScroll(EventHandler&lt;? super ScrollEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnScrollFinished(EventHandler&lt;? super ScrollEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnScrollStarted(EventHandler&lt;? super ScrollEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnSwipeDown(EventHandler&lt;? super SwipeEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnSwipeLeft(EventHandler&lt;? super SwipeEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnSwipeRight(EventHandler&lt;? super SwipeEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnSwipeUp(EventHandler&lt;? super SwipeEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnTouchMoved(EventHandler&lt;? super TouchEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnTouchPressed(EventHandler&lt;? super TouchEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnTouchReleased(EventHandler&lt;? super TouchEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnTouchStationary(EventHandler&lt;? super TouchEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnZoom(EventHandler&lt;? super ZoomEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnZoomFinished(EventHandler&lt;? super ZoomEvent> value)</code> -- </p></li>
                                <li><p><code>void 	setOnZoomStarted(EventHandler&lt;? super ZoomEvent> value)</code> -- </p></li>

                                <li class="group"><p><code>EventHandler&lt;? super ContextMenuEvent> 	getOnContextMenuRequested()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseEvent> 	getOnDragDetected()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super DragEvent> 	getOnDragDone()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super DragEvent> 	getOnDragDropped()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super DragEvent> 	getOnDragEntered()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super DragEvent> 	getOnDragExited()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super DragEvent> 	getOnDragOver()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super InputMethodEvent> 	getOnInputMethodTextChanged()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super KeyEvent> 	getOnKeyPressed()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super KeyEvent> 	getOnKeyReleased()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super KeyEvent> 	getOnKeyTyped()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseEvent> 	getOnMouseClicked()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseDragEvent> 	getOnMouseDragEntered()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseDragEvent> 	getOnMouseDragExited()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseEvent> 	getOnMouseDragged()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseDragEvent> 	getOnMouseDragOver()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseDragEvent> 	getOnMouseDragReleased()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseEvent> 	getOnMouseEntered()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseEvent> 	getOnMouseExited()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseEvent> 	getOnMouseMoved()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseEvent> 	getOnMousePressed()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super MouseEvent> 	getOnMouseReleased()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super RotateEvent> 	getOnRotate()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super RotateEvent> 	getOnRotationFinished()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super RotateEvent> 	getOnRotationStarted()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super ScrollEvent> 	getOnScroll()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super ScrollEvent> 	getOnScrollFinished()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super ScrollEvent> 	getOnScrollStarted()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super SwipeEvent> 	getOnSwipeDown()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super SwipeEvent> 	getOnSwipeLeft()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super SwipeEvent> 	getOnSwipeRight()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super SwipeEvent> 	getOnSwipeUp()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super TouchEvent> 	getOnTouchMoved()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super TouchEvent> 	getOnTouchPressed()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super TouchEvent> 	getOnTouchReleased()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super TouchEvent> 	getOnTouchStationary()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super ZoomEvent> 	getOnZoom()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super ZoomEvent> 	getOnZoomFinished()</code> -- </p></li>
                                <li><p><code>EventHandler&lt;? super ZoomEvent> 	getOnZoomStarted()</code> -- </p></li>

                                <li class="group"><p><code>ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent>> 	onContextMenuRequestedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseEvent>> 	onDragDetectedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super DragEvent>> 	onDragDoneProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super DragEvent>> 	onDragDroppedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super DragEvent>> 	onDragEnteredProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super DragEvent>> 	onDragExitedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super DragEvent>> 	onDragOverProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent>> 	onInputMethodTextChangedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super KeyEvent>> 	onKeyPressedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super KeyEvent>> 	onKeyReleasedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super KeyEvent>> 	onKeyTypedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseEvent>> 	onMouseClickedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent>> 	onMouseDragEnteredProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent>> 	onMouseDragExitedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseEvent>> 	onMouseDraggedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent>> 	onMouseDragOverProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent>> 	onMouseDragReleasedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseEvent>> 	onMouseEnteredProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseEvent>> 	onMouseExitedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseEvent>> 	onMouseMovedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseEvent>> 	onMousePressedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super MouseEvent>> 	onMouseReleasedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super RotateEvent>> 	onRotateProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super RotateEvent>> 	onRotationFinishedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super RotateEvent>> 	onRotationStartedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super ScrollEvent>> 	onScrollFinishedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super ScrollEvent>> 	onScrollProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super ScrollEvent>> 	onScrollStartedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super SwipeEvent>> 	onSwipeDownProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super SwipeEvent>> 	onSwipeLeftProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super SwipeEvent>> 	onSwipeRightProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super SwipeEvent>> 	onSwipeUpProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super TouchEvent>> 	onTouchMovedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super TouchEvent>> 	onTouchPressedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super TouchEvent>> 	onTouchReleasedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super TouchEvent>> 	onTouchStationaryProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super ZoomEvent>> 	onZoomFinishedProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super ZoomEvent>> 	onZoomProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;EventHandler&lt;? super ZoomEvent>> 	onZoomStartedProperty()</code> -- </p></li>


                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public abstract class Parent extends Node {
    protected Parent() {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/Parent.html" target="_blank">Parent</a> 是具有子节点的所有节点的基类。</p>
                            <p>Parent 类处理所有分层场景图操作，包括添加/移除子节点、为布局和渲染标记脏分支、挑选、边界计算以及在每个脉冲上执行布局传递。</p>
                            <ol>
                                <li><p><code>protected double 	computeMinHeight(double width)</code> -- </p></li>
                                <li><p><code>protected double 	computeMinWidth(double height)</code> -- </p></li>
                                <li><p><code>protected double 	computePrefHeight(double width)</code> -- </p></li>
                                <li><p><code>protected double 	computePrefWidth(double height)</code> -- </p></li>
                                <li><p><code>double 	getBaselineOffset()</code> -- </p></li>
                                <li><p><code>protected ObservableList&lt;Node> 	getChildren()</code> -- </p></li>
                                <li><p><code>ObservableList&lt;Node> 	getChildrenUnmodifiable()</code> -- </p></li>
                                <li><p><code>protected &lt;E extends Node>List&lt;E> 	getManagedChildren()</code> -- </p></li>
                                <li><p><code>ObservableList&lt;String> 	getStylesheets()</code> -- </p></li>
                                <li><p><code>boolean 	isNeedsLayout()</code> -- </p></li>
                                <li><p><code>void 	layout()</code> -- </p></li>
                                <li><p><code>protected void 	layoutChildren()</code> -- </p></li>
                                <li><p><code>Node 	lookup(String selector)</code> -- </p></li>
                                <li><p><code>double 	minHeight(double width)</code> -- </p></li>
                                <li><p><code>double 	minWidth(double height)</code> -- </p></li>
                                <li><p><code>ReadOnlyBooleanProperty 	needsLayoutProperty()</code> -- </p></li>
                                <li><p><code>double 	prefHeight(double width)</code> -- </p></li>
                                <li><p><code>double 	prefWidth(double height)</code> -- </p></li>
                                <li><p><code>Object 	queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters)</code> -- </p></li>
                                <li><p><code>void 	requestLayout()</code> -- </p></li>
                                <li><p><code>protected void 	requestParentLayout()</code> -- </p></li>
                                <li><p><code>protected void 	setNeedsLayout(boolean value)</code> -- </p></li>
                                <li><p><code>protected void 	updateBounds()</code> -- </p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Region extends Parent {
    public static final double USE_PREF_SIZE = Double.NEGATIVE_INFINITY;
    public static final double USE_COMPUTED_SIZE = -1;
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/layout/Region.html" target="_blank">Region</a></p>
                            <ol>
                                <li><p><code>ObjectProperty&lt;Background> 	backgroundProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;Border> 	borderProperty()</code> -- </p></li>
                                <li><p><code>BooleanProperty 	cacheShapeProperty()</code> -- </p></li>
                                <li><p><code>BooleanProperty 	centerShapeProperty()</code> -- </p></li>
                                <li><p><code>protected double 	computeMaxHeight(double width)</code> -- </p></li>
                                <li><p><code>protected double 	computeMaxWidth(double height)</code> -- </p></li>
                                <li><p><code>protected double 	computeMinHeight(double width)</code> -- </p></li>
                                <li><p><code>protected double 	computeMinWidth(double height)</code> -- </p></li>
                                <li><p><code>protected double 	computePrefHeight(double width)</code> -- </p></li>
                                <li><p><code>protected double 	computePrefWidth(double height)</code> -- </p></li>
                                <li><p><code>Background 	getBackground()</code> -- </p></li>
                                <li><p><code>Border 	getBorder()</code> -- </p></li>
                                <li><p><code>static List&lt;CssMetaData&lt;? extends Styleable,?>> 	getClassCssMetaData()</code> -- </p></li>
                                <li><p><code>List&lt;CssMetaData&lt;? extends Styleable,?>> 	getCssMetaData()</code> -- </p></li>
                                <li><p><code>double 	getHeight()</code> -- </p></li>
                                <li><p><code>Insets 	getInsets()</code> -- </p></li>
                                <li><p><code>double 	getMaxHeight()</code> -- </p></li>
                                <li><p><code>double 	getMaxWidth()</code> -- </p></li>
                                <li><p><code>double 	getMinHeight()</code> -- </p></li>
                                <li><p><code>double 	getMinWidth()</code> -- </p></li>
                                <li><p><code>Insets 	getOpaqueInsets()</code> -- </p></li>
                                <li><p><code>Insets 	getPadding()</code> -- </p></li>
                                <li><p><code>double 	getPrefHeight()</code> -- </p></li>
                                <li><p><code>double 	getPrefWidth()</code> -- </p></li>
                                <li><p><code>Shape 	getShape()</code> -- </p></li>
                                <li><p><code>String 	getUserAgentStylesheet()</code> -- </p></li>
                                <li><p><code>double 	getWidth()</code> -- </p></li>
                                <li><p><code>ReadOnlyDoubleProperty 	heightProperty()</code> -- </p></li>
                                <li><p><code>ReadOnlyObjectProperty&lt;Insets> 	insetsProperty()</code> -- </p></li>
                                <li><p><code>boolean 	isCacheShape()</code> -- </p></li>
                                <li><p><code>boolean 	isCenterShape()</code> -- </p></li>
                                <li><p><code>boolean 	isResizable()</code> -- </p></li>
                                <li><p><code>boolean 	isScaleShape()</code> -- </p></li>
                                <li><p><code>boolean 	isSnapToPixel()</code> -- </p></li>
                                <li><p><code>protected void 	layoutInArea(Node child, double areaX, double areaY, double areaWidth, double areaHeight, double areaBaselineOffset, HPos halignment, VPos valignment)</code> -- </p></li>
                                <li><p><code>protected void 	layoutInArea(Node child, double areaX, double areaY, double areaWidth, double areaHeight, double areaBaselineOffset, Insets margin, boolean fillWidth, boolean fillHeight, HPos halignment, VPos valignment)</code> -- </p></li>
                                <li><p><code>static void 	layoutInArea(Node child, double areaX, double areaY, double areaWidth, double areaHeight, double areaBaselineOffset, Insets margin, boolean fillWidth, boolean fillHeight, HPos halignment, VPos valignment, boolean isSnapToPixel)</code> -- </p></li>
                                <li><p><code>protected void 	layoutInArea(Node child, double areaX, double areaY, double areaWidth, double areaHeight, double areaBaselineOffset, Insets margin, HPos halignment, VPos valignment)</code> -- </p></li>
                                <li><p><code>double 	maxHeight(double width)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	maxHeightProperty()</code> -- </p></li>
                                <li><p><code>double 	maxWidth(double height)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	maxWidthProperty()</code> -- </p></li>
                                <li><p><code>double 	minHeight(double width)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	minHeightProperty()</code> -- </p></li>
                                <li><p><code>double 	minWidth(double height)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	minWidthProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;Insets> 	opaqueInsetsProperty()</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;Insets> 	paddingProperty()</code> -- </p></li>
                                <li><p><code>protected void 	positionInArea(Node child, double areaX, double areaY, double areaWidth, double areaHeight, double areaBaselineOffset, HPos halignment, VPos valignment)</code> -- </p></li>
                                <li><p><code>static void 	positionInArea(Node child, double areaX, double areaY, double areaWidth, double areaHeight, double areaBaselineOffset, Insets margin, HPos halignment, VPos valignment, boolean isSnapToPixel)</code> -- </p></li>
                                <li><p><code>double 	prefHeight(double width)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	prefHeightProperty()</code> -- </p></li>
                                <li><p><code>double 	prefWidth(double height)</code> -- </p></li>
                                <li><p><code>DoubleProperty 	prefWidthProperty()</code> -- </p></li>
                                <li><p><code>void 	resize(double width, double height)</code> -- </p></li>
                                <li><p><code>BooleanProperty 	scaleShapeProperty()</code> -- </p></li>
                                <li><p><code>void 	setBackground(Background value)</code> -- </p></li>
                                <li><p><code>void 	setBorder(Border value)</code> -- </p></li>
                                <li><p><code>void 	setCacheShape(boolean value)</code> -- </p></li>
                                <li><p><code>void 	setCenterShape(boolean value)</code> -- </p></li>
                                <li><p><code>protected void 	setHeight(double value)</code> -- </p></li>
                                <li><p><code>void 	setMaxHeight(double value)</code> -- </p></li>
                                <li><p><code>void 	setMaxSize(double maxWidth, double maxHeight)</code> -- </p></li>
                                <li><p><code>void 	setMaxWidth(double value)</code> -- </p></li>
                                <li><p><code>void 	setMinHeight(double value)</code> -- </p></li>
                                <li><p><code>void 	setMinSize(double minWidth, double minHeight)</code> -- </p></li>
                                <li><p><code>void 	setMinWidth(double value)</code> -- </p></li>
                                <li><p><code>void 	setOpaqueInsets(Insets value)</code> -- </p></li>
                                <li><p><code>void 	setPadding(Insets value)</code> -- </p></li>
                                <li><p><code>void 	setPrefHeight(double value)</code> -- </p></li>
                                <li><p><code>void 	setPrefSize(double prefWidth, double prefHeight)</code> -- </p></li>
                                <li><p><code>void 	setPrefWidth(double value)</code> -- </p></li>
                                <li><p><code>void 	setScaleShape(boolean value)</code> -- </p></li>
                                <li><p><code>void 	setShape(Shape value)</code> -- </p></li>
                                <li><p><code>void 	setSnapToPixel(boolean value)</code> -- </p></li>
                                <li><p><code>protected void 	setWidth(double value)</code> -- </p></li>
                                <li><p><code>ObjectProperty&lt;Shape> 	shapeProperty()</code> -- </p></li>
                                <li><p><code>double 	snappedBottomInset()</code> -- </p></li>
                                <li><p><code>double 	snappedLeftInset()</code> -- </p></li>
                                <li><p><code>double 	snappedRightInset()</code> -- </p></li>
                                <li><p><code>double 	snappedTopInset()</code> -- </p></li>
                                <li><p><code>protected double 	snapPosition(double value)</code> -- </p></li>
                                <li><p><code>protected double 	snapSize(double value)</code> -- </p></li>
                                <li><p><code>protected double 	snapSpace(double value)</code> -- </p></li>
                                <li><p><code>BooleanProperty 	snapToPixelProperty()</code> -- </p></li>
                                <li><p><code>ReadOnlyDoubleProperty 	widthProperty()</code> -- </p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javafx-scene-layout-Pane"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">布局类： Pane 及子类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public class Pane extends Region {
    public Pane() {}
    public Pane(Node... children) {}

    public ObservableList&lt;Node> getChildren() {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/layout/Pane.html" target="_blank">Pane</a> 布局窗格的基类，需要将子类列表公开为公共的，以便子类的用户可以自由添加/删除子类。</p>
                            <p>此类的继承结构查看： <a href="#javafx-scene-Node">图形基类: Node</a></p>
                            <p>子类导航: <a href="#javafx-scene-layout-AnchorPane">AnchorPane</a>, <a href="#javafx-scene-layout-BorderPane">BorderPane</a>, <a href="#javafx-scene-layout-FlowPane">FlowPane</a>, <a href="#javafx-scene-layout-GridPane">GridPane</a>, <a href="#javafx-scene-layout-StackPane">StackPane</a>, <a href="#javafx-scene-layout-TilePane">TilePane</a>, <a href="#javafx-scene-layout-Hbox">HBox</a>, <a href="#javafx-scene-layout-VBox">VBox</a></p>
                            <p>Pane 类可以直接用于需要对子类进行绝对定位的情况，因为除了将可调整大小的子类调整到其首选大小之外，它不执行布局。</p>
                        </div>

                        <a id="javafx-scene-layout-AnchorPane" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class AnchorPane extends Pane {
    public AnchorPane() {}
    public AnchorPane(Node... children) {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/layout/AnchorPane.html" target="_blank">AnchorPane</a> 锚节点允许子节点的边缘锚定到锚面板边缘的偏移。如果锚窗格具有边框和/或填充集，偏移量将从这些插图的内边缘测量。</p>
                            <p>AnchorPane 中每个节点的位置，都是设置其距离 AnchorPane 边界的上，下，左，右距离来控制其位置。实例：</p>
                            <pre class="brush: java;">
AnchorPane root = new AnchorPane();
Button btn = new Button("Top10-Left20");
AnchorPane.setTopAnchor(btn, 10.0);    // 距离顶部 10
AnchorPane.setLeftAnchor(btn, 20.0);   // 距离左边 20
root.getChildren().add(btn);
</pre>
                            <p>AnchorPane 对每个托管子节点进行布局，而不管子节点的可见属性值如何；对于所有布局计算，都将忽略非托管子节点。</p>
                            <p>AnchorPane 可以使用 CSS 来设置背景和边界。</p>
                            <p>此类的继承结构查看： <a href="#javafx-scene-Node">图形基类: Node</a></p>
                            <ol>
                                <li><p><code>static void 	clearConstraints(Node child)</code> -- 清除指定节点的约束</p></li>

                                <li class="group"><p><code>static Double 	getBottomAnchor(Node child)</code> -- 获取指定节点距离下边界的距离</p></li>
                                <li><p><code>static Double 	getTopAnchor(Node child)</code> -- 获取指定节点距离上边界的距离</p></li>
                                <li><p><code>static Double 	getLeftAnchor(Node child)</code> -- 获取指定节点距离左边界的距离</p></li>
                                <li><p><code>static Double 	getRightAnchor(Node child)</code> -- 获取指定节点距离右边界的距离</p></li>

                                <li class="group"><p><code>static void 	setBottomAnchor(Node child, Double value)</code> -- 设置指定节点距离下边界的距离</p></li>
                                <li><p><code>static void 	setTopAnchor(Node child, Double value)</code> --  设置指定节点距离上边界的距离</p></li>
                                <li><p><code>static void 	setLeftAnchor(Node child, Double value)</code> --  设置指定节点距离左边界的距离</p></li>
                                <li><p><code>static void 	setRightAnchor(Node child, Double value)</code> --  设置指定节点距离右边界的距离</p></li>

                                <li class="group"><p><code>protected double 	computeMinHeight(double width)</code> -- 计算该区域的最小高度和</p></li>
                                <li><p><code>protected double 	computeMinWidth(double height)</code> -- 计算该区域的最小宽度</p></li>
                                <li><p><code>protected double 	computePrefHeight(double width)</code> -- 计算该区域的首选高度</p></li>
                                <li><p><code>protected double 	computePrefWidth(double height)</code> -- 计算该区域的首选宽度</p></li>

                                <li class="group"><p><code>protected void 	layoutChildren()</code> -- 在布局传递过程中调用，以布局父级中的子代。默认情况下，它只将托管的、可调整大小的内容设置为它们的首选大小，不执行任何节点定位</p></li>
                            </ol>
                        </div>

                        <a id="javafx-scene-layout-BorderPane" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class BorderPane extends Pane {
    public BorderPane() {}
    public BorderPane(Node center) {}
    public BorderPane(Node center, Node top, Node right, Node bottom, Node left) {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/layout/BorderPane.html" target="_blank">BorderPane</a> 将空间分为 中，上，下，左，右五个部分，中心节点将被调整大小以填充中间可用空间，顶部和底部的子元素调整到它们的首选高度并扩展边界窗格的宽度，左右子元素将被调整到它们的首选宽度，并延长顶部和底部节点之间的长度。</p>
                            <p>BorderPane 常用于定义一个非常经典的布局效果：上方是菜单栏和工具栏，下方是状态栏，左边是导航面板，右边是附加信息面板，中间是核心工作区域。</p>
                            <p>BorderPane 将在五个位置中设置每个子集，而不管子节点的可见属性值；忽略非托管子节点。</p>
                            <p>BorderPane 可以使用 CSS 来设置背景和边框。</p>
                            <p>此类的继承结构查看： <a href="#javafx-scene-Node">图形基类: Node</a></p>
                            <ol>
                                <li><p><code>static void 	clearConstraints(Node child)</code> -- 清除指定节点的约束</p></li>

                                <li class="group"><p><code>static Insets 	getMargin(Node child)</code> -- 获取指定节点的边距</p></li>
                                <li><p><code>static void 	setMargin(Node child, Insets value)</code> -- 设置指定节点的边距</p></li>

                                <li class="group"><p><code>static Pos 	getAlignment(Node child)</code> -- 获取指定节点的对齐方式</p></li>
                                <li><p><code>static void 	setAlignment(Node child, Pos value)</code> -- 设置指定节点的对齐方式</p></li>

                                <li class="group"><p><code>void 	setCenter(Node value)</code> -- 设置中心节点元素</p></li>
                                <li><p><code>Node 	getCenter()</code> -- 获取中心节点元素</p></li>
                                <li><p><code>ObjectProperty&lt;Node> 	centerProperty()</code> -- 属性形式读写中心节点元素</p></li>

                                <li class="group"><p><code>void 	setTop(Node value)</code> -- 设置中心顶部节点元素</p></li>
                                <li><p><code>Node 	getTop()</code> -- 获取顶部节点元素</p></li>
                                <li><p><code>ObjectProperty&lt;Node> 	topProperty()</code> -- 属性形式读写中心节点元素</p></li>

                                <li class="group"><p><code>void 	setBottom(Node value)</code> -- 设置底部顶部元素</p></li>
                                <li><p><code>Node 	getBottom()</code> -- 获取底部节点元素</p></li>
                                <li><p><code>ObjectProperty&lt;Node> 	bottomProperty()</code> -- 属性形式读写底部节点元素</p></li>

                                <li class="group"><p><code>void 	setLeft(Node value)</code> -- 设置左节点元素</p></li>
                                <li><p><code>Node 	getLeft()</code> -- 获取左节点元素</p></li>
                                <li><p><code>ObjectProperty&lt;Node> 	leftProperty()</code> -- 属性形式读写左节点元素</p></li>

                                <li class="group"><p><code>void 	setRight(Node value)</code> -- 设置右节点元素</p></li>
                                <li><p><code>Node 	getRight()</code> -- 获取右节点元素</p></li>
                                <li><p><code>ObjectProperty&lt;Node> 	rightProperty()</code> -- 属性形式读写右节点元素</p></li>

                                <li class="group"><p><code>Orientation 	getContentBias()</code> -- 返回节点对布局目的的调整大小偏差的方向</p></li>

                                <li class="group"><p><code>protected double 	computeMinHeight(double width)</code> -- 计算该区域的最小高度和</p></li>
                                <li><p><code>protected double 	computeMinWidth(double height)</code> -- 计算该区域的最小宽度</p></li>
                                <li><p><code>protected double 	computePrefHeight(double width)</code> -- 计算该区域的首选高度</p></li>
                                <li><p><code>protected double 	computePrefWidth(double height)</code> -- 计算该区域的首选宽度</p></li>

                                <li class="group"><p><code>protected void 	layoutChildren()</code> -- 在布局传递过程中调用，以布局父级中的子代。默认情况下，它只将托管的、可调整大小的内容设置为它们的首选大小，不执行任何节点定位</p></li>
                            </ol>
                        </div>

                        <a id="javafx-scene-layout-FlowPane" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class FlowPane extends Pane {
    public FlowPane() {}
    public FlowPane(double hgap, double vgap) {}
    public FlowPane(double hgap, double vgap, Node... children) {}
    public FlowPane(Node... children) {}
    public FlowPane(Orientation orientation) {}
    public FlowPane(Orientation orientation, double hgap, double vgap) {}
    public FlowPane(Orientation orientation, double hgap, double vgap, Node... children) {}
    public FlowPane(Orientation orientation, Node... children) {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/layout/FlowPane.html" target="_blank">FlowPane</a> 为流式布局，默认以横向流布局，并且到达面板的宽度会自动换行。</p>
                            <p>可以使用 <code>Orientation.VERTICAL</code> 将流修改为纵向流，到高度不够是自动布局到下一列。</p>
                            <p>FlowPane 对每个托管子节点进行布局，而不管子节点的可见属性值如何；对于所有布局计算，都将忽略非托管子节点。</p>
                            <p>FlowPane 可以使用 CSS 来设置背景和边界。</p>
                            <p>此类的继承结构查看： <a href="#javafx-scene-Node">图形基类: Node</a></p>
                            <ol>
                                <li><p><code>static void 	clearConstraints(Node child)</code> -- 清除指定节点的约束</p></li>

                                <li class="group"><p><code>static List&lt;CssMetaData&lt;? extends Styleable,?>> 	getClassCssMetaData()</code> -- 获取与此类关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>static Insets 	getMargin(Node child)</code> -- 获取指定节点的边距</p></li>
                                <li><p><code>static void 	setMargin(Node child, Insets value)</code> -- 设置指定节点的边距</p></li>

                                <li class="group"><p><code>void 	setOrientation(Orientation value)</code> -- 设置横/纵向排列</p></li>
                                <li><p><code>Orientation 	getOrientation()</code> -- 获取排列方向</p></li>
                                <li><p><code>ObjectProperty&lt;Orientation> 	orientationProperty()</code> -- 属性形式读写排列方向</p></li>

                                <li class="group"><p><code>void 	setAlignment(Pos value)</code> -- 设置对齐方式</p></li>
                                <li><p><code>Pos 	getAlignment()</code> -- 获取对齐方式</p></li>
                                <li><p><code>ObjectProperty&lt;Pos> 	alignmentProperty()</code> -- 属性形式读写对齐方式</p></li>

                                <li class="group"><p><code>void 	setRowValignment(VPos value)</code> -- 设置行对齐方式(同一行的元素高度不一时其对齐方式)</p></li>
                                <li><p><code>VPos 	getRowValignment()</code> -- 获取行对齐方式</p></li>
                                <li><p><code>ObjectProperty&lt;VPos> 	rowValignmentProperty()</code> -- 属性形式读写行对齐方式</p></li>

                                <li class="group"><p><code>void 	setColumnHalignment(HPos value)</code> -- 设置列对齐方式(同一列的元素宽度不一时其对齐方式)</p></li>
                                <li><p><code>HPos 	getColumnHalignment()</code> -- 获取列对齐方式</p></li>
                                <li><p><code>ObjectProperty&lt;HPos> 	columnHalignmentProperty()</code> -- 属性形式读写列对齐方式</p></li>

                                <li class="group"><p><code>void 	setPrefWrapLength(double value)</code> -- 内容应该在水平流窗格中的优选宽度或内容应该在垂直流窗格中的优选高度</p></li>
                                <li><p><code>double 	getPrefWrapLength()</code> -- 获取其首选宽度/高度</p></li>
                                <li><p><code>DoubleProperty 	prefWrapLengthProperty()</code> -- 属性形式读写其首选宽度/高度</p></li>

                                <li class="group"><p><code>void 	setHgap(double value)</code> -- 设置子元素间横向间距</p></li>
                                <li><p><code>double 	getHgap()</code> -- 获取子元素间横向间距</p></li>
                                <li><p><code>DoubleProperty 	hgapProperty()</code> -- 属性形式读写子元素间横向间距</p></li>

                                <li class="group"><p><code>void 	setVgap(double value)</code> -- 设置子元素间纵向间距</p></li>
                                <li><p><code>double 	getVgap()</code> -- 获取子元素间纵向间距</p></li>
                                <li><p><code>DoubleProperty 	vgapProperty()</code> -- 属性形式读写子元素间纵向间距</p></li>

                                <li class="group"><p><code>void 	requestLayout()</code> -- 请求在呈现下一个场景之前执行的布局传递</p></li>
                                <li><p><code>Orientation 	getContentBias()</code> -- 返回节点对布局目的的调整大小偏差的方向</p></li>
                                <li><p><code>List&lt;CssMetaData&lt;? extends Styleable,?>> 	getCssMetaData()</code> -- 获取与此实例关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>protected double 	computeMinHeight(double width)</code> -- 计算该区域的最小高度和</p></li>
                                <li><p><code>protected double 	computeMinWidth(double height)</code> -- 计算该区域的最小宽度</p></li>
                                <li><p><code>protected double 	computePrefHeight(double width)</code> -- 计算该区域的首选高度</p></li>
                                <li><p><code>protected double 	computePrefWidth(double height)</code> -- 计算该区域的首选宽度</p></li>

                                <li class="group"><p><code>protected void 	layoutChildren()</code> -- 在布局传递过程中调用，以布局父级中的子代。默认情况下，它只将托管的、可调整大小的内容设置为它们的首选大小，不执行任何节点定位</p></li>
                            </ol>
                        </div>

                        <a id="javafx-scene-layout-GridPane" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class GridPane extends Pane {
    public static final int REMAINING = Integer.MAX_VALUE;
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/layout/GridPane.html" target="_blank">GridPane</a> 布局面板使你可以创建灵活的基于行和列的网格来放置节点。</p>
                            <p>节点可以被放置到任意一个单元格中，也可以根据需要设置一个节点跨越多个单元格(行或者列)。</p>
                            <p>GridPane 对于创建表单或者其他以行和列来组织的界面来说是非常有用的。</p>
                            <p>设置垂直(Vertical)和水平(Horizontal)对齐属性(Alignment)能够控制单元格中的各个控件的对齐方式。</p>
                            <p><b>GridPane 的行和列坐标都是从 0 开始。</b></p>
                            <p>GRIDANE 可以使用 CSS 来设置背景和边框。</p>
                            <p>此类的继承结构查看： <a href="#javafx-scene-Node">图形基类: Node</a></p>
                            <ol>
                                <li><p><code>static List&lt;CssMetaData&lt;? extends Styleable,?>> 	getClassCssMetaData()</code> -- 获取与此类关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>static void 	clearConstraints(Node child)</code> -- 清除指定节点的约束</p></li>

                                <li class="group"><p><code>static void 	setColumnIndex(Node child, Integer value)</code> -- 设置指定节点所在的列(未添加到节点)</p></li>
                                <li><p><code>static Integer 	getColumnIndex(Node child)</code> -- 获取指定节点所在的行</p></li>
                                <li><p><code>static void 	setRowIndex(Node child, Integer value)</code> -- 设置指定节点所在的行(未添加到节点)</p></li>
                                <li><p><code>static Integer 	getRowIndex(Node child)</code> -- 获取指定节点所在的行</p></li>

                                <li class="group"><p><code>static void 	setColumnSpan(Node child, Integer value)</code> -- 设置指定节点占用的列</p></li>
                                <li><p><code>static Integer 	getColumnSpan(Node child)</code> -- 获取指定节点占用的列</p></li>
                                <li><p><code>static void 	setRowSpan(Node child, Integer value)</code> -- 设置指定节点占用的行</p></li>
                                <li><p><code>static Integer 	getRowSpan(Node child)</code> -- 获取指定节点占用的行</p></li>

                                <li class="group"><p><code>static void 	setHgrow(Node child, Priority value)</code> -- 设置子节点的横向增长优先级(不清楚怎么用)</p></li>
                                <li><p><code>static Priority 	getHgrow(Node child)</code> -- 获取子节点的横向增长优先级(不清楚怎么用)</p></li>
                                <li><p><code>static void 	setVgrow(Node child, Priority value)</code> -- 设置子节点的纵向增长优先级(不清楚怎么用)</p></li>
                                <li><p><code>static Priority 	getVgrow(Node child)</code> -- 获取子节点的纵向增长优先级(不清楚怎么用)</p></li>

                                <li class="group"><p><code>static void 	setFillWidth(Node child, Boolean value)</code> -- 设置是否横向填充网格(针对某些首选大小为包含子节点的节点)</p></li>
                                <li><p><code>static Boolean 	isFillWidth(Node child)</code> -- 获取是否横向填充网格</p></li>
                                <li><p><code>static void 	setFillHeight(Node n, Boolean value)</code> -- 设置是否纵向填充网格(针对某些首选大小为包含子节点的节点)</p></li>
                                <li><p><code>static Boolean 	isFillHeight(Node child)</code> -- 获取是否纵向填充网格</p>
                                    <pre class="brush: java;">
Pane pane = new Pane();
pane.getChildren().add(new Button("N-2, 0"));
pane.getStyleClass().add("cl-05");
GridPane.setFillWidth(pane, false); // 宽度为包含组件大小
GridPane.setFillHeight(btn, true);  // 高度填充网格
root.add(pane, 2, 0, 2, 2);
</pre>
</li>

                                <li class="group"><p><code>static void 	setMargin(Node child, Insets value)</code> -- 设置指定节点距离网格边界的距离</p></li>
                                <li><p><code>static Insets 	getMargin(Node child)</code> -- 获取指定节点距离网格边界的距离</p></li>

                                <li class="group"><p><code>static void 	setHalignment(Node child, HPos v)</code> -- 设置指定节点横向对齐方式，默认左对齐(当节点宽度小于网格宽度)</p></li>
                                <li><p><code>static HPos 	getHalignment(Node child)</code> -- 获取横向对齐方式</p></li>
                                <li><p><code>static void 	setValignment(Node n, VPos v)</code> -- 设置指定节点纵向对齐方式，默认居中对齐(当节点高度小于网格高度)</p></li>
                                <li><p><code>static VPos 	getValignment(Node child)</code> -- 获取纵向对齐方式</p></li>

                                <li class="group"><p><code>static void 	setConstraints(Node child, int columnIndex, int rowIndex)</code> -- 设置指定节点的列和行</p></li>
                                <li><p><code>static void 	setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan)</code> -- 设置指定节点的列和行，和其占用的列和行数量</p></li>
                                <li><p><code>static void 	setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan, HPos halignment, VPos valignment)</code> -- 设置指定节点的列和行，其占用的列和行数量，并指定横纵向对齐方式</p></li>
                                <li><p><code>static void 	setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan, HPos halignment, VPos valignment, Priority hgrow, Priority vgrow)</code> -- 设置指定节点的列和行，其占用的列和行数量，并指定横纵向对齐方式，并指定优先级</p></li>
                                <li><p><code>static void 	setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan, HPos halignment, VPos valignment, Priority hgrow, Priority vgrow, Insets margin)</code> -- 设置指定节点的列和行，其占用的列和行数量，并指定横纵向对齐方式，并指定优先级，并指定边距</p></li>

                                <li class="group"><p><code>void 	setAlignment(Pos value)</code> -- 设置对齐方式</p></li>
                                <li><p><code>Pos 	getAlignment()</code> -- 获取对齐方式</p></li>
                                <li><p><code>ObjectProperty&lg;Pos> 	alignmentProperty()</code> -- 属性形式读写对齐方式</p></li>

                                <li class="group"><p><code>void 	setVgap(double value)</code> -- 设置纵向间距</p></li>
                                <li><p><code>double 	getVgap()</code> -- 获取纵向间距</p></li>
                                <li><p><code>DoubleProperty 	vgapProperty()</code> -- 属性形式读写纵向间距</p></li>

                                <li class="group"><p><code>void 	setHgap(double value)</code> -- 设置横向间距</p></li>
                                <li><p><code>double 	getHgap()</code> -- 获取横向间距</p></li>
                                <li><p><code>DoubleProperty 	hgapProperty()</code> -- 属性形式读写横向间距</p></li>

                                <li class="group"><p><code>void 	setGridLinesVisible(boolean value)</code> -- 设置网格线是否可见</p></li>
                                <li><p><code>boolean 	isGridLinesVisible()</code> -- 获取网格线是否可见</p></li>
                                <li><p><code>BooleanProperty 	gridLinesVisibleProperty()</code> -- 属性形式读写网格线是否可见</p></li>

                                <li class="group"><p><code>void 	add(Node child, int columnIndex, int rowIndex)</code> -- 在指定列和行添加一个节点</p></li>
                                <li><p><code>void 	addRow(int row, Node... children)</code> -- 在指定行中顺序放置指定节点，如果此行已经存在，那么顺序添加到最后</p></li>
                                <li><p><code>void 	addColumn(int column, Node... children)</code> -- 在指定列中顺序放置指定节点，如果列已存在，那么顺序添加到最后</p></li>
                                <li><p><code>void 	add(Node child, int columnIndex, int rowIndex, int colspan, int rowspan)</code> -- 在指定列和行添加一个节点, 并指定其占用的列和行数量(节点可以占用多行和多列，后边添加的可能覆盖前面添加的元素)</p></li>

                                <li class="group"><p><code>ObservableList&lt;ColumnConstraints> 	getColumnConstraints()</code> -- 获取列约束列表</p></li>
                                <li><p><code>ObservableList&lt;RowConstraints> 	getRowConstraints()</code> -- 获取行约束列表</p></li>

                                <li class="group"><p><code>void 	requestLayout()</code> -- 请求在呈现下一个场景之前执行的布局传递</p></li>
                                <li><p><code>Orientation 	getContentBias()</code> -- 返回节点对布局目的的调整大小偏差的方向</p></li>
                                <li><p><code>List&lt;CssMetaData&lt;? extends Styleable,?>> 	getCssMetaData()</code> -- 获取与此实例关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>protected double 	computeMinHeight(double width)</code> -- 计算该区域的最小高度和</p></li>
                                <li><p><code>protected double 	computeMinWidth(double height)</code> -- 计算该区域的最小宽度</p></li>
                                <li><p><code>protected double 	computePrefHeight(double width)</code> -- 计算该区域的首选高度</p></li>
                                <li><p><code>protected double 	computePrefWidth(double height)</code> -- 计算该区域的首选宽度</p></li>

                                <li class="group"><p><code>protected void 	layoutChildren()</code> -- 在布局传递过程中调用，以布局父级中的子代。默认情况下，它只将托管的、可调整大小的内容设置为它们的首选大小，不执行任何节点定位</p></li>
                            </ol>
                        </div>

                        <a id="javafx-scene-layout-StackPane" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class StackPane extends Pane {
    public StackPane() {}
    public StackPane(Node... children) {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/layout/StackPane.html" target="_blank">StackPane</a> 布局面板将所有的节点放在一个堆栈中进行布局管理，后添加进去的节点会显示在前一个添加进去的节点之上。</p>
                            <p>这个布局为将文本(Text)覆盖到一个图形(Shape)或者图像(Image)之上，或者将普通图形相互覆盖来创建更复杂的图形，提供了一个简单的方案。</p>
                            <p>通过设置对齐属性(Alignment)来控制子节点在 StackPane 中的位置。这个属性会影响所有的子节点，而设置外边距属性(Margin)可以控制在 StackPane 中的单个子节点位置。</p>
                            <p>StackPane 在 Pane 的基础上加了设置对齐方式的方法： <code>setAlignment(Pos)</code>， 默认全部堆叠在指定的位置(由对齐方式指定)，但是可以静态方法：<code>StackPane.setAlignment(Node, Pos)</code> 来使指定的节点使用不同的对齐方式。</p>
                            <p>此类的继承结构查看： <a href="#javafx-scene-Node">图形基类: Node</a></p>
                            <ol>
                                <li><p><code>static void 	clearConstraints(Node child)</code> -- 清除指定节点的约束</p></li>

                                <li class="group"><p><code>static List&lt;CssMetaData&lt;? extends Styleable,?>> 	getClassCssMetaData()</code> -- 获取与此类关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>static Insets 	getMargin(Node child)</code> -- 获取指定节点的边距</p></li>
                                <li><p><code>static void 	setMargin(Node child, Insets value)</code> -- 设置指定节点的边距</p></li>

                                <li class="group"><p><code>static void 	setAlignment(Node child, Pos value)</code> -- 设置指定节点对齐方式</p></li>
                                <li><p><code>static Pos 	getAlignment(Node child)</code> -- 获取指定节点对齐方式</p></li>

                                <li class="group"><p><code>void 	setAlignment(Pos value)</code> -- 设置对齐方式</p></li>
                                <li><p><code>Pos 	getAlignment()</code> -- 获取对齐方式</p></li>
                                <li><p><code>ObjectProperty&lt;Pos> 	alignmentProperty()</code> -- 属性形式读写对齐方式</p></li>

                                <li class="group"><p><code>void 	requestLayout()</code> -- 请求在呈现下一个场景之前执行的布局传递</p></li>
                                <li><p><code>Orientation 	getContentBias()</code> -- 返回节点对布局目的的调整大小偏差的方向</p></li>
                                <li><p><code>List&lt;CssMetaData&lt;? extends Styleable,?>> 	getCssMetaData()</code> -- 获取与此实例关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>protected double 	computeMinHeight(double width)</code> -- 计算该区域的最小高度和</p></li>
                                <li><p><code>protected double 	computeMinWidth(double height)</code> -- 计算该区域的最小宽度</p></li>
                                <li><p><code>protected double 	computePrefHeight(double width)</code> -- 计算该区域的首选高度</p></li>
                                <li><p><code>protected double 	computePrefWidth(double height)</code> -- 计算该区域的首选宽度</p></li>

                                <li class="group"><p><code>protected void 	layoutChildren()</code> -- 在布局传递过程中调用，以布局父级中的子代。默认情况下，它只将托管的、可调整大小的内容设置为它们的首选大小，不执行任何节点定位。</p></li>
                            </ol>
                        </div>

                        <a id="javafx-scene-layout-TilePane" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class TilePane extends Pane {
    public TilePane() {}
    public TilePane(double hgap, double vgap) {}
    public TilePane(double hgap, double vgap, Node... children) {}
    public TilePane(Node... children) {}
    public TilePane(Orientation orientation) {}
    public TilePane(Orientation orientation, double hgap, double vgap) {}
    public TilePane(Orientation orientation, double hgap, double vgap, Node... children) {}
    public TilePane(Orientation orientation, Node... children) {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/layout/TilePane.html" target="_blank">TilePane</a> 布局面板和 FlowPane 很相似。</p>
                            <p>TilePane 将其包含的节点都放在一个网格中，其中<b>每格或者每块磁贴的大小都是一样的</b>。</p>
                            <p>节点可以按水平方向(行)进行排列，或者以垂直方向(列)进行排列。水平排列时会在 TilePane 的宽度边界处对 Tile 进行自动换行，垂直排列时会在 TilePane 的高度边界处对 Tile 进行自动换列。</p>
                            <p>使用 prefColumns 和 prefRows 属性可以设定 TilePane 的首选大小。</p>
                            <p>设置间隙属性(Gap)用来管理行和列之间间距。设置内边距属性(Padding)用来设管理节点元素和 TilePane 边缘之间的距离。</p>
                            <p>此类的继承结构查看： <a href="#javafx-scene-Node">图形基类: Node</a></p>
                            <ol>
                                <li><p><code>static List&lt;CssMetaData&lt;? extends Styleable,?>> 	getClassCssMetaData()</code> -- 获取与此类关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>static void 	clearConstraints(Node child)</code> -- 清除指定节点的约束</p></li>

                                <li><p><code>static void 	setAlignment(Node node, Pos value)</code> -- 设置指定节点对齐方式</p></li>
                                <li><p><code>static Pos 	getAlignment(Node node)</code> -- 获取指定节点对齐方式</p></li>

                                <li class="group"><p><code>static void 	setMargin(Node child, Insets value)</code> -- 设置指定节点距离网格边界的距离</p></li>
                                <li><p><code>static Insets 	getMargin(Node child)</code> -- 获取指定节点距离网格边界的距离</p></li>

                                <li class="group"><p><code>void 	setAlignment(Pos value)</code> -- 设置对齐方式</p></li>
                                <li><p><code>Pos 	getAlignment()</code> -- 获取对齐方式</p></li>
                                <li><p><code>ObjectProperty&lt;Pos> 	alignmentProperty()</code> -- 属性形式读写对齐方式</p></li>

                                <li class="group"><p><code>void 	setHgap(double value)</code> -- 设置纵向间距</p></li>
                                <li><p><code>double 	getHgap()</code> -- 获取纵向间距</p></li>
                                <li><p><code>DoubleProperty 	hgapProperty()</code> -- 属性形式读写纵向间距</p></li>

                                <li class="group"><p><code>double 	getVgap()</code> -- 设置横向间距</p></li>
                                <li><p><code>void 	setVgap(double value)</code> -- 获取横向间距</p></li>
                                <li><p><code>DoubleProperty 	vgapProperty()</code> -- 属性形式读写横向间距</p></li>

                                <li class="group"><p><code>void 	setOrientation(Orientation value)</code> -- 设置横/纵向排列</p></li>
                                <li><p><code>Orientation 	getOrientation()</code> -- 获取排列方向</p></li>
                                <li><p><code>ObjectProperty&lt;Orientation> 	orientationProperty()</code> -- 属性形式读写排列方向</p></li>

                                <li class="group"><p><code>void 	setPrefColumns(int value)</code> -- 设置首选列数</p></li>
                                <li><p><code>int 	getPrefColumns()</code> -- 获取首选列数</p></li>
                                <li><p><code>IntegerProperty 	prefColumnsProperty()</code> -- 属性形式读写首选列数</p></li>

                                <li class="group"><p><code>int 	getPrefRows()</code> -- 设置首选行数</p></li>
                                <li><p><code>void 	setPrefRows(int value)</code> -- 获取首选行数</p></li>
                                <li><p><code>IntegerProperty 	prefRowsProperty()</code> -- 属性形式读写首选行数</p></li>

                                <li class="group"><p><code>void 	setPrefTileHeight(double value)</code> -- 设置首选磁贴高度</p></li>
                                <li><p><code>double 	getPrefTileHeight()</code> -- 获取首选磁贴高度</p></li>
                                <li><p><code>DoubleProperty 	prefTileHeightProperty()</code> -- 属性形式读写首选磁贴高度</p></li>

                                <li class="group"><p><code>void 	setPrefTileWidth(double value)</code> -- 设置首选磁贴宽度</p></li>
                                <li><p><code>double 	getPrefTileWidth()</code> -- 获取首选磁贴宽度</p></li>
                                <li><p><code>DoubleProperty 	prefTileWidthProperty()</code> -- 属性形式读写首选磁贴宽度</p></li>

                                <li class="group"><p><code>void 	setTileAlignment(Pos value)</code> -- 设置磁贴对齐方式</p></li>
                                <li><p><code>Pos 	getTileAlignment()</code> -- 获取磁贴对齐方式</p></li>
                                <li><p><code>ObjectProperty&lt;Pos> 	tileAlignmentProperty()</code> -- 属性形式读写磁贴对齐方式</p></li>

                                <li class="group"><p><code>double 	getTileHeight()</code> -- 获取磁贴高度</p></li>
                                <li><p><code>ReadOnlyDoubleProperty 	tileHeightProperty()</code> -- 属性形式读磁贴高度</p></li>

                                <li class="group"><p><code>double 	getTileWidth()</code> -- 获取磁贴宽度</p></li>
                                <li><p><code>ReadOnlyDoubleProperty 	tileWidthProperty()</code> -- 性形式读磁贴宽度</p></li>

                                <li class="group"><p><code>void 	requestLayout()</code> -- 请求在呈现下一个场景之前执行的布局传递</p></li>
                                <li><p><code>Orientation 	getContentBias()</code> -- 返回节点对布局目的的调整大小偏差的方向</p></li>
                                <li><p><code>List&lt;CssMetaData&lt;? extends Styleable,?>> 	getCssMetaData()</code> -- 获取与此实例关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>protected double 	computeMinHeight(double width)</code> -- 计算该区域的最小高度和</p></li>
                                <li><p><code>protected double 	computeMinWidth(double height)</code> -- 计算该区域的最小宽度</p></li>
                                <li><p><code>protected double 	computePrefHeight(double width)</code> -- 计算该区域的首选高度</p></li>
                                <li><p><code>protected double 	computePrefWidth(double height)</code> -- 计算该区域的首选宽度</p></li>

                                <li class="group"><p><code>protected void 	layoutChildren()</code> -- 在布局传递过程中调用，以布局父级中的子代。默认情况下，它只将托管的、可调整大小的内容设置为它们的首选大小，不执行任何节点定位</p></li>
                            </ol>
                        </div>

                        <a id="javafx-scene-layout-Hbox" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class HBox extends Pane {
    public HBox() {}
    public HBox(double spacing) {}
    public HBox(Node... children) {}
    public HBox(double spacing, Node... children) {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/layout/HBox.html" target="_blank">HBox</a> 布局面板为将多个节点排列在一行中提供了一个简单的方法。</p>
                            <p>设置内边距(Padding)属性可以用于管理节点到 HBox 边缘的距离。设置间距(Spacing)属性可以用于管理节点之间的距离。设置外边距(Margin)属性可以为单个控件周围增加额外的空间。</p>
                            <p>此类的继承结构查看： <a href="#javafx-scene-Node">图形基类: Node</a></p>
                            <ol>
                                <li><p><code>static List&lt;CssMetaData&lt;? extends Styleable,?>> 	getClassCssMetaData()</code> -- 获取与此类关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>static void 	clearConstraints(Node child)</code> -- 清除指定节点的约束</p></li>

                                <li class="group"><p><code>static void 	setMargin(Node child, Insets value)</code> -- 设置指定节点距离网格边界的距离</p></li>
                                <li><p><code>static Insets 	getMargin(Node child)</code> -- 获取指定节点距离网格边界的距离</p></li>

                                <li class="group"><p><code>static void 	setHgrow(Node child, Priority value)</code> -- 设置子节点的横向增长优先级(不清楚怎么用)</p></li>
                                <li><p><code>static Priority 	getHgrow(Node child)</code> -- 获取子节点的横向增长优先级(不清楚怎么用)</p></li>

                                <li class="group"><p><code>void 	setAlignment(Pos value)</code> -- 设置对齐方式</p></li>
                                <li><p><code>Pos 	getAlignment()</code> -- 获取对齐方式</p></li>
                                <li><p><code>ObjectProperty&lt;Pos> 	alignmentProperty()</code> -- 属性形式读写对齐方式</p></li>

                                <li class="group"><p><code>void 	setSpacing(double value)</code> -- 设置间距</p></li>
                                <li><p><code>double 	getSpacing()</code> -- 获取间距</p></li>
                                <li><p><code>DoubleProperty 	spacingProperty()</code> -- 属性形式读写间距</p></li>

                                <li class="group"><p><code>void 	setFillHeight(boolean value)</code> -- 设置是否纵向填充</p></li>
                                <li><p><code>boolean 	isFillHeight()</code> -- 获取是否纵向填充</p></li>
                                <li><p><code>BooleanProperty 	fillHeightProperty()</code> -- 属性形式读写是否纵向填充</p></li>

                                <li class="group"><p><code>double 	getBaselineOffset()</code> -- 根据第一个托管子节点计算基线偏移量</p></li>

                                <li class="group"><p><code>void 	requestLayout()</code> -- 请求在呈现下一个场景之前执行的布局传递</p></li>
                                <li><p><code>Orientation 	getContentBias()</code> -- 返回节点对布局目的的调整大小偏差的方向</p></li>
                                <li><p><code>List&lt;CssMetaData&lt;? extends Styleable,?>> 	getCssMetaData()</code> -- 获取与此实例关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>protected double 	computeMinHeight(double width)</code> -- 计算该区域的最小高度和</p></li>
                                <li><p><code>protected double 	computeMinWidth(double height)</code> -- 计算该区域的最小宽度</p></li>
                                <li><p><code>protected double 	computePrefHeight(double width)</code> -- 计算该区域的首选高度</p></li>
                                <li><p><code>protected double 	computePrefWidth(double height)</code> -- 计算该区域的首选宽度</p></li>

                                <li class="group"><p><code>protected void 	layoutChildren()</code> -- 在布局传递过程中调用，以布局父级中的子代。默认情况下，它只将托管的、可调整大小的内容设置为它们的首选大小，不执行任何节点定位</p></li>

                            </ol>
                        </div>

                        <a id="javafx-scene-layout-VBox" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class VBox extends Pane {
    public VBox() {}
    public VBox(double spacing) {}
    public VBox(Node... children) {}
    public VBox(double spacing, Node... children) {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/layout/VBox.html" target="_blank">VBox</a> 布局面板和 HBox 很类似，只是其包含的节点是排成一列。</p>
                            <p>设置内边距(Padding)属性可以管理节点到VBox边缘的距离。设置间距(Spacing)属性可以管理节点之间的距离。设置外边距(Margin)属性可以为单个控件周围增加额外的空间。</p>
                            <p>此类的继承结构查看： <a href="#javafx-scene-Node">图形基类: Node</a></p>
                            <ol>
                                <li><p><code>static List&lt;CssMetaData&lt;? extends Styleable,?>> 	getClassCssMetaData()</code> -- 获取与此类关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>static void 	clearConstraints(Node child)</code> -- 清除指定节点的约束</p></li>

                                <li class="group"><p><code>static void 	setMargin(Node child, Insets value)</code> -- 设置指定节点距离网格边界的距离</p></li>
                                <li><p><code>static Insets 	getMargin(Node child)</code> -- 获取指定节点距离网格边界的距离</p></li>

                                <li class="group"><p><code>static void 	setVgrow(Node child, Priority value)</code> -- 设置子节点的纵向增长优先级(不清楚怎么用)</p></li>
                                <li><p><code>static Priority 	getVgrow(Node child)</code> -- 获取子节点的纵向增长优先级(不清楚怎么用)</p></li>

                                <li class="group"><p><code>void 	setAlignment(Pos value)</code> -- 设置对齐方式</p></li>
                                <li><p><code>Pos 	getAlignment()</code> -- 获取对齐方式</p></li>
                                <li><p><code>ObjectProperty&lt;Pos> 	alignmentProperty()</code> -- 属性形式读写对齐方式</p></li>

                                <li class="group"><p><code>void 	setSpacing(double value)</code> -- 设置间距</p></li>
                                <li><p><code>double 	getSpacing()</code> -- 获取间距</p></li>
                                <li><p><code>DoubleProperty 	spacingProperty()</code> -- 属性形式读写间距</p></li>

                                <li class="group"><p><code>void 	setFillWidth(boolean value)</code> -- 设置是否横向填充</p></li>
                                <li><p><code>boolean 	isFillWidth()</code> -- 获取是否横向填充</p></li>
                                <li><p><code>BooleanProperty 	fillWidthProperty()</code> -- 属性形式读写是否横向填充</p></li>

                                <li class="group"><p><code>void 	requestLayout()</code> -- 请求在呈现下一个场景之前执行的布局传递</p></li>
                                <li><p><code>Orientation 	getContentBias()</code> -- 返回节点对布局目的的调整大小偏差的方向</p></li>
                                <li><p><code>List&lt;CssMetaData&lt;? extends Styleable,?>> 	getCssMetaData()</code> -- 获取与此实例关联的 CSS 元数据</p></li>

                                <li class="group"><p><code>protected double 	computeMinHeight(double width)</code> -- 计算该区域的最小高度和</p></li>
                                <li><p><code>protected double 	computeMinWidth(double height)</code> -- 计算该区域的最小宽度</p></li>
                                <li><p><code>protected double 	computePrefHeight(double width)</code> -- 计算该区域的首选高度</p></li>
                                <li><p><code>protected double 	computePrefWidth(double height)</code> -- 计算该区域的首选宽度</p></li>

                                <li class="group"><p><code>protected void 	layoutChildren()</code> -- 在布局传递过程中调用，以布局父级中的子代。默认情况下，它只将托管的、可调整大小的内容设置为它们的首选大小，不执行任何节点定位</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javafx-scene-control-Control"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">控件类: Control 及相关类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    javafx.scene.Node
        javafx.scene.Parent
            javafx.scene.layout.Region
                javafx.scene.control.Control

public abstract class Control extends Region implements Skinnable {

}

public interface Skinnable {
    public ObjectProperty&lt;Skin&lt;?>> skinProperty();
    public void setSkin(Skin&lt;?> value);
    public Skin&lt;?> getSkin();
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/" target="_blank"></a></p>
                            <p>此类的继承结构查看： <a href="#javafx-scene-Node">图形基类: Node</a></p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/" target="_blank"></a></p>
                            <p>此类的继承结构查看： <a href="#javafx-scene-Node">图形基类: Node</a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javafx-fxml"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">使用 FXML 进行布局</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <p><a href="docs/docs-java/api-javafx8/javafx/fxml/doc-files/introduction_to_fxml.html" target="_blank">FXML 介绍</a></p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    javafx.fxml.FXMLLoader

public class FXMLLoader {
    public static final String DEFAULT_CHARSET_NAME = "UTF-8";
    public static final String LANGUAGE_PROCESSING_INSTRUCTION = "language";
    public static final String IMPORT_PROCESSING_INSTRUCTION = "import";
    public static final String FX_NAMESPACE_PREFIX = "fx";
    public static final String FX_CONTROLLER_ATTRIBUTE = "controller";
    public static final String FX_ID_ATTRIBUTE = "id";
    public static final String FX_VALUE_ATTRIBUTE = "value";
    public static final String FX_CONSTANT_ATTRIBUTE = "constant";
    public static final String FX_FACTORY_ATTRIBUTE = "factory";
    public static final String INCLUDE_TAG = "include";
    public static final String INCLUDE_SOURCE_ATTRIBUTE = "source";
    public static final String INCLUDE_RESOURCES_ATTRIBUTE = "resources";
    public static final String INCLUDE_CHARSET_ATTRIBUTE = "charset";
    public static final String SCRIPT_TAG = "script";
    public static final String SCRIPT_SOURCE_ATTRIBUTE = "source";
    public static final String SCRIPT_CHARSET_ATTRIBUTE = "charset";
    public static final String DEFINE_TAG = "define";
    public static final String REFERENCE_TAG = "reference";
    public static final String REFERENCE_SOURCE_ATTRIBUTE = "source";
    public static final String ROOT_TAG = "root";
    public static final String ROOT_TYPE_ATTRIBUTE = "type";
    public static final String COPY_TAG = "copy";
    public static final String COPY_SOURCE_ATTRIBUTE = "source";
    public static final String EVENT_HANDLER_PREFIX = "on";
    public static final String EVENT_KEY = "event";
    public static final String CHANGE_EVENT_HANDLER_SUFFIX = "Change";
    public static final String NULL_KEYWORD = "null";
    public static final String ESCAPE_PREFIX = "\\";
    public static final String RELATIVE_PATH_PREFIX = "@";
    public static final String RESOURCE_KEY_PREFIX = "%";
    public static final String EXPRESSION_PREFIX = "$";
    public static final String BINDING_EXPRESSION_PREFIX = "${";
    public static final String BINDING_EXPRESSION_SUFFIX = "}";
    public static final String BI_DIRECTIONAL_BINDING_PREFIX = "#{";
    public static final String BI_DIRECTIONAL_BINDING_SUFFIX = "}";
    public static final String ARRAY_COMPONENT_DELIMITER = ",";
    public static final String LOCATION_KEY = "location";
    public static final String RESOURCES_KEY = "resources";
    public static final String CONTROLLER_METHOD_PREFIX = "#";
    public static final String CONTROLLER_KEYWORD = "controller";
    public static final String CONTROLLER_SUFFIX = "Controller";
    public static final String INITIALIZE_METHOD_NAME = "initialize";
    public static final String JAVAFX_VERSION;
    public static final String FX_NAMESPACE_VERSION = "1";

    public FXMLLoader() {}
    public FXMLLoader(Charset charset) {}
    public FXMLLoader(URL location) {}
    public FXMLLoader(URL location, ResourceBundle resources) {}
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory) {}
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?>, Object> controllerFactory) {}
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?>, Object> controllerFactory, Charset charset) {}
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?>, Object> controllerFactory, Charset charset,
        LinkedList&lt;FXMLLoader> loaders) {}
}
</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/fxml/FXMLLoader.html" target="_blank">FXMLLoader</a> 用于加载和解析 <code>.fxml</code> 的布局文件。</p>
                            <pre class="brush: java;">
@Override
public void start(Stage primaryStage) throws Exception {
    /** 指定 .fxml 文件路径 */
    URL url = getClass().getResource("/layout/login.fxml");

    FXMLLoader fxmlLoader = new FXMLLoader();
    fxmlLoader.setLocation(url);
    Pane root = fxmlLoader.load();

    Scene scene = new Scene(root);
    primaryStage.setScene(scene);

    /** 此类为自定义的控制器，在 .fxml 文件中需要指定此类，可以在此类实现事件处理 */
    LoginController controller = fxmlLoader.getController();
    controller.setPrimaryStage(primaryStage);

    primaryStage.show();
}
</pre>
                            <p>如果项目使用 Gradle 编译，那么 <code>.fxml</code> 文件可以放在 <code>resources</code> 目录下，上例的文件位于: <code>resources/layout/login.fxml</code></p>
                            <pre class="brush: xml;">
&lt;GridPane
    xmlns:fx="http://javafx.com/fxml/1"
    xmlns="http://javafx.com/javafx/8.0.131"
    ...
    fx:controller="io.jiwanger.javafx.controller.LoginController"> <!-- 此类由 FXMLLoader 类实例化 -->

    <!-- ... -->
    &lt;Button fx:id="button" onAction="#onClick" /> <!-- 上面指定的 controller 中要有 onClick 方法 -->
    <!-- ... -->
&lt;/GridPane>
</pre>
                            <ol>
                                <li><p><code>static &lt;T> T 	load(URL location)</code> -- </p></li>
                                <li><p><code>static &lt;T> T 	load(URL location, ResourceBundle resources)</code> -- </p></li>
                                <li><p><code>static &lt;T> T 	load(URL location, ResourceBundle resources, BuilderFactory builderFactory)</code> -- </p></li>
                                <li><p><code>static &lt;T> T 	load(URL location, ResourceBundle resources, BuilderFactory builderFactory, Callback&lt;Class<?>, Object> controllerFactory)</code> -- </p></li>
                                <li><p><code>static &lt;T> T 	load(URL location, ResourceBundle resources, BuilderFactory builderFactory, Callback&lt;Class<?>, Object> controllerFactory, Charset charset)</code> -- </p></li>

                                <li class="group"><p><code>static ClassLoader 	getDefaultClassLoader()</code> -- </p></li>
                                <li><p><code>static void 	setDefaultClassLoader(ClassLoader defaultClassLoader)</code> -- </p></li>

                                <li class="group"><p><code>URL 	getLocation()</code> -- </p></li>
                                <li><p><code>void 	setLocation(URL location)</code> -- </p></li>
                                <li><p><code>Object 	load()</code> -- </p></li>
                                <li><p><code>Object 	load(InputStream inputStream)</code> -- </p></li>

                                <li class="group"><p><code>&lt;T> T 	getController()</code> -- </p></li>
                                <li><p><code>void 	setController(Object controller)</code> -- </p></li>
                                <li><p><code>void 	setControllerFactory(Callback&lt;Class&lt;?>, Object> controllerFactory)</code> -- </p></li>
                                <li><p><code>Callback&lt;Class&lt;?>, Object> 	getControllerFactory()</code> -- </p></li>

                                <li class="group"><p><code>ClassLoader 	getClassLoader()</code> -- </p></li>
                                <li><p><code>void 	setClassLoader(ClassLoader classLoader)</code> -- </p></li>

                                <li class="group"><p><code>BuilderFactory 	getBuilderFactory()</code> -- </p></li>
                                <li><p><code>void 	setBuilderFactory(BuilderFactory builderFactory)</code> -- </p></li>
                                <li><p><code>Charset 	getCharset()</code> -- </p></li>
                                <li><p><code>void 	setCharset(Charset charset)</code> -- </p></li>
                                <li><p><code>ResourceBundle 	getResources()</code> -- </p></li>
                                <li><p><code>void 	setResources(ResourceBundle resources)</code> -- </p></li>
                                <li><p><code>&lt;T> T 	getRoot()</code> -- </p></li>
                                <li><p><code>void 	setRoot(Object root)</code> -- </p></li>

                                <li class="group"><p><code>ObservableMap&lt;String,Object> 	getNamespace()</code> -- </p></li>
                            </ol>
                        </div>

                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javafx-css"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">使用 CSS 控制样式</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/scene/doc-files/cssref.html" target="_blank">JavaFX CSS 参考指南</a></p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/" target="_blank"></a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javafx-"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">...</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/" target="_blank"></a></p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-java/api-javafx8/javafx/" target="_blank"></a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="JFoenix-intro"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">JFoenix -- JavaFX 美化</h3>
                    </div>
                    <div class="panel-body">
                        <pre class="brush: bash;">
## Gradle 引入 ##
compile 'com.jfoenix:jfoenix:8.0.7'   ## Java 8 对应版本
compile 'com.jfoenix:jfoenix:9.0.6'   ## Java 9 对应版本

## 可以下载其源码并运行它的 Demo 项目: ##
$ git clone https://github.com/jfoenixadmin/JFoenix.git
$ cd JFoenix
$ gradlew build
$ gradlew run
</pre>
                        <p><a href="https://github.com/jfoenixadmin/JFoenix" target="_blank">JFoenix</a> 是基于 JavaFX 的一个开源的 Material Design 设计的界面美化 Library 项目。</p>
                        <p>Java 8 可以使用 JFoenix 8.0.7 版本，其 API 文档: <a href="docs/docs-jfoenix-8.0.7/javadoc/index.html" target="_blank">JFoenix API</a></p>
                    </div>
                </div>
                <!-- item over -->

			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
		   class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
		   class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> TOP </a>
		<a target="_blank" href="./docs/docs-java/api-zh/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-6 </a>
		<a target="_blank" href="./docs/docs-java/api/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-8 </a>
        <a target="_blank" href="./docs/docs-java/api-javafx8/index.html"
           type="button" class="btn btn-default dropdown-toggle btn-primary"
           data-toggle="dropup"> JavaFX </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
    <script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
    <script src="../support/syntaxhighlighter/scripts/shBrushBash.js"></script>
    <script src="../support/syntaxhighlighter/scripts/shBrushXml.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
