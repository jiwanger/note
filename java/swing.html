<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--SWING</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>


<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle"
					data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					style="position: fixed; top: 70px; width: 260px;  overflow: auto; float: left;">
					<div class="panel-heading">
						<h3 class="panel-title">AWT & SWING</h3>
					</div>
					<div class="list-group">
						<a href="#javax-swing-intro" class="list-group-item">AWT & SWING</a>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#java-awt" aria-expanded="true"  style="border-top: 1px solid #DDDDDD;">
							<code>java.awt</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-awt" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#java-awt-Frame" class="list-group-item">Frame 及父类</a>
							<a href="#java-awt-LayoutManager" class="list-group-item">LayoutManager 及实现类(AWT)</a>
							<a href="#java-awt-MenuComponent" class="list-group-item">MenuComponent 及子类(AWT)</a>
                            <a href="#java-awt-Container" class="list-group-item">Container 的子类(AWT)</a>
                            <a href="#java-awt-Component" class="list-group-item">Component 的子类(AWT)</a>
                            <a href="#java-awt-" class="list-group-item">...</a>
						</div>

                        <a class="list-group-item active dropup" data-toggle="collapse"
                           data-parent="#accordion" href="#javax-swing" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
                            <code>javax.swing</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="javax-swing" class="panel-collapse collapse in"
                             role="tabpanel">
                            <a href="#javax-swing-JFrame" class="list-group-item">JFrame</a>
                            <a href="#javax-swing-LayoutManager" class="list-group-item">LayoutManager 及实现类(SWING)</a>
                            <a href="#javax-swing-MenuComponent" class="list-group-item">MenuComponent 子类(SWING)</a>
                            <a href="#javax-swing-Container" class="list-group-item">Container 子类(SWING)</a>
                            <a href="#javax-swing-Component" class="list-group-item">Component 子类(SWING)</a>
                            <a href="#" class="list-group-item">...</a>
                        </div>
						<a href="#java-class-loader" class="list-group-item">...</a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-3"></div>
			<div class="col-md-9" style="float: left;">
				<!-- item start -->
				<a class="offset" id="javax-swing-intro"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">AWT & SWING</h3>
					</div>
					<div class="panel-body">
                        <p><b>AWT</b> 是 Abstract Window ToolKit (抽象窗口工具包)的缩写，这个工具包提供了一套与本地图形界面进行交互的接口。AWT 中的图形函数与操作系统所提供的图形函数之间有着一一对应的关系，我们把它称为peers。 也就是说，当我们利用 AWT 来构件图形用户界面的时候，我们实际上是在利用操作系统所提供的图形库。由于不同操作系统的图形库所提供的功能是不一样的，在一个平台上存在的功能在另外一个平台上则可能不存在。为了实现 Java 语言所宣称的"一次编译，到处运行"的概念，AWT 不得不通过牺牲功能来实现其平台无关性，也就是说，AWT 所提供的图形功能是各种通用型操作系统所提供的图形功能的交集。由于 AWT 是依靠本地方法来实现其功能的，我们通常把 AWT 控件称为重量级控件。 </p>
                        <p><b>Swing</b> 是在 AWT 的基础上构建的一套新的图形界面系统，它提供了 AWT 所能够提供的所有功能，并且用纯粹的 Java 代码对 AWT 的功能进行了大幅度的扩充。例如说并不是所有的操作系统都提供了对树形控件的支持， Swing 利用了 AWT 中所提供的基本作图方法对树形控件进行模拟。由于 Swing 控件是用 100% 的 Java 代码来实现的，因此在一个平台上设计的树形控件可以在其他平台上使用。由于在 Swing 中没有使用本地方法来实现图形功能，我们通常把 Swing 控件称为轻量级控件。 </p>
                        <p><b>AWT</b> 是抽象窗口组件工具包，是 Java 最早的用于编写图形节目应用程序的开发包。</p>
                        <p><b>Swing</b> 是为了解决 AWT 存在的问题而新开发的包，它以 AWT 为基础的。</p>
                        <p><b>AWT</b> 和 <b>Swing</b> 之间的基本区别：AWT 是基于本地方法的 C/C++ 程序，其运行速度比较快；Swing 是基于 AWT 的 Java 程序，其运行速度比较慢。对于一个嵌入式应用来说，目标平台的硬件资源往往非常有限，而应用程序的运行速度又是项目中至关重要的因素。在这种矛盾的情况下，简单而高效的 AWT 当然成了嵌入式 Java 的第一选择。而在普通的基于 PC 或者是工作站的标准 Java 应用中，硬件资源对应用程序所造成的限制往往不是项目中的关键因素，所以在标准版的 Java 中则提倡使用 Swing， 也就是通过牺牲速度来实现应用程序的功能。 </p>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-awt-Frame"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Frame  及父类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.awt.Component
        java.awt.Container
            java.awt.Window
                java.awt.Frame

public class Frame extends Window implements MenuContainer {
    /** 实现对 Frame 类的可访问性支持 */
    protected class AccessibleAWTFrame extends AccessibleAWTWindow {}

    /** 只是窗口的状态 */
    public static final int NORMAL = 0;          // 窗体处于 "normal" 状态
    public static final int ICONIFIED = 1;       // 此状态位指示将窗体图标化
    public static final int MAXIMIZED_BOTH = 6;  // 此状态位掩码指示将窗体完全最大化
    public static final int MAXIMIZED_HORIZ = 2; // 此状态位指示在水平方向将窗体最大化
    public static final int MAXIMIZED_VERT = 4;  // 此状态位指示在垂直方向将窗体最大化

    /** 构造的 Frame 实例最初是不可见的 */
    public Frame() {}
    public Frame(String title) {}
    public Frame(GraphicsConfiguration gc) {}
    public Frame(String title, GraphicsConfiguration gc) {}
}

/** 所有菜单相关容器的超类 */
public interface MenuContainer {
    Font getFont();
    void remove(MenuComponent comp);
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Frame.html" target="_blank">Frame</a> 是带有标题和边框的顶层窗口。</p>
                            <p>窗体的大小包括为边框指定的所有区域。边框区域的尺寸可以使用 getInsets 方法获得，但是，由于这些尺寸与平台相关，因此在通过调用 pack 或 show 将窗体设置为可显示之前，将无法获得有效的 insets 值。由于窗体的总大小包括了边框区，因此边框实际上遮掩了窗体的部分区域，并将可用于在矩形中呈现和/或显示子部件的区域限制在一个矩形内，该矩形左上角的位置为 (insets.left, insets.top)，宽度为 width - (insets.left + insets.right)，长度为 height - (insets.top + insets.bottom)。 </p>
                            <p>窗体的默认布局为 BorderLayout。 </p>
                            <p>使用 setUndecorated，窗体可以关闭本机装饰（即 Frame 和 Titlebar）。但只有在窗体不是 displayable 时才能这样做。</p>
                            <p>在多屏幕环境中，通过使用 Frame(GraphicsConfiguration) 或 Frame(String title, GraphicsConfiguration) 构造 Frame，可以在不同的屏幕设备上创建 Frame。GraphicsConfiguration 对象是目标屏幕设备的 GraphicsConfiguration 对象之一。</p>
                            <p>在虚拟设备多屏幕环境中（其中桌面区域可以跨越多物理屏幕设备），所有配置的边界都是相对于虚拟坐标系的。虚拟坐标系的原点位于主物理屏幕的左上角。</p>
                            <ol>
                                <li><p><code>static Frame[] 	getFrames()</code> -- 返回一个此应用程序创建的所有 Frame 所组成的数组</p></li>

                                <li class="group"><p><code>MenuBar 	getMenuBar()</code> -- 获取此窗体的菜单栏</p></li>
                                <li><p><code>void 	setMenuBar(MenuBar mb)</code> -- 将此窗体的菜单栏设置为指定的菜单栏</p></li>
                                <li><p><code>void 	remove(MenuComponent m)</code> -- 从此窗体移除指定的菜单栏</p></li>

                                <li class="group"><p><code>int 	getExtendedState()</code> -- 获取此窗体的状态</p></li>
                                <li><p><code>void 	setExtendedState(int state)</code> -- 设置此窗体的状态</p></li>
                                <li><p><code>Image 	getIconImage()</code> -- 返回要作为此窗体图标显示的图像</p></li>
                                <li><p><code>void 	setIconImage(Image image)</code> -- 设置要作为此窗口图标显示的图像</p></li>
                                <li><p><code>Rectangle 	getMaximizedBounds()</code> -- 获取此窗体的最大化边界</p></li>
                                <li><p><code>void 	setMaximizedBounds(Rectangle bounds)</code> -- 设置此窗体的最大化边界</p></li>
                                <li><p><code>String 	getTitle()</code> -- 获得窗体的标题</p></li>
                                <li><p><code>void 	setTitle(String title)</code> -- 将此窗体的标题设置为指定的字符串</p></li>
                                <li><p><code>boolean 	isResizable()</code> -- 指示此窗体是否可由用户调整大小</p></li>
                                <li><p><code>void 	setResizable(boolean resizable)</code> -- 设置此窗体是否可由用户调整大小</p></li>
                                <li><p><code>boolean 	isUndecorated()</code> -- 指示此窗体是否未装饰</p></li>
                                <li><p><code>void 	setUndecorated(boolean undecorated)</code> -- 禁用或启用此窗体的装饰</p></li>
                                <li><p><code>void 	addNotify()</code> -- 通过将此窗体连接到本机屏幕资源，使其成为可显示的</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 通过移除与本机屏幕资源的连接，将此窗体设置为不可显示的</p></li>

                                <li class="group"><p><code>protected String 	paramString()</code> -- 返回表示此 Frame 状态的字符串</p></li>

                                <li class="group"><p><code>void 	setBackground(Color bgColor)</code> -- 设置此窗体的背景颜色</p></li>
                                <li><p><code>void 	setOpacity(float opacity)</code> -- 设置透明度(依赖于平台)</p></li>
                                <li><p><code>void 	setShape(Shape shape)</code> -- 设置窗口的形状</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此窗体有关的 AccessibleContext</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Window extends Container implements Accessible {
    /** Window 类型 */
    public enum Type {
        NORMAL,  // 正常窗口
        UTILITY, // 弹出窗口，如下拉菜单，对话框
        POPUP    // 实用程序窗口，通常是一个小窗口，如工具栏或调色板
    }

    /** 实现对 Window 类的可访问性支持 */
    protected class AccessibleAWTWindow extends AccessibleAWTContainer {}

    public Window(Frame owner) {}
    public Window(Window owner) {}
    public Window(Window owner, GraphicsConfiguration gc) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Window.html" target="_blank">Window</a> 对象是一个没有边界和菜单栏的顶层窗口。窗口的默认布局是 BorderLayout。</p>
                            <p>构造窗口时，它必须拥有窗体、对话框或其他作为其所有者定义的窗口。</p>
                            <p>注：顶层窗口（包括 Window、Frame 和 Dialog）的位置和大小受桌面窗口管理系统的控制。对 setLocation、setSize 和 setBounds 的调用是转发到窗口管理系统的请求（不是指令）。将尽所有努力响应这样的请求。但是，在某些情况下，窗口管理系统可以忽略这样的请求，或修改请求的几何结构，以放置和调整 Window 的大小，使之更好地与桌面设置匹配。 </p>
                            <p>应用程序可以随意设置不可见 Window 的大小和位置，但是当 Window 可见时，窗口管理系统可以随后更改它的大小和/或位置。将生成一个或多个 ComponentEvent 来表示新的几何结构。 </p>
                            <ol>
                                <li><p><code>static Window[] 	getOwnerlessWindows()</code> -- 返回此应用程序创建的所有没有所有者的 Window 组成的数组</p></li>
                                <li><p><code>static Window[] 	getWindows()</code> -- 返回此应用程序创建的所有 Window 数组</p></li>

                                <li class="group"><p><code>void 	addPropertyChangeListener(PropertyChangeListener listener)</code> -- 将 PropertyChangeListener 添加到侦听器列表</p></li>
                                <li><p><code>void 	addPropertyChangeListener(String propertyName, PropertyChangeListener listener)</code> -- 将某个特定属性的侦听器列表</p>
                                    <pre class="brush: java;">
/** 包括此窗体的以下属性:
 * this Window's font ("font")
 * this Window's background color ("background")
 * this Window's foreground color ("foreground")
 * this Window's focusability ("focusable")
 * this Window's focus traversal keys enabled state ("focusTraversalKeysEnabled")
 * this Window's Set of FORWARD_TRAVERSAL_KEYS ("forwardFocusTraversalKeys")
 * this Window's Set of BACKWARD_TRAVERSAL_KEYS ("backwardFocusTraversalKeys")
 *  this Window's Set of UP_CYCLE_TRAVERSAL_KEYS ("upCycleFocusTraversalKeys")
 * this Window's Set of DOWN_CYCLE_TRAVERSAL_KEYS ("downCycleFocusTraversalKeys")
 * this Window's focus traversal policy ("focusTraversalPolicy")
 * this Window's focusable Window state ("focusableWindowState")
 * this Window's always-on-top state("alwaysOnTop")
 */
</pre>
                                </li>

                                <li class="group"><p><code>void 	addWindowFocusListener(WindowFocusListener l)</code> -- 添加指定的窗口焦点侦听器</p></li>
                                <li><p><code>void 	removeWindowFocusListener(WindowFocusListener l)</code> -- 移除指定的窗口焦点侦听器，以便不再从此窗口接收窗口事件</p></li>
                                <li><p><code>void 	addWindowStateListener(WindowStateListener l)</code> -- 添加指定的窗口状态侦听器(最大化，最小化等)</p></li>
                                <li><p><code>void 	removeWindowStateListener(WindowStateListener l)</code> -- 移除指定的窗口状态侦听器，以便不再从此窗口接收窗口事件</p></li>
                                <li><p><code>void 	addWindowListener(WindowListener l)</code> -- 添加指定的窗口侦听器(包括以上两项，参见：<a href="docs/docs-java/api/java/awt/event/WindowAdapter.html" target="_blank">WindowAdapter</a>)</p></li>
                                <li><p><code>void 	removeWindowListener(WindowListener l)</code> -- 移除指定的窗口侦听器，以便不再从此窗口接收窗口事件</p></li>
                                <li><p><code>WindowFocusListener[] 	getWindowFocusListeners()</code> -- 返回在此窗口注册的所有窗口焦点侦听器所组成的数组</p></li>
                                <li><p><code>WindowStateListener[] 	getWindowStateListeners()</code> -- 返回在此窗口注册的所有窗口状态侦听器所组成的数组</p></li>
                                <li><p><code>WindowListener[] 	getWindowListeners()</code> -- 返回在此窗口注册的所有窗口侦听器所组成的数组</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前在此 Window 上注册的所有对象所组成的数组</p></li>

                                <li class="group"><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此窗口上的事件</p></li>
                                <li><p><code>protected void 	processWindowEvent(WindowEvent e)</code> -- 处理此窗口上发生的窗口事件</p></li>
                                <li><p><code>protected void 	processWindowFocusEvent(WindowEvent e)</code> -- 处理此窗口上发生的窗口焦点事件</p></li>
                                <li><p><code>protected void 	processWindowStateEvent(WindowEvent e)</code> -- 处理此窗口上发生的窗口状态事件</p></li>

                                <li class="group"><p><code>void 	setSize(Dimension d)</code> -- 设置窗体大小</p></li>
                                <li><p><code>void 	setSize(int width, int height)</code> -- 设置窗体大小</p></li>
                                <li><p><code>void 	setMinimumSize(Dimension minimumSize)</code> -- 将此窗口的最小大小设置为一个常量值</p></li>
                                <li><p><code>Color 	getBackground()</code> -- 获取此窗体的背景色</p></li>
                                <li><p><code>void 	setBackground(Color bgColor)</code> -- 设置背景颜色</p></li>
                                <li><p><code>void 	paint(Graphics g)</code> -- 使用 Graphics 绘制此容器</p></li>

                                <li class="group"><p><code>void 	setBounds(int x, int y, int width, int height)</code> -- 移动组件并调整其大小</p></li>
                                <li><p><code>void 	setBounds(Rectangle r)</code> -- 使用矩形设置此窗体位置和大小</p></li>

                                <li class="group"><p><code>void 	setLocation(int x, int y)</code> -- 设置窗体左上角距离屏幕的左上角的位置</p></li>
                                <li><p><code>void 	setLocation(Point p)</code> -- 设置窗体左上角距离屏幕的左上角的位置</p></li>
                                <li><p><code>void 	setLocationByPlatform(boolean locationByPlatform)</code> -- 设置窗口下次可见时应该出现的位置：本机窗口系统的默认位置，还是当前位置</p></li>
                                <li><p><code>void 	setLocationRelativeTo(Component c)</code> -- 位置为相对于某个组件的位置</p></li>
                                <li><p><code>boolean 	isLocationByPlatform()</code> -- 如果此窗口下次可见时，出现在本机窗口操作系统的默认位置，则返回 true</p></li>

                                <li class="group"><p><code>void 	setVisible(boolean b)</code> -- 设置此窗体可见性</p></li>
                                <li><p><code>void 	pack()</code> -- 调整此窗口的大小，以适合其子组件的首选大小和布局</p></li>
                                <li><p><code>boolean 	isShowing()</code> -- 检查此窗口是否显示在屏幕上</p></li>
                                <li><p><code>void 	dispose()</code> -- 释放由此 Window、其子组件及其拥有的所有子组件所使用的所有本机屏幕资源</p></li>
                                <li><p><code>void 	addNotify()</code> -- 通过创建到本机屏幕资源的连接，使此窗口变得可显示</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 通过移除此 Container 到其本机屏幕资源的连接，使其不可显示</p></li>
                                <li><p><code>void 	toBack()</code> -- 如果此窗口是可视的，则将此窗口置于后方，如果它是焦点窗口或活动窗口，则会导致丢失焦点或活动状态</p></li>
                                <li><p><code>void 	toFront()</code> -- 如果此窗口是可见的，则将此窗口置于前端，并可以将其设为焦点 Window</p></li>

                                <li class="group"><p><code>void 	setCursor(Cursor cursor)</code> -- 设置指定光标的光标图像</p></li>
                                <li><p><code>void 	setIconImage(Image image)</code> -- 设置要作为此窗口图标显示的图像</p></li>
                                <li><p><code>List&lt;Image> 	getIconImages()</code> -- 返回要作为此窗口的图标显示的图像序列</p></li>
                                <li><p><code>void 	setIconImages(List&lt;? extends Image> icons)</code> -- 设置要作为此窗口的图标显示的图像序列</p></li>

                                <li class="group"><p><code>float 	getOpacity()</code> -- 获取透明度值(依赖平台)</p></li>
                                <li><p><code>void 	setOpacity(float opacity)</code> -- 设置透明度(依赖平台)</p></li>
                                <li><p><code>boolean 	isOpaque()</code> -- 指示窗口当前是否不透明</p></li>
                                <li><p><code>Shape 	getShape()</code> -- 返回此窗体的图形</p></li>
                                <li><p><code>void 	setShape(Shape shape)</code> -- 设置此窗体的图形</p></li>
                                <li><p><code>Window.Type 	getType()</code> -- 获取窗体类型</p></li>
                                <li><p><code>void 	setType(Window.Type type)</code> -- 设置此窗体类型</p></li>
                                <li><p><code>Locale 	getLocale()</code> -- 如果设置了区域，则获取与此窗口关联的 Locale 对象</p></li>

                                <li class="group"><p><code>Window[] 	getOwnedWindows()</code> -- 返回包含此窗口当前拥有的所有窗口的数组</p></li>
                                <li><p><code>Window 	getOwner()</code> -- 返回此窗口的所有者</p></li>
                                <li><p><code>Toolkit 	getToolkit()</code> -- 返回此窗体的工具包</p></li>
                                <li><p><code>boolean 	isActive()</code> -- 返回此窗口是否为活动窗口</p></li>
                                <li><p><code>boolean 	isValidateRoot()</code> -- 是否为根窗口</p></li>

                                <li class="group"><p><code>boolean 	getFocusableWindowState()</code> -- 返回如果此窗口满足 isFocusableWindow 中列出的其他要求，其是否可以成为焦点窗口</p></li>
                                <li><p><code>void 	setFocusableWindowState(boolean focusableWindowState)</code> -- 设置如果此窗口满足 isFocusableWindow 中列出的其他要求，其是否可以成为焦点窗口</p></li>
                                <li><p><code>Container 	getFocusCycleRootAncestor()</code> -- 始终返回 null，因为窗口没有祖先；它们表示组件层次结构的顶层</p></li>
                                <li><p><code>void 	setFocusCycleRoot(boolean focusCycleRoot)</code> -- 不执行任何操作，因为窗口必须始终是焦点遍历循环的根</p></li>
                                <li><p><code>boolean 	isFocusCycleRoot()</code> -- 始终返回 true，因为所有窗口必须是焦点遍历循环的根</p></li>

                                <li class="group"><p><code>Component 	getFocusOwner()</code> -- 如果此窗口为焦点窗口，则返回是焦点窗口的子组件</p></li>
                                <li><p><code>Component 	getMostRecentFocusOwner()</code> -- 返回此窗口的子组件，该子组件在此窗口为焦点窗口时将接收焦点</p></li>
                                <li><p><code>boolean 	isFocusableWindow()</code> -- 返回此窗口是否可以成为焦点窗口</p></li>
                                <li><p><code>boolean 	isFocused()</code> -- 返回此窗口是否为焦点窗口</p></li>
                                <li><p><code>boolean 	isAutoRequestFocus()</code> -- 是否可以自动获取焦点</p></li>
                                <li><p><code>void 	setAutoRequestFocus(boolean autoRequestFocus)</code> -- 设置是否自动获取焦点</p></li>
                                <li><p><code>Set&lt;AWTKeyStroke> 	getFocusTraversalKeys(int id)</code> -- 获取此窗口的焦点遍历键</p></li>

                                <li class="group"><p><code>InputContext 	getInputContext()</code> --  获取此窗口的输入上下文</p></li>
                                <li><p><code>Dialog.ModalExclusionType 	getModalExclusionType()</code> -- 返回此窗口的模式排斥类型</p></li>
                                <li><p><code>void 	setModalExclusionType(Dialog.ModalExclusionType exclusionType)</code> -- 指定此窗口的模式排斥类型</p></li>
                                <li><p><code>String 	getWarningString()</code> -- 获取此窗口中显示的警告字符串</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此窗口关联的 AccessibleContext</p></li>

                                <li class="group"><p><code>boolean 	isAlwaysOnTopSupported()</code> -- 返回此窗口是否支持 always-on-top 模式</p></li>
                                <li><p><code>boolean 	isAlwaysOnTop()</code> -- 返回此窗口是否为 always-on-top 窗口</p></li>
                                <li><p><code>void 	setAlwaysOnTop(boolean alwaysOnTop)</code> -- 设置此窗口是否应该始终位于其他窗口上方</p></li>

                                <li class="group"><p><code>void 	createBufferStrategy(int numBuffers)</code> -- 为此组件上的多缓冲创建一个新策略</p></li>
                                <li><p><code>BufferStrategy 	getBufferStrategy()</code> -- 返回此组件使用的 BufferStrategy</p></li>
                                <li><p><code>void 	createBufferStrategy(int num, BufferCapabilities caps)</code> -- 根据所需缓冲区能力为此组件上的多缓冲创建新策略</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Container extends Component {
    /** 用于对可访问性提供默认支持的 Container 内部类 */
    protected class AccessibleAWTContainer extends AccessibleAWTComponent {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Container.html" target="_blank">Container</a> 是一般的 Abstract Window Toolkit(AWT) 容器对象是一个可包含其他 AWT 组件的组件。 </p>
                            <p>添加到容器中的组件放在一个列表中。列表的顺序将定义组件在容器内的正向堆栈顺序。如果将组件添加到容器中时未指定索引，则该索引将被添加到列表尾部（此后它位于堆栈顺序的底部）。 </p>
                            <ol>
                                <li><p><code>Component 	add(Component comp)</code> -- 将指定组件追加到此容器的尾部</p></li>
                                <li><p><code>Component 	add(Component comp, int index)</code> -- 将指定组件添加到此容器的给定位置上</p></li>
                                <li><p><code>void 	add(Component comp, Object constraints)</code> -- 将指定的组件添加到此容器的尾部</p></li>
                                <li><p><code>void 	add(Component comp, Object constraints, int index)</code> -- 使用指定约束，将指定组件添加到此容器的指定索引所在的位置上</p></li>
                                <li><p><code>Component 	add(String name, Component comp)</code> -- 将指定组件添加到此容器中</p></li>
                                <li><p><code>protected void 	addImpl(Component comp, Object constraints, int index)</code> -- 将指定组件添加到此容器的指定索引所在的位置上</p></li>

                                <li class="group"><p><code>void 	remove(Component comp)</code> -- 从此容器中移除指定组件</p></li>
                                <li><p><code>void 	remove(int index)</code> -- 从此容器中移除 index 指定的组件</p></li>
                                <li><p><code>void 	removeAll()</code> -- 从此容器中移除所有组件</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 通过将这个 Container 连接到本机屏幕资源，使其可以显示</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 通过移除此 Container 到其本机屏幕资源的连接，使其不可显示</p></li>
                                <li><p><code>void 	invalidate()</code> -- 使容器失效</p></li>
                                <li><p><code>void 	validate()</code> -- 验证此容器及其所有子组件</p></li>
                                <li><p><code>protected void 	validateTree()</code> -- 递归继承容器树，对于所有被标记为需要重新计算布局的子树（标记为无效的那些子树）重新计算布局</p></li>

                                <li class="group"><p><code>void 	paint(Graphics g)</code> -- 绘制容器</p></li>
                                <li><p><code>void 	paintComponents(Graphics g)</code> -- 绘制此容器中的每个组件</p></li>
                                <li><p><code>void 	print(Graphics g)</code> -- 打印容器</p></li>
                                <li><p><code>void 	printComponents(Graphics g)</code> -- 打印此容器中的每个组件</p></li>
                                <li><p><code>void 	update(Graphics g)</code> -- 更新容器</p></li>

                                <li class="group"><p><code>void 	setLayout(LayoutManager mgr)</code> -- 设置此容器的布局管理器</p></li>
                                <li><p><code>void 	doLayout()</code> -- 使此容器布置其组件</p></li>

                                <li class="group"><p><code>void 	addContainerListener(ContainerListener l)</code> -- 添加指定容器的侦听器(添加/移除组件到此容器监听)</p></li>
                                <li><p><code>void 	removeContainerListener(ContainerListener l)</code> -- 移除指定容器的侦听器，从而不再接收来自此容器的容器事件</p></li>
                                <li><p><code>ContainerListener[] 	getContainerListeners()</code> -- 返回已在此容器上注册的所有容器侦听器的数组</p></li>
                                <li><p><code>protected void 	processContainerEvent(ContainerEvent e)</code> -- 通过将发生在此容器上的容器事件指派给所有已注册的 ContainerListener 对象来处理这些事件</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理关于此容器的事件</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前已在此 Container 上注册的指定类型的监听器数组</p></li>

                                <li class="group"><p><code>void 	addPropertyChangeListener(PropertyChangeListener listener)</code> -- 将一个 PropertyChangeListener 添加到侦听器列表中</p></li>
                                <li><p><code>void 	addPropertyChangeListener(String propertyName, PropertyChangeListener listener)</code> -- 将某个特定属性的侦听器列表</p></li>

                                <li class="group"><p><code>Component 	findComponentAt(int x, int y)</code> -- 对包含指定位置的可视子组件进行定位</p></li>
                                <li><p><code>Component 	findComponentAt(Point p)</code> -- 对包含指定点的可视子组件进行定位</p></li>
                                <li><p><code>Component 	getComponent(int n)</code> -- 获取此容器中的第 n 个组件</p></li>
                                <li><p><code>Component 	getComponentAt(int x, int y)</code> -- 对包含 x，y 位置的组件进行定位</p></li>
                                <li><p><code>Component 	getComponentAt(Point p)</code> -- 获取包含指定点的组件</p></li>
                                <li><p><code>int 	getComponentCount()</code> -- 获取此面板中的组件数</p></li>
                                <li><p><code>Component[] 	getComponents()</code> -- 获取此容器中的所有组件</p></li>
                                <li><p><code>void 	applyComponentOrientation(ComponentOrientation o)</code> -- 设置此容器和其中包含的所有组件的 ComponentOrientation 属性</p></li>
                                <li><p><code>boolean 	isAncestorOf(Component c)</code> -- 检查该组件是否包含在此容器的组件层次结构中</p></li>
                                <li><p><code>int 	getComponentZOrder(Component comp)</code> -- 返回容器内组件的 z 顺序索引</p></li>
                                <li><p><code>void 	setComponentZOrder(Component comp, int index)</code> -- 将指定组件移动到容器中指定的 z 顺序索引</p></li>

                                <li class="group"><p><code>Set&lt;AWTKeyStroke> 	getFocusTraversalKeys(int id)</code> -- 为此 Container 的给定遍历操作返回焦点遍历键的 Set</p></li>
                                <li><p><code>void 	setFocusTraversalKeys(int id, Set&lt;? extends AWTKeyStroke> keystrokes)</code> -- 为此 Container 的给定遍历操作设置焦点遍历键</p></li>
                                <li><p><code>boolean 	areFocusTraversalKeysSet(int id)</code> -- 返回是否已经为此 Container 明确定义了用于给定焦点遍历操作的焦点遍历键的 Set</p></li>
                                <li><p><code>boolean 	isFocusTraversalPolicySet()</code> -- 返回是否为此 Container 明确设置焦点遍历策略</p></li>
                                <li><p><code>FocusTraversalPolicy 	getFocusTraversalPolicy()</code> -- 返回焦点遍历策略</p></li>
                                <li><p><code>void 	setFocusTraversalPolicy(FocusTraversalPolicy policy)</code> -- 如果此 Container 是一个焦点循环根，则设置将管理此 Container 的子代的键盘遍历的焦点遍历策略</p></li>
                                <li><p><code>void 	setFocusTraversalPolicyProvider(boolean provider)</code> -- 设置是否将用此容器提供焦点遍历策略</p></li>
                                <li><p><code>boolean 	isFocusTraversalPolicyProvider()</code> -- 返回此容器是否提供焦点遍历策略</p></li>
                                <li><p><code>boolean 	isFocusCycleRoot()</code> -- 返回此 Container 是否是某个焦点遍历循环的根</p></li>
                                <li><p><code>void 	setFocusCycleRoot(boolean focusCycleRoot)</code> -- 设置此 Container 是否是某个焦点遍历循环的根</p></li>
                                <li><p><code>boolean 	isFocusCycleRoot(Container container)</code> -- 返回指定的 Container 是否是此 Container 的焦点遍历循环的焦点循环根</p></li>
                                <li><p><code>void 	transferFocusDownCycle()</code> -- 将焦点向下传输一个焦点遍历循环</p></li>

                                <li class="group"><p><code>Dimension 	getMaximumSize()</code> -- 返回此容器的最大大小</p></li>
                                <li><p><code>Dimension 	getPreferredSize()</code> -- 返回此容器的首选大小</p></li>
                                <li><p><code>Dimension 	getMinimumSize()</code> -- 返回此容器的最小大小</p></li>
                                <li><p><code>Insets 	getInsets()</code> -- 确定此容器的 insets，它指示容器边框的大小</p></li>
                                <li><p><code>LayoutManager 	getLayout()</code> -- 获取此容器的布局管理器</p></li>
                                <li><p><code>float 	getAlignmentX()</code> -- 返回沿 x 轴的对齐方式</p></li>
                                <li><p><code>float 	getAlignmentY()</code> -- 返回沿 y 轴的对齐方式</p></li>

                                <li class="group"><p><code>void 	setFont(Font f)</code> -- 设置此容器的字体</p></li>
                                <li><p><code>Point 	getMousePosition(boolean allowChildren)</code> -- 如果 Container 位于鼠标指针下，则返回鼠标指针在此 Container 的坐标中的位置</p></li>
                                <li><p><code>boolean 	isValidateRoot()</code> -- </p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此 Container 的状态的字符串</p></li>

                                <li class="group"><p><code>void 	list(PrintStream out, int indent)</code> -- 将此容器的清单打印到指定输出流，从指定缩排位置开始</p></li>
                                <li><p><code>void 	list(PrintWriter out, int indent)</code> -- 将一个列表打印到指定打印编写器，从指定缩排位置开始</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public abstract class Component implements ImageObserver, MenuContainer, Serializable {
    public static final float TOP_ALIGNMENT = 0.0f;    // 顶部对齐
    public static final float BOTTOM_ALIGNMENT = 1.0f; // 底部对齐
    public static final float CENTER_ALIGNMENT = 0.5f; // 居中对齐
    public static final float LEFT_ALIGNMENT = 0.0f;   // 左对齐
    public static final float RIGHT_ALIGNMENT = 1.0f;  // 右对齐

    protected Component() {}
    protected AccessibleContext accessibleContext = null;

    /** 常见方式的枚举，指示组件的基线可以随大小的更改而更改 */
    public enum BaselineResizeBehavior {
        CONSTANT_ASCENT,  // 指示基线相对于 y 原点保持不变
        CENTER_OFFSET,    // 指示基线与组件的中心保持固定的距离
        CONSTANT_DESCENT, // 指示基线相对于高度保持不变，且不会随着宽度不同而发生更改
        OTHER             // 指示基线调整行为无法使用其他任何常量表示
    }
    /** 用于将屏幕外的画面以位图传输方式传输到一个组件的内部类 */
    protected class BltBufferStrategy extends BufferStrategy {}
    /**  在组件上翻转缓冲区的内部类 */
    protected class FlipBufferStrategy extends BufferStrategy {}
    /** 用来为可访问性提供默认支持的 Component 的内部类 */
    protected abstract class AccessibleAWTComponent extends AccessibleContext implements Serializable,
                                AccessibleComponent {}
}

/** 用于在构造 Image 时，接收有关 Image 信息通知的异步更新接口 */
public interface ImageObserver {
    /** infoflags 参数 */
    int WIDTH = 1;        // 指示基本图像的宽度现在可用
    int HEIGHT = 2;       // 指示基本图像的高度现在可用
    int PROPERTIES = 4;   // 指示该图像的属性现在可用
    int SOMEBITS = 8;     // 指示已提供了绘制图像缩放变体所需的更多像素
    int FRAMEBITS = 16;   // 指示多帧图像（以前绘制的）的另一个完整帧现在可以再次绘制
    int ALLBITS = 32;     // 指示现在已完成了一幅以前绘制的静态图像，并且可以其最终形式再次绘制它
    int ERROR = 64;       // 指示被异步跟踪的图像遇到了错误
    int ABORT = 128;      // 指示被异步跟踪的图像在生成完成前即已中止

    /** 当以前使用异步接口所请求的图像的信息变得可用时就调用此方法 */
    boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height);
}

/** 所有菜单相关容器的超类 */
public interface MenuContainer {
    Font getFont(); // 获取使用的字体
    void remove(MenuComponent comp); // 移除指定的菜单组件
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Component.html" target="_blank">Component</a> 是一个具有图形表示能力的对象，可在屏幕上显示，并可与用户进行交互。</p>
                            <p>Component 类是与菜单不相关的 Abstract Window Toolkit 组件的抽象超类。还可以直接扩展类 Component 来创建一个轻量级组件。轻量级组件是与本机不透明窗口不相关的组件。 </p>
                            <ol>
                                <li><p><code>void 	addComponentListener(ComponentListener l)</code> -- 添加指定的组件侦听器(位置，大小，是否可见)</p></li>
                                <li><p><code>void 	addFocusListener(FocusListener l)</code> -- 添加指定的焦点侦听器</p></li>
                                <li><p><code>void 	addHierarchyBoundsListener(HierarchyBoundsListener l)</code> -- 添加指定的层次结构边界侦听器</p></li>
                                <li><p><code>void 	addHierarchyListener(HierarchyListener l)</code> -- 添加指定的层次结构侦听器</p></li>
                                <li><p><code>void 	addInputMethodListener(InputMethodListener l)</code> -- 添加指定的输入方法侦听器</p></li>
                                <li><p><code>void 	addKeyListener(KeyListener l)</code> -- 添加指定的按键侦听器</p></li>
                                <li><p><code>void 	addMouseListener(MouseListener l)</code> -- 添加指定的鼠标侦听器</p></li>
                                <li><p><code>void 	addMouseMotionListener(MouseMotionListener l)</code> -- 添加指定的鼠标移动侦听器</p></li>
                                <li><p><code>void 	addMouseWheelListener(MouseWheelListener l)</code> -- 添加指定的鼠标滚轮侦听器</p></li>

                                <li class="group"><p><code>void 	removeComponentListener(ComponentListener l)</code> -- 移除指定的组件侦听器</p></li>
                                <li><p><code>void 	removeFocusListener(FocusListener l)</code> -- 移除指定的焦点侦听器</p></li>
                                <li><p><code>void 	removeHierarchyBoundsListener(HierarchyBoundsListener l)</code> -- 移除指定的层次结构边界侦听器</p></li>
                                <li><p><code>void 	removeHierarchyListener(HierarchyListener l)</code> -- 移除指定的层次结构侦听器</p></li>
                                <li><p><code>void 	removeInputMethodListener(InputMethodListener l)</code> -- 移除指定的输入方法侦听器</p></li>
                                <li><p><code>void 	removeKeyListener(KeyListener l)</code> -- 移除指定的按键侦听器</p></li>
                                <li><p><code>void 	removeMouseListener(MouseListener l)</code> -- 移除指定的鼠标侦听器</p></li>
                                <li><p><code>void 	removeMouseMotionListener(MouseMotionListener l)</code> -- 移除指定的鼠标移动侦听器</p></li>
                                <li><p><code>void 	removeMouseWheelListener(MouseWheelListener l)</code> -- 移除指定的鼠标滚轮侦听器</p></li>

                                <li class="group"><p><code>protected void 	processComponentEvent(ComponentEvent e)</code> -- 处理组件上发生的组件事件</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理组件上发生的事件</p></li>
                                <li><p><code>protected void 	processFocusEvent(FocusEvent e)</code> -- 处理组件上发生的焦点事件</p></li>
                                <li><p><code>protected void 	processHierarchyBoundsEvent(HierarchyEvent e)</code> -- 处理组件上发生的层次结构边界事件</p></li>
                                <li><p><code>protected void 	processHierarchyEvent(HierarchyEvent e)</code> -- 处理组件上发生的层次结构事件</p></li>
                                <li><p><code>protected void 	processInputMethodEvent(InputMethodEvent e)</code> -- 处理组件上发生的输入方法事件</p></li>
                                <li><p><code>protected void 	processKeyEvent(KeyEvent e)</code> -- 处理组件上发生的按键事件</p></li>
                                <li><p><code>protected void 	processMouseEvent(MouseEvent e)</code> -- 处理组件上发生的鼠标事件</p></li>
                                <li><p><code>protected void 	processMouseMotionEvent(MouseEvent e)</code> -- 处理组件上发生的鼠标移动事件</p></li>
                                <li><p><code>protected void 	processMouseWheelEvent(MouseWheelEvent e)</code> -- 处理组件上发生的鼠标滚轮事件</p></li>

                                <li class="group"><p><code>void 	addPropertyChangeListener(PropertyChangeListener listener)</code> -- 属性改变监听器</p></li>
                                <li><p><code>void 	addPropertyChangeListener(String propertyName, PropertyChangeListener listener)</code> -- 指定属性改变监听器</p></li>
                                <li><p><code>void 	removePropertyChangeListener(PropertyChangeListener listener)</code> -- 移除一个属性改变监听器</p></li>
                                <li><p><code>void 	removePropertyChangeListener(String propertyName, PropertyChangeListener listener)</code> -- 移除指定属性名的属性改变监听器</p></li>
                                <li><p><code>PropertyChangeListener[] 	getPropertyChangeListeners()</code> -- 返回在此组件上所有已注册的属性更改侦听器的数组</p></li>
                                <li><p><code>PropertyChangeListener[] 	getPropertyChangeListeners(String propertyName)</code> -- 返回与指定属性相关联的所有侦听器的数组</p></li>
                                <li><p><code>protected void 	firePropertyChange(String propertyName, boolean oldValue, boolean newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>protected void 	firePropertyChange(String propertyName, int oldValue, int newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>protected void 	firePropertyChange(String propertyName, Object oldValue, Object newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, byte oldValue, byte newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, char oldValue, char newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, short oldValue, short newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, long oldValue, long newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, float oldValue, float newValue)</code> -- 通知属性发生改变</p></li>
                                <li><p><code>void 	firePropertyChange(String propertyName, double oldValue, double newValue)</code> -- 通知属性发生改变</p></li>

                                <li><p><code>void 	add(PopupMenu popup)</code> -- 向组件添加指定的弹出菜单</p></li>
                                <li><p><code>void 	addNotify()</code> -- 通过将此 Component 连接到一个本机屏幕资源使其成为可显示的</p></li>

                                <li><p><code>void 	applyComponentOrientation(ComponentOrientation orientation)</code> -- 设置此组件及其包含的所有组件的 ComponentOrientation 属性</p></li>
                                <li><p><code>boolean 	areFocusTraversalKeysSet(int id)</code> -- 返回是否为此 Component 显式定义了给定焦点遍历操作的焦点遍历键 Set</p></li>

                                <li class="group"><p><code>int 	checkImage(Image image, ImageObserver observer)</code> -- 返回指定图像屏幕表示的构造状态</p></li>
                                <li><p><code>int 	checkImage(Image image, int width, int height, ImageObserver observer)</code> -- 返回指定图像屏幕表示的构造状态</p></li>
                                <li><p><code>Image 	createImage(ImageProducer producer)</code> -- 根据指定的图像生成器创建一幅图像</p></li>
                                <li><p><code>Image 	createImage(int width, int height)</code> -- 创建一幅用于双缓冲的、可在屏幕外绘制的图像</p></li>
                                <li><p><code>VolatileImage 	createVolatileImage(int width, int height)</code> -- 创建一幅用于双缓冲的、可变的、可在屏幕外绘制的图像</p></li>
                                <li><p><code>VolatileImage 	createVolatileImage(int width, int height, ImageCapabilities caps)</code> -- 创建一幅具有给定能力的、可变的、可在屏幕外绘制的图像</p></li>

                                <li><p><code>protected AWTEvent 	coalesceEvents(AWTEvent existingEvent, AWTEvent newEvent)</code> -- 将正发送的事件与现有事件组合在一起</p></li>
                                <li><p><code>boolean 	contains(int x, int y)</code> -- 检查组件是否“包含”指定的点</p></li>
                                <li><p><code>boolean 	contains(Point p)</code> -- 检查组件是否“包含”指定的点</p></li>

                                <li><p><code>protected void 	disableEvents(long eventsToDisable)</code> -- 禁用由传递给此组件的指定事件掩码参数所定义的事件</p></li>
                                <li><p><code>protected void 	enableEvents(long eventsToEnable)</code> -- 启用由传递给此组件的指定事件掩码参数所定义的事件</p></li>
                                <li><p><code>void 	dispatchEvent(AWTEvent e)</code> -- 为组件或其子组件之一指派事件</p></li>
                                <li><p><code>void 	doLayout()</code> -- 提示布局管理器布局此组件</p></li>
                                <li><p><code>void 	enableInputMethods(boolean enable)</code> -- 启用或禁用此组件的输入方法支持</p></li>

                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Component 相关的 AccessibleContext</p></li>
                                <li><p><code>float 	getAlignmentX()</code> -- 返回 x 轴的对齐方式</p></li>
                                <li><p><code>float 	getAlignmentY()</code> -- 返回 y 轴的对齐方式</p></li>
                                <li><p><code>Color 	getBackground()</code> -- 获取组件的背景色</p></li>

                                <li><p><code>int 	getBaseline(int width, int height)</code> -- 返回基线</p></li>
                                <li><p><code>Component.BaselineResizeBehavior 	getBaselineResizeBehavior()</code> -- 返回一个指示组件的基线如何随大小发生更改的枚举</p></li>

                                <li><p><code>Rectangle 	getBounds()</code> -- 以 Rectangle 对象的形式获取组件的边界</p></li>
                                <li><p><code>Rectangle 	getBounds(Rectangle rv)</code> -- 将组件的边界存储到“返回值” rv 中并返回 rv</p></li>
                                <li><p><code>ColorModel 	getColorModel()</code> -- 获取用于在输出设备上显示组件的 ColorModel 实例</p></li>
                                <li><p><code>Component 	getComponentAt(int x, int y)</code> -- 确定此组件或其直接子组件之一是否包含（x，y）位置，并且如果是，则返回包含该位置的组件</p></li>
                                <li><p><code>Component 	getComponentAt(Point p)</code> -- 返回包含指定点的组件或子组件</p></li>
                                <li><p><code>ComponentListener[] 	getComponentListeners()</code> -- 返回在此组件上所有已注册的组件侦听器的数组</p></li>
                                <li><p><code>ComponentOrientation 	getComponentOrientation()</code> -- 检索将用于排序此组件内的元素或文本的语言敏感的方向</p></li>
                                <li><p><code>Cursor 	getCursor()</code> -- 获取组件中的光标</p></li>
                                <li><p><code>DropTarget 	getDropTarget()</code> -- 获取与此 Component 相关的 DropTarget</p></li>
                                <li><p><code>Container 	getFocusCycleRootAncestor()</code> -- 返回作为此 Component 焦点遍历循环的焦点循环根的 Container</p></li>
                                <li><p><code>FocusListener[] 	getFocusListeners()</code> -- 返回在此组件上所有已注册的焦点侦听器的数组</p></li>
                                <li><p><code>Set&lt;AWTKeyStroke> 	getFocusTraversalKeys(int id)</code> -- 返回此 Component 的给定遍历操作的焦点遍历键 Set</p></li>
                                <li><p><code>boolean 	getFocusTraversalKeysEnabled()</code> -- 返回是否已为此 Component 启用了焦点遍历键</p></li>
                                <li><p><code>Font 	getFont()</code> -- 获取组件的字体</p></li>
                                <li><p><code>FontMetrics 	getFontMetrics(Font font)</code> -- 获取指定字体的字体规格</p></li>
                                <li><p><code>Color 	getForeground()</code> -- 获取组件的前景色</p></li>
                                <li><p><code>Graphics 	getGraphics()</code> -- 为组件创建一个图形上下文</p></li>
                                <li><p><code>GraphicsConfiguration 	getGraphicsConfiguration()</code> -- 获取与此 Component 相关的 GraphicsConfiguration</p></li>
                                <li><p><code>int 	getHeight()</code> -- 返回组件的当前高度</p></li>
                                <li><p><code>HierarchyBoundsListener[] 	getHierarchyBoundsListeners()</code> -- 返回在此组件上所有已注册的层次结构边界侦听器的数组</p></li>
                                <li><p><code>HierarchyListener[] 	getHierarchyListeners()</code> -- 返回在此组件上所有已注册的层次结构侦听器的数组</p></li>
                                <li><p><code>boolean 	getIgnoreRepaint()</code> -- 是否应该忽略接收操作系统发出的绘制消息</p></li>
                                <li><p><code>InputContext 	getInputContext()</code> -- 获取此组件使用的输入上下文</p></li>
                                <li><p><code>InputMethodListener[] 	getInputMethodListeners()</code> -- 返回在此组件上所有已注册的输入方法侦听器的数组</p></li>
                                <li><p><code>InputMethodRequests 	getInputMethodRequests()</code> -- 获取输入方法请求处理程序，该处理程序支持此组件输入方法发出的请求</p></li>
                                <li><p><code>KeyListener[] 	getKeyListeners()</code> -- 返回在此组件上所有已注册的按键侦听器的数组</p></li>
                                <li><p><code>&lt;T extends EventListener>T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回一个当前在此 Component 上作为 FooListener 注册的所有对象的数组</p></li>
                                <li><p><code>Locale 	getLocale()</code> -- 获取组件的语言环境</p></li>
                                <li><p><code>Point 	getLocation()</code> -- 获取组件的位置，形式是指定组件左上角的一个点</p></li>
                                <li><p><code>Point 	getLocation(Point rv)</code> -- 将组件的 x，y 原点存储到“返回值” rv 中并返回 rv</p></li>
                                <li><p><code>Point 	getLocationOnScreen()</code> -- 获取组件的位置，形式是一个指定屏幕坐标空间中组件左上角的一个点</p></li>
                                <li><p><code>Dimension 	getMaximumSize()</code> -- 获取组件的最大大小</p></li>
                                <li><p><code>Dimension 	getPreferredSize()</code> -- 获取组件的首选大小</p></li>
                                <li><p><code>Dimension 	getMinimumSize()</code> -- 获取组件的最小大小</p></li>
                                <li><p><code>MouseListener[] 	getMouseListeners()</code> -- 返回在此组件上所有已注册的鼠标侦听器的数组</p></li>
                                <li><p><code>MouseMotionListener[] 	getMouseMotionListeners()</code> -- 返回在此组件上所有已注册的鼠标移动侦听器的数组</p></li>
                                <li><p><code>Point 	getMousePosition()</code> -- 如果此 Component 正好位于鼠标指针下，则返回鼠标指针在该 Component 的坐标空间中的位置</p></li>
                                <li><p><code>MouseWheelListener[] 	getMouseWheelListeners()</code> -- 返回在此组件上所有已注册的鼠标滚轮侦听器的数组</p></li>
                                <li><p><code>String 	getName()</code> -- 获取组件的名称</p></li>
                                <li><p><code>Container 	getParent()</code> -- 获取此组件的父级</p></li>


                                <li><p><code>Dimension 	getSize()</code> -- 以 Dimension 对象的形式返回组件的大小</p></li>
                                <li><p><code>Dimension 	getSize(Dimension rv)</code> -- 将组件的宽度/高度存储到“返回值”rv 中并返回 rv</p></li>
                                <li><p><code>Toolkit 	getToolkit()</code> -- 获取此组件的工具包</p></li>
                                <li><p><code>Object 	getTreeLock()</code> -- 获取此组件用于 AWT 组件树和布局操作的锁定对象</p></li>
                                <li><p><code>int 	getWidth()</code> -- 返回组件的当前宽度</p></li>
                                <li><p><code>int 	getX()</code> -- 返回组件原点的当前 x 坐标</p></li>
                                <li><p><code>int 	getY()</code> -- 返回组件原点的当前 y 坐标</p></li>
                                <li><p><code>boolean 	hasFocus()</code> -- 如果此 Component 是焦点所有者，则返回 true</p></li>
                                <li><p><code>boolean 	imageUpdate(Image img, int infoflags, int x, int y, int w, int h)</code> -- 图像已改变时重绘组件</p></li>
                                <li><p><code>void 	invalidate()</code> -- 使此组件无效</p></li>
                                <li><p><code>boolean 	isBackgroundSet()</code> -- 返回是否已为此组件显示地设置了背景色</p></li>
                                <li><p><code>boolean 	isCursorSet()</code> -- 返回是否已为此组件显示地设置了光标</p></li>
                                <li><p><code>boolean 	isDisplayable()</code> -- 确定此组件是否可以显示</p></li>
                                <li><p><code>boolean 	isDoubleBuffered()</code> -- 如果将此组件绘制到一个随后复制到屏幕上的屏幕外图像（“缓冲区”），则返回 true</p></li>
                                <li><p><code>boolean 	isEnabled()</code> -- 确定此组件是否已启用</p></li>
                                <li><p><code>boolean 	isFocusable()</code> -- 返回此 Component 是否可以获得焦点</p></li>
                                <li><p><code>boolean 	isFocusCycleRoot(Container container)</code> -- 返回指定的 Container 是否为此 Component 焦点遍历循环的焦点循环根</p></li>
                                <li><p><code>boolean 	isFocusOwner()</code> -- 如果此 Component 是焦点所有者，则返回 true</p></li>
                                <li><p><code>boolean 	isFontSet()</code> -- 返回是否已为此组件显示地设置了字体</p></li>
                                <li><p><code>boolean 	isForegroundSet()</code> -- 返回是否已为此组件显式地设置了前景色</p></li>
                                <li><p><code>boolean 	isLightweight()</code> -- 轻量级组件没有本机工具包同位体</p></li>
                                <li><p><code>boolean 	isMaximumSizeSet()</code> -- 如果已将最大大小设置为非 null 值，则返回 true</p></li>
                                <li><p><code>boolean 	isPreferredSizeSet()</code> -- 如果已将首选大小设置为非 null 值，则返回 true</p></li>
                                <li><p><code>boolean 	isMinimumSizeSet()</code> -- 是否调用了 setMinimumSize</p></li>
                                <li><p><code>boolean 	isOpaque()</code> -- 如果组件是完全不透明的，则返回 true</p></li>
                                <li><p><code>boolean 	isShowing()</code> -- 确定此组件是否在屏幕上显示</p></li>
                                <li><p><code>boolean 	isValid()</code> -- 确定组件是否有效</p></li>
                                <li><p><code>boolean 	isVisible()</code> -- 确定此组件在其父容器可见时是否应该可见</p></li>
                                <li><p><code>void 	list()</code> -- 将组件列表打印到标准系统输出流 System.out</p></li>
                                <li><p><code>void 	list(PrintStream out)</code> -- 将组件列表打印到指定的输出流</p></li>
                                <li><p><code>void 	list(PrintStream out, int indent)</code> -- 将列表从指定的缩排开始打印到指定的打印流</p></li>
                                <li><p><code>void 	list(PrintWriter out)</code> -- 将列表打印到指定的打印编写器</p></li>
                                <li><p><code>void 	list(PrintWriter out, int indent)</code> -- 将列表从指定的缩排开始打印到指定的打印编写器</p></li>
                                <li><p><code>void 	paint(Graphics g)</code> -- 绘制此组件</p></li>
                                <li><p><code>void 	paintAll(Graphics g)</code> -- 绘制此组件及其所有子组件</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回此组件状态的字符串表示形式</p></li>
                                <li><p><code>boolean 	prepareImage(Image image, ImageObserver observer)</code> -- 准备一幅在此组件上呈现的图像</p></li>
                                <li><p><code>boolean 	prepareImage(Image image, int width, int height, ImageObserver observer)</code> -- 以指定的宽度和高度准备一幅在此组件上呈现的图像</p></li>
                                <li><p><code>void 	print(Graphics g)</code> -- 打印此组件</p></li>
                                <li><p><code>void 	printAll(Graphics g)</code> -- 打印此组件及其所有子组件</p></li>



                                <li><p><code>void 	remove(MenuComponent popup)</code> -- 从组件移除指定的弹出菜单</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 通过销毁此 Component 的本机屏幕资源使其成为不可显示的</p></li>

                                <li><p><code>void 	repaint()</code> -- 重绘此组件</p></li>
                                <li><p><code>void 	repaint(int x, int y, int width, int height)</code> -- 重绘组件的指定矩形区域</p></li>
                                <li><p><code>void 	repaint(long tm)</code> --  在 tm 毫秒内重绘组件</p></li>
                                <li><p><code>void 	repaint(long tm, int x, int y, int width, int height)</code> -- 在 tm 毫秒内重绘组件的指定矩形区域</p></li>

                                <li><p><code>void 	requestFocus()</code> -- 请求此 Component 获取输入焦点</p></li>
                                <li><p><code>protected boolean 	requestFocus(boolean temporary)</code> -- 请求此 Component 获取输入焦点，并且此 Component 的顶层祖先成为获得焦点的 Window</p></li>
                                <li><p><code>boolean 	requestFocusInWindow()</code> -- 如果此 Component 的顶层祖先已经是获得焦点的 Window，则请求此 Component 获取输入焦点</p></li>
                                <li><p><code>protected boolean 	requestFocusInWindow(boolean temporary)</code> -- 如果此 Component 的顶层祖先已经是获得焦点的 Window，则请求此 Component 获取输入焦点</p></li>

                                <li><p><code>void 	revalidate()</code> -- </p></li>
                                <li><p><code>void 	setBackground(Color c)</code> -- 设置组件的背景色</p></li>
                                <li><p><code>void 	setBounds(int x, int y, int width, int height)</code> -- 移动组件并调整其大小</p></li>
                                <li><p><code>void 	setBounds(Rectangle r)</code> -- 移动组件并调整其大小，使其符合新的有界矩形 r</p></li>
                                <li><p><code>void 	setComponentOrientation(ComponentOrientation o)</code> -- 设置语言敏感的方向，用于排序此组件内的元素或文本</p></li>
                                <li><p><code>void 	setCursor(Cursor cursor)</code> -- 为指定的光标设置光标图像</p></li>
                                <li><p><code>void 	setDropTarget(DropTarget dt)</code> -- 将组件与 DropTarget 相关联</p></li>
                                <li><p><code>void 	setEnabled(boolean b)</code> -- 启用或禁用此组件</p></li>
                                <li><p><code>void 	setFocusable(boolean focusable)</code> -- 将此 Component 的焦点状态设置为指定值</p></li>
                                <li><p><code>void 	setFocusTraversalKeys(int id, Set&lt;? extends AWTKeyStroke> keystrokes)</code> -- 为此 Component 的给定遍历操作设置焦点遍历键</p></li>
                                <li><p><code>void 	setFocusTraversalKeysEnabled(boolean focusTraversalKeysEnabled)</code> -- 设置是否为此 Component 启用焦点遍历键</p></li>
                                <li><p><code>void 	setFont(Font f)</code> -- 设置组件的字体</p></li>
                                <li><p><code>void 	setForeground(Color c)</code> -- 设置组件的前景色</p></li>
                                <li><p><code>void 	setIgnoreRepaint(boolean ignoreRepaint)</code> -- 设置是否应该忽略从操作系统接受的绘制消息</p></li>
                                <li><p><code>void 	setLocale(Locale l)</code> -- 设置组件的语言环境</p></li>
                                <li><p><code>void 	setLocation(int x, int y)</code> -- 将组件移到新位置</p></li>
                                <li><p><code>void 	setLocation(Point p)</code> -- 将组件移到新位置</p></li>
                                <li><p><code>void 	setMaximumSize(Dimension maximumSize)</code> -- 将组件的最大大小设置为常量值</p></li>
                                <li><p><code>void 	setPreferredSize(Dimension preferredSize)</code> -- 将组件的首选大小设置为常量值</p></li>
                                <li><p><code>void 	setMinimumSize(Dimension minimumSize)</code> -- 将组件的最小大小设置为常量值</p></li>
                                <li><p><code>void 	setName(String name)</code> -- 将组件的名称设置为指定的字符串</p></li>
                                <li><p><code>void 	setSize(Dimension d)</code> -- 调整组件的大小</p></li>
                                <li><p><code>void 	setSize(int width, int height)</code> -- 调整组件的大小</p></li>
                                <li><p><code>void 	setVisible(boolean b)</code> -- 显示或隐藏此组件</p></li>
                                <li><p><code>String 	toString()</code> -- 返回此组件及其值的字符串表示形式</p></li>
                                <li><p><code>void 	transferFocus()</code> -- 将焦点转移到下一个组件</p></li>
                                <li><p><code>void 	transferFocusBackward()</code> -- 将焦点转移到前一个组件</p></li>
                                <li><p><code>void 	transferFocusUpCycle()</code> -- 将焦点向上转移一个焦点遍历循环</p></li>
                                <li><p><code>void 	update(Graphics g)</code> -- 更新组件</p></li>
                                <li><p><code>void 	validate()</code> -- 确保组件具有有效的布局</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-awt-LayoutManager"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">LayoutManager 及实现类(AWT)</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface LayoutManager {
    void layoutContainer(Container parent); // 指定布局容器
    void addLayoutComponent(String name, Component comp); // 添加组件到容器，并关联名字
    void removeLayoutComponent(Component comp); // 从容器移除指定组件
    Dimension minimumLayoutSize(Container parent); // 给定指定容器所包含的组件，计算该容器的最小大小维数
    Dimension preferredLayoutSize(Container parent); // 给定指定容器所包含的组件，计算该容器的首选大小维数
}

public interface LayoutManager2 extends LayoutManager {
    void addLayoutComponent(Component comp, Object constraints); // 使用指定约束对象，将指定组件添加到布局
    float getLayoutAlignmentX(Container target); // 返回指定容器沿 X 轴的对齐方式
    float getLayoutAlignmentY(Container target); // 返回指定容器沿 Y 轴的对齐方式
    void invalidateLayout(Container target); // 使容器失效
    Dimension maximumLayoutSize(Container target); // 给定指定容器的组件，计算该容器的最大大小维数
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/LayoutManager.html" target="_blank">LayoutManager</a> 定义如何布置 Container 类的接口。</p>
                            <p>Swing 的绘制架构假定 JComponent 的子组件不发生重叠。如果 JComponent 的 LayoutManager 允许子组件重叠，则 JComponent 必须重写 isOptimizedDrawingEnabled 以返回 false。 </p>
                            <p>LayoutManager & LayoutManager2 的常见实现类(<code>javax.swing</code> 包下的类这里没有列出，参见: <a href="#javax-swing-LayoutManager">SWING 中的 LayoutManager 实现类</a>)：</p>
                            <ul>
                                <li><p><a href="#BorderLayout">BorderLayout</a> -- 是边框布局。分为五个区域：NORTH、SOUTH、EAST、WEST、CENTER。NORTH 和 SOUTH 组件可以在水平方向上拉伸；而 EAST 和 WEST 组件可以在垂直方向上拉伸；CENTER 组件可同时在水平和垂直方向上拉伸，从而填充所有剩余空间。</p></li>
                                <li><p><a href="#FlowLayout">FlowLayout</a> -- 是流式布局，类似于段落中的文本行。从左到右或从右到左一次排列组件，到达边界从下一行开始排列。</p></li>
                                <li><p><a href="#GridLayout">GridLayout</a> -- 矩形网格形式对容器的组件进行布置。容器被分成大小相等的矩形，一个矩形中放置一个组件。</p></li>
                                <li><p><a href="#GridBagLayout">GridBagLayout</a> -- 是一个灵活的布局管理器(类似于单元格可以合并)，它不要求组件的大小相同便可以将组件垂直、水平或沿它们的基线对齐。每个 GridBagLayout 对象维持一个动态的矩形单元网格，每个组件占用一个或多个这样的单元，该单元被称为显示区域。 </p></li>
                                <li><p><a href="#CardLayout">CardLayout</a> -- 将容器中的每个组件看作一张卡片。一次只能看到一张卡片，容器则充当卡片的堆栈。当容器第一次显示时，第一个添加到 CardLayout 对象的组件为可见组件。 </p></li>
                            </ul>
                        </div>

                        <a id="BorderLayout" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class BorderLayout implements LayoutManager2, Serializable {
    /** 每个区域最多只能包含一个组件(Component) */
    public static final String NORTH  = "North";
    public static final String SOUTH  = "South";
    public static final String EAST   = "East";
    public static final String WEST   = "West";
    public static final String CENTER = "Center";

    /** 不同的 ComponentOrientation 会将以下常量映射到上面的不同区域 */
    public static final String BEFORE_FIRST_LINE = "First";
    public static final String AFTER_LAST_LINE = "Last";
    public static final String BEFORE_LINE_BEGINS = "Before";
    public static final String AFTER_LINE_ENDS = "After";

    public static final String PAGE_START = BEFORE_FIRST_LINE;
    public static final String PAGE_END = AFTER_LAST_LINE;
    public static final String LINE_START = BEFORE_LINE_BEGINS;
    public static final String LINE_END = AFTER_LINE_ENDS;

    public BorderLayout() {}
    public BorderLayout(int hgap, int vgap) {} // 构造一个具有指定组件间距的边框布局
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/BorderLayout.html" target="_blank">BorderLayout</a> 是边框布局，也是 Frame 的默认布局，它可以对容器组件进行安排，并调整其大小，使其符合下列五个区域：北、南、东、西、中。<b>每个区域最多只能包含一个组件</b>，并通过相应的常量进行标识：NORTH、SOUTH、EAST、WEST、CENTER。</p>
                            <p class=""><img src="images/Swing-BorderLayout.jpeg" class="center-block img-responsive"></p>
                            <p>为了方便起见，BorderLayout 将缺少字符串说明的情况解释为常量 CENTER。 </p>
                            <p>此外，BorderLayout 支持相对定位常量 PAGE_START、PAGE_END、LINE_START 和 LINE_END。在 ComponentOrientation 设置为 ComponentOrientation.LEFT_TO_RIGHT 的容器中，这些常量分别映射到 NORTH、SOUTH、WEST 和 EAST。 </p>
                            <p>为了与以前的版本兼容，BorderLayout 还包括相对定位常量 BEFORE_FIRST_LINE、AFTER_LAST_LINE、BEFORE_LINE_BEGINS 和 AFTER_LINE_ENDS。这些常量分别等同于 PAGE_START、PAGE_END、LINE_START 和 LINE_END。为了与其他组件使用的相对定位常量一致，应优先使用后一组常量。</p>
                            <p>将绝对定位常量与相对定位常量混合会产生无法预料的结果。如果两种类型的常量都使用，则优先采用相对常量。例如，如果同时使用 NORTH 和 PAGE_START 常量在方向性为 LEFT_TO_RIGHT 的容器中添加组件，则只体现 PAGE_START 布局。 </p>
                            <p><b>根据其首选大小和容器大小的约束 (constraints) 对组件进行布局。NORTH 和 SOUTH 组件可以在水平方向上拉伸；而 EAST 和 WEST 组件可以在垂直方向上拉伸；CENTER 组件可同时在水平和垂直方向上拉伸，从而填充所有剩余空间。</b> </p>
                            <ol>
                                <li><p><code>void 	addLayoutComponent(Component comp, Object constraints)</code> -- 使用指定的约束对象将指定组件添加到布局中(constraints 为其常量值)</p></li>
                                <li><p><code>void 	removeLayoutComponent(Component comp)</code> -- 从此边框布局中移除指定组件</p></li>
                                <li><p><code>Object 	getConstraints(Component comp)</code> -- 获取指定组件的约束</p></li>
                                <li><p><code>Component 	getLayoutComponent(Container target, Object constraints)</code> -- 基于目标 Container 的组件方向，返回给定约束位置对应的组件</p></li>
                                <li><p><code>Component 	getLayoutComponent(Object constraints)</code> -- 获取使用给定约束添加的组件</p></li>

                                <li class="group"><p><code>int 	getHgap()</code> -- 返回组件之间的水平间距</p></li>
                                <li><p><code>int 	getVgap()</code> -- 返回组件之间的垂直间距</p></li>
                                <li><p><code>void 	setHgap(int hgap)</code> -- 设置组件之间的水平间距</p></li>
                                <li><p><code>void 	setVgap(int vgap)</code> -- 设置组件之间的垂直间距</p></li>

                                <li class="group"><p><code>float 	getLayoutAlignmentX(Container parent)</code> -- 返回沿 x 轴的对齐方式</p></li>
                                <li><p><code>float 	getLayoutAlignmentY(Container parent)</code> -- 返回沿 y 轴的对齐方式</p></li>

                                <li class="group"><p><code>void 	invalidateLayout(Container target)</code> -- 使布局无效，指示如果布局管理器缓存了信息，则应该将其丢弃</p></li>
                                <li><p><code>void 	layoutContainer(Container target)</code> -- 使用此边框布局对容器参数进行布局</p></li>

                                <li class="group"><p><code>Dimension 	maximumLayoutSize(Container target)</code> -- 在给出指定目标容器中的组件的前提下，返回此布局的最大尺寸</p></li>
                                <li><p><code>Dimension 	preferredLayoutSize(Container target)</code> -- 基于容器中的组件，使用此布局管理器确定 target 容器的首选大小</p></li>
                                <li><p><code>Dimension 	minimumLayoutSize(Container target)</code> -- 使用此布局管理器确定 target 容器的最小大小</p></li>

                                <li class="group"><p><code>String 	toString()</code> -- 返回此边框布局的状态的字符串表示形式</p></li>
                            </ol>
                        </div>

                        <a id="FlowLayout" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class FlowLayout implements LayoutManager, Serializable {

    public static final int LEFT     = 0; // 指示每一行组件都应该是左对齐的
    public static final int CENTER   = 1; // 默认，指示每一行组件都应该是居中的
    public static final int RIGHT    = 2; // 指示每一行组件都应该是右对齐的
    public static final int LEADING  = 3; // 指示每一行组件都应该与容器方向的开始边对齐
    public static final int TRAILING = 4; // 指示每行组件都应该与容器方向的结束边对齐


    public FlowLayout() {} // 居中对齐，水平和垂直间隙为 5
    public FlowLayout(int align) {]
    public FlowLayout(int align, int hgap, int vgap) {} // 指定的对齐方式以及指定的水平和垂直间隙
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/FlowLayout.html" target="_blank">FlowLayout</a> 是流式布局，这非常类似于段落中的文本行。从左到右或从右到左一次排列组件，到达边界从下一行开始排列。</p>
                            <p>流布局把每个组件都假定为它的自然（首选）大小。 </p>
                            <ol>
                                <li><p><code>int 	getAlignment()</code> -- 获取此布局的对齐方式</p></li>
                                <li><p><code>void 	setAlignment(int align)</code> -- 设置此布局的对齐方式</p></li>
                                <li><p><code>int 	getHgap()</code> -- 获取组件之间以及组件与 Container 的边之间的水平间隙</p></li>
                                <li><p><code>void 	setHgap(int hgap)</code> -- 设置组件之间以及组件与 Container 的边之间的水平间隙</p></li>
                                <li><p><code>int 	getVgap()</code> -- 获取组件之间以及组件与 Container 的边之间的垂直间隙</p></li>
                                <li><p><code>void 	setVgap(int vgap)</code> -- 设置组件之间以及组件与 Container 的边之间的垂直间隙</p></li>

                                <li class="group"><p><code>boolean 	getAlignOnBaseline()</code> -- 如果组件将沿其基线垂直对齐，则返回 true</p></li>
                                <li><p><code>void 	setAlignOnBaseline(boolean alignOnBaseline)</code> -- 设置组件是否应该沿着其基线垂直对齐</p></li>

                                <li class="group"><p><code>void 	addLayoutComponent(String name, Component comp)</code> -- 将指定的组件添加到布局中</p></li>
                                <li><p><code>void 	removeLayoutComponent(Component comp)</code> -- 从布局中移除指定的组件</p></li>
                                <li><p><code>void 	layoutContainer(Container target)</code> -- 布置该容器</p></li>

                                <li class="group"><p><code>Dimension 	minimumLayoutSize(Container target)</code> -- 布置指定容器的子组件的最小维数</p></li>
                                <li><p><code>Dimension 	preferredLayoutSize(Container target)</code> -- 布置指定容器的子组件的首选维数</p></li>

                                <li class="group"><p><code>String 	toString()</code> -- 返回此 FlowLayout 对象及其值的字符串表示形式</p></li>
                            </ol>
                        </div>

                        <a id="GridLayout" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class GridLayout implements LayoutManager, Serializable {
    public GridLayout() {} // 单行无间距
    public GridLayout(int rows, int cols) {}
    public GridLayout(int rows, int cols, int hgap, int vgap) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/GridLayout.html" target="_blank">GridLayout</a> 以矩形网格形式对容器的组件进行布置。容器被分成大小相等的矩形，一个矩形中放置一个组件。</p>
                            <p><b>通过构造方法或 setRows 和 setColumns 方法将行数和列数都设置为非零值时，指定的列数将被忽略。列数通过指定的行数和布局中的组件总数来确定。因此，例如，如果指定了三行和两列，在布局中添加了九个组件，则它们将显示为三行三列。仅当将行数设置为零时，指定列数才对布局有效。</b></p>
                            <ol>
                                <li><p><code>int 	getColumns()</code> -- 获取此布局中的列数</p></li>
                                <li><p><code>void 	setColumns(int cols)</code> -- 将此布局中的列数设置为指定值</p></li>
                                <li><p><code>int 	getRows()</code> -- 获取此布局中的行数</p></li>
                                <li><p><code>void 	setRows(int rows)</code> -- 将此布局中的行数设置为指定值</p></li>

                                <li class="group"><p><code>int 	getHgap()</code> -- 获取组件之间的水平间距</p></li>
                                <li><p><code>void 	setHgap(int hgap)</code> -- 将组件之间的水平间距设置为指定值</p></li>
                                <li><p><code>int 	getVgap()</code> -- 获取组件之间的垂直间距</p></li>
                                <li><p><code>void 	setVgap(int vgap)</code> -- 将组件之间的垂直间距设置为指定值</p></li>

                                <li class="group"><p><code>void 	addLayoutComponent(String name, Component comp)</code> -- 将具有指定名称的指定组件添加到布局</p></li>
                                <li><p><code>void 	removeLayoutComponent(Component comp)</code> -- 从布局移除指定组件</p></li>

                                <li class="group"><p><code>void 	layoutContainer(Container parent)</code> -- 使用此布局布置指定容器</p></li>
                                <li><p><code>Dimension 	minimumLayoutSize(Container parent)</code> -- 使用此网络布局确定最小大小的容器参数</p></li>
                                <li><p><code>Dimension 	preferredLayoutSize(Container parent)</code> -- 使用此网格布局确定容器参数的首选大小</p></li>

                                <li class="group"><p><code>String 	toString()</code> -- 返回此网格布局的值的字符串表示形式</p></li>
                            </ol>
                        </div>

                        <a id="GridBagLayout" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class GridBagLayout implements LayoutManager2, Serializable {
    public int columnWidths[];      // 保存对列最小宽度的重写
    public double columnWeights[];  // 保存对列权重的重写
    public int rowHeights[];        // 保存对行最小高度的重写
    public double rowWeights[];     // 保存对行权重的重写

    protected static final int MAXGRIDSIZE = 512;
    protected static final int MINSIZE = 1;
    protected static final int PREFERREDSIZE = 2;

    protected Hashtable&lt;Component,GridBagConstraints> comptable;
    protected GridBagConstraints defaultConstraints;
    protected GridBagLayoutInfo layoutInfo;
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/GridBagLayout.html" target="_blank">GridBagLayout</a> 是一个灵活的布局管理器(类似于单元格可以合并)，它不要求组件的大小相同便可以将组件垂直、水平或沿它们的基线对齐。每个 GridBagLayout 对象维持一个动态的矩形单元网格，每个组件占用一个或多个这样的单元，该单元被称为显示区域。</p>
                            <p>每个由 GridBagLayout 管理的组件都与 GridBagConstraints 的实例相关联。Constraints 对象指定组件的显示区域在网格中的具体放置位置，以及组件在其显示区域中的放置方式。除了 Constraints 对象之外，GridBagLayout 还考虑每个组件的最小大小和首选大小，以确定组件的大小。 </p>
                            <p>网格的总体方向取决于容器的 ComponentOrientation 属性。对于水平的从左到右的方向，网格坐标 (0,0) 位于容器的左上角，其中 X 向右递增，Y 向下递增。对于水平的从右到左的方向，网格坐标 (0,0) 位于容器的右上角，其中 X 向左递增，Y 向下递增。 </p>
                            <ol>
                                <li><p><code>void 	addLayoutComponent(Component comp, Object constraints)</code> -- 使用指定 constraints 对象将指定组件添加到布局中(constraints 参数必须是 GridBagConstraints 的实例)</p>
                                    <pre class="brush: java;">
public class GridBagConstraints implements Cloneable, Serializable {
    /** fill 字段使用常量 */
    public static final int NONE = 0;        // 默认值，不伸升组件
    public static final int BOTH = 1;        // 横纵向都拉伸
    public static final int HORIZONTAL = 2;  // 横向都拉伸
    public static final int VERTICAL = 3;    // 纵向都拉伸

    // 用于 gridwidth, gridheight 字段值, 指定此组件是其行或列中的最后一个组件
    public static final int REMAINDER = 0;
    // 用于 gridwidth, gridheight 表示倒数第二个组件，用于 gridx, gridy 表示紧跟在以前添加的组件之后
    public static final int RELATIVE = -1;

    /** 用于 anthor 字段常量值，绝对位置 */
    public static final int NORTH = 11;       // 上
    public static final int SOUTH = 15;       // 下
    public static final int WEST = 17;        // 左
    public static final int EAST = 13;        // 右
    public static final int CENTER = 10;      // 中
    public static final int NORTHWEST = 18;   // 左上
    public static final int SOUTHWEST = 16;   // 左下
    public static final int NORTHEAST = 12;   // 右上
    public static final int SOUTHEAST = 14;   // 右下

    /** 用于 anthor 字段常量值，相对于方向的值(根据 ComponentOrientation 映射) */
    public static final int PAGE_START = 19;  // 映射到 上
    public static final int PAGE_END = 20;    // 映射到 下
    public static final int LINE_START = 21;  // 映射到 左/右
    public static final int LINE_END = 22;    // 映射到 右/左
    public static final int FIRST_LINE_START = 23;   // 映射到 左上/右上
    public static final int FIRST_LINE_END = 24;     // 映射到 右上/左上
    public static final int LAST_LINE_START = 25;    // 映射到 左下/右下
    public static final int LAST_LINE_END = 26;      // 映射到 右下/左下

    /** 用于 anthor 字段常量值，相对于基线的值 */
    public static final int BASELINE = 0x100;
    public static final int BASELINE_LEADING = 0x200;
    public static final int BASELINE_TRAILING = 0x300;
    public static final int ABOVE_BASELINE = 0x400;
    public static final int ABOVE_BASELINE_LEADING = 0x500;
    public static final int ABOVE_BASELINE_TRAILING = 0x600;
    public static final int BELOW_BASELINE = 0x700;
    public static final int BELOW_BASELINE_LEADING = 0x800;
    public static final int BELOW_BASELINE_TRAILING = 0x900;

    public int fill;       // 指定当组件大小小于单元格大小时的拉伸操作(参见常量)
    public int anchor;     // 指定当组件大小小于单元格大小时的位置(参见常量)
    public int gridwidth;  // 指定组件占用某一行的单元格数量
    public int gridheight; // 指定组件占用某一列的单元格数量
    public int gridx;      // 组件单元格的 x 坐标(如果此数大于已有的横向单元格数量，那么单元横向格数量将会 + 1)
    public int gridy;      // 组件单元格的 y 坐标(如果此数大于已有的纵向单元格数量，那么单元纵向格数量将会 + 1)
    public Insets insets;  // 组件的外部填充(margin)，可以分别指定其上下左右的边距
    public int ipadx;      // 组件 X 方向的内部填充(padding)
    public int ipady;      // 组件 Y 方向的内部填充(padding)
    public double weightx; // X 方向的重力指数
    public double weighty; // Y 方向的重力指数

    public GridBagConstraints () {}

    public GridBagConstraints(int gridx, int gridy, int gridwidth, int gridheight, double weightx,
            double weighty, int anchor, int fill, Insets insets, int ipadx, int ipady) {}
}
</pre>
                                </li>
                                <li><p><code>void 	addLayoutComponent(String name, Component comp)</code> -- 此方法为空方法</p></li>
                                <li><p><code>void 	removeLayoutComponent(Component comp)</code> -- 从此布局移除指定组件</p></li>

                                <li class="group"><p><code>GridBagConstraints 	getConstraints(Component comp)</code> -- 获取指定组件的约束</p></li>
                                <li><p><code>void 	setConstraints(Component comp, GridBagConstraints constraints)</code> -- 设置此布局中指定组件的约束条件</p></li>

                                <li class="group"><p><code>protected void 	adjustForGravity(GridBagConstraints constraints, Rectangle r)</code> -- 根据约束几何结构和填充将 x、y、宽度和高度四个字段调整为正确值</p></li>
                                <li><p><code>protected void 	AdjustForGravity(GridBagConstraints constraints, Rectangle r)</code> -- 应使用上面方法</p></li>
                                <li><p><code>protected void 	arrangeGrid(Container parent)</code> -- 布置网格</p></li>
                                <li><p><code>protected void 	ArrangeGrid(Container parent)</code> -- 应使用上面方法</p></li>

                                <li class="group"><p><code>float 	getLayoutAlignmentX(Container parent)</code> -- 返回沿 X 轴的对齐方式</p></li>
                                <li><p><code>float 	getLayoutAlignmentY(Container parent)</code> -- 返回沿 y 轴的对齐方式</p></li>
                                <li><p><code>int[][] 	getLayoutDimensions()</code> -- 确定布局网格的列宽度和行高度</p></li>
                                <li><p><code>Point 	getLayoutOrigin()</code> -- 在目标容器的图形坐标空间确定布局区域的原点</p></li>
                                <li><p><code>double[][] 	getLayoutWeights()</code> -- 确定布局网格的行与列的权重</p></li>
                                <li><p><code>protected Dimension 	getMinSize(Container parent, GridBagLayoutInfo info)</code> -- 基于 getLayoutInfo 中的信息计算其所有者的最小大小</p></li>
                                <li><p><code>protected Dimension 	GetMinSize(Container parent, GridBagLayoutInfo info)</code> -- 应使用上面方法</p></li>
                                <li><p><code>Point 	location(int x, int y)</code> -- 确定在布局网格中哪个单元包含由 (x, y) 指定的点</p></li>

                                <li class="group"><p><code>Dimension 	maximumLayoutSize(Container target)</code> -- 在给出指定目标容器中的组件的前提下，返回此布局的最大维数</p></li>
                                <li><p><code>Dimension 	minimumLayoutSize(Container parent)</code> -- 使用此网格包布局确定 parent 容器的最小大小</p></li>
                                <li><p><code>Dimension 	preferredLayoutSize(Container parent)</code> -- 使用此网络包布局确定 parent 容器的首选大小</p></li>

                                <li class="group"><p><code>protected GridBagLayoutInfo 	getLayoutInfo(Container parent, int sizeflag)</code> -- 为当前受管子级的集合填充 GridBagLayoutInfo 的实例</p></li>
                                <li><p><code>protected GridBagLayoutInfo 	GetLayoutInfo(Container parent, int sizeflag)</code> -- 应使用上面方法</p></li>
                                <li><p><code>protected GridBagConstraints 	lookupConstraints(Component comp)</code> -- 检索指定组件的约束</p></li>

                                <li class="group"><p><code>void 	layoutContainer(Container parent)</code> -- 使用此网格包布局布置指定容器</p></li>
                                <li><p><code>void 	invalidateLayout(Container target)</code> -- 使布局失效，指示如果布局管理器缓存了信息，则应该将其丢弃</p></li>
                                <li><p><code>String 	toString()</code> -- 返回此网格包布局的值的字符串表示形式</p></li>
                            </ol>
                            <p><b>GridBagLayout 实例:</b></p>
                            <p><img src="images/GridBagLayout.png" class="img-responsive center-block"></p>
                            <div class="panel panel-default">
                                <div class="panel-heading">
                                    <a data-toggle="collapse" data-parent="#accordion" href="#GridBasLayout-Example" aria-expanded="false" class="code-header collapsed">
                                        <span class="glyphicon glyphicon-plus"></span> View Code
                                    </a>
                                </div>
                                <div id="GridBasLayout-Example" class="panel-collapse collapse" style="height: 0px;" aria-expanded="false">
                                    <pre class="brush: java;">
public class GridBagPanel extends Panel {
    private GridBagConstraints c;
    private GridBagLayout mLayout;

    public GridBagPanel() {
        c = new GridBagConstraints();
        mLayout = new GridBagLayout();
        setLayout(mLayout);
    }

    public Panel example() {
        c.ipadx = 20; // 指定每个组件 X 方向的填充
        c.ipady = 10; // 指定每个组件 Y 方向的填充
        c.insets = new Insets(5, 5, 5,5); // 指定每个组件外边距

        c.fill = GridBagConstraints.BOTH; // 横纵向都拉伸组件
        c.weightx = 1.0; // x 方向比重设置为 1
        addCompent(new Button("Button1"));
        addCompent(new Button("Button2"));
        addCompent(new Button("Button3"));

        c.gridwidth = GridBagConstraints.REMAINDER; // 在行的最后位置
        addCompent(new Button("Button4"));

        c.weightx = 0.0; // 重置 X 方向比重
        addCompent(new Button("Button5"));

        c.gridwidth = GridBagConstraints.RELATIVE; // 在行的倒数第二位
        addCompent(new Button("Button6"));

        c.gridwidth = GridBagConstraints.REMAINDER; // 在行的最后位置
        addCompent(new Button("Button7"));

        c.gridwidth = 1; // 重置为默认
        c.gridheight = 2; // 这里占用两行，因此后面可以添加两个单行的组件
        c.weighty = 1.0;
        addCompent(new Button("Button8"));

        c.weighty = 0.0; // 重置为默认
        c.gridwidth = GridBagConstraints.REMAINDER; // 在行的最后位置
        c.gridheight = 1; // 重置为默认
        addCompent(new Button("Button9"));
        addCompent(new Button("Button10"));

        addCompent(new Button("Button11"));

        return this;
    }

    public void addCompent(Component component) {
        mLayout.setConstraints(component, c);
        add(component);
    }
}
</pre>
                                </div>
                            </div>
                        </div>

                        <a id="CardLayout" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public class CardLayout implements LayoutManager2, Serializable {
    public CardLayout() {}
    public CardLayout(int hgap, int vgap) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/CardLayout.html" target="_blank">CardLayout</a> 容器中的每个组件看作一张卡片(类似 Android 的 Gallery 组件)。一次只能看到一张卡片，容器则充当卡片的堆栈。当容器第一次显示时，第一个添加到 CardLayout 对象的组件为可见组件。 </p>
                            <p>卡片的顺序由组件对象本身在容器内部的顺序决定。CardLayout 定义了一组方法，这些方法允许应用程序按顺序地浏览这些卡片，或者显示指定的卡片。</p>
                            <ol>
                                <li><p><code>void 	addLayoutComponent(Component comp, Object constraints)</code> -- 将指定的组件添加到此卡片布局的内部名称表(constraints 是 String 的实例)</p></li>
                                <li><p><code>void 	removeLayoutComponent(Component comp)</code> -- 从布局中移除指定的组件</p></li>
                                <li><p><code>void 	layoutContainer(Container parent)</code> -- 使用此卡片布局布置指定的容器</p></li>
                                <li><p><code>void 	invalidateLayout(Container target)</code> -- 使布局无效，指示如果布局管理器缓存了信息，则应该将其丢弃</p></li>

                                <li class="group"><p><code>void 	first(Container parent)</code> -- 翻转到容器的第一张卡片</p></li>
                                <li><p><code>void 	previous(Container parent)</code> -- 翻转到指定容器的前一张卡片</p></li>
                                <li><p><code>void 	next(Container parent)</code> -- 翻转到指定容器的下一张卡片</p></li>
                                <li><p><code>void 	last(Container parent)</code> -- 翻转到容器的最后一张卡片</p></li>
                                <li><p><code>void 	show(Container parent, String name)</code> -- 翻转到使用 addLayoutComponent 添加到此布局的具有指定 name 的组件</p></li>

                                <li class="group"><p><code>int 	getHgap()</code> -- 获取组件之间的水平间距</p></li>
                                <li><p><code>void 	setHgap(int hgap)</code> -- 设置组件之间的水平间距</p></li>
                                <li><p><code>int 	getVgap()</code> -- 获取组件之间的垂直间距</p></li>
                                <li><p><code>void 	setVgap(int vgap)</code> -- 设置组件之间的垂直间距</p></li>

                                <li class="group"><p><code>float 	getLayoutAlignmentX(Container parent)</code> -- 返回沿 x 轴的对齐方式</p></li>
                                <li><p><code>float 	getLayoutAlignmentY(Container parent)</code> -- 返回沿 y 轴的对齐方式</p></li>

                                <li class="group"><p><code>Dimension 	maximumLayoutSize(Container target)</code> -- 给出指定目标容器中的组件，返回此布局的最大尺寸</p></li>
                                <li><p><code>Dimension 	preferredLayoutSize(Container parent)</code> -- 使用此卡片布局确定容器参数的首选大小</p></li>
                                <li><p><code>Dimension 	minimumLayoutSize(Container parent)</code> -- 计算指定面板大小的最小值</p></li>

                                <li class="group"><p><code>String 	toString()</code> -- 返回此卡片布局状态的字符串表示形式</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-awt-MenuComponent"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">MenuComponent 及子类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
MenuComponent
 ├ MenuBar implements MenuContainer -- 整个菜单栏
 └ MenuItem  -- 单个菜单项
    ├ Menu implements MenuContainer -- 一组(一列)菜单栏
    ├   └ PopupMenu -- 弹出式菜单(点击可以弹出下一级菜单)
    └ CheckboxMenuItem implements ItemSelectable -- 复选框菜单

public abstract class MenuComponent implements Serializable {
    /**  用于为可访问性提供默认支持的 MenuComponent 的内部类 */
    protected abstract class AccessibleAWTMenuComponent extends AccessibleContext
        implements Serializable, AccessibleComponent, AccessibleSelection {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/MenuComponent.html" target="_blank">MenuComponent</a> 是所有与菜单相关的组件的超类。在这一方面，类 MenuComponent 与 AWT 组件的抽象超类 Component 相似。 </p>
                            <p>菜单组件接收并处理 AWT 事件，就像组件通过方法 processEvent 执行的操作一样。</p>
                            <ol>
                                <li><p><code>Font 	getFont()</code> -- 获取用于此菜单组件的字体</p></li>
                                <li><p><code>void 	setFont(Font f)</code> -- 将用于此菜单组件的字体设置为指定字体</p></li>
                                <li><p><code>String 	getName()</code> -- 获取该菜单组件的名称</p></li>
                                <li><p><code>void 	setName(String name)</code> -- 将该组件的名称设置为指定字符串</p></li>

                                <li class="group"><p><code>void 	dispatchEvent(AWTEvent e)</code> -- 将事件传递给此组件或其子组件之一</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理发生在此菜单组件上的事件</p></li>

                                <li class="group"><p><code>MenuContainer 	getParent()</code> -- 返回此菜单组件的父容器</p></li>
                                <li><p><code>protected Object 	getTreeLock()</code> -- 获取此组件的锁定对象</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此 MenuComponent 状态的字符串</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 移除该菜单组件的同位体</p></li>

                                <li class="group"><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 MenuComponent 关联的 AccessibleContext</p></li>
                                <li><p><code>String 	toString()</code> -- 返回此菜单组件的表示形式</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class MenuBar extends MenuComponent implements MenuContainer, Accessible {
    /** 菜单栏的内部类，用于为可访问性提供默认支持 */
    protected class AccessibleAWTMenuBar extends AccessibleAWTMenuComponent {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/MenuBar.html" target="_blank">MenuBar</a> 类封装绑定到框架的菜单栏的平台概念。为了将该菜单栏与 Frame 对象关联，可以调用该框架的 setMenuBar 方法。 </p>
                            <ol>
                                <li><p><code>Menu 	add(Menu m)</code> -- 将指定的菜单添加到菜单栏</p></li>
                                <li><p><code>void 	remove(int index)</code> -- 从此菜单栏移除指定索引处的菜单</p></li>
                                <li><p><code>void 	remove(MenuComponent m)</code> -- 从此菜单栏移除指定的菜单组件</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建该菜单栏的同位体</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 移除该菜单栏的同位体</p></li>

                                <li class="group"><p><code>MenuItem 	getShortcutMenuItem(MenuShortcut s)</code> -- 获取与指定 MenuShortcut 对象关联的 MenuItem 的实例</p></li>
                                <li><p><code>void 	deleteShortcut(MenuShortcut s)</code> -- 删除指定的菜单快捷方式</p></li>
                                <li><p><code>Enumeration&lt;MenuShortcut> 	shortcuts()</code> -- 获取此菜单栏正在管理的所有菜单快捷方式的枚举</p></li>

                                <li class="group"><p><code>Menu 	getMenu(int i)</code> -- 获取指定的菜单</p></li>
                                <li><p><code>int 	getMenuCount()</code> -- 获取该菜单栏上的菜单数</p></li>
                                <li><p><code>Menu 	getHelpMenu()</code> -- 获取该菜单栏上的帮助菜单</p></li>
                                <li><p><code>void 	setHelpMenu(Menu m)</code> -- 将指定的菜单设置为此菜单栏的帮助菜单</p></li>

                                <li class="group"><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此菜单栏关联的 AccessibleContext</p></li>

                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class MenuItem extends MenuComponent implements Accessible {
    /** 用于为可访问性提供默认支持的 MenuItem 的内部类 */
    protected class AccessibleAWTMenuItem extends AccessibleAWTMenuComponent
        implements AccessibleAction, AccessibleValue {}

    public MenuItem() {}
    public MenuItem(String label) {}
    public MenuItem(String label, MenuShortcut s) {} // 创建具有关联的键盘快捷方式的菜单项
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/MenuItem.html" target="_blank">MenuItem</a> 菜单中的所有项必须属于类 MenuItem 或其子类之一。</p>
                            <p>默认的 MenuItem 对象包含一个简单的加标签的菜单项。 </p>
                            <p>选择菜单项时，AWT 发送一个动作事件到该菜单项。由于该事件是一个 ActionEvent 实例，processEvent 方法会检查该事件，并将它传递到 processActionEvent。后一方法将该事件重定向到任何 ActionListener 对象，该对象已在由此菜单项生成的动作事件中注册权益。</p>
                            <ol>
                                <li><p><code>void 	addActionListener(ActionListener l)</code> -- 添加指定的动作侦听器，以从此菜单项接收动作事件</p></li>
                                <li><p><code>void 	removeActionListener(ActionListener l)</code> -- 移除指定的动作侦听器</p></li>
                                <li><p><code>ActionListener[] 	getActionListeners()</code> -- 返回在此菜单项上注册的所有动作侦听器组成的数组</p></li>

                                <li class="group"><p><code>protected void 	processActionEvent(ActionEvent e)</code> -- 处理此菜单项上发生的动作事件</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此菜单项上的事件</p></li>
                                <li><p><code>protected void 	disableEvents(long eventsToDisable)</code> -- 禁止将事件提交到将由指定事件掩码参数定义的事件的菜单项</p></li>
                                <li><p><code>protected void 	enableEvents(long eventsToEnable)</code> -- 允许将事件提交到将由指定事件掩码参数定义的事件的菜单项</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前在此 MenuItem 上注册为 FooListener 的所有对象组成的数组</p></li>

                                <li class="group"><p><code>String 	getActionCommand()</code> -- 获取由此菜单项引发的动作事件的命令名</p></li>
                                <li><p><code>void 	setActionCommand(String command)</code> -- 设置由此菜单项引发的动作事件的命令名</p></li>
                                <li><p><code>String 	getLabel()</code> -- 获取此菜单项的标签</p></li>
                                <li><p><code>void 	setLabel(String label)</code> -- 将此菜单项的标签设置为指定标签</p></li>
                                <li><p><code>MenuShortcut 	getShortcut()</code> -- 获取与此菜单项关联的 MenuShortcut 对象</p></li>
                                <li><p><code>boolean 	isEnabled()</code> -- 检查是否启用了此菜单项</p></li>
                                <li><p><code>void 	setEnabled(boolean b)</code> -- 设置是否可以选择此菜单项</p></li>
                                <li><p><code>void 	setShortcut(MenuShortcut s)</code> -- 设置与此菜单项关联的 MenuShortcut 对象</p></li>
                                <li><p><code>void 	deleteShortcut()</code> -- 删除与此菜单项关联的任何 MenuShortcut 对象</p></li>

                                <li class="group"><p><code>String 	paramString()</code> -- 返回表示此 MenuItem 状态的字符串</p></li>
                                <li><p><code>void 	addNotify()</code> -- 创建该菜单项的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此菜单项关联的 AccessibleContext</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Menu extends MenuItem implements MenuContainer, Accessible {
    /** 菜单的内部类，用于为可访问性提供默认支持 */
    protected class AccessibleAWTMenu extends AccessibleAWTMenuItem {}

    public Menu() {}
    public Menu(String label) {}
    public Menu(String label, boolean tearOff) {} // 指示该菜单是否可以分离(AWT 的所有实现都不支持分离功能)
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Menu.html" target="_blank">Menu</a> 对象是从菜单栏部署的下拉式菜单组件。 </p>
                            <p>菜单可以是任意分离式 菜单。可以打开分离式菜单，并从其父菜单栏或菜单中拖开。释放鼠标按钮之后，它仍然在屏幕上。分离菜单的机制与平台有关，因为分离式菜单的外观由其同位体确定。对于不支持分离式菜单的平台，分离属性会被忽略。 </p>
                            <p>菜单中的每一项都必须属于 MenuItem 类。它可以是 MenuItem 的一个实例、子菜单（Menu 的一个实例）、或复选框（CheckboxMenuItem 的一个实例）。 </p>
                            <ol>
                                <li><p><code>MenuItem 	add(MenuItem mi)</code> -- 将指定的菜单项添加到此菜单</p></li>
                                <li><p><code>void 	add(String label)</code> -- 调用 <code>add(new MenuItem(label))</code></p></li>
                                <li><p><code>void 	insert(MenuItem menuitem, int index)</code> -- 将菜单项插入到此菜单的指定位置</p></li>
                                <li><p><code>void 	insert(String label, int index)</code> -- 调用 <code>insert(new MenuItem(label), index)</code></p></li>
                                <li><p><code>void 	insertSeparator(int index)</code> -- 将一个分隔线插入到此菜单的指定位置</p></li>
                                <li><p><code>void 	addSeparator()</code> -- 将一个分隔线添加到菜单的当前位置</p></li>

                                <li class="group"><p><code>void 	remove(int index)</code> -- 从此菜单移除指定索引处的菜单项</p></li>
                                <li><p><code>void 	remove(MenuComponent item)</code> -- 从此菜单移除指定的菜单项</p></li>
                                <li><p><code>void 	removeAll()</code> -- 从此菜单移除所有项</p></li>
                                <li><p><code>MenuItem 	getItem(int index)</code> -- 获取此菜单的指定索引处的项</p></li>
                                <li><p><code>int 	getItemCount()</code> -- 获取此菜单中的项数</p></li>

                                <li><p><code>void 	addNotify()</code> -- 创建该菜单的同位体</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 移除该菜单的同位体</p></li>

                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此菜单关联的 AccessibleContext</p></li>
                                <li><p><code>boolean 	isTearOff()</code> -- 指示此菜单是否为分离式菜单(AWT 的所有实现都不支持分离功能)</p></li>
                                <li><p><code>String 	paramString()</code> -- 返回表示此 Menu 状态的字符串</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class PopupMenu extends Menu {
    /** 用于为可访问性提供默认支持的 PopupMenu 的内部类 */
    protected class AccessibleAWTPopupMenu extends AccessibleAWTMenu {}

    public PopupMenu() {}
    public PopupMenu(String label) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/PopupMenu.html" target="_blank">PopupMenu</a> 实现能够在组件中的指定位置上动态弹出的菜单。</p>
                            <p>正如继承层次关系所暗示的那样，任何可以使用 Menu 的地方都可以使用 PopupMenu。但是，如果使用像 Menu 这样的 PopupMenu（例如，将其添加到 MenuBar），则不能调用该 PopupMenu 的 show。 </p>
                            <ol>
                                <li><p><code>void 	addNotify()</code> -- 创建弹出式菜单的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 PopupMenu 关联的 AccessibleContext</p></li>
                                <li><p><code>MenuContainer 	getParent()</code> -- 返回此菜单组件的父容器</p></li>
                                <li><p><code>void 	show(Component origin, int x, int y)</code> -- 在相对于初始组件的 x、y 位置上显示弹出式菜单</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class CheckboxMenuItem extends MenuItem implements ItemSelectable, Accessible {
    /** 用来为可访问性提供默认支持的 CheckboxMenuItem 的内部类 */
    protected class AccessibleAWTCheckboxMenuItem extends AccessibleAWTMenuItem
                implements AccessibleAction, AccessibleValue{}

    public CheckboxMenuItem() {}
    public CheckboxMenuItem(String label) {}
    public CheckboxMenuItem(String label, boolean state) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/CheckboxMenuItem.html" target="_blank">CheckboxMenuItem</a> 表示一个可包括在菜单中的复选框。</p>
                            <p>当选定一个复选框菜单项时，AWT 将一个项事件发送到该项。因为该事件是 ItemEvent 的一个实例，所以 processEvent 方法检查该事件，同时将它传递给 processItemEvent。后一种方法将该事件重定向到任何为关注此菜单项生成的项事件而注册的 ItemListener 对象。 </p>
                            <ol>
                                <li><p><code>void 	addItemListener(ItemListener l)</code> -- 添加指定的动作侦听器，以从此菜单项接收动作事件</p></li>
                                <li><p><code>void 	removeItemListener(ItemListener l)</code> -- 移除指定的动作侦听器</p></li>
                                <li><p><code>ItemListener[] 	getItemListeners()</code> -- 返回在此菜单项上注册的所有动作侦听器组成的数组</p></li>

                                <li class="group"><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此菜单项上的事件</p></li>
                                <li><p><code>protected void 	processItemEvent(ItemEvent e)</code> -- </p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前在此 MenuItem 上注册为 FooListener 的所有对象组成的数组</p></li>

                                <li class="group"><p><code>boolean 	getState()</code> -- 获取复选框的状态</p></li>
                                <li><p><code>void 	setState(boolean b)</code> -- 将此复选框菜单项设置为指定的状态</p></li>
                                <li><p><code>Object[] 	getSelectedObjects()</code> -- 返回数组(长度为 1)，它包含复选框菜单项的标签;如果没有选中复选框，则返回 null</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建该菜单项的同位体</p></li>
                                <li><p><code>String 	paramString()</code> -- 返回表示此 MenuItem 状态的字符串</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此菜单项关联的 AccessibleContext</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->

                <a class="offset" id="java-awt-Container"></a>
                <div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Container 的子类</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public class Panel extends Container implements Accessible {
    /** 此类实现 Panel 类的可访问性支持 */
    protected class AccessibleAWTPanel extends AccessibleAWTContainer {}

    public Panel() {} // 默认布局管理器是 FlowLayout
    public Panel(LayoutManager layout) {} // 创建具有指定布局管理器的新面板
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Panel.html" target="_blank">Panel</a> 是最简单的容器类。应用程序可以将其他组件放在面板提供的空间内，这些组件包括其他面板。 </p>
                            <p>Panel 的默认布局管理器是 FlowLayout 布局管理器。</p>
                            <p><code>Window</code> 也是 Container 的子类，<code>Frame</code> 是 Window 的子类。</p>
                            <ol>
                                <li><p><code>void 	addNotify()</code> -- 创建 Panel 的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与 Panel 相关的 AccessibleContext</p></li>
                            </ol>
                        </div>



                        <div class="sub-item">
                            <pre class="brush: java;">
public class ScrollPane extends Container implements Accessible {
    /** 可访问性支持 */
    protected class AccessibleAWTScrollPane extends AccessibleAWTContainer {}

    /** 滚动条显示模式 */
    public static final int SCROLLBARS_AS_NEEDED = 0; // 默认,子组件的大小超过了滚动窗格尺寸时显示
    public static final int SCROLLBARS_ALWAYS = 1;    // 总是显示
    public static final int SCROLLBARS_NEVER = 2;     // 永不显示

    public ScrollPane() {}
    public ScrollPane(int scrollbarDisplayPolicy) {} // 指定滚动条显示模式
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/ScrollPane.html" target="_blank">ScrollPane</a> 实现用于单个子组件的自动水平和/或垂直滚动的容器类。</p>
                            <p>ScrollPane 不可设置布局，只能容纳一个组件，添加新的组件会将原来的组件移除。</p>
                            <ol>
                                <li><p><code>int 	getScrollbarDisplayPolicy()</code> -- 返回滚动条的显示策略</p></li>

                                <li class="group"><p><code>Dimension 	getViewportSize()</code> -- 返回滚动条窗格视口的当前大小</p></li>
                                <li><p><code>int 	getHScrollbarHeight()</code> -- 返回水平滚动条占用的高度，它与当前是否由滚动窗格显示无关</p></li>
                                <li><p><code>int 	getVScrollbarWidth()</code> -- 返回垂直滚动条占用的宽度，它与当前是否由滚动窗格显示无关</p></li>
                                <li><p><code>Adjustable 	getHAdjustable()</code> -- 返回表示水平滚动条状态的 ScrollPaneAdjustable 对象</p></li>
                                <li><p><code>Adjustable 	getVAdjustable()</code> -- 返回表示垂直滚动条状态的 ScrollPaneAdjustable 对象</p></li>

                                <li class="group"><p><code>Point 	getScrollPosition()</code> -- 返回子组件中的当前 x,y 位置，子组件显示在滚动窗格视口的 0,0 位置</p></li>
                                <li><p><code>void 	setScrollPosition(int x, int y)</code> -- 滚动到子组件中的指定位置</p></li>
                                <li><p><code>void 	setScrollPosition(Point p)</code> -- 滚动到子组件中的指定位置</p></li>

                                <li class="group"><p><code>boolean 	isWheelScrollingEnabled()</code> -- 指示是否进行滚动来响应鼠标滚轮</p></li>
                                <li><p><code>void 	setWheelScrollingEnabled(boolean handleWheel)</code> -- 启用/禁用对鼠标滚轮滚动的移动响应</p></li>

                                <li class="group"><p><code>protected void 	addImpl(Component comp, Object constraints, int index)</code> -- 将指定的组件添加到此滚动窗格容器</p></li>
                                <li><p><code>void 	doLayout()</code> -- 通过将子组件的大小调整为其首选大小来布置此容器</p></li>
                                <li><p><code>void 	printComponents(Graphics g)</code> -- 显示此滚动窗格中的组件</p></li>
                                <li><p><code>protected boolean 	eventTypeEnabled(int type)</code> -- 如果启用滚轮滚动，则对 MouseWheelEvents 返回 true</p></li>
                                <li><p><code>protected void 	processMouseWheelEvent(MouseWheelEvent e)</code> -- 处理通过滚动适当量而传递给此 ScrollPane 的鼠标滚轮事件</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建滚动窗格的同位体</p></li>
                                <li><p><code>void 	setLayout(LayoutManager mgr)</code> -- 设置此容器的布局管理器(不允许，抛出异常)</p></li>
                                <li><p><code>String 	paramString()</code> -- 返回表示此 ScrollPane 的状态的字符串</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 ScrollPane 相关的 AccessibleContext</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Applet extends Panel {
    /** 可访问性支持 */
    protected class AccessibleApplet extends AccessibleAWTPanel {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Applet.html" target="_blank">Applet</a> 是一种不能单独运行但可嵌入在其他应用程序中的小程序。 </p>
                            <p>Applet 类必须是任何嵌入 Web 页或可用 Java Applet Viewer 查看的 applet 的超类。Applet 类提供了 applet 及其运行环境之间的标准接口。</p>
                            <ol>
                                <li><p><code>static AudioClip 	newAudioClip(URL url)</code> -- 从给定 URL 处获取音频剪辑</p></li>

                                <li class="group"><p><code>void 	play(URL url)</code> -- 播放指定绝对 URL 处的音频剪辑</p></li>
                                <li><p><code>void 	play(URL url, String name)</code> -- 播放音频剪辑，给定了 URL 及与之相对的说明符</p></li>
                                <li><p><code>AudioClip 	getAudioClip(URL url)</code> -- 返回 URL 参数指定的 AudioClip 对象</p></li>
                                <li><p><code>AudioClip 	getAudioClip(URL url, String name)</code> -- 返回 URL 和 name 参数指定的 AudioClip 对象</p></li>

                                <li class="group"><p><code>Image 	getImage(URL url)</code> -- 返回能被绘制到屏幕上的 Image 对象</p></li>
                                <li><p><code>Image 	getImage(URL url, String name)</code> -- 返回能被绘制到屏幕上的 Image 对象</p></li>

                                <li class="group"><p><code>AppletContext 	getAppletContext()</code> -- 确定此 applet 的上下文，上下文允许 applet 查询和影响它所运行的环境</p></li>
                                <li><p><code>String 	getAppletInfo()</code> -- 返回有关此 applet 的信息</p></li>
                                <li><p><code>URL 	getCodeBase()</code> -- 获得基 URL</p></li>
                                <li><p><code>URL 	getDocumentBase()</code> -- 获取嵌入此 applet 的文档的 URL</p></li>
                                <li><p><code>String 	getParameter(String name)</code> -- 返回 HTML 标记中指定参数的值</p></li>
                                <li><p><code>String[][] 	getParameterInfo()</code> -- 返回此 applet 理解的关于参数的信息</p></li>

                                <li class="group"><p><code>Locale 	getLocale()</code> -- 获取 applet 的语言环境</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Applet 关联的 AccessibleContext</p></li>
                                <li><p><code>boolean 	isActive()</code> -- 确定 applet 是否处于活动状态</p></li>
                                <li><p><code>boolean 	isValidateRoot()</code> -- </p></li>

                                <li class="group"><p><code>void 	resize(Dimension d)</code> -- 请求调整此 applet 的大小</p></li>
                                <li><p><code>void 	resize(int width, int height)</code> -- 请求调整此 applet 的大小</p></li>

                                <li class="group"><p><code>void 	setStub(AppletStub stub)</code> -- 设置此 applet 的 stub</p></li>
                                <li><p><code>void 	showStatus(String msg)</code> -- 请求将参数字符串显示在“状态窗口”中</p></li>

                                <li class="group"><p><code>void 	init()</code> -- 由浏览器或 applet viewer 调用，通知此 applet 它已经被加载到系统中</p></li>
                                <li><p><code>void 	start()</code> -- 由浏览器或 applet viewer 调用，通知此 applet 它应该开始执行</p></li>
                                <li><p><code>void 	stop()</code> -- 由浏览器或 applet viewer 调用，通知此 applet 它应该终止执行</p></li>
                                <li><p><code>void 	destroy()</code> --  由浏览器或 applet viewer 调用，通知此 applet 它正在被回收，它应该销毁分配给它的任何资源</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-awt-Component"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Component 及子类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public class Label extends Component implements Accessible {
    /** 可访问性支持 */
    protected class AccessibleAWTLabel extends AccessibleAWTComponent {}

    public static final int LEFT        = 0; // 左对齐
    public static final int CENTER      = 1; // 居中
    public static final int RIGHT       = 2; // 右对齐

    public Label() () // 无标题，左对齐
    public Label(String text) {}
    public Label(String text, int alignment) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Label.html" target="_blank">Label</a> 对象是一个可在容器中放置文本的组件。一个标签只显示一行只读文本。文本可由应用程序更改，但是用户不能直接对其进行编辑。</p>
                            <ol>
                                <li><p><code>int 	getAlignment()</code> -- 获取此标签的当前对齐方式</p></li>
                                <li><p><code>void 	setAlignment(int alignment)</code> -- 设置此标签的当前对齐方式</p></li>
                                <li><p><code>String 	getText()</code> -- 获取此标签的文本</p></li>
                                <li><p><code>void 	setText(String text)</code> -- 设置此标签的文本</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建此标签的同位体</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回一个表示此 Label 状态的字符串</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此标签相关的 AccessibleContext</p></li>

                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Button extends Component implements Accessible {
    /** 可访问性支持 */
    protected class AccessibleAWTButton extends AccessibleAWTComponent implements AccessibleAction,
                                AccessibleValue {}

    public Button() {}
    public Button(String label) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Button.html" target="_blank">Button</a> 当按下该按钮时，应用程序能执行某项动作。</p>
                            <p>用鼠标单击按钮这一动作与 ActionEvent 的一个实例相关，在按下鼠标和释放按钮的时候都会用到该类。如果应用程序希望知道何时按钮作为一个单独动作被按下但未释放，它可以特殊化 processMouseEvent，或者通过调用 addMouseListener 将自身注册为鼠标事件的侦听器。这两种方法都是由所有组件的抽象超类 Component 定义的。 </p>
                            <p>当按下按钮并释放时，AWT 通过调用按钮的 processEvent，将 ActionEvent 的一个实例发送给按钮。按钮的 processEvent 方法接收按钮的所有事件；同时，它通过调用自身的 processActionEvent 方法传递一个动作事件。后一种方法将动作事件传递给为关注此按钮生成的动作事件而注册的任何动作侦听器。 </p>
                            <p>如果应用程序想要执行基于按下并释放按钮的某个动作，则它应该实现 ActionListener 并注册新的侦听器，以便通过调用按钮的 addActionListener 方法来接收发自此按钮的事件。应用程序可以按消息传递协议使用按钮的动作命令。 </p>
                            <ol>
                                <li><p><code>void 	addActionListener(ActionListener l)</code> -- 添加指定的动作侦听器</p></li>
                                <li><p><code>void 	removeActionListener(ActionListener l)</code> -- 移除指定的动作侦听器</p></li>
                                <li><p><code>ActionListener[] 	getActionListeners()</code> -- 返回在此按钮上注册的所有动作侦听器的一个数组</p></li>

                                <li class="group"><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前在此 Button 上注册为 FooListener 的所有对象的数组</p></li>
                                <li><p><code>protected void 	processActionEvent(ActionEvent e)</code> -- 处理发生在此按钮上的动作事件，方法是将这些事件指派给所有已注册的 ActionListener 对象</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此按钮上的事件</p></li>

                                <li class="group"><p><code>String 	getLabel()</code> -- 获取此按钮的标签</p></li>
                                <li><p><code>void 	setLabel(String label)</code> -- 将按钮的标签设置为指定的字符串</p></li>
                                <li><p><code>String 	getActionCommand()</code> -- 返回此按钮激发的动作事件的命令名称</p></li>
                                <li><p><code>void 	setActionCommand(String command)</code> -- 设置此按钮激发的动作事件的命令名称</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建按钮的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Button 相关的 AccessibleContext</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回此 Button 状态的字符串表示形式</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <div class="split-item">
                                <pre class="brush: java;">
public class TextComponent extends Component implements Accessible {
    /** 可访问性支持 */
    protected class AccessibleAWTTextComponent extends AccessibleAWTComponent implements AccessibleText,
                                    TextListener {}

    protected TextListener textListener;
}
</pre>
                                <p><a href="docs/docs-java/api/java/awt/TextComponent.html" target="_blank">TextComponent</a> 是所有允许编辑文本的组件的超类。</p>
                                <p>文本组件具体化文本字符串。TextComponent 类定义了一组判断此文本是否可编辑的方法。如果组件是可编辑的，则该类还定义了另一组支持文件插入符的方法。 </p>
                                <p>此外，该类定义了用于维护文本当前选择 的方法。文本选择是组件文本的子字符串，是编辑操作的目标。它也被称为选定文本。</p>
                                <ol>
                                    <li><p><code>String 	getText()</code> -- 返回此文本组件表示的文本</p></li>
                                    <li><p><code>void 	setText(String t)</code> -- 将此文本组件显示的文本设置为指定文本</p></li>
                                    <li><p><code>boolean 	isEditable()</code> -- 指示此文本组件是否可编辑</p></li>
                                    <li><p><code>void 	setEditable(boolean b)</code> -- 设置判断此文本组件是否可编辑的标志</p></li>

                                    <li class="group"><p><code>String 	getSelectedText()</code> -- 返回此文本组件所表示文本的选定文本</p></li>
                                    <li><p><code>int 	getSelectionStart()</code> -- 获取此文本组件中选定文本的开始位置</p></li>
                                    <li><p><code>int 	getSelectionEnd()</code> -- 获取此文本组件中选定文本的结束位置</p></li>
                                    <li><p><code>int 	getCaretPosition()</code> -- 返回文本插入符的位置</p></li>
                                    <li><p><code>void 	setCaretPosition(int position)</code> -- 设置文本插入符的位置</p></li>
                                    <li><p><code>void 	select(int selectionStart, int selectionEnd)</code> -- 选择指定开始位置和结束位置之间的文本</p></li>
                                    <li><p><code>void 	setSelectionStart(int selectionStart)</code> -- 将此文本组件的选定开始位置设置为指定位置</p></li>
                                    <li><p><code>void 	setSelectionEnd(int selectionEnd)</code> -- 将此文本组件的选定结束位置设置为指定位置</p></li>
                                    <li><p><code>void 	selectAll()</code> -- 选择此文本组件中的所有文本</p></li>

                                    <li class="group"><p><code>Color 	getBackground()</code> -- 获得此文本组件的背景色</p></li>
                                    <li><p><code>void 	setBackground(Color c)</code> -- 设置此文本组件的背景色</p></li>
                                    <li><p><code>void 	enableInputMethods(boolean enable)</code> -- 启用或禁用此文本组件的输入法支持</p></li>
                                    <li><p><code>InputMethodRequests 	getInputMethodRequests()</code> -- 获取输入方法请求处理程序</p></li>

                                    <li class="group"><p><code>void 	addTextListener(TextListener l)</code> -- 添加指定的文本事件侦听器</p></li>
                                    <li><p><code>void 	removeTextListener(TextListener l)</code> -- 移除指定的文本事件侦听器</p></li>
                                    <li><p><code>TextListener[] 	getTextListeners()</code> -- 返回在此文本组件上所有已注册文本侦听器的数组</p></li>

                                    <li class="group"><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前已在此 TextComponent 上注册为 FooListener 的所有对象的数组</p></li>
                                    <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此文本组件上发生的事件</p></li>
                                    <li><p><code>protected void 	processTextEvent(TextEvent e)</code> -- 处理发生在此文本组件上的文本事件</p></li>

                                    <li class="group"><p><code>void 	addNotify()</code> -- 通过将此 Component 连接到一个本机屏幕资源，使其成为可显示的</p></li>
                                    <li><p><code>void 	removeNotify()</code> -- 移除 TextComponent 的同位体</p></li>
                                    <li><p><code>protected String 	paramString()</code> -- 返回表示此 TextComponent 状态的字符串</p></li>
                                    <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 TextComponent 关联的 AccessibleContext</p></li>
                                </ol>
                            </div>

                            <div class="split-item">
                                <pre class="brush: java;">
public class TextField extends TextComponent {
    /** 可访问性支持 */
    protected class AccessibleAWTTextField extends AccessibleAWTTextComponent {}

    public TextField() {} // 创建 0 列的文本框
    public TextField(int columns) {}
    public TextField(String text) {}
    public TextField(String text, int columns) {}
}
</pre>
                                <p><a href="docs/docs-java/api/java/awt/TextField.html" target="_blank">TextField</a> 是允许编辑单行文本的文本组件。</p>
                                <p>每次用户在文本字段中键入一个键时，就有一个或更多键事件被发送到该文本字段。</p>
                                <ol>
                                    <li><p><code>void 	addActionListener(ActionListener l)</code> -- 添加指定的操作侦听器</p></li>
                                    <li><p><code>void 	removeActionListener(ActionListener l)</code> -- 移除指定的操作侦听器</p></li>
                                    <li><p><code>ActionListener[] 	getActionListeners()</code> -- 返回此文本字段上已注册的所有操作侦听器的数组</p></li>

                                    <li class="group"><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回当前已在此 TextField 上注册为 FooListener 的所有对象的数组</p></li>
                                    <li><p><code>protected void 	processActionEvent(ActionEvent e)</code> -- 处理发生在此文本字段上的操作事件</p></li>
                                    <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此文本字段上的事件</p></li>

                                    <li class="group"><p><code>void 	setText(String t)</code> -- 将此文本组件显示的文本设置为指定文本</p></li>
                                    <li><p><code>Dimension 	getMinimumSize()</code> --  获取此文本字段的最小尺寸</p></li>
                                    <li><p><code>Dimension 	getMinimumSize(int columns)</code> -- 获取具有指定列数的文本字段的最小尺寸</p></li>
                                    <li><p><code>Dimension 	getPreferredSize()</code> -- 获取此文本字段的首选大小</p></li>
                                    <li><p><code>Dimension 	getPreferredSize(int columns)</code> -- 获取具有指定列数的文本字段的首选大小</p></li>

                                    <li class="group"><p><code>int 	getColumns()</code> -- 获取此文本字段中的列数</p></li>
                                    <li><p><code>void 	setColumns(int columns)</code> -- 设置此文本字段中的列数</p></li>
                                    <li><p><code>char 	getEchoChar()</code> -- 获取用于回显的字符</p></li>
                                    <li><p><code>boolean 	echoCharIsSet()</code> -- 指示此文本字段是否有一个回显字符集</p></li>
                                    <li><p><code>void 	setEchoChar(char c)</code> -- 设置此文本字段的回显字符</p></li>

                                    <li class="group"><p><code>void 	addNotify()</code> -- 创建 TextField 的同位体</p></li>
                                    <li><p><code>protected String 	paramString()</code> -- 返回表示此 TextField 状态的字符串</p></li>
                                    <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 TextField 关联的 AccessibleContext</p></li>
                                </ol>
                            </div>

                            <div class="split-item">
                                <pre class="brush: java;">
public class TextArea extends TextComponent {
    /** 可访问性支持 */
    protected class AccessibleAWTTextArea extends AccessibleAWTTextComponent {}

    /** 滚动条样式 */
    public static final int SCROLLBARS_BOTH = 0;            // 显示垂直和水平滚动条
    public static final int SCROLLBARS_VERTICAL_ONLY = 1;   // 显示垂直滚动条
    public static final int SCROLLBARS_HORIZONTAL_ONLY = 2; // 显示水平滚动条
    public static final int SCROLLBARS_NONE = 3;            // 不显示任何滚动条

    public TextArea() {} // 默认滚动条样式为 SCROLLBARS_BOTH
    public TextArea(int rows, int columns) {}
    public TextArea(String text) {}
    public TextArea(String text, int rows, int columns) {}
    public TextArea(String text, int rows, int columns, int scrollbars) {}
}
</pre>
                                <p><a href="docs/docs-java/api/java/awt/TextArea.html" target="_blank">TextArea</a> 是显示文本的多行区域。可以将它设置为允许编辑或只读。 </p>
                                <ol>
                                    <li><p><code>int 	getRows()</code> -- 返回此文本区的行数</p></li>
                                    <li><p><code>void 	setRows(int rows)</code> -- 设置此文本区的行数</p></li>
                                    <li><p><code>int 	getColumns()</code> -- 返回此文本区中的列数</p></li>
                                    <li><p><code>void 	setColumns(int columns)</code> -- 设置此文本区的列数</p></li>

                                    <li class="group"><p><code>Dimension 	getMinimumSize()</code> -- 确定此文本区的最小大小</p></li>
                                    <li><p><code>Dimension 	getMinimumSize(int rows, int columns)</code> -- 确定具有指定行数和列数的文本区的最小大小</p></li>
                                    <li><p><code>Dimension 	getPreferredSize()</code> -- 确定此文本区的首选大小</p></li>
                                    <li><p><code>Dimension 	getPreferredSize(int rows, int columns)</code> -- 确定具有指定行数和列数的文本区的首选大小</p></li>

                                    <li class="group"><p><code>void 	insert(String str, int pos)</code> -- 在此文本区的指定位置插入指定文本</p></li>
                                    <li><p><code>void 	replaceRange(String str, int start, int end)</code> -- 用指定替换文本替换指定开始位置与结束位置之间的文本</p></li>

                                    <li class="group"><p><code>void 	append(String str)</code> -- 将给定文本追加到文本区的当前文本</p></li>
                                    <li><p><code>int 	getScrollbarVisibility()</code> -- 返回指示文本区使用何种滚动条的枚举值</p></li>

                                    <li class="group"><p><code>void 	addNotify()</code> -- 创建 TextArea 的同位体</p></li>
                                    <li><p><code>protected String 	paramString()</code> -- 返回表示此 TextArea 状态的字符串</p></li>
                                    <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 返回与此 TextArea 相关的 AccessibleContext</p></li>
                                </ol>
                            </div>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Scrollbar extends Component implements Adjustable, Accessible {
    /** 可访问性支持 */
    protected class AccessibleAWTScrollBar extends AccessibleAWTComponent implements AccessibleValue {}

    /** 方向 */
    public static final int HORIZONTAL = 0;
    public static final int VERTICAL   = 1;

    public Scrollbar() {} // 纵向，初始值为 0, 可见量(滑块长度)为 10, 最小值为 0, 最大值为 100
    public Scrollbar(int orientation) {}
    public Scrollbar(int orientation, int value, int visible, int minimum, int maximum) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Scrollbar.html" target="_blank">Scrollbar</a> 描述了一个滚动条，这是大家都很熟悉的用户界面对象。滚动条提供了一个允许用户在一定范围的值中进行选择的便捷方式。</p>
                            <p>注：我们建议只对值的选择使用 Scrollbar(比如调节音量，类似 Android 中的 SeekBar)。如果想在容器中实现一个可滚动的组件，那么建议您使用 ScrollPane。如果使用 Scrollbar 来实现这一目的，那么可能会遇到绘制、键处理、大小调整和定位问题。 </p>
                            <ol>
                                <li><p><code>int 	getOrientation()</code> -- 返回此滚动条的方向</p></li>
                                <li><p><code>void 	setOrientation(int orientation)</code> -- 设置此滚动条的方向</p></li>
                                <li><p><code>int 	getValue()</code> -- 获取此滚动条的当前值</p></li>
                                <li><p><code>void 	setValue(int newValue)</code> -- 将此滚动条的值设置为指定值</p></li>
                                <li><p><code>int 	getVisibleAmount()</code> -- 获取此滚动条的可见量</p></li>
                                <li><p><code>void 	setVisibleAmount(int newAmount)</code> -- 设置此滚动条的可见量</p></li>
                                <li><p><code>int 	getMinimum()</code> -- 获取此滚动条的最小值</p></li>
                                <li><p><code>void 	setMinimum(int newMinimum)</code> -- 设置此滚动条的最小值</p></li>
                                <li><p><code>int 	getMaximum()</code> -- 获取此滚动条的最大值</p></li>
                                <li><p><code>void 	setMaximum(int newMaximum)</code> -- 设置此滚动条的最大值</p></li>
                                <li><p><code>void 	setValues(int value, int visible, int minimum, int maximum)</code> -- 设置此滚动条的四个属性值(参见构造方法)</p></li>

                                <li class="group"><p><code>int 	getBlockIncrement()</code> -- 获取此滚动条的块增量(点击三角形滑块移动数量)</p></li>
                                <li><p><code>void 	setBlockIncrement(int v)</code> -- 设置此滚动条的块增量</p></li>
                                <li><p><code>int 	getUnitIncrement()</code> -- 获取此滚动条的单位增量(比如其值可以只为偶数)</p></li>
                                <li><p><code>void 	setUnitIncrement(int v)</code> -- 设置此滚动条的单位增量</p></li>

                                <li class="group"><p><code>boolean 	getValueIsAdjusting()</code> -- 如果该值作为用户执行动作的结果正处于更改过程中，则返回 true</p></li>
                                <li><p><code>void 	setValueIsAdjusting(boolean b)</code> -- 设置 valueIsAdjusting 属性</p></li>

                                <li class="group"><p><code>void 	addAdjustmentListener(AdjustmentListener l)</code> -- 添加指定的调整侦听器</p></li>
                                <li><p><code>void 	removeAdjustmentListener(AdjustmentListener l)</code> -- 移除指定的调整侦听器</p></li>
                                <li><p><code>AdjustmentListener[] 	getAdjustmentListeners()</code> -- 返回在此滚动条上所有已注册调整侦听器组成的数组</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回目前已在此 Scrollbar 上注册为 FooListener 的所有对象组成的数组</p></li>

                                <li class="group"><p><code>protected void 	processAdjustmentEvent(AdjustmentEvent e)</code> -- 处理此滚动条上发生的调整事件</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理在滚动条上发生的事件</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建 Scrollbar 的同位体</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此 Scrollbar 当前状态的字符串表示形式</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Scrollbar 相关的 AccessibleContext</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Checkbox extends Component implements ItemSelectable, Accessible {
    protected class AccessibleAWTCheckbox extends AccessibleAWTComponent implements ItemListener,
                                AccessibleAction, AccessibleValue {}
    public Checkbox() {}
    public Checkbox(String label) {}
    public Checkbox(String label, boolean state) {}
    public Checkbox(String label, boolean state, CheckboxGroup group) {} // 加入一个 Group 变成单选框
    public Checkbox(String label, CheckboxGroup group, boolean state) {} // 同上
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Checkbox.html" target="_blank">Checkbox</a> 是复选框。一个可处于“开”(true) 或“关”(false) 状态的图形组件。单击复选框可将其状态从“开”更改为“关”，或从“关”更改为“开”。 </p>
                            <p>作为选择，可使用 CheckboxGroup 类将一些复选框组成一组，作为单个对象来控制。在一个复选框组中，在任何给定时间，最多只能有一个按钮处于“开”状态。单击并打开一个复选框会强迫同组中其他原来处于打开状态的复选框变为“关”状态。 </p>
                            <ol>
                                <li><p><code>void 	addItemListener(ItemListener l)</code> -- 添加指定的项侦听器</p></li>
                                <li><p><code>void 	removeItemListener(ItemListener l)</code> -- 移除此项侦听器</p></li>
                                <li><p><code>ItemListener[] 	getItemListeners()</code> -- 返回已在此复选框上注册的所有项侦听器所组成的数组</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回目前已在此 Checkbox 上注册为 FooListener 的所有对象组成的数组</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理关于此复选框的事件</p></li>
                                <li><p><code>protected void 	processItemEvent(ItemEvent e)</code> -- 处理发生在此复选框上的项事件</p></li>

                                <li class="group"><p><code>boolean 	getState()</code> -- 确定此复选框是状态</p></li>
                                <li><p><code>void 	setState(boolean state)</code> -- 将此复选框的状态设置为指定状态</p></li>
                                <li><p><code>CheckboxGroup 	getCheckboxGroup()</code> -- 确定此复选框的组</p></li>
                                <li><p><code>void 	setCheckboxGroup(CheckboxGroup g)</code> -- 将此复选框的组设置为指定复选框组</p></li>
                                <li><p><code>String 	getLabel()</code> -- 获取此复选框的标签</p></li>
                                <li><p><code>void 	setLabel(String label)</code> -- 将此复选框的标签设置为字符串参数</p></li>

                                <li class="group"><p><code>Object[] 	getSelectedObjects()</code> -- 返回包含复选框标签的数组 (length 1)，如果没有选定复选框，则返回 null</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建 Checkbox 的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Checkbox 相关的 AccessibleContext</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此 Checkbox 的状态的字符串</p></li>

                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Choice extends Component implements ItemSelectable, Accessible {
    protected class AccessibleAWTChoice extends AccessibleAWTComponent implements AccessibleAction {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Choice.html" target="_blank">Choice</a> 表示一个弹出式选择菜单。类似于 Android 中的 Spinner。 </p>
                            <p>一些本机平台不支持任意调整 Choice 组件的大小，setSize()/getSize() 的行为受到这类限制的约束。</p>
                            <ol>
                                <li><p><code>void 	addItem(String item)</code> -- 将一个项添加到此 Choice 菜单中</p></li>
                                <li><p><code>void 	add(String item)</code> -- 同上</p></li>
                                <li><p><code>void 	insert(String item, int index)</code> -- 将菜单项插入此选择的指定位置上</p></li>
                                <li><p><code>void 	remove(int position)</code> -- 从选择菜单的指定位置上移除一个项</p></li>
                                <li><p><code>void 	remove(String item)</code> -- 移除 Choice 菜单中第一个出现的 item</p></li>
                                <li><p><code>void 	removeAll()</code> -- 从选择菜单中移除所有的项</p></li>

                                <li class="group"><p><code>void 	select(int pos)</code> -- 将此 Choice 菜单中的选定项设置为指定位置上的项</p></li>
                                <li><p><code>void 	select(String str)</code> -- 将此 Choice 菜单中的选定项设置为其名称等于指定字符串的项</p></li>
                                <li><p><code>int 	getSelectedIndex()</code> -- 返回当前选定项的索引</p></li>
                                <li><p><code>String 	getSelectedItem()</code> -- 获取当前选择的字符串表示形式</p></li>
                                <li><p><code>String 	getItem(int index)</code> -- 获取此 Choice 菜单中指定索引上的字符串</p></li>

                                <li class="group"><p><code>int 	getItemCount()</code> -- 返回此 Choice 菜单中项的数量</p></li>
                                <li><p><code>Object[] 	getSelectedObjects()</code> -- 返回包含当前选定项的数组（长度为 1）</p></li>

                                <li class="group"><p><code>void 	addItemListener(ItemListener l)</code> -- 添加指定的项侦听器</p></li>
                                <li><p><code>void 	removeItemListener(ItemListener l)</code> -- 移除指定的项侦听器</p></li>
                                <li><p><code>ItemListener[] 	getItemListeners()</code> -- 返回已在此选择上注册的所有项侦听器组成的数组</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回目前已在此 Choice 上注册为 FooListener 的所有对象组成的数组</p></li>

                                <li class="group"><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理关于此选择的事件</p></li>
                                <li><p><code>protected void 	processItemEvent(ItemEvent e)</code> -- 处理发生在此 Choice 菜单上的项事件</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建 Choice 的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Choice 相关的 AccessibleContext</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此 Choice 菜单的状态的字符串</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class List extends Component implements ItemSelectable, Accessible {
    protected class AccessibleAWTList extends AccessibleAWTComponent implements AccessibleSelection,
                                ItemListener, ActionListener {}

    public List() {} // 0 行，不允许多选
    public List(int rows) {}
    public List(int rows, boolean multipleMode) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/List.html" target="_blank">List</a> 组件为用户提供了一个可滚动的文本项列表。可设置此 list，使其允许用户进行单项或多项选择。</p>
                            <p>如果 List 允许进行多项选择，则单击已选中的项时，将取消选中该项。</p>
                            <ol>
                                <li><p><code>void 	add(String item)</code> -- 向滚动列表的末尾添加指定的项</p></li>
                                <li><p><code>void 	add(String item, int index)</code> -- 向滚动列表中索引指示的位置添加指定的项</p></li>
                                <li><p><code>void 	replaceItem(String newValue, int index)</code> -- 使用新字符串替换滚动列表中指定索引处的项</p></li>
                                <li><p><code>void 	remove(int position)</code> -- 从此滚动列表中移除指定位置处的项</p></li>
                                <li><p><code>void 	remove(String item)</code> -- 从列表中移除项的第一次出现</p></li>
                                <li><p><code>void 	removeAll()</code> -- 从此列表中移除所有项</p></li>

                                <li class="group"><p><code>void 	select(int index)</code> -- 选择滚动列表中指定索引处的项</p></li>
                                <li><p><code>void 	deselect(int index)</code> -- 取消选择指定索引处的项</p></li>
                                <li><p><code>String 	getSelectedItem()</code> -- 获取此滚动列表中选中的项</p></li>
                                <li><p><code>String[] 	getSelectedItems()</code> -- 获取此滚动列表中选中的项</p></li>
                                <li><p><code>int 	getSelectedIndex()</code> -- 获取列表中选中项的索引</p></li>
                                <li><p><code>int[] 	getSelectedIndexes()</code> -- 获取列表中选中的索引</p></li>
                                <li><p><code>Object[] 	getSelectedObjects()</code> -- 获取对象数组中此滚动列表的选中项</p></li>
                                <li><p><code>boolean 	isIndexSelected(int index)</code> -- 确定是否已选中此滚动列表中的指定项</p></li>

                                <li class="group"><p><code>boolean 	isMultipleMode()</code> -- 确定此列表是否允许进行多项选择</p></li>
                                <li><p><code>void 	setMultipleMode(boolean b)</code> -- 设置是否允许进行多项选择</p></li>

                                <li class="group"><p><code>int 	getItemCount()</code> -- 获取列表中的项数</p></li>
                                <li><p><code>String 	getItem(int index)</code> -- 获取与指定索引关联的项</p></li>
                                <li><p><code>String[] 	getItems()</code> -- 获取列表中的项</p></li>
                                <li><p><code>void 	makeVisible(int index)</code> -- 使指定索引处的项可视</p></li>
                                <li><p><code>int 	getVisibleIndex()</code> -- 获取上次由 makeVisible 方法使其可视的项的索引</p></li>
                                <li><p><code>int 	getRows()</code> -- 获取此列表中的可视行数</p></li>

                                <li class="group"><p><code>void 	addActionListener(ActionListener l)</code> -- 添加指定的动作侦听器以从此列表接收动作事件</p></li>
                                <li><p><code>void 	removeActionListener(ActionListener l)</code> -- 移除指定的动作侦听器</p></li>
                                <li><p><code>ActionListener[] 	getActionListeners()</code> -- 返回已在此列表上注册的所有动作侦听器的数组</p></li>
                                <li><p><code>void 	addItemListener(ItemListener l)</code> -- 添加指定的项侦听器以接收此列表的项事件</p></li>
                                <li><p><code>void 	removeItemListener(ItemListener l)</code> -- 移除指定的项侦听器</p></li>
                                <li><p><code>ItemListener[] 	getItemListeners()</code> -- 返回已在此列表上注册的所有项侦听器的数组</p></li>
                                <li><p><code>&lt;T extends EventListener> T[] 	getListeners(Class&lt;T> listenerType)</code> -- 返回目前已在此 List 上注册为 FooListener 的所有对象的数组</p></li>

                                <li class="group"><p><code>protected void 	processActionEvent(ActionEvent e)</code> -- 处理发生在此列表上的动作事件</p></li>
                                <li><p><code>protected void 	processEvent(AWTEvent e)</code> -- 处理此滚动列表的进程事件</p></li>
                                <li><p><code>protected void 	processItemEvent(ItemEvent e)</code> -- 处理发生在此列表上的项事件</p></li>

                                <li class="group"><p><code>Dimension 	getMinimumSize()</code> -- 确定此滚动列表的最小大小</p></li>
                                <li><p><code>Dimension 	getMinimumSize(int rows)</code> -- 获取具有指定行数的列表的最少维数</p></li>
                                <li><p><code>Dimension 	getPreferredSize()</code> -- 获取此滚动列表的首选大小</p></li>
                                <li><p><code>Dimension 	getPreferredSize(int rows)</code> -- 获取具有指定行数的列表的首选维数</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建列表的同位体</p></li>
                                <li><p><code>void 	removeNotify()</code> -- 移除此列表的同位体</p></li>
                                <li><p><code>protected String 	paramString()</code> -- 返回表示此滚动列表状态的参数字符串</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 List 关联的 AccessibleContext</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class Canvas extends Component implements Accessible {
    protected class AccessibleAWTCanvas extends AccessibleAWTComponent {}

    public Canvas() {}
    public Canvas(GraphicsConfiguration config) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/awt/Canvas.html" target="_blank">Canvas</a> 组件表示屏幕上一个空白矩形区域，应用程序可以在该区域内绘图，或者可以从该区域捕获用户的输入事件。 </p>
                            <p>应用程序必须为 Canvas 类创建子类，以获得有用的功能（如创建自定义组件）。必须重写 paint 方法，以便在 canvas 上执行自定义图形。</p>
                            <ol>
                                <li><p><code>void 	paint(Graphics g)</code> -- 绘制此 canvas</p></li>
                                <li><p><code>void 	update(Graphics g)</code> -- 更新此 canvas</p></li>

                                <li class="group"><p><code>void 	createBufferStrategy(int numBuffers)</code> -- 创建一个新的策略，用于对此组件的多缓冲</p></li>
                                <li><p><code>void 	createBufferStrategy(int numBuffers, BufferCapabilities caps)</code> -- 创建一个新的策略，使用所需的缓冲区能力对此组件进行多缓冲</p></li>
                                <li><p><code>BufferStrategy 	getBufferStrategy()</code> -- 返回由此组件使用的多缓冲策略</p></li>

                                <li class="group"><p><code>void 	addNotify()</code> -- 创建 canvas 的同位体</p></li>
                                <li><p><code>AccessibleContext 	getAccessibleContext()</code> -- 获取与此 Canvas 相关的 AccessibleContext</p></li>
                            </ol>

                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-awt-"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">...</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-java/api/java/awt/.html" target="_blank"></a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-swing-JFrame"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">JFrame</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.awt.Component
        java.awt.Container
            java.awt.Window
                java.awt.Frame
                    javax.swing.JFrame

public class JFrame extends Frame implements WindowConstants, Accessible, RootPaneContainer {
    /** 可访问性支持 */
    protected class AccessibleJFrame extends AccessibleAWTFrame {}

    public static final int EXIT_ON_CLOSE = 3;

    protected JRootPane rootPane;
    protected boolean rootPaneCheckingEnabled = false;
    protected AccessibleContext accessibleContext = null;

    public JFrame() {}
    public JFrame(GraphicsConfiguration gc) {}
    public JFrame(String title) {}
    public JFrame(String title, GraphicsConfiguration gc) {}
}

public interface WindowConstants {
    public static final int DO_NOTHING_ON_CLOSE = 0;
    public static final int HIDE_ON_CLOSE = 1;
    public static final int DISPOSE_ON_CLOSE = 2;
    public static final int EXIT_ON_CLOSE = 3;
}

public interface RootPaneContainer {
    JRootPane getRootPane();
    void setContentPane(Container contentPane);
    Container getContentPane();
    void setLayeredPane(JLayeredPane layeredPane);
    JLayeredPane getLayeredPane();
    void setGlassPane(Component glassPane);
    Component getGlassPane();

}
</pre>
                            <p><a href="docs/docs-java/api/javax/swing/JFrame.html" target="_blank">JFrame</a> 此类继承自 <code>java.awt.Frame</code>, 添加了对 JFC/Swing 组件架构的支持。Frame 参考： <a href="#java-awt-Frame">Frame  及父类</a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-swing-LayoutManager"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">...</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <p>LayoutManager / LayoutManager2 定义如何布置 Container 类的接口。此接口定义在 <code>java.awt</code> 包中。</p>
                            <p>LayoutManager / LayoutManager2 的实现类:(<code>java.awt</code> 包中的部分实现类查看: <a href="#java-awt-LayoutManager">AWT 下的 LayoutManager 实现类</a>)</p>
                            <ul>
                                <li><p><a href="#GroupLayout">GroupLayout</a> -- </p></li>
                                <li><p><a href="#DefaultMenuLayout">DefaultMenuLayout</a> -- </p></li>
                                <li><p><a href="#MetalScrollBarUI">MetalScrollBarUI</a> -- </p></li>
                                <li><p><a href="#BasicScrollBarUI">BasicScrollBarUI</a> -- </p></li>
                                <li><p><a href="#OverlayLayout">OverlayLayout</a> -- </p></li>
                                <li><p><a href="#ScrollPaneLayout">ScrollPaneLayout</a> -- </p></li>
                                <li><p><a href="#SpringLayout">SpringLayout</a> -- </p></li>
                                <li><p><a href="#SynthScrollBarUI">SynthScrollBarUI</a> -- </p></li>
                                <li><p><a href="#ViewportLayout">ViewportLayout</a> -- </p></li>
                            </ul>
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-java/api/javax/swing/.html" target="_blank"></a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
		   class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
		   class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> TOP </a>
		<a target="_blank" href="./docs/docs-java/api-zh/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-6 </a>
		<a target="_blank" href="./docs/docs-java/api/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-8 </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
    <script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
