<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--LIBS</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">LIBS</h3>
					</div>
					<div class="list-group">
						<a class="list-group-item active drop" data-toggle="collapse"
						   data-parent="#accordion" href="#libs-commons" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							Apache Commons 组件<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="libs-commons" class="panel-collapse collapse"
							 role="tabpanel">
							<a href="#commons-intro" class="list-group-item">Apache Commons 简介</a>
							<a href="#commons-lang" class="list-group-item">commons-lang3-3.5</a>
							<a href="#commons-logging" class="list-group-item">commons-logging-1.2</a>
							<a href="#apache-log4j" class="list-group-item">apache-log4j-1.2.17</a>
							<a href="#junit" class="list-group-item">junit-4.12</a>
							<a href="#commons-collections" class="list-group-item">commons-collections4-4.1</a>
							<a href="#commons-compress" class="list-group-item">commons-compress-1.12</a>
							<a href="#commons-compress" class="list-group-item">commons-io-2.5</a>
							<a href="#apache-lucene" class="list-group-item">apache-lucene-6.4.2</a>
						</div>
						<a href="#libs-guava" class="list-group-item">Guava</a>
                        <a href="#libs-JavaPoet" class="list-group-item">JavaPoet -- 源文件生成工具</a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3">
				<!-- item start -->
				<a class="offset" id="commons-intro"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<p>Apache Commons包含了很多开源的工具，致力于创建和维护可重用Java组件。</p>
						<p>Apache Commons项目由三部分组成：</p>
						<ul>
							<li>The Commons Proper -- 一个可重用的Java组件库。(当前使用，活动状态)</li>
							<li>The Commons Sandbox -- Java组件开发工作区. (正在开发的项目)</li>
							<li>The Commons Dormant -- 当前处于非活动状态的组件库.(刚启动或者已经停止维护的项目)</li>
						</ul>
						<p>
							项目主页 --
							<a href="http://commons.apache.org/" target="_blank">commons.apache.org</a>
						<p class="h5 text-primary">The Commons Proper:</p>
						<table class="table table-bordered table-striped table-hover">
							<thead>
								<tr>
									<td>组件</td>
									<td>描述</td>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>BCEL</td>
									<td>字节码工程库——分析，创建和操纵Java类文件</td>
								</tr>
								<tr>
									<td>BeanUtils</td>
									<td>易于使用的Java反射和内省API</td>
								</tr>
								<tr>
									<td>BSF</td>
									<td>Bean脚本框架 - 包括脚本语言接口，以及JSR-223</td>
								</tr>
								<tr>
									<td>Chain</td>
									<td>责任链模式实现</td>
								</tr>
								<tr>
									<td>CLI</td>
									<td>命令行参数解析器</td>
								</tr>
								<tr>
									<td>Codec</td>
									<td>常用的编码/解码算法（例如：语音，base64，URL）</td>
								</tr>
								<tr>
									<td>Collections</td>
									<td>扩展或增强Java集合框架</td>
								</tr>
								<tr>
									<td>Compress</td>
									<td>为处理tar,zip，zbip2等文件定义的一些接口</td>
								</tr>
								<tr>
									<td>Configuration</td>
									<td>读取各种格式的配置/首选项文件</td>
								</tr>
								<tr>
									<td>Crypto</td>
									<td>一个加密库，使用 AES-NI (Advanced Encryption Standard New
										Instructions) 进行优化。提供了加密级别和流级别的 API</td>
								</tr>
								<tr>
									<td>CSV</td>
									<td>读取和写入逗号分隔值文件的组件</td>
								</tr>
								<tr>
									<td>Daemon</td>
									<td>可以帮你实现将一个普通的 Java 应用变成系统的一个后台服务</td>
								</tr>
								<tr>
									<td>DBCP</td>
									<td>数据库线程池服务</td>
								</tr>
								<tr>
									<td>DbUtils</td>
									<td>JDBC助手库</td>
								</tr>
								<tr>
									<td>Digester</td>
									<td>XML到Java对象的映射工具</td>
								</tr>
								<tr>
									<td>Discovery</td>
									<td>通过将服务名称及引用名称映射为资源名称来查找资源的工具</td>
								</tr>
								<tr>
									<td>Email</td>
									<td>通过Java发送邮件的库</td>
								</tr>
								<tr>
									<td>Exec</td>
									<td>Java中处理外部进程执行和环境管理的API用于</td>
								</tr>
								<tr>
									<td>FileUpload</td>
									<td>在servlet和Web application中添加文件上传的功能</td>
								</tr>
								<tr>
									<td>Functor</td>
									<td>Apache Commons Functor
										库包括大量基本构造,可以在涉及闭包和高阶函数的复杂使用场景中重复使用</td>
								</tr>
								<tr>
									<td>Imaging</td>
									<td>纯Java的图像库</td>
								</tr>
								<tr>
									<td>IO</td>
									<td>I / O工具集</td>
								</tr>
								<tr>
									<td>JCI</td>
									<td>Java 编译器接口</td>
								</tr>
								<tr>
									<td>JCS</td>
									<td>Java缓存系统</td>
								</tr>
								<tr>
									<td>Jelly</td>
									<td>基于XML的脚本和处理引擎</td>
								</tr>
								<tr>
									<td>Jexl</td>
									<td>表达式语言，它扩展了JSTL的表达式语言</td>
								</tr>
								<tr>
									<td>JXPath</td>
									<td>使用XPath语法操作Java bean的实用工具包</td>
								</tr>
								<tr>
									<td>Lang</td>
									<td>java.lang中的类提供额外的功能</td>
								</tr>
								<tr>
									<td>Launcher</td>
									<td>跨平台的Java应用程序启动</td>
								</tr>
								<tr>
									<td>Logging</td>
									<td>各种日志API的实现的包装器</td>
								</tr>
								<tr>
									<td>Math</td>
									<td>轻量，无依赖的数学和统计组件</td>
								</tr>
								<tr>
									<td>Modeler</td>
									<td>提供符合JMX规范的，用于创建Model Mbeans的机制</td>
								</tr>
								<tr>
									<td>Net</td>
									<td>网络工具和协议的实现集合</td>
								</tr>
								<tr>
									<td>OGNL</td>
									<td>OGNL是Object-Graph Navigation
										Language的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。</td>
								</tr>
								<tr>
									<td>Pool</td>
									<td>通用对象池组件</td>
								</tr>
								<tr>
									<td>Proxy</td>
									<td>创建动态代理的包</td>
								</tr>
								<tr>
									<td>RNG</td>
									<td>随机数生成器的实现</td>
								</tr>
								<tr>
									<td>SCXML</td>
									<td>有限状态机XML规范的实现，目的是为了创建和维护Java的SCXML引擎。它能够执行一个使用SCXML文档定义的的状态机，及抽象出环境的接口</td>
								</tr>
								<tr>
									<td>Validator</td>
									<td>通过XML文件定义验证器和验证规则的框架</td>
								</tr>
								<tr>
									<td>VFS</td>
									<td>VFS把对各种各样的的文件系统的访问封装成统一的应用程序接口，这大大的简化了应用程序本身代码的复杂度。Apache上的项目的稳定性也是有目共睹的，目前VFS支持下面一些文件系统，当然你也可以自行进行扩展。如FTP,SMB,ZIP或者单个逻辑文件系统</td>
								</tr>
								<tr>
									<td>Weaver</td>
									<td>提供了一种简单的方法来增强(织)编译后的字节码</td>
								</tr>
							</tbody>
						</table>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="commons-lang"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">commons-lang3-3.5</h3>
					</div>
					<div class="panel-body">
						<p>
							<span class="text-primary">说明：</span>这个工具包可以看成是对java.lang的扩展。提供了诸如StringUtils,
							StringEscapeUtils, RandomStringUtils, Tokenizer, WordUtils等工具类。
						</p>
						<p>
							jar包 --
							<a href="commons/commons-lang3-3.5/commons-lang3-3.5.jar">commons-lang3-3.5.jar</a>
						</p>
						<p>
							文档 --
							<a target="_blank"
								href="commons/commons-lang3-3.5/apidocs/index.html">apidocs</a>
						</p>
						<p>常用类:</p>
						<ul>
							<li>
								<p>
									<code>StringUtils / WordUtils</code>
									-- 主要提供对字符串 / 单词的操作
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-lang-StringUtils" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-lang-StringUtils"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
/** StringUtils */
System.out.println("将字符串重复n次，将文字按某宽度居中，将字符串数组用某字符串连接.");
String[] header = new String[3];
header[0] = StringUtils.repeat("*", 50);
header[1] = StringUtils.center("  StringUtilsDemo  ", 50, "^O^");
header[2] = header[0];
String head = StringUtils.join(header, "\n");
System.out.println(head);

System.out.println("缩短到某长度,用...结尾.");
System.out.println(StringUtils.abbreviate(
		"The quick brown fox jumps over the lazy dog.", 10));
System.out.println(StringUtils.abbreviate(
		"The quick brown fox jumps over the lazy dog.", 15, 10));

System.out.println("返回两字符串不同处索引号.");
System.out.println(StringUtils.indexOfDifference("aaabc", "aaacc"));

System.out.println("返回两字符串不同处开始至结束.");
System.out.println(StringUtils.difference("aaabcde", "aaaccde"));

System.out.println("截去字符串为以指定字符串结尾的部分.");
System.out.println(StringUtils.chomp("aaabcde", "de"));

System.out.println("检查一字符串是否为另一字符串的子集.");
System.out.println(StringUtils.containsOnly("aad", "aadd"));

System.out.println("检查一字符串是否不是另一字符串的子集.");
System.out.println(StringUtils.containsNone("defg", "aadd"));

System.out.println("检查一字符串是否包含另一字符串.");
System.out.println(StringUtils.contains("defg", "ef"));
System.out.println(StringUtils.containsOnly("ef", "defg"));

System.out.println("返回可以处理null的toString().");
System.out.println(StringUtils.defaultString("aaaa"));
System.out.println("?" + StringUtils.defaultString(null) + "!");

System.out.println("去除字符中的空格.");
System.out.println(StringUtils.deleteWhitespace("aa  bb  cc"));

System.out.println("分隔符处理成数组.");
String[] strArray = StringUtils.split("a,b,,c,d,null,e", ",");
System.out.println(strArray.length);
System.out.println(strArray.toString());

System.out.println("判断是否是某类字符.");
System.out.println(StringUtils.isAlpha("ab"));
System.out.println(StringUtils.isAlphanumeric("12"));
System.out.println(StringUtils.isBlank(""));
System.out.println(StringUtils.isNumeric("123"));

/** WordUtils */
String str1 = "wOrD";
String str2 = "ghj\nui\tpo";
System.out.println(WordUtils.capitalize(str1)); // 首字母大写
System.out.println(WordUtils.capitalizeFully(str1)); // 首字母大写其它字母小写
char[] ctrg = { '.' };
System.out.println(WordUtils.capitalizeFully("i aM.fine", ctrg)); // 在规则地方转换
System.out.println(WordUtils.initials(str1)); // 获取首字母
System.out.println(WordUtils.initials("Ben John Lee", null)); // 取每个单词的首字母
char[] ctr = { ' ', '.' };
System.out.println(WordUtils.initials("Ben J.Lee", ctr)); // 按指定规则获取首字母
System.out.println(WordUtils.swapCase(str1)); // 大小写逆转
System.out.println(WordUtils.wrap(str2, 1)); // 解析\n和\t等字符
</pre>
									</div>
								</div>

							</li>
							<li>
								<p>
									<code>ObjectUtils</code>
									--
									主要是对null进行安全处理,可以设置为null时的默认返回值,比较相等时是调用对象的equals方法,因此需要对对象进行方法进行覆盖
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-lang-ObjectUtils" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-lang-ObjectUtils"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
System.out.println("Object为null时，默认打印某字符.");
Object obj = null;
System.out.println(ObjectUtils.defaultIfNull(obj, "空"));

System.out.println("验证两个引用是否指向的Object是否相等,取决于Object的equals()方法.");
Object a = new Object();
Object b = a;
Object c = new Object();
System.out.println(ObjectUtils.equals(a, b));
System.out.println(ObjectUtils.equals(a, c));

System.out.println("用父类Object的toString()方法返回对象信息.");
Date date = new Date();
System.out.println(ObjectUtils.identityToString(date));
System.out.println(date);

System.out.println("返回类本身的toString()方法结果,对象为null时，返回0长度字符串.");
System.out.println(ObjectUtils.toString(date));
System.out.println(ObjectUtils.toString(null));
System.out.println(date);
</pre>
									</div>
								</div>
							</li>
							<li>
								<p>
									<code>SystemUtils</code>
									-- 主要获取一些系统属性,例如工作目录等等
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-lang-SystemUtils" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-lang-SystemUtils"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
System.out.println("获得系统文件分隔符.");
System.out.println(SystemUtils.FILE_SEPARATOR);

System.out.println("获得源文件编码.");
System.out.println(SystemUtils.FILE_ENCODING);

System.out.println("获得ext目录.");
System.out.println(SystemUtils.JAVA_EXT_DIRS);

System.out.println("获得java版本.");
System.out.println(SystemUtils.JAVA_VM_VERSION);

System.out.println("获得java厂商.");
System.out.println(SystemUtils.JAVA_VENDOR);
</pre>
									</div>
								</div>
							</li>
							<li>
								<p>
									<code>ClassUtils</code>
									-- 类相关操作
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-lang-ClassUtils" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-lang-ClassUtils"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
System.out.println("获取类实现的所有接口.");
System.out.println(ClassUtils.getAllInterfaces(Date.class));

System.out.println("获取类所有父类.");
System.out.println(ClassUtils.getAllSuperclasses(Date.class));

System.out.println("获取简单类名.");
System.out.println(ClassUtils.getShortClassName(Date.class));

System.out.println("获取包名.");
System.out.println(ClassUtils.getPackageName(Date.class));

System.out.println("判断是否可以转型.");
System.out.println(ClassUtils.isAssignable(Date.class, Object.class));
System.out.println(ClassUtils.isAssignable(Object.class, Date.class));
</pre>
									</div>
								</div>
							</li>
							<li>
								<p>
									<code>DateUtils / CalendarUtils / StopWatch</code>
									-- 对日期的操作,包括日期加减,日期格式化,日期比较,一定时间范围内日期的迭代提供,秒表的计时,暂停等功能
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-lang-DateUtils" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-lang-DateUtils"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
System.out.println("格式化日期输出.");
System.out.println(DateFormatUtils.format(System.currentTimeMillis(),
		"yyyy-MM-dd HH:mm:ss"));

System.out.println("秒表.");
StopWatch sw = new StopWatch();
sw.start();

for (Iterator iterator = DateUtils.iterator(new Date(),
		DateUtils.RANGE_WEEK_CENTER); iterator.hasNext();) {
	Calendar cal = (Calendar) iterator.next();
	System.out.println(DateFormatUtils.format(cal.getTime(), "yy-MM-dd HH:mm"));
}

sw.stop();
System.out.println("秒表计时:" + sw.getTime());
</pre>
									</div>
								</div>
							</li>
							<li>
								<p>
									<code>SerializationUtils</code>
									-- 序列化相关操作
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-lang-SerializationUtils" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-lang-SerializationUtils"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
System.out.println("*SerializationUtils**");
Date date = new Date();
byte[] bytes = SerializationUtils.serialize(date);
System.out.println(ArrayUtils.toString(bytes));
System.out.println(date);

Date reDate = (Date) SerializationUtils.deserialize(bytes);
System.out.println(reDate);
System.out.println(ObjectUtils.equals(date, reDate));
System.out.println(date == reDate);

FileOutputStream fos = null;
FileInputStream fis = null;
try {
	fos = new FileOutputStream(new File("./test/test.txt"));
	fis = new FileInputStream(new File("./test/test.txt"));
	SerializationUtils.serialize(date, fos);
	Date reDate2 = (Date) SerializationUtils.deserialize(fis);

	System.out.println(date.equals(reDate2));

} catch (FileNotFoundException e) {
	e.printStackTrace();
} finally {
	try {
		fos.close();
		fis.close();
	} catch (IOException e) {
		e.printStackTrace();
	}
}

</pre>
									</div>
								</div>
							</li>
							<li>
								<p>
									<code>ToStringBuilder / HashCodeBuilder / EqualsBuilder</code>
									-- 提供了方便的方法来覆盖toString, equals() 和hashCode()方法
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-lang-Builder" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-lang-Builder" class="panel-collapse collapse"
										style="" aria-expanded="true">
										<pre class="brush: java;">
public class BuildDemo {
	String name;
	int age;

	public BuildDemo(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public String toString() {
		ToStringBuilder tsb = new ToStringBuilder(this,
				ToStringStyle.MULTI_LINE_STYLE);
		tsb.append("Name", name);
		tsb.append("Age", age);
		return tsb.toString();
	}

	public int hashCode() {
		HashCodeBuilder hcb = new HashCodeBuilder();
		hcb.append(name);
		hcb.append(age);
		return hcb.hashCode();
	}

	public boolean equals(Object obj) {
		if (!(obj instanceof BuildDemo)) {
			return false;
		}
		BuildDemo bd = (BuildDemo) obj;
		EqualsBuilder eb = new EqualsBuilder();
		eb.append(name, bd.name);
		eb.append(age, bd.age);
		return eb.isEquals();
	}
}

public void builderDemo() {
	BuildDemo obj1 = new BuildDemo("a", 1);
	BuildDemo obj2 = new BuildDemo("b", 2);
	BuildDemo obj3 = new BuildDemo("a", 1);

	System.out.println("toString()");
	System.out.println(obj1);
	System.out.println(obj2);
	System.out.println(obj3);

	System.out.println("hashCode()");
	System.out.println(obj1.hashCode());
	System.out.println(obj2.hashCode());
	System.out.println(obj3.hashCode());

	System.out.println("equals()");
	System.out.println(obj1.equals(obj2));
	System.out.println(obj1.equals(obj3));
}
</pre>
									</div>
								</div>
							</li>
							<li>
								<p>
									<code>ArrayUtils</code>
									-- 提供了数组的复制,查找,获取子数组,反转等功能
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-lang-ArrayUtils" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-lang-ArrayUtils"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
/*** 1. ArrayUtils.isEmpty(strs) : 判断数组是否为空 , 不为空返回false,为空true */

ArrayUtils.isEmpty(new String[] { "21", "是" });// 结果是false
ArrayUtils.isEmpty(new String[] { "" });// 结果是false
ArrayUtils.isEmpty(new String[] {});// 结果是true

/** 2. ArrayUtils.isNotEmpty(strs) : 判断数组是否不为空 , 不为空返回true,为空false */

ArrayUtils.isNotEmpty(new String[] { "21", "是" }); // 结果是true
ArrayUtils.isNotEmpty(new String[] { "" });// 结果是true
ArrayUtils.isNotEmpty(new String[] {});// 结果是false

/**
 * 3. ArrayUtils.isSameLength(strs, strs2) : 判断两个数组长度是否相等,
 * 长度相等返回true,否则返回false 。相比较的两个数组类型必须相同
 */

ArrayUtils.isSameLength(new String[] { "21", "是" }, new String[] { "21", "是" });// 返回false

/**
 * 4. ArrayUtils.isSameType(strs, strs2)
 * :判断两个数组的类型是否相同,相同返回true,否则返回false
 */

ArrayUtils.isSameType(new String[] { "21", "是" }, new Integer[] { 3 });

/** 5. ArrayUtils.isEquals(strs, strs2) 判断两个数组是否相等 */

ArrayUtils.isEquals(strs, strs);// 结果是true

/** 6. ArrayUtils.toString() 将一个数组转换成String,用于打印 */

ArrayUtils.toString(new String[] { "21", "是" });// 结果是：{21,是}

/** 7. ArrayUtils.clone 赋值 （克隆） 数组 */

Object[] s = ArrayUtils.clone(new Object[] { "33", "yy" });

/**
 * 8. ArrayUtils.subarray 截取 子数组 ： 根据 起始索引 startIndexInclusive 到
 * 结束索引startIndexInclusive
 */

Object[] s1 = ArrayUtils.subarray(new Object[] { "33", "yy", "uu" }, 0, 1);// 结果是返回数组 ：[33]

Object[] s2 = ArrayUtils.subarray(new Object[] { "33", "yy", "uu" }, 0, 2);// 结果是返回数组 ：[33, yy]

/** 9. ArrayUtils.indexOf 查询某个object在数组中的位置，可是指定起始搜索位置 */

int index = ArrayUtils.indexOf(new Object[] { "33", "yy", "uu" }, "uu");// 结果是2
int index1 = ArrayUtils.indexOf(new Object[] { "33", "yy", "uu" }, "uu", 2);// 结果是2
int index3 = ArrayUtils.indexOf(new Object[] { "33", "yy", "uu" }, "uu", 3);// 结果是-1

/** 10. ArrayUtils.lastIndexOf 反向查询某个object在数组中的位置 可是指定起始搜索位置 */

int index11 = ArrayUtils.lastIndexOf(new Object[] { "33", "yy", "uu" }, "33");// 结果是0
int index22 = ArrayUtils.lastIndexOf(new Object[] { "33", "yy", "uu" }, "33", 2);

/** 11. ArrayUtils.contains 查询某个object是否在数组中 */

/** 12. ArrayUtils.reverse 反转数组 */

ArrayUtils.reverse(new String[] { "22", "yy" });// 结果是：{"yy"，"22"}

/** 13. ArrayUtils.add 添加一object到数组 */

String[] t = { "22", "yy" };
String[] gg = (String[]) ArrayUtils.add(t, "jj");// {"22","yy","jj"}

/** 14. ArrayUtils.addAll 合并两个数组 */

String[] ggo = (String[]) ArrayUtils.addAll(
		new String[] { "22", "yy" }, new String[] { "jj" });// 结果是：[22, // yy, jj]

/** 15. ArrayUtils.remove 删除数组某个位置的元素 */

String[] gg4 = (String[]) ArrayUtils.remove( new String[] { "22", "yy" }, 1);

/** 16. ArrayUtils.removeElement 删除数组中某个对象 */

String[] ggpp = (String[]) ArrayUtils.removeElement(new String[] { "22", "yy" }, "yy");
</pre>
									</div>
								</div>
							</li>
						</ul>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="commons-logging"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">commons-logging-1.2</h3>
					</div>
					<div class="panel-body">
						<p>
							<span class="text-primary">说明：</span>各种日志API的实现的包装器。common-logging是apache提供的一个通用的日志接口。用户可以自由选择第三方的日志组件作为具体实现，像log4j，或者jdk自带的logging，
							common-logging会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。当然，common-logging内部有一个Simple
							logger的简单实现，但是功能很弱。所以使用common-logging，通常都是配合着log4j来使用。使用它的好处就是，代码依赖是common-logging而非log4j，
							避免了和具体的日志方案直接耦合，在有必要时，可以更改日志实现的第三方库。
						</p>
						<p>
							jar包 --
							<a href="commons/commons-logging-1.2/commons-logging-1.2.jar">commons-logging-1.2.jar</a>
						</p>
						<p>
							文档 --
							<a target="_blank"
								href="commons/commons-logging-1.2/apidocs/index.html">apidocs</a>
						</p>
						<p>日志等级分为以下６种:</p>
						<ol>
							<li>
								<strong>trace</strong> -- 更加细节的信息。期望这类信息仅被写入log文件中。
							</li>
							<li>
								<strong>debug</strong> -- 系统流程中的细节信息。期望这类信息仅被写入log文件中。
							</li>
							<li>
								<strong>info</strong> -- 运行时产生的有意义的事件。期望这类信息能立即显示在状态控制台上。
							</li>
							<li>
								<strong>warn</strong> -- 使用了不赞成使用的API、非常拙劣使用API, '几乎就是'错误,
								其它运行时不合需要和不合预期的状态但还没必要称为 "错误"。期望这类信息能立即显示在状态控制台上。
							</li>
							<li>
								<strong>error</strong> -- 其它运行期错误或不是预期的条件。期望这类信息能立即显示在状态控制台上。
							</li>
							<li>
								<strong>fatal</strong> -- 非常严重的错误，导致系统中止。期望这类信息能立即显示在状态控制台上。
							</li>
						</ol>
						<p class="alert alert-success" style="line-height: 1.6em;">
							关于配置
							<code>commons-logging.propertyies</code>
							,
							<code>simplelog.properties</code>
							或
							<code>log4j.properties</code>
							文件的位置，如果是在eclipse中直接运行，位置是
							<code>src</code>
							目录下，eclipse 自动将其复制到
							<code>bin</code>
							目录；如果打成jar包，请将配置文件一起打包到jar包的根目录下；web项目位于
							<code>web-inif/classes</code>
							目录下；配置文件默认从class位置根目录读取。
						</p>
						<p>
							<code>commons-logging.propertyies</code>
							文件:
						</p>
						<pre class="brush: bash;">
# 使用 SimpleLog
org.apache.commons.logging.Log=org.apache.commons.logging.impl.SimpleLog

# 使用 Jdk14Logger
# org.apache.commons.logging.Log=org.apache.commons.logging.impl.Jdk14Logger

# 使用 Log4JLogger
# org.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4JLogger
</pre>
						<p>
							<code>simplelog.propertyies</code>
							文件:
						</p>
						<pre class="brush: bash;">
# 日志等级 "trace", "debug", "info", "warn", "error", "fatal"
org.apache.commons.logging.simplelog.defaultlog=debug

# 是否显示 log级别名字
org.apache.commons.logging.simplelog.showlogname=false

# 是否使用 log级别短名字
org.apache.commons.logging.simplelog.showShortLogname=false

# 是否显示时间
org.apache.commons.logging.simplelog.showdatetime=true

# 时间格式控制
org.apache.commons.logging.simplelog.dateTimeFormat=yyyy-MM-dd hh:mm:ss
</pre>
						<p>
							<code>log4j.propertyies</code>
							文件配置看下节: --
							<a href="#apache-log4j-config">log4j.propertyies</a>
						</p>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="apache-log4j"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">apache-log4j-1.2.17</h3>
					</div>
					<div class="panel-body">
						<p>
							<span class="text-primary">说明：</span>Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录。此项目不属于commons组件。
						</p>
						<p>
							jar包 --
							<a href="commons/apache-log4j-1.2.17/log4j-1.2.17.jar">apache-log4j-1.2.17.jar</a>
						</p>
						<p>
							文档 --
							<a target="_blank"
								href="commons/apache-log4j-1.2.17/apidocs/index.html">apidocs</a>
						</p>

						<p class="h5 text-primary">log4j简介</p>
						<p>Log4j有三个主要的组件：Loggers(记录器)，Appenders
							(输出源)和Layouts(布局)。Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。</p>
						<p>Logger之间是具有java的继承特性的。Log4j有一个rootLogger，所有普通logger都默认继承rootLogger。而普通logger之间的继承关系是通过logger
							name来实现的。</p>
						<p>比如，叫"com.foo.Bar"名字的logger就继承于叫"com.foo"名字的logger。就好像java中"java.util"
							和"java.util.Vector"的关系一样。</p>

						<p>
							<code>commons-logging.propertyies</code>
							文件:
						</p>
						<pre class="brush: bash;">
# 使用 Log4JLogger
org.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4JLogger
</pre>
						<p id="apache-log4j-config">
							<code>log4j.propertyies</code>
							文件配置:
						</p>
						<pre class="brush: bash;">
# log4j.rootLogger=OFF 关闭log4j
# 配置根Logger
log4j.rootLogger=[LEVEL], console, message, error
	# LEVEL为日志级别(从低到高): DEBUG - INFO - WARN - ERROR - FATAL
	# console, message, error 都是自己的 appender 名字

# 配置 appender
log4j.appender.console=org.apache.log4j.ConsoleAppender
	# org.apache.log4j.ConsoleAppender（控制台）
		# Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG
		# ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true
		# Target=System.err：默认值是System.out
	# org.apache.log4j.FileAppender（文件）
		# Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG
		# ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true
		# Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true
		# File=./logs/logging.log4j：指定消息输出到logging.log4j文件中
	# org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）
		# Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG
		# ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true
		# Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true
		# File=./logs/logging.log4j：指定当前消息输出到logging.log4j文件中
		# DatePattern='.'yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。
			# 当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。
			# 另外，也可以指定按周、天、时、分等来滚动日志文件，对应的格式如下
				# 1)'.'yyyy-MM：每月
				# 2)'.'yyyy-ww：每周
				# 3)'.'yyyy-MM-dd：每天
				# 4)'.'yyyy-MM-dd-a：每天两次
				# 5)'.'yyyy-MM-dd-HH：每小时
				# 6)'.'yyyy-MM-dd-HH-mm：每分钟
	# org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）
		# Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG
		# ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true
		# Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true
		# File=./logs/logging.log4j：指定消息输出到logging.log4j文件中
		# MaxFileSize=100KB：后缀可以是KB, MB 或者GB。在日志文件到达该大小时，将会自动滚动，
			# 即将原来的内容移到logging.log4j.1文件中
		# MaxBackupIndex=2：指定可以产生的滚动文件的最大数，
			# 例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文件
	# org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
	
# 配置　appender layout
log4j.appender.console.layout=org.apache.log4j.PatternLayout
	# org.apache.log4j.HTMLLayout（以HTML表格形式布局）
		# LocationInfo=true：输出java文件名称和行号，默认值是false
		# Title=My Logging： 默认值是Log4J Log Messages
	# org.apache.log4j.PatternLayout（可以灵活地指定布局模式）
		# ConversionPattern=%m%n：设定以怎样的格式显示消息
			# %p：输出日志信息的优先级，即DEBUG，INFO，WARN，ERROR，FATAL。
			# %d：输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，
				# 如：%d{yyyy/MM/dd HH:mm:ss,SSS}。
			# %r：输出自应用程序启动到输出该log信息耗费的毫秒数。
			# %t：输出产生该日志事件的线程名。
			# %l：输出日志事件的发生位置，相当于%c.%M(%F:%L)的组合，包括类全名、方法、文件名以及在代码中的行数。
				# 例如：test.TestLog4j.main(TestLog4j.java:10)。
			# %c：输出日志信息所属的类目，通常就是所在类的全名。
			# %M：输出产生日志信息的方法名。
			# %F：输出日志消息产生时所在的文件名称。
			# %L:：输出代码中的行号。
			# %m:：输出代码中指定的具体日志信息。
			# %n：输出一个回车换行符，Windows平台为"\r\n"，Unix平台为"\n"。
			# %x：输出和当前线程相关联的NDC(嵌套诊断环境)，尤其用到像java servlets这样的多客户多线程的应用中。
			# %%：输出一个"%"字符。
			# 另外，还可以在%与格式字符之间加上修饰符来控制其最小长度、最大长度、和文本的对齐方式。如：
				# 1) c：指定输出category的名称，最小的长度是20，如果category的名称长度小于20的话，默认的情况下右对齐。
				# 2) %-20c："-"号表示左对齐。
				# 3) %.30c：指定输出category的名称，最大的长度是30，如果category的名称长度大于30的话，
					# 就会将左边多出的字符截掉，但小于30的话也不会补空格。
	# org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）
	# org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）
</pre>
						<p class="h5 text-primary">example</p>
						<div class="panel panel-default">
							<div class="panel-heading">
								<a data-toggle="collapse" data-parent="#accordion"
									href="#apache-log4j-example" aria-expanded="true"
									class="code-header">
									<span class="glyphicon glyphicon-plus"></span> View Code
								</a>
							</div>
							<div id="apache-log4j-example" class="panel-collapse collapse"
								style="" aria-expanded="true">
								<pre class="brush: bash;">
# 配置根Logger
log4j.rootLogger=DEBUG, console, message, error
# 为 com.release 包配置专门的Logger
log4j.logger.com.release=DEBUG, release

# 控制台输出内容
log4j.appender.console=org.apache.log4j.ConsoleAppender
log4j.appender.console.layout=org.apache.log4j.PatternLayout
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout.ConversionPattern=[ %m ] %p %r %l %n

# 信息输出文件
log4j.appender.message=org.apache.log4j.FileAppender
log4j.appender.message.layout=org.apache.log4j.PatternLayout
log4j.appender.message.Threshold=INFO
log4j.appender.message.layout.ConversionPattern=[ %m ] %p %r %l %n
log4j.appender.message.File=./logs/info.log4j

# 错误输出文件
log4j.appender.error=org.apache.log4j.FileAppender
log4j.appender.error.layout=org.apache.log4j.PatternLayout
log4j.appender.error.Threshold=ERROR
log4j.appender.error.Append=false
log4j.appender.error.layout.ConversionPattern=[ %m ] %p %r %l %n
log4j.appender.error.File=./logs/error.log4j

# com.release包下使用这个
log4j.appender.release=org.apache.log4j.FileAppender
log4j.appender.release.layout=org.apache.log4j.PatternLayout
log4j.appender.release.Threshold=INFO
log4j.appender.release.layout.ConversionPattern=[ %m ] %p %r %l %n
log4j.appender.release.File=./logs/release.log4j
</pre>
							</div>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="junit"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">JUnit-4.12</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p>
								<span class="text-primary">说明：</span> JUnit 是一个 Java
								语言的单元测试框架，有它自己的 JUnit 扩展生态圈。多数 Java 的开发环境都已经集成了 JUnit 作为单元测试的工具。
							</p>
							<p>JUnit 是一个开放源代码的 Java 测试框架，用于编写和运行可重复的测试。JUnit 提供以下功能：</p>
							<ol>
								<li>用于测试期望结果的断言</li>
								<li>用于共享共同测试数据的测试工具</li>
								<li>用于方便的组织和运行测试的测试套件</li>
								<li>图形和文本的测试运行器</li>
							</ol>
							<p>
								<b>JUnit 的特点:</b>
							</p>
							<ul>
								<li>
									<p>JUnit是用于编写和运行测试的开源框架。</p>
								</li>
								<li>
									<p>提供了注释，以确定测试方法。</p>
								</li>
								<li>
									<p>提供断言测试预期结果。</p>
								</li>
								<li>
									<p>提供了测试运行的运行测试。</p>
								</li>
								<li>
									<p>JUnit测试让您可以更快地编写代码，提高质量</p>
								</li>
								<li>
									<p>JUnit是优雅简洁。它是不那么复杂以及不需要花费太多的时间。</p>
								</li>
								<li>
									<p>JUnit测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。</p>
								</li>
								<li>
									<p>JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件。</p>
								</li>
								<li>
									<p>Junit显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。</p>
								</li>
							</ul>
							<p>
								JAR 包 --
								<a href="commons/junit-4.12/junit-4.12.jar">JUnit-4.12.jar</a>
							</p>
							<p>
								JUnit-4.12 依赖 hamcrest-1.3 版本 --
								<a href="commons/junit-4.12/hamcrest-core-1.3.jar">hamcrest-core-1.3.jar</a>
								和
								<a href="commons/junit-4.12/hamcrest-library-1.3.jar">hamcrest-library-1.3.jar</a>
							</p>
							<p>
								文档 --
								<a target="_blank"
									href="commons/junit-4.12/javadoc/latest/index.html">apidocs</a>
							</p>

						</div>

						<div class="sub-item">
							<p>
								<b>在 Gradle 中使用 JUnit 测试</b>
							</p>
							<div class="row">
								<div class="col-md-6">
									<p>使用 Gradle 构建的 Java项目，结构如右图所示：</p>
									<p>
										1. 在
										<code>build.gradle</code>
										文件中加入
										<code>junit-4.12</code>
										依赖
									</p>
									<pre class="brush: groovy;">
apply plugin: 'java'
apply plugin: 'application'

// 为 application 插件指定运行主类
mainClassName = 'App'

// 使用 jcenter 仓库
repositories {
    jcenter()
}

// 加入 junit-4.12 库依赖
dependencies {
    testCompile 'junit:junit:4.12'
}

// 生成的 jar 包 manefest 文件加入运行主类和作者信息
jar {
    manifest {
        attributes 'Main-Class': 'App'
        attributes 'author': author
        attributes 'mail': mail
    }
}
</pre>
								</div>
								<div class="col-md-6">
									<p width="100%">
										<img src="images/java-project.png" class="img-responsive">
									</p>
								</div>
							</div>

							<p>
								2. 在
								<code>src/test/java</code>
								目录编写相关测试类。
							</p>
							<div class="panel panel-default">
								<div class="panel-heading">
									<a data-toggle="collapse" data-parent="#accordion"
										href="#junit-java-src" aria-expanded="false"
										class="code-header collapsed">
										<span class="glyphicon glyphicon-plus"></span> View Code
										&nbsp;&nbsp;&nbsp;&nbsp;
										<code>src/main/java/cm/nate/parser/XmlParserUtils.java</code>
									</a>
								</div>
								<div id="junit-java-src" class="panel-collapse collapse"
									style="height: 0px;" aria-expanded="false">
									<pre class="brush: java;">
package cm.nate.parser;

import java.io.File;
import java.io.FileInputStream;
import java.util.ArrayList;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.SAXException;

import cm.nate.model.Book;
import cm.nate.service.BookSaxParserService;

public class XmlParserUtils {
	/**
	 * 此类从 res/books.xml 文件中读取 book 信息
	 */
    public static ArrayList&lt;Book> getBooks(String xmlPath) {
        if(null == xmlPath || "".equals(xmlPath)) {
            return null;
        }

        File xml = new File(xmlPath);
        if(!xml.exists() || xml.isDirectory()) {
            return null;
        }

        SAXParserFactory factory = SAXParserFactory.newInstance();  
        SAXParser parser = null;
        BookSaxParserService handler;
        try {
            parser = factory.newSAXParser();
            handler = new BookSaxParserService();
            parser.parse(new FileInputStream(xml), handler);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

        ArrayList&lt;Book> list = handler.getBooks();
        
        return list;
    }
}
</pre>
								</div>
							</div>

							<div class="panel panel-default">
								<div class="panel-heading">
									<a data-toggle="collapse" data-parent="#accordion"
										href="#junit-test-src" aria-expanded="false"
										class="code-header collapsed">
										<span class="glyphicon glyphicon-plus"></span> View Code
										&nbsp;&nbsp;&nbsp;&nbsp;
										<code>src/main/java/cm/nate/parser/XmlParserUtilsTest.java</code>
									</a>
								</div>
								<div id="junit-test-src" class="panel-collapse collapse"
									style="height: 0px;" aria-expanded="false">
									<pre class="brush: java;">
package cm.nate.parser;

import cm.nate.model.Book;
import java.util.ArrayList;

// 静态导入 Assert 类的方法
import static org.junit.Assert.*;
import org.junit.Test;

public class XmlParserUtilsTest {

    @Test			// 使用 Test 注解
    public void testGetBooks() {
        assertNull(XmlParserUtils.getBooks(null));		// 参数为 null 测试
        assertNull(XmlParserUtils.getBooks(""));		// 参数为空测试

        assertNull(XmlParserUtils.getBooks("res/"));	// 参数为目录测试
        assertNull(XmlParserUtils.getBooks("res/not-exist.xml"));    // 文件不存在测试
        assertNotNull(XmlParserUtils.getBooks("res/books.xml"));     // 一切正常测试
    }
}
</pre>
								</div>
							</div>
							<p>
								3. 直接运行
								<code>$ gradle test</code>
								, 如果测试通过，打开
								<code>build/reports/tests/test/index.html</code>
								文件，可以看到生成的测试报告。
							</p>

						</div>

						<div class="sub-item">
							<p>
								<b>Assert 类的一些方法：</b> -- 详情参数 API 文档: &nbsp;&nbsp;
								<a
									href="commons/junit-4.12/javadoc/latest/org/junit/Assert.html"
									target="_blank">Assert</a>
							</p>
							<ul>
								<li>
									<p>
										<code>assertNull(Object object)</code>
										-- 检查对象是空的
									</p>
								</li>
								<li>
									<p>
										<code>assertNotNull(Object object)</code>
										-- 检查对象不是空的
									</p>
								</li>
								<li>
									<p>
										<code>assertTrue(boolean condition)</code>
										-- 检查条件为 true
									</p>
								</li>
								<li>
									<p>
										<code>assertFalse(boolean condition)</code>
										-- 检查条件为 false
									</p>
								</li>
								<li>
									<p>
										<code>assertEquals(Object expected, Object actual)</code>
										-- 检查是否 equals
									</p>
								</li>
								<li>
									<p>
										<code>assertNotEquals(Object expected, Object actual)</code>
										-- 检查是否不 equals
									</p>
								</li>
								<li>
									<p>
										<code>fail</code>
										-- 在没有报告的情况下使测试不通过
									</p>
								</li>
								<li>
									<p>
										<code>fail((String message))</code>
										-- 使测试不通过并生成一条消息
									</p>
								</li>
							</ul>

							<p>
								<b>JUnit 4 中常用注解:</b>
							</p>
							<ul>
								<li>
									<p>
										<code>@Test</code>
										-- @Test 注解的 public void 方法将会被当做测试用例，JUnit 每次都会创建一个新的测试实例，然后调用
										@Test 注解方法，任何异常的抛出都会认为测试失败。
									</p>
									<pre class="brush: java;">
/**
 * @Test 注解提供 2 个参数：
 * 1. expected -- 定义测试方法应该抛出的异常，如果测试方法没有抛出异常或者抛出了一个不同的异常，测试失败
 * 2. timeout -- 如果测试运行时间长于该定义时间，测试失败（单位为毫秒）
 */
@Test(expected=Exception.class)
public void testAdd() throws Exception {  
    throw new Exception();
}

@Test(timeout=5000)  
public void testAdd() {  
    while(true) {}  
}
</pre>
								</li>
								<li>
									<p>
										<code>@Before</code>
										-- 使用 @Before 注解一个 public void 方法会使该方法在 @Test
										注解方法被执行前执行（那么就可以在该方法中创建相同的对象）
									</p>
								</li>
								<li>
									<p>
										<code>@After</code>
										-- 使用 @After 注解一个 public void 方法会使该方法在 @Test 注解方法执行后被执行, 即使在
										@Before 注解方法、@Test 注解方法中抛出了异常，所有的 @After 注解方法依然会被执行
									</p>
								</li>
								<li>
									<p>
										<code>@BeforeClass</code>
										-- 使用 @BeforeClass 注解一个 public static void
										方法，并且该方法不带任何参数，会使该方法在所有测试方法被执行前执行一次，并且只执行一次
									</p>
								</li>
								<li>
									<p>
										<code>@AfterClass</code>
										-- 使用 @AfterClass 注解一个 public static void
										方法会使该方法在测试类中的所有测试方法执行完后被执行, 即使在 @BeforeClass 注解方法中抛出了异常，所有的
										@AfterClass 注解方法依然会被执行
									</p>
								</li>
								<li>
									<p>
										<code>@Ignore</code>
										-- 对包含测试类的类或 @Test 注解方法使用 @Ignore
										注解将使被注解的类或方法不会被当做测试执行，相当于放弃对类或 @Test 标示方法的测试。
									</p>
								</li>
							</ul>
						</div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="commons-collections"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">commons-collections4-4.1</h3>
					</div>
					<div class="panel-body">
						<p>
							<span class="text-primary">说明：</span>Apache Commons
							Collections是一个用来处理集合Collection的开源工具包，比如你可以用来将一个对象拷贝多份并存放到一个Bag对象中（这个看来没有多大用处），得到两个集合里相同的元素，删除一个集合里的元素并返回删除的元素，还有除了通过一个集合里的key得到value外，还可以通过value
							得到key，也就是说这个集合里的value是唯一的，另外还可以将一个集合里的key和value值对调，得到一个集合里的某一key之后的另一个
							key值等等。
						</p>
						<p>
							jar包 --
							<a
								href="commons/commons-collections4-4.1/commons-collections4-4.1.jar">commons-collections4-4.1.jar</a>
						</p>
						<p>
							文档 --
							<a target="_blank"
								href="commons/commons-collections4-4.1/apidocs/index.html">apidocs</a>
						</p>
						<p>根据集合类型，大致将此包的类归纳为9类：</p>
						<ol>
							<li>
								<p>
									<u><strong>Bag</strong></u> --
									在org.apache.commons.collections包中定义的接口，它extends
									java.util.Collection，而它的<strong>实现类</strong>都被放在下面的bag包中。<strong>HashBag</strong>是Bag接口的一个标准实现。而<strong>BagUtils</strong>提供一组static的方法让调用者获取经过不同装饰后的Bag实例.具体用法见代码样例
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-collections-bag" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-collections-bag"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
public class Book {  
    private String name;  
    private String isbn;  
    private double retailPrice;  
     
    public Book() {}  
    public Book(String name, String isbn, double retailPrice) {  
        this.name = name;  
        this.isbn = isbn;  
        this.retailPrice = retailPrice;  
    }  
    public String toString() {  
        return new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE)  
        .append("name", name)  
        .append("ISBN", isbn)  
        .append("retailPrice", retailPrice)  
        .toString();  
    }  
    public String getIsbn() {  
        return isbn;  
    }  
    public void setIsbn(String isbn) {  
        this.isbn = isbn;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    public double getRetailPrice() {  
        return retailPrice;  
    }  
    public void setRetailPrice(double retailPrice) {  
        this.retailPrice = retailPrice;  
    }  
}  
// data setup  
Book book1 = new Book("Refactoring Workbook", "7-5083-2208-8", 29.8);  
Book book2 = new Book("J2EE Design Patterns", "7-5083-3099-4", 45);  
Book book3 = new Book("Agile Software Development", "7-5083-1503-0", 59);  

// create a bag  
Bag myBag = BagUtils.typedBag(new HashBag(), Book.class);  
myBag.add(book1, 360); //Bag, add 360 book1s into myBag  
myBag.add(book2, 500); //Bag,add function  
myBag.add(book3, 170); //Bag,add function  

// calculations for a bag  
double price1 = book1.getRetailPrice();  
double price2 = book2.getRetailPrice();  
double price3 = book3.getRetailPrice();  
int book1Count = myBag.getCount(book1);//the count should be 360  
int book2Count = myBag.getCount(book2);//the count should be 500  
int book3Count = myBag.getCount(book3);//the count should be 170  
double totalValue = (price1 * book1Count) + (price2 * book2Count) + (price3 * book3Count);  

// dispaly results  
System.out.println("There are " + book1Count + " copies of " + book1.getName() + ".");  
System.out.println("There are " + book2Count + " copies of " + book2.getName() + ".");  
System.out.println("There are " + book3Count + " copies of " + book3.getName() + ".");  
System.out.println("The total value of these books is: " + totalValue);
</pre>
									</div>
								</div>
							</li>
							<li>
								<p>
									<u><strong>Buffer</strong></u> --
									定义在org.apache.commons.collections包下面的接口，用于表示按一定顺序除去成员对象的collection如队列等。具体的
									<strong>实现类</strong>在org.apache.commons.collections.buffer
									包下可以找到。最简单直接的Buffer实现类是 <strong>UnboundedFifoBuffer</strong>，提供先进先出的大小可变的队列。而
									<strong>BoundedFifoBuffer</strong>则是对其大小进行了限制，是固定大小的先进先出队列。 <strong>BlockingBuffer</strong>要在多线程的环境中才能体现出它的价值，尤其是当我们需要实现某种流水线时这个BlockingBuffer很有用：每个流水线上的组件从上游的BlockingBuffer获取数据，处理后放到下一个BlockingBuffer中依次传递。BlockingBuffer的核心特色通俗点说就是如果你向它要东西，而它暂时还没有的话，你可以一直等待直至拿到为止。
									<strong>PriorityBuffer</strong>则提供比一般的先进先出Buffer更强的控制力：我们可以自定义Comparator给它，告诉它怎么判定它的成员的先后顺序，优先级最高的最先走。此外还有执行类型检查的
									<strong>TypedBuffer</strong>、或者不可改变的 <strong>UnmodifiableBuffer</strong>等等
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-collections-buffer" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-collections-buffer"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
// data setup  
Book book1 = new Book("Refactoring Workbook", "7-5083-2208-8", 29.8);  
Book book2 = new Book("J2EE Design Patterns", "7-5083-3099-4", 45);  
Book book3 = new Book("Agile Software Development", "7-5083-1503-0", 59);  
Book book4 = new Book("Professional JSP", "7-5053-8005-2", 100);  

// create a Buffer  
Buffer buffer =  
    BufferUtils.typedBuffer(new BoundedFifoBuffer(3), Book.class); //key line1  
buffer.add(book1);  
buffer.add(book2);  
buffer.add(book3);  
Book removed = (Book) buffer.remove();//key line2  
System.out.println("Removed:");  
System.out.println(removed);  
buffer.add(book4);//key line3  
 
// get items in buffer  
for (int i = 0; i < 3; i++) {  
    System.out.println(buffer.get());  
    buffer.remove();  
}  
</pre>
									</div>
								</div>
							</li>
							<li>
								<p>
									<u><strong>Map</strong></u> -- 在java.util.Map的基础上扩展的接口和类。 <strong>BidiMap</strong>，直译就是双向Map，可以通过key找到value，也可以通过value找到key，这在我们日常的代码-名称匹配的时候很方便：因为我们除了需要通过代码找到名称之外，往往也需要处理用户输入的名称，然后获取其代码。需要注意的是BidiMap当中不光key不能重复，value也不可以。
									<strong>MultiMap</strong>，就是说一个key不在是简单的指向一个对象，而是一组对象，add()和remove()的时候跟普通的Map无异，只是在get()时返回一个Collection，利用MultiMap，我们就可以很方便的往一个key上放数量不定的对象，也就实现了一对多。
									<strong>LazyMap</strong>，意思就是这个Map中的键/值对一开始并不存在，当被调用到时才创建。
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-collections-map" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-collections-map"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
public static void demoBidiMap() {  
    System.out.println(StringUtils.center(" demoBidiMap ", 40, "="));  
    BidiMap bidiMap = new DualHashBidiMap();  
    bidiMap.put("BJ", "Beijing");  
    bidiMap.put("SH", "Shanghai");  
    bidiMap.put("GZ", "Guangzhou");  
    bidiMap.put("CD", "Chengdu");  
    System.out.println("Key-Value: BJ = " + bidiMap.get("BJ"));  
    System.out.println("Value-Key: Chengdu = " + bidiMap.getKey("Chengdu"));  
    System.out.println(StringUtils.repeat("=", 40));  
}  
public static void demoMultiMap() {  
    System.out.println(StringUtils.center(" demoMultiMap ", 40, "="));  
    MultiMap multiMap = new MultiHashMap();  
    multiMap.put("Sean", "C/C++");  
    multiMap.put("Sean", "OO");  
    multiMap.put("Sean", "Java");  
    multiMap.put("Sean", ".NET");  
    multiMap.remove("Sean", "C/C++");  
    System.out.println("Sean's skill set: " + multiMap.get("Sean"));  
    System.out.println(StringUtils.repeat("=", 40));  
}  
public static void demoLazyMap() {  
    System.out.println(StringUtils.center(" demoLazyMap ", 40, "="));  
    // borrowed from Commons Collection's Javadoc  
    Factory factory = new Factory() {  
        public Object create() {  
            return new Date();  
        }  
    };  
    Map lazy = LazyMap.decorate(new HashMap(), factory);  
    System.out.println(lazy.get("NOW"));  
    System.out.println(StringUtils.repeat("=", 40));  
}
</pre>
									</div>
								</div>
							</li>

							<li>
								<p>
									<u><strong>Collection</strong></u> -- 用也各collection之间的类型转换。典型的是
									<strong>TypedCollection</strong>，它实际上的作用就是提供一个decorate方法，我们传进去一个Collection和需要的类型甄别信息java.lang.Class，它给我们创建一个全新的强类型的Collection
								</p>
							</li>

							<li>
								<p>
									<u><strong>Comparator</strong></u> --
									提供了一些Comparator的实现类（都在org.apache.commons.collections.comparators包下面）<br>
									<strong>BooleanComparator</strong> –
									用于排序一组Boolean对象，指明先true还是先false；<br> <strong>ComparableComparator</strong>
									–
									用于排序实现了java.lang.Comparable接口的对象（我们常用的Java类如String、Integer、Date、Double、File、Character等等都实现了Comparable接口）；<br>
									<strong>ComparatorChain</strong> –
									定义一组Comparator链，链中的Comparator对象会被依次执行；<br> <strong>FixedOrderComparator</strong>
									– 用于定义一个特殊的顺序，对一组对象按照这样的自定义顺序进行排序；<br> <strong>NullComparator</strong>
									– 让null值也可参与比较，可以设定为先null或者后null；<br> <strong>ReverseComparator</strong>
									– 将原有的Comparator效果反转；<br> <strong>TransformingComparator</strong>
									– 将一个Comparator装饰为具有Transformer效果的Comparator。
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-collections-Comparator" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-collections-Comparator"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
public class Issue {  
    private long id;  
    private String severity;  
    private String owner;  
     
    public Issue() {}  
    public Issue(long id, String severity, String owner) {  
        this.id = id;  
        this.severity = severity;  
        this.owner = owner;  
    }  
    public String toString() {  
        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)  
                .append("id", id)  
                .append("severity", severity)  
                .append("owner", owner)  
                .toString();  
    }  
    public long getId() {  
        return id;  
    }  
    public void setId(long id) {  
        this.id = id;  
    }  
    public String getOwner() {  
        return owner;  
    }  
    public void setOwner(String owner) {  
        this.owner = owner;  
    }  
    public String getSeverity() {  
        return severity;  
    }  
    public void setSeverity(String severity) {  
        this.severity = severity;  
    }  
}  
 // data setup  
Issue[] issues = new Issue[] {  
        new Issue(15102, "Major", "John"),  
        new Issue(15103, "Minor", "Agnes"),  
        new Issue(15104, "Critical", "Bill"),  
        new Issue(15105, "Major", "John"),  
        new Issue(15106, "Major", "John"),  
        new Issue(15107, "Critical", "John"),  
        new Issue(15108, "Major", "Agnes"),  
        new Issue(15109, "Minor", "Julie"),  
        new Issue(15110, "Major", "Mary"),  
        new Issue(15111, "Enhancement", "Bill"),  
        new Issue(15112, "Minor", "Julie"),  
        new Issue(15113, "Major", "Julie")  
};  
// comparators setup  
String[] severityOrder = {"Critical", "Major", "Minor", "Enhancement"};  
Comparator severityComparator = new FixedOrderComparator(severityOrder);//key line1  
ComparatorChain compChain = new ComparatorChain();//key line2  
compChain.addComparator(new BeanComparator("owner"));  
compChain.addComparator(new BeanComparator("severity", severityComparator));  
compChain.addComparator(new BeanComparator("id"));  
// sort and display  
Arrays.sort(issues, compChain);//key line3  
for (int i = 0; i < issues.length; i++) {  
    System.out.println(issues[i]);  
}  
</pre>
									</div>
								</div>
							</li>

							<li>
								<p>
									<u><strong>Predicate</strong></u> --
									它以一个Object对象为参数，处理后返回一个boolean值，检验某个对象是否满足某个条件。Commons
									Collections也提供了一组定义好的Predicate类供我们使用，这些类都放在org.apache.commons.collections.functors包中。当然，我们也可以自定义Predicate，只要实现这个Predicate接口即可。
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-collections-Predicate" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-collections-Predicate"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
Predicate p1 = new InstanceofPredicate(String.class); //key line1  
Predicate p2 = NotNullPredicate.getInstance(); //key line2  
Predicate p3 = new Predicate() { //key line3  
    public boolean evaluate(Object obj) {  
        String str = (String) obj;  
        return StringUtils.isAlphanumeric(str)  
            && str.length() >= 6  
            && str.length() <= 10;  
    }  
};  
Predicate p4 = PredicateUtils.allPredicate(new Predicate[]{p1, p2, p3}); //key line4                 
String input = "ABCD1234";  
Object[] raw = new Object[] {  
    "Is '",  
    input,  
    "' a valid input? ",  
    BooleanUtils.toStringYesNo(p4.evaluate(input)),  
    "."  
};  
System.out.println(StringUtils.join(raw));
</pre>
									</div>
								</div>
							</li>

							<li>
								<p>
									<u><strong>Transformer</strong></u> --
									我们有时候需要将某个对象转换成另一个对象供另一组方法调用，而这两类对象的类型有可能并不是出于同一个继承体系的，或者说出了很基本的Object之外没有共同的父类，或者我们根本不关心他们是不是有其他继承关系，甚至就是同一个类的实例只是对我们而言无所谓，我们为了它能够被后续的调用者有意义的识别和处理，在这样的情形，我们就可以利用Transformer。除了基本的转型Transformer之外，Commons
									Collections还提供了Transformer链和带条件的Transformer，使得我们很方便的组装出有意义的转型逻辑。
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-collections-Transformer" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-collections-Transformer"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
public class Applicant {  
    private String name;  
    private int age;  
    private String applyFor;  
     
    public Applicant() {}  
    public Applicant(String name, int age, String applyFor) {  
        this.name = name;  
        this.age = age;  
        this.applyFor = applyFor;  
    }  
    public String toString() {  
        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)  
                .append("name", name)  
                .append("age", age)  
                .append("applyFor", applyFor)  
                .toString();  
    }  
    public int getAge() {  
        return age;  
    }  
    public void setAge(int age) {  
        this.age = age;  
    }  
    public String getApplyFor() {  
        return applyFor;  
    }  
    public void setApplyFor(String applyFor) {  
        this.applyFor = applyFor;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
} 
public class Employee {  
    private String name;  
    private int age;  
    private Date dateJoined;  
    private String grade;  
    private double salary;  
     
    public Employee() {}  
    public Employee(String name, int age, Date dateJoined, String grade, double salary) {  
        this.name = name;  
        this.age = age;  
        this.dateJoined = dateJoined;  
        this.grade = grade;  
        this.salary = salary;  
    }  
    public String toString() {  
        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)  
                .append("name", name)  
                .append("age", age)  
                .append("dateJoined", DateFormatUtils.format(dateJoined, "yyyy-MM-dd"))  
                .append("grade", grade)  
                .append("salary", salary)  
                .toString();  
    }  
    public int getAge() {  
        return age;  
    }  
    public void setAge(int age) {  
        this.age = age;  
    }  
    public Date getDateJoined() {  
        return dateJoined;  
    }  
    public void setDateJoined(Date dateJoined) {  
        this.dateJoined = dateJoined;  
    }  
    public String getGrade() {  
        return grade;  
    }  
    public void setGrade(String grade) {  
        this.grade = grade;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    public double getSalary() {  
        return salary;  
    }  
    public void setSalary(double salary) {  
        this.salary = salary;  
    }  
}

// data setup  
Applicant[] applicants = new Applicant[] {  
    new Applicant("Tony", 26, "Developer"),  
    new Applicant("Michelle", 24, "Tester"),  
    new Applicant("Jack", 28, "Project Manager")  
};  
List appList = Arrays.asList(applicants);  
 
// predicate setup  
Predicate isDeveloper = new Predicate() {  
    public boolean evaluate(Object obj) {  
        Applicant app = (Applicant) obj;  
        return "Developer".equalsIgnoreCase(app.getApplyFor());  
    }  
};  
Predicate isTester = new Predicate() {  
    public boolean evaluate(Object obj) {  
        Applicant app = (Applicant) obj;  
        return "Tester".equalsIgnoreCase(app.getApplyFor());  
    }  
};  
Predicate isPM = new Predicate() {  
    public boolean evaluate(Object obj) {  
        Applicant app = (Applicant) obj;  
        return "Project Manager".equalsIgnoreCase(app.getApplyFor());  
    }  
};  
Predicate[] checkApplyFor = new Predicate[] {  
    isDeveloper,  
    isTester,  
    isPM  
};  
 
// transformer setup  
Transformer developerTransformer = new Transformer() {  
    public Object transform(Object obj) {  
        Applicant app = (Applicant) obj;  
        return new Employee(  
            app.getName(), app.getAge(), new Date(), "E4", 2000  
        );  
    }  
};  
Transformer testerTransformer = new Transformer() {  
    public Object transform(Object obj) {  
        Applicant app = (Applicant) obj;  
        return new Employee(  
            app.getName(), app.getAge(), new Date(), "E4", 2000  
        );  
    }  
};  
Transformer pmTransformer = new Transformer() {  
    public Object transform(Object obj) {  
        Applicant app = (Applicant) obj;  
        return new Employee(  
            app.getName(), app.getAge(), new Date(), "E5", 3000  
        );  
    }  
};  
Transformer[] transformers = new Transformer[] {  
    developerTransformer,  
    testerTransformer,  
    pmTransformer  
};  
 
// transform  
Transformer employTransformer = new SwitchTransformer(  
    checkApplyFor, transformers, null  
);  
Collection employed = CollectionUtils.collect(appList, employTransformer);  
 
// output  
System.out.println("Applicants: ");  
Iterator iter1 = appList.iterator();  
while (iter1.hasNext()) {  
    System.out.println(iter1.next());  
}  
System.out.println("Employed: ");  
Iterator iter2 = employed.iterator();  
while (iter2.hasNext()) {  
    System.out.println(iter2.next());  
}
</pre>
									</div>
								</div>
							</li>

							<li>
								<p>
									<u><strong>Closure</strong></u> -- 这一组接口和类提供一个操作对象的 execute
									方法，为我们在处理一系列对象时可以将处理逻辑分离出来。 <strong>ChainedClosure</strong>可以包装一组Closure作为整体执行；IfClosure在创建时需要提供给它一个Predicate和两个Closure，执行时先做Predicate判定再决定执行哪一个Closure；
									<strong>SwitchClosure</strong>跟SwitchTransformer类似，根据创建时传入的Predicate组和Closure组对应执行；
									<strong>WhileClosure</strong>则根据创建时传入的Predicate做判断，如果为true则执行Closure，直到Predicate返回false；等等。
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-collections-Closure" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-collections-Closure"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
public static void demoClosureUsage() {  
    // data setup  
    Employee[] employees = new Employee[] {  
        new Employee("Tony", 26, new Date(), "E4", 2000),  
        new Employee("Michelle", 24, new Date(), "E4", 2000),  
        new Employee("Jack", 28, new Date(), "E5", 3000)  
    };  
    Collection empColl = Arrays.asList(employees);  
    printColl("Before salary increase:", empColl);  
     
    // closure setup  
    Closure salaryIncreaseClosure = new Closure() {//key line1  
        public void execute(Object obj) {  
            Employee emp = (Employee) obj;  
            emp.setSalary(emp.getSalary() * 1.20);  
        }  
    };  
     
    // salary increase  
    CollectionUtils.forAllDo(empColl, salaryIncreaseClosure);//key line2  
    printColl("After salary increase:", empColl);  

    System.out.println(StringUtils.repeat("=", 40));  
}  
 
public static void printColl(String label, Collection c) {  
    if (StringUtils.isNotBlank(label)) {  
        System.out.println(label);  
    }  
    Iterator iter = c.iterator();  
    while (iter.hasNext()) {  
        System.out.println(iter.next());  
    }  
}
</pre>
									</div>
								</div>
							</li>

							<li>
								<p>
									<u><strong>Iterator</strong></u> --
									java.util.Iterator接口定义了标准的Collection遍历方法，但是如果不做改变的使用它，我们得到的是从头到尾一次性的遍历。假如我们需要循环遍历，假如我们需要遍历某一段，假如我们需要遍历满足某些条件的元素，等等等等，我们就不能完全依赖于这个Iterator的标准实现了。除非我们宁可在此基础上在调用的代码中多加一些判断，不过这样的话代码就会显得混乱，时间长了就容易变得难以维护。Commons
									Collections的这一组Iterator为我们带来了便利。
								</p>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
											href="#commons-collections-Iterator" aria-expanded="true"
											class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code
										</a>
									</div>
									<div id="commons-collections-Iterator"
										class="panel-collapse collapse" style="" aria-expanded="true">
										<pre class="brush: java;">
public static void demoIteratorUsage() {  
    // data setup  
    String[] weekDays = {  
        "Monday", "Tuesday", "Wednesday",  
        "Thursday", "Friday", "Saturday", "Sunday"  
    };  
    List weekDayList = Arrays.asList(weekDays);  
     
    // workdays  
    Iterator iter1 = new ArrayListIterator(weekDays, 0, 5);//key line1  
    printColl("Partial:", iter1, 5);  
     
    // loop  
    Iterator iter2 = new LoopingIterator(weekDayList);//key line2  
    printColl("Loop:", iter2, 10);  
     
    // looping workdays  
    Predicate notWeekendPredicate = new Predicate() {  
        public boolean evaluate(Object obj) {  
            String str = (String) obj;  
            if ("Saturday".equalsIgnoreCase(str)) {  
                return false;  
            }  
            if ("Sunday".equalsIgnoreCase(str)) {  
                return false;  
            }  
            return true;  
        }  
    };  
    Iterator iter3 = new FilterIterator(//key line3  
        new LoopingIterator(weekDayList),  
        notWeekendPredicate  
    );  
    printColl("No Weekends loop:", iter3, 12);  
     
    System.out.println(StringUtils.repeat("=", 40));  

}  
 
public static void printColl(String label, Iterator iter, int maxCount) {  
    if (StringUtils.isNotBlank(label)) {  
        System.out.println(label);  
    }  
    int i = 0;  
    while (iter.hasNext() && i < maxCount) {  
        System.out.println("# " + iter.next() + " #");  
        i++;  
    }  
}  
</pre>
									</div>
								</div>
							</li>
						</ol>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="commons-compress"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">commons-compress-1.12</h3>
					</div>
					<div class="panel-body">
						<p>
							<span class="text-primary">说明：</span>Apache Commons
							Compress是一个压缩、解压缩文件的类库。 定义一套 API 与 ar, cpio, Unix dump, tar, zip,
							gzip, XZ, Pack200, bzip2, 7z, arj, lzma, snappy, DEFLATE 和 Z
							files一起工作。
						</p>
						<p>
							jar包 --
							<a href="commons/commons-compress-1.12/commons-compress-1.12.jar">commons-compress-1.12.jar</a>
						</p>
						<p>
							文档 --
							<a target="_blank"
								href="commons/commons-compress-1.12/apidocs/index.html">apidocs</a>
						</p>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="commons-io"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">commons-io-2.5</h3>
					</div>
					<div class="panel-body">
						<p>
							<span class="text-primary">说明：</span>
						</p>
						<p>
							jar包 --
							<a href="commons/commons-io-2.5/commons-io-2.5.jar">commons-io-2.5.jar</a>
						</p>
						<p>
							文档 --
							<a target="_blank" href="commons/commons-io-2.5/docs/index.html">apidocs</a>
						</p>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="apache-lucene"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">apache-lucene</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p>
								<span class="text-primary">说明：</span>
								Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。
							</p>
							<p>
								文档 --
								<a target="_blank" href="commons/lucene-6.4.2/docs/index.html">apidocs</a>
							</p>
							<p>
								<b>Lucene 的一些概念:</b>
							</p>
							<ul>
								<li>
									<b>analyzer</b> --
									Analyzer是分析器，它的作用是把一个字符串按某种规则划分成一个个词语，并去除其中的无效词语，这里说的无效词语是指英文中的“of”、
									“the”，中文中的“的”、“地”等词语，这些词语在文章中大量出现，但是本身不包含什么关键信息，去掉有利于缩小索引文件、提高效率、提高命中率。
								</li>
								<li>
									<b>document</b> --
									用户提供的源是一条条记录，它们可以是文本文件、字符串或者数据库表的一条记录等等。一条记录经过索引之后，就是以一个Document的形式存储在索引文件中的。用户进行搜索，也是以Document列表的形式返回。
								</li>
								<li>
									<b>field</b> --
									一个Document可以包含多个信息域，例如一篇文章可以包含“标题”、“正文”、“最后修改时间”等信息域，这些信息域就是通过Field在Document中存储的。Field有两个属性可选：存储和索引。通过存储属性你可以控制是否对这个Field进行存储；通过索引属性你可以控制是否对该Field进行索引。
								</li>
								<li>
									<b>term</b> --
									term是搜索的最小单位，它表示文档的一个词语，term由两部分组成：它表示的词语和这个词语所出现的field。
								</li>
								<li>
									<b>tocken</b> --
									tocken是term的一次出现，它包含trem文本和相应的起止偏移，以及一个类型字符串。一句话中可以出现多次相同的词语，它们都用同一个term表示，但是用不同的tocken，每个tocken标记该词语出现的地方。
								</li>
								<li>
									<b>segment</b> --
									添加索引时并不是每个document都马上添加到同一个索引文件，它们首先被写入到不同的小文件，然后再合并成一个大索引文件，这里每个小文件都是一个segment。
								</li>
							</ul>

							<p>
								<b>lucene的工作方式:</b>
							</p>
							<p>
								Lucene提供的服务实际包含两部分：一入一出。所谓入是写入，即将你提供的源（本质是字符串）写入索引或者将其从索引中删除；所谓出是读出，即向用户提供全文搜索服务，让用户可以通过关键词定位源。
							</p>

							<p>
								<b>Lucene的写入流程:</b>
							</p>
							<ol>
								<li>源字符串首先经过analyzer处理，包括：分词，分成一个个单词；去除stopword（可选）。</li>
								<li>将源中需要的信息加入Document的各个Field中，并把需要索引的Field索引起来，把需要存储的Field存储起来。
								</li>
								<li>将索引写入存储器，存储器可以是内存或磁盘。</li>
							</ol>
							<p>
								<b>Lucene的读出流程:</b>
							</p>
							<ol>
								<li>用户提供搜索关键词，经过analyzer处理。</li>
								<li>对处理后的关键词搜索索引找出对应的Document。</li>
								<li>用户根据需要从找到的Document中提取需要的Field。</li>
							</ol>
							<p>
								<b>Lucene 6.4.2 主要包括如下内容(jar)：</b>
							</p>
							<ul>
								<li>
									<a href="commons/lucene-6.4.2/core/lucene-core-6.4.2.jar">core</a>
									-- Lucene 核心库。
								</li>

								<li>
									<a
										href="commons/lucene-6.4.2/analysis/common/lucene-analyzers-common-6.4.2.jar">analyzers-common</a>
									-- 在不同的语言和领域分析索引内容。
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/analysis/icu/lucene-analyzers-icu-6.4.2.jar">analyzers-icu</a>
									-- 分析与ICU(国际组件对Unicode)的集成。
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/analysis/kuromoji/lucene-analyzers-kuromoji-6.4.2.jar">analyzers-kuromoji</a>
									-- 日语形态分析器。
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/analysis/morfologik/lucene-analyzers-morfologik-6.4.2.jar">analyzers-morfologik</a>
									-- 分析器的字典,内置波兰字典。
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/analysis/phonetic/lucene-analyzers-phonetic-6.4.2.jar">analyzers-phonetic</a>
									-- Analyzer for indexing phonetic signatures (for sounds-alike
									search)
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/analysis/smartcn/lucene-analyzers-smartcn-6.4.2.jar">analyzers-smartcn</a>
									-- 中文分词查询器
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/analysis/stempel/lucene-analyzers-stempel-6.4.2.jar">analyzers-stempel</a>
									-- Analyzer for indexing Polish
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/analysis/uima/lucene-analyzers-uima-6.4.2.jar">analyzers-uima</a>
									-- Analysis integration with Apache UIMA
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/backward-codecs/lucene-backward-codecs-6.4.2.jar">backward-codecs</a>
									-- 编解码器Lucene的旧版本。
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/benchmark/lucene-benchmark-6.4.2.jar">benchmark</a>
									-- System for benchmarking Lucene
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/classification/lucene-classification-6.4.2.jar">classification</a>
									-- Lucene 分类模块
								</li>
								<li>
									<a href="commons/lucene-6.4.2/codecs/lucene-codecs-6.4.2.jar">codecs</a>
									-- Lucene编解码器和检索格式。
								</li>
								<li>
									<a href="commons/lucene-6.4.2/demo/lucene-demo-6.4.2.jar">demo</a>
									-- 简单的实例。
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/expressions/lucene-expressions-6.4.2.jar">expressions</a>
									-- Dynamically computed values to sort/facet/search on based on
									a pluggable grammar.
								</li>
								<li>
									<a href="commons/lucene-6.4.2/facet/lucene-facet-6.4.2.jar">facet</a>
									-- Faceted indexing and search capabilities
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/grouping/lucene-grouping-6.4.2.jar">grouping</a>
									-- 搜索结果进行分组收集。
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/highlighter/lucene-highlighter-6.4.2.jar">highlighter</a>
									-- 高亮显示
								</li>
								<li>
									<a href="commons/lucene-6.4.2/join/lucene-join-6.4.2.jar">join</a>
									-- Index-time and Query-time joins for normalized content
								</li>
								<li>
									<a href="commons/lucene-6.4.2/memory/lucene-memory-6.4.2.jar">memory</a>
									-- Single-document in-memory index implementation
								</li>
								<li>
									<a href="commons/lucene-6.4.2/misc/lucene-misc-6.4.2.jar">misc</a>
									-- Index tools and other miscellaneous code
								</li>
								<li>
									<a href="commons/lucene-6.4.2/queries/lucene-queries-6.4.2.jar">queries</a>
									-- Filters and Queries that add to core Lucene
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/queryparser/lucene-queryparser-6.4.2.jar">queryparser</a>
									-- Query parsers and parsing framework
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/replicator/lucene-replicator-6.4.2.jar">replicator</a>
									-- Files replication utility
								</li>
								<li>
									<a href="commons/lucene-6.4.2/sandbox/lucene-sandbox-6.4.2.jar">sandbox</a>
									-- Various third party contributions and new ideas
								</li>
								<li>
									<a href="commons/lucene-6.4.2/spatial/lucene-spatial-6.4.2.jar">spatial</a>
									-- Geospatial search
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/spatial3d/lucene-spatial3d-6.4.2.jar">spatial3d</a>
									-- 3D spatial planar geometry APIs
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/spatial-extras/lucene-spatial-extras-6.4.2.jar">spatial-extras</a>
									-- 地理位置查询
								</li>
								<li>
									<a href="commons/lucene-6.4.2/suggest/lucene-suggest-6.4.2.jar">suggest</a>
									-- 自动联想与拼写检查
								</li>
								<li>
									<a
										href="commons/lucene-6.4.2/test-framework/lucene-test-framework-6.4.2.jar">test-framework</a>
									-- Framework for testing Lucene-based applications
								</li>
							</ul>
						</div>

						<div class="sub-item">
							<p class="text-primary">Lucene的实例:</p>
							<p>
								<b>要导入的 jar 包:</b><br> &nbsp;&nbsp;&nbsp;&nbsp;
								<a href="libs/IKAnalyzer2012_FF.jar">IKAnalyzer2012_FF.jar</a>
								<br> &nbsp;&nbsp;&nbsp;&nbsp;
								<a href="libs/lucene-core-4.0.0.jar">lucene-core-4.0.0.jar</a>
								<br> &nbsp;&nbsp;&nbsp;&nbsp;
								<a href="libs/lucene-analyzers-common-4.0.0.jar">lucene-analyzers-common-4.0.0.jar</a>
								<br> &nbsp;&nbsp;&nbsp;&nbsp;
								<a href="libs/lucene-queryparser-4.0.0.jar">lucene-queryparser-4.0.0.jar</a>
							</p>
							<ul>
								<li>
									<b>Lucene的写入:</b>
									<pre class="brush: java;">
public class WhyIndexWriter {
	private IndexWriter indexWriter;

	public void init(String dir) {
		try {
			// 这里放索引文件的位置
			File indexDir = new File(dir); // 存放 检索文件的路径
			if (!indexDir.exists()) {
				indexDir.mkdirs();
			}
			// 创建标准文本分析器
			Analyzer luceneAnalyzer = new IKAnalyzer(true);		// 使用 IKAnalyzer 作为分词器
			
			IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_40,
					luceneAnalyzer);
			indexWriter = new IndexWriter(FSDirectory.open(new File(dir)), iwc);
		} catch (IOException e) {
			System.out.println("建立索引失败!!!");
			e.printStackTrace();
		}
	}
	
	public void write(HashMap&lt;String, String> map) throws IOException {
		if(null == indexWriter) {
			System.out.println("请先调用 init() 方法!");
			return;
		}
		Set&lt;String> set = map.keySet();
		Iterator&lt;String> it = set.iterator();
		while(it.hasNext()){
			
			String key = it.next();
			Document doc = new Document();
			
			doc.add(new TextField("type", "why", Store.YES));
			doc.add(new TextField("text", key, Store.YES));
			doc.add(new TextField("answer", map.get(key), Store.YES));
			
			indexWriter.addDocument(doc);
		}
		
		indexWriter.close();
	}
}

public class ChengYuIndexWriter {
	private IndexWriter indexWriter;

	public void init(String dir) {
		try {
			/* 这里放索引文件的位置 */
			File indexDir = new File(dir); // 存放 检索文件的路径
			if (!indexDir.exists()) {
				indexDir.mkdirs();
			}
			// 创建标准文本分析器， 标准的是可以支持的中文的

			Analyzer luceneAnalyzer = new IKAnalyzer(true);
			IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_40,
					luceneAnalyzer);
			indexWriter = new IndexWriter(FSDirectory.open(new File(dir)), iwc);
		} catch (IOException e) {
			System.out.println("建立索引失败!!!");
			e.printStackTrace();
		}
	}

	public void write(ArrayList&lt;ChengYu> datas) throws IOException {
		if (null == indexWriter) {
			System.out.println("请先调用 init() 方法!");
			return;
		}
		for (int i = 0; i &lt; datas.size(); i++) {
			ChengYu cy = datas.get(i);
			
			Document doc = new Document();

			doc.add(new TextField("type", "chengyu", Store.YES));
			doc.add(new TextField("text", cy.getContent(), Store.YES));
			if(cy.getStory() != null) {
				doc.add(new TextField("story", cy.getStory(), Store.YES));				
			}
			if(cy.getAnalyze() != null) {
				doc.add(new TextField("analyze", cy.getAnalyze(), Store.YES));				
			}
			if(cy.getSentence() != null) {
				doc.add(new TextField("sentence", cy.getSentence(), Store.YES));				
			}

			indexWriter.addDocument(doc);

		}

		indexWriter.close();
	}
}
</pre>
								</li>
								<li>
									<b>Lucene的读取:</b>
									<pre class="brush: java;">
private Directory directory;
private IndexReader ireader;
private IndexSearcher isearcher;
private QueryParser qp;
private final int SCORE_MAX = 5;
private boolean inited = false;

private void init() throws IOException {
	File indexDir = new File("./index");
	directory = FSDirectory.open(indexDir);

	ireader = DirectoryReader.open(directory);
	isearcher = new IndexSearcher(ireader);

	Analyzer analyzer = new IKAnalyzer(true);		// 使用 IKAnalyzer 作为分词器

	qp = new QueryParser(Version.LUCENE_40, "text", analyzer);
	qp.setDefaultOperator(QueryParser.OR_OPERATOR);
	inited = true;
}

// 查询　keyword
public ArrayList&lt;Document> search(String keyword) throws ParseException,
		IOException {
	if (!inited) {
		init();
	}

	ArrayList&lt;Document> datas = new ArrayList&lt;Document>();
	Query query = qp.parse(keyword);

	TopDocs topDocs = isearcher.search(query, SCORE_MAX);
	// 输出结果
	ScoreDoc[] scoreDocs = topDocs.scoreDocs;
	for (int i = 0; i &lt; topDocs.totalHits && i &lt; SCORE_MAX; i++) {
		Document targetDoc = isearcher.doc(scoreDocs[i].doc);
		datas.add(targetDoc);
	}
	return datas;
}

// 查询所有数据
public void queryAll() {
	try {
		File indexDir = new File("./index");
		Directory directory = FSDirectory.open(indexDir);

		IndexReader ireader = DirectoryReader.open(directory);
		
		IndexSearcher isearcher = new IndexSearcher(ireader);
		
		int cy = 0;
		int why = 0;
		for (int j = 0; j &lt; 10000; j++) {
			Document doc = isearcher.doc(j);
			if(null != doc) {
				if("chengyu".equals(doc.get("type"))){
					cy++;
					System.out.println(j + "-->" + doc.get("text") + ":" + doc.get("story"));
				} else {
					why++;
					System.out.println(j + "==>" + doc.get("text") + ":" + doc.get("answer"));
				}
				
			}
		}
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}	
}
</pre>
								</li>
							</ul>
						</div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="libs-guava"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Guava</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p><b>Guava 网站和 JavaDoc</b>:<a href="https://github.com/google/guava" target="_blank">Github 地址</a>, <a href="https://guava.dev/" target="_blank">网站</a> 和 <a href="https://guava.dev/releases/snapshot-jre/api/docs/" target="_blank">JavaDoc</a></p>
							<p><b>Guava 的 Gradle 引用：</b></p>
							<pre class="brush: bash;">
## 1. Use Guava in your implementation only:
implementation("com.google.guava:guava:28.2-jre")

## 2. Use Guava types in your public API:
api("com.google.guava:guava:28.2-jre")

## 3. Android - Use Guava in your implementation only:
implementation("com.google.guava:guava:28.2-android")

## 4. Android - Use Guava types in your public API:
api("com.google.guava:guava:28.2-android")
</pre>
							<p><b>Guava 包</b></p>
							<pre class="brush: java;">
com.google.common.base 		 // 条件检查，NULL 处理，字符串处理
com.google.common.cache      // 缓存，和 ConcurrentMap 很相似，但是支持基于容量回收、定时回收和基于引用回收
com.google.common.collect    // 集合，排序，区间，集合工具类
com.google.common.escape     // 转义器和编码器的简单实现
com.google.common.eventbus   // 发布-订阅式通信
com.google.common.graph      // 一种通用的、可扩展性的语言描述实体以及实体之间的关系
com.google.common.hash       // 哈希函数及相关结构
com.google.common.html       // HTML 转义器实例
com.google.common.xml        // XML 转义器实例
com.google.common.io         // 处理 Java I/O 的实用程序方法和类
com.google.common.math       // 数学运算，主要是 int、long 和 BigInteger
com.google.common.net        // 用于处理网络地址的实用程序方法和类
com.google.common.primitives      // 处理基本类型和 void 的使用程序
com.google.common.reflect 		  // 反射的实用程序
com.google.common.util.concurrent // 并发实用程序
</pre>
							<p><b>Guava</b> 工程包含了若干被 Google 的 Java 项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。 所有这些工具每天都在被 Google 的工程师应用在产品服务中。</p>
							<h4>官方教程：</h4>
							<p><b>1. 基本工具 [Basic utilities]</b> -- 让使用 Java 语言变得更舒适</p>
							<ul>
								<li><p><a href="#guava-base-null">1.1 使用和避免 null</a> -- null 是模棱两可的，会引起令人困惑的错误，有些时候它让人很不舒服。很多 Guava 工具类用快速失败拒绝 null 值，而不是盲目地接受</p></li>
								<li><p><a href="#guava-base-before">1.2 前置条件</a> -- 让方法中的条件检查更简单</p></li>
								<li><p><a href="#guava-base-object">1.3 常见 Object 方法</a> -- 简化 Object 方法实现，如 hashCode() 和 toString()</p></li>
								<li><p><a href="#guava-base-sort">1.4 排序</a> -- Guava 强大的”流畅风格比较器”</p></li>
								<li><p><a href="#guava-base-throwables">1.5 Throwables</a> -- 简化了异常和错误的传播与检查</p></li>
							</ul>
							<p><b>2. <a href="#guava-collection">集合[Collections]</a></b> -- Guava 对 JDK 集合的扩展，这是 Guava 最成熟和为人所知的部分</p>
							<p><b>3. <a href="#guava-cache">缓存[Caches]</a></b> -- Guava Cache：本地缓存实现，支持多种缓存过期策略</p>
							<p><b>4. <a href="#guava-function">函数式风格[Functional idioms]</a></b> -- Guava的函数式支持可以显著简化代码，但请谨慎使用它</p>
							<p><b>5. <a href="#guava-thread">并发[Concurrency]</a></b> -- 强大而简单的抽象，让编写正确的并发代码更简单</p>
							<p><b>6. <a href="#guava-string">字符串处理[Strings]</a></b> -- 非常有用的字符串工具，包括分割、连接、填充等操作</p>
							<p><b>7. <a href="#guava-primitive">原生类型[Primitives]</a></b> -- 扩展 JDK 未提供的原生类型（如 int、char）操作， 包括某些类型的无符号形式</p>
							<p><b>8. <a href="#guava-range">区间[Ranges]</a></b> -- 可比较类型的区间 API，包括连续和离散类型</p>
							<p><b>9. <a href="#guava-io">I/O</a></b> -- 简化 I/O 尤其是 I/O流 和文件的操作，针对 Java 5 和 6 版本</p>
							<p><b>10. <a href="#guava-hash">散列[Hash]</a></b> -- 提供比 Object.hashCode() 更复杂的散列实现，并提供布鲁姆过滤器的实现</p>
							<p><b>11. <a href="#guava-event">事件总线[EventBus]</a></b> -- 发布-订阅模式的组件通信，但组件不需要显式地注册到其他组件中</p>
							<p><b>12. <a href="#guava-math">数学运算[Math]</a></b> -- 优化的、充分测试的数学工具类</p>
							<p><b>13. <a href="#guava-reflection">反射[Reflection]</a></b> -- Guava 的 Java 反射机制工具类</p>
						</div>

						<div class="sub-item">
							<a id="guava-base-null" class="offset"></a>
							<div class="split-item">
								<p><b>1.1 使用和避免 null</b></p>
								<p>Guava 用 <code>Optional&lt;T></code> 表示可能为 null 的 T 类型引用。一个 Optional 实例可能包含非 null 的引用（我们称之为引用存在），也可能什么也不包括（称之为引用缺失）。</p>
								<ol>
									<li><p><code>static &lt;T> Optional&lt;T> of(T reference)</code> -- 创建指定引用的 Optional 实例，若引用为 null 则快速失败(直接抛出异常)</p></li>
									<li><p><code>static &lt;T> Optional&lt;T> absent()</code> -- 创建引用缺失的 Optional 实例</p></li>
									<li><p><code>static &lt;T> Optional&lt;T> fromNullable(T nullableReference)</code> -- 创建引用可为 null 的 Optional 实例</p></li>

									<li class="group"><p><code>static &lt;T> Iterable&lt;T> presentInstances(Iterable&lt;? extends Optional&lt;? extends T>> optionals)</code> -- 顺序跳过 <code>optionals</code> 中为 <code>absent()</code> 的项目</p></li>

									<li class="group"><p><code>static &lt;T> @Nullable Optional&lt;T> fromJavaUtil(Optional&lt;T> javaUtilOptional)</code> -- 从 <code>java.util.Optional</code> 转换</p></li>
									<li><p><code>static &lt;T> Optional&lt;T> toJavaUtil(@Nullable Optional&lt;T> googleOptional)</code> -- 转换为 <code>java.util.Optional</code></p></li>

									<li class="group"><p><code>abstract T get()</code> -- 返回 Optional 所包含的引用，若引用缺失，则抛出 java.lang.IllegalStateException</p></li>
									<li><p><code>abstract boolean 	isPresent()</code> -- 如果 Optional 包含非 null 的引用（引用存在），返回 true</p></li>

									<li class="group"><p><code>abstract T 	or(T defaultValue)</code> -- 返回 Optional 所包含的引用，若引用缺失，返回指定的值</p></li>
									<li><p><code>abstract T 	or(Supplier&lt;? extends T> supplier)</code> -- 若引用缺失，从 Supplier 返回指定的值</p></li>
									<li><p><code>abstract T 	orNull()</code> -- 返回 Optional 所包含的引用，若引用缺失，返回 null</p></li>
									<li><p><code>abstract Optional&lt;T> 	or(Optional&lt;? extends T> secondChoice)</code> -- 若引用缺失，返回指定的 Optional</p></li>

									<li class="group"><p><code>Optional&lt;T> 	toJavaUtil()</code> -- 转换为 <code>java.util.Optional</code></p></li>

									<li class="group"><p><code>abstract &lt;V> Optional&lt;V> 	transform(Function&lt;? super T,V> function)</code> -- 如果实例存在，则使用给定函数对其进行转换；否则，将返回 <code>Optional.absent()</code></p></li>

									<li class="group"><p><code>abstract Set&lt;T> 	asSet()</code> -- 返回 Optional 所包含引用的单例不可变集，如果引用存在，返回一个只有单一元素的集合，如果引用缺失，返回一个空集合</p></li>
								</ol>
							</div>

							<a id="guava-base-before" class="offset"></a>
							<div class="split-item">
								<p><b>1.2 前置条件</b></p>
								<p>Guava 在 <code>Preconditions</code> 类中提供了若干前置条件判断的实用方法，强烈建议静态导入这些方法。每个方法都有三个变种：</p>
								<pre class="brush: bash;">import static com.google.common.base.Preconditions.*;</pre>
								<ul>
									<li><p>没有额外参数：抛出的异常中没有错误消息；</p></li>
									<li><p>有一个 Object 对象作为额外参数：抛出的异常使用 Object.toString() 作为错误消息；</p></li>
									<li><p>有一个 String 对象作为额外参数，并且有一组任意数量的附加 Object 对象：这个变种处理异常消息的方式有点类似 printf，但考虑 GWT 的兼容性和效率，只支持 %s 指示符。</p></li>
								</ul>
								<ol>
									<li><p><code>checkNotNull(T)</code> -- 检查 obj 是否为 null，不为 null 直接返回；当 obj 为 null 的时候抛出 <code>NullPointerException</code></p>
										<pre class="brush: java;">
static &lt;T> T checkNotNull(T obj)
static &lt;T> T checkNotNull(T obj, Object errorMessage)
static &lt;T> T checkNotNull(T obj, String eTemplate, char p1)
static &lt;T> T checkNotNull(T obj, String eTemplate, char p1, char p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, char p1, int p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, char p1, long p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, char p1, Object p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, int p1)
static &lt;T> T checkNotNull(T obj, String eTemplate, int p1, char p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, int p1, int p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, int p1, long p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, int p1, Object p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, long p1)
static &lt;T> T checkNotNull(T obj, String eTemplate, long p1, char p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, long p1, int p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, long p1, long p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, long p1, Object p2)
static &lt;T> T checkNotNull(T reference, String eTemplate, Object... errorMessageArgs)
static &lt;T> T checkNotNull(T obj, String eTemplate, Object p1)
static &lt;T> T checkNotNull(T obj, String eTemplate, Object p1, char p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, Object p1, int p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, Object p1, long p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, Object p1, Object p2)
static &lt;T> T checkNotNull(T obj, String eTemplate, Object p1, Object p2, Object p3)
static &lt;T> T checkNotNull(T obj, String eTemplate, Object p1, Object p2, Object p3, Object p4)
</pre>
									</li>
									<li><p><code>checkArgument(boolean)</code> -- 用来检查传递给方法的参数，当 b 为 false 的时候抛出 <code>IllegalArgumentException</code></p>
										<pre class="brush: java;">
static void checkArgument(boolean b)
static void checkArgument(boolean b, Object errorMessage)
static void checkArgument(boolean b, String eTemplate, char p1)
static void checkArgument(boolean b, String eTemplate, char p1, char p2)
static void checkArgument(boolean b, String eTemplate, char p1, int p2)
static void checkArgument(boolean b, String eTemplate, char p1, long p2)
static void checkArgument(boolean b, String eTemplate, char p1, Object p2)
static void checkArgument(boolean b, String eTemplate, int p1)
static void checkArgument(boolean b, String eTemplate, int p1, char p2)
static void checkArgument(boolean b, String eTemplate, int p1, int p2)
static void checkArgument(boolean b, String eTemplate, int p1, long p2)
static void checkArgument(boolean b, String eTemplate, int p1, Object p2)
static void checkArgument(boolean b, String eTemplate, long p1)
static void checkArgument(boolean b, String eTemplate, long p1, char p2)
static void checkArgument(boolean b, String eTemplate, long p1, int p2)
static void checkArgument(boolean b, String eTemplate, long p1, long p2)
static void checkArgument(boolean b, String eTemplate, long p1, Object p2)
static void checkArgument(boolean b, String eTemplate, Object... errorMessageArgs)
static void checkArgument(boolean b, String eTemplate, Object p1)
static void checkArgument(boolean b, String eTemplate, Object p1, char p2)
static void checkArgument(boolean b, String eTemplate, Object p1, int p2)
static void checkArgument(boolean b, String eTemplate, Object p1, long p2)
static void checkArgument(boolean b, String eTemplate, Object p1, Object p2)
static void checkArgument(boolean b, String eTemplate, Object p1, Object p2, Object p3)
static void checkArgument(boolean b, String eTemplate, Object p1, Object p2, Object p3, Object p4)
</pre>
									</li>

									<li><p><code>checkState(boolean)</code> -- 用来检查传递给方法的参数，当 b 为 false 的时候抛出 <code>IllegalStateException</code></p>
										<pre class="brush: java;">
static void checkState(boolean b)
static void checkState(boolean b, Object errorMessage)
static void checkState(boolean b, String eTemplate, char p1)
static void checkState(boolean b, String eTemplate, char p1, char p2)
static void checkState(boolean b, String eTemplate, char p1, int p2)
static void checkState(boolean b, String eTemplate, char p1, long p2)
static void checkState(boolean b, String eTemplate, char p1, Object p2)
static void checkState(boolean b, String eTemplate, int p1)
static void checkState(boolean b, String eTemplate, int p1, char p2)
static void checkState(boolean b, String eTemplate, int p1, int p2)
static void checkState(boolean b, String eTemplate, int p1, long p2)
static void checkState(boolean b, String eTemplate, int p1, Object p2)
static void checkState(boolean b, String eTemplate, long p1)
static void checkState(boolean b, String eTemplate, long p1, char p2)
static void checkState(boolean b, String eTemplate, long p1, int p2)
static void checkState(boolean b, String eTemplate, long p1, long p2)
static void checkState(boolean b, String eTemplate, long p1, Object p2)
static void checkState(boolean b, String eTemplate, Object... errorMessageArgs)
static void checkState(boolean b, String eTemplate, Object p1)
static void checkState(boolean b, String eTemplate, Object p1, char p2)
static void checkState(boolean b, String eTemplate, Object p1, int p2)
static void checkState(boolean b, String eTemplate, Object p1, long p2)
static void checkState(boolean b, String eTemplate, Object p1, Object p2)
static void checkState(boolean b, String eTemplate, Object p1, Object p2, Object p3)
static void checkState(boolean b, String eTemplate, Object p1, Object p2, Object p3, Object p4)
</pre>
									</li>
									<li><p><code>checkElementIndex(int index, int size)</code> -- 当 <code>index &lt; 0 || index >= size</code> 时抛出 <code>IndexOutOfBoundsException</code></p>
										<pre class="brush: java;">
static int checkElementIndex(int index, int size)
static int checkElementIndex(int index, int size, String desc)
</pre>
									</li>
									<li><p><code>checkPositionIndex(int index, int size)</code> -- 当 <code>index &lt; 0 || index > size</code> 时抛出 <code>IndexOutOfBoundsException</code></p>
										<pre class="brush: java;">
static int checkPositionIndex(int index, int size)
static int checkPositionIndex(int index, int size, String desc)
</pre>
									</li>
									<li><p><code>checkPositionIndexes(int start, int end, int size)</code> -- 当 <code>start < 0 || end < start || end > size</code> 时抛出 <code>IndexOutOfBoundsException</code></p>
										<pre class="brush: java;">
static void checkPositionIndexes(int start, int end, int size)
</pre>
									</li>
								</ol>
							</div>

							<a id="guava-base-object" class="offset"></a>
							<div class="split-item">
								<p><b>1.3 常见 Object 方法</b></p>
								<p><code>Objects</code> 类提供了 <code>equal</code> 和 <code>hashCode</code> 方法</p>
								<ol>
									<li><p><code>equals</code> -- 当一个对象中的字段可以为 null 时，实现 Object.equals 方法会很痛苦，因为不得不分别对它们进行 null 检查</p>
										<pre class="brush: java;">
public static boolean equal(@Nullable Object a, @Nullable Object b) {
	return a == b || (a != null && a.equals(b));
}
</pre>
									</li>
									<li><p><code>hashCode</code> -- 用对象的所有字段作散列 [hash] 运算应当更简单</p>
										<pre class="brush: java;">
public static int hashCode(@Nullable Object @Nullable ... objects) {
	return Arrays.hashCode(objects);
}
</pre>
									</li>
								</ol>
							</div>

							<a id="guava-base-sort" class="offset"></a>
							<div class="split-item">
								<p><b>1.4 排序</b></p>
								<p><code>Ordering</code> 是 Guava 流畅风格比较器 <code>Comparator</code> 的实现，它可以用来为构建复杂的比较器，以完成集合排序的功能。</p>
								<p>从实现上说，<code>Ordering</code> 实例就是一个特殊的 <code>Comparator</code> 实例。<code>Ordering</code> 把很多基于 <code>Comparator</code> 的静态方法（如 <code>Collections.max</code>）包装为自己的实例方法（非静态方法），并且提供了链式调用方法，来定制和增强现有的比较器。</p>
								<pre class="brush: java;">
public abstract class Ordering&lt;T> implements Comparator&lt;T> {
	protected Ordering() {}

	public abstract int compare(@Nullable T left, @Nullable T right);
	...
}
</pre>
								<ol>
									<li><p><code>static &lt;C extends Comparable> Ordering&lt;C> natural()</code> -- 对可排序类型做自然排序，如数字按大小，日期按先后排序</p></li>
									<li><p><code>static Ordering&lt;Object> usingToString()</code> -- 按对象的字符串形式做字典排序</p></li>
									<li><p><code>static &lt;T> Ordering&lt;T> from(Comparator&lt;T> comparator)</code> -- 把给定的 Comparator 转化为排序器</p></li>
									<li><p><code>static Ordering&lt;Object> allEqual()</code> -- 返回一个将所有值视为相等的顺序</p></li>
									<li><p><code>static Ordering&lt;Object> arbitrary()</code> -- 任意排序，但是相等(<code>compare(a, b) == 0</code>)的元素一定是挨着的</p></li>
									<li><p><code>static &lt;T> Ordering&lt;T> compound(Iterable&lt;? extends Comparator&lt;? super T>> comparators)</code> -- 合成另一个比较器，以处理当前排序器中的相等情况</p></li>
									<li><p><code>static &lt;T> Ordering&lt;T> explicit(List&lt;T> valuesInOrder)</code> -- 指定排序(排序的元素会按 List 中的顺序进行排序)</p>
										<pre class="brush: java;">
List&lt;String> orderTemplate = Arrays.asList("陈茂", "简婷", "陈筱钰", "陈俊宏");
Ordering explicitOrdering = Ordering.explicit(orderTemplate);

List after = explicitOrdering.sortedCopy(Arrays.asList("简婷", "陈筱钰", "陈俊宏", "陈筱钰", "陈茂"));
System.out.println(after); // 排序后：[陈茂, 简婷, 陈筱钰, 陈筱钰, 陈俊宏]
</pre>
									</li>
									<li><p><code>static &lt;T> Ordering&lt;T> explicit(T leastValue, T... remainingValuesInOrder)</code> -- 同上</p></li>

									<li class="group"><p><code>&lt;S extends T>Ordering&lt;S> reverse()</code> -- 获取语义相反的排序器</p></li>
									<li><p><code>&lt;S extends T>Ordering&lt;S> nullsFirst()</code> -- 使用当前排序器，但额外把 null 值排到最前面</p></li>
									<li><p><code>&lt;S extends T>Ordering&lt;S> nullsLast()</code> -- 使用当前排序器，但额外把 null 值排到最后面</p></li>
									<li><p><code>&lt;U extends T> Ordering&lt;U> compound(Comparator&lt;? super U> secondaryComparator)</code> -- 合成另一个比较器，以处理当前排序器中的相等情况</p></li>
									<li><p><code>&lt;S extends T> Ordering&lt;Iterable&lt;S>> lexicographical()</code> -- 基于处理类型 T 的排序器，返回该类型的可迭代对象 Iterable&lt;T> 的排序器</p></li>
									<li><p><code>&lt;F> Ordering&lt;F> onResultOf(Function&lt;F,? extends T> function)</code> -- 对集合中元素调用 Function，再按返回值用当前排序器排序</p></li>

									<li class="group"><p><code>&lt;E extends T> List&lt;E> greatestOf(Iterable&lt;E> iterable, int k)</code> -- 获取可迭代对象中最大的 k 个元素</p></li>
									<li><p><code>&lt;E extends T> List&lt;E> greatestOf(Iterator&lt;E> iterator, int k)</code> -- 同上</p></li>
									<li><p><code>&lt;E extends T> List&lt;E> leastOf(Iterable&lt;E> iterable, int k)</code> -- 获取可迭代对象中最小的 k 个元素</p></li>
									<li><p><code>&lt;E extends T> List&lt;E> leastOf(Iterator&lt;E> iterator, int k)</code> -- 同上</p></li>

									<li class="group"><p><code>boolean isOrdered(Iterable&lt;? extends T> iterable)</code> -- 判断可迭代对象是否已按排序器排序：允许有排序值相等的元素</p></li>
									<li><p><code>boolean isStrictlyOrdered(Iterable&lt;? extends T> iterable)</code> -- 同上：但不允许有排序值相等的元素</p></li>

									<li class="group"><p><code>&lt;E extends T> List&lt;E> sortedCopy(Iterable&lt;E> elements)</code> -- 取可迭代对象排序后的列表</p></li>
									<li><p><code>&lt;E extends T> ImmutableList&lt;E> immutableSortedCopy(Iterable&lt;E> elements)</code> -- 同上</p></li>


									<li class="group"><p><code>&lt;E extends T> E max(E a, E b)</code> -- 返回两个参数中最大的那个。如果相等，则返回第一个参数</p></li>
									<li><p><code>&lt;E extends T> E min(E a, E b)</code> -- 返回两个参数中最小的那个。如果相等，则返回第一个参数</p></li>
									<li><p><code>&lt;E extends T> E max(E a, E b, E c, E... rest)</code> -- 返回多个参数中最大的那个。如果有超过一个最大返回第一个最大</p></li>
									<li><p><code>&lt;E extends T> E min(E a, E b, E c, E... rest)</code> -- 返回多个参数中最小的那个。如果有超过一个参数返回第一个最小</p></li>
									<li><p><code>&lt;E extends T> E max(Iterable&lt;E> iterable)</code> -- 返回最大的元素。如果没有元素，则抛出 <code>NoSuchElementException</code></p></li>
									<li><p><code>&lt;E extends T> E max(Iterator&lt;E> iterator)</code> -- 同上</p></li>
									<li><p><code>&lt;E extends T> E min(Iterable&lt;E> iterable)</code> -- 返回最小的元素。如果没有元素，则抛出 <code>NoSuchElementException</code></p></li>
									<li><p><code>&lt;E extends T> E min(Iterator&lt;E> iterator)</code> -- 同上</p></li>
								</ol>
							</div>

							<a id="guava-base-throwables" class="offset"></a>
							<div class="split-item">
								<p><b>1.5 Throwables</b></p>
								<p>有时候，你会想把捕获到的异常再次抛出。这种情况通常发生在 Error 或 RuntimeException 被捕获的时候，你没想捕获它们，但是声明捕获 Throwable 和 Exception 的时候，也包括了了 Error 或 RuntimeException。Guava 提供了若干方法，来判断异常类型并且重新传播异常。</p>
								<ol>
									<li><p><code>static void throwIfUnchecked(Throwable throwable)</code> -- 如果是运行时异常或错误才抛出</p></li>
									<li><p><code>static &lt;X extends Throwable> void throwIfInstanceOf(Throwable throwable, Class&lt;X> declaredType)</code> -- 如果是 X 的实例才抛出</p></li>
									<li><p><code>static &lt;X extends Throwable> void propagateIfPossible(@Nullable Throwable throwable, Class&lt;X> declaredType)</code> -- Throwable 类型为 X, Error 或 RuntimeException 才抛出</p></li>
									<li><p><code>static &lt;X1 extends Throwable,X2 extends Throwable> void propagateIfPossible(@Nullable Throwable throwable, Class&lt;X1> declaredType1, Class&lt;X2> declaredType2)</code> -- Throwable 类型为 X1, X2, Error 或 RuntimeException 才抛出</p></li>

									<li class="group"><p><code>static List&lt;Throwable> getCausalChain(Throwable throwable)</code> -- 获取异常链</p></li>
									<li><p><code>static Throwable getRootCause(Throwable throwable)</code> -- 获取异常最里面的原因</p></li>
									<li><p><code>static String getStackTraceAsString(Throwable throwable)</code> -- 返回包含 toString() 的结果字符串，随后完整抛出，递归的堆栈跟踪</p></li>



									<li class="group"><p><code>static &lt;X extends Throwable> X getCauseAs(Throwable throwable, Class&lt;X> expectedCauseType)</code> -- 返回抛出的原因，强制转换为 X 的类型</p></li>
									<li><p><code>static List&lt;StackTraceElement> lazyStackTrace(Throwable throwable)</code> -- 返回抛出的堆栈跟踪，可能在整个跟踪上提供较慢的迭代，但在部分跟踪上提供较快的迭代</p></li>
									<li><p><code>static boolean lazyStackTraceIsLazy()</code> -- 返回 <code>lazyStackTrace(Throwable)</code> 是否将使用其文档中描述的特殊实现</p></li>
								</ol>

							</div>
						</div>

						<a id="guava-collection" class="offset"></a>
						<div class="sub-item">
							<div class="split-item">
								<p><b>Guava 集合的顶级接口，继承关系和工具类</b></p>
								<pre class="brush: java;">
/** 顶级接口 */
Collection
 └─ Multiset // 没有元素顺序限制的 ArrayList 和 Map&lt;E, Integer>，键为元素，值为计数
	├─ SortedMultiset //
	└─ SortedMultisetBridge

Multimap
 ├─ ListMultimap
 └─ SetMultimap
    └─ SortedSetMultimap
Map
 ├─ BiMap
 ├─ ClassToInstanceMap
 └─ TypeToInstanceMap

RangeMap
RangeSet

Table
 └─ RowSortedTable

/** Guava 集合类 */
AbstractCollection implements Collection
 ├─ EnumMultiset implements Multiset // 非直接子类
 ├─ TreeMultiset implements SortedMultiset // 非直接子类
 ├─ AbstractQueue implements Queue
 │	 ├─ MinMaxPriorityQueue
 │	 ├─ ConcurrentLinkedQueue
 │	 ├─ ArrayBlockingQueue implements BlockingQueue
 │	 ├─ DelayQueue implements BlockingQueue
 │	 ├─ LinkedBlockingQueue implements BlockingQueue
 │	 ├─ PriorityBlockingQueue implements BlockingQueue
 │	 ├─ SynchronousQueue implements BlockingQueue
 │	 ├─ LinkedBlockingDeque implements BlockingDeque
 │	 ├─ LinkedTransferQueue implements TransferQueue
 │	 └─ PriorityQueue
 └─ ImmutableCollection
	 ├─ ImmutableList implements List
	 ├─ ImmutableMultiset implements Multiset
	 │ 	 └─ ImmutableSortedMultiset implements SortedMultiset
	 ├─ ImmutableSet implements Set
	 │ 	 └─ ImmutableSortedSet implements NavigableSet
	 │ 		 └─ ContiguousSet
	 ├─ HashMultiset implements Multiset // 非直接子类
	 ├─ TreeMultiset implements SortedMultiset // 非直接子类
	 ├─ LinkedHashMultiset implements Multiset // 非直接子类
	 └─ ConcurrentHashMultiset implements Multiset // 非直接子类

ImmutableMap implements Map
 ├─ ImmutableBiMap implements BiMap
 └─ ImmutableSortedMap implements NavigableMap
ImmutableMultimap
 ├─ ImmutableListMultimap implements ListMultimap
 └─ ImmutableSetMultimap implements SetMultimap
ArrayListMultimap implements ListMultimap
LinkedListMultimap implements ListMultimap
TreeMultimap implements SortedSetMultimap
HashMultimap implements SetMultimap
LinkedHashMultimap implements SetMultimap
AbstractMap implements Map
 └─ HashBiMap implements BiMap
ImmutableRangeMap implements RangeMap
TreeRangeMap implements RangeMap

EnumMultiset implements Multiset
TreeRangeSet implements RangeSet
ImmutableRangeSet implements RangeSet

AbstractTable implements Table
HashBasedTable implements Table
ImmutableTable implements Table
TreeBasedTable implements RowSortedTable

UnmodifiableIterator implements Iterator
 ├─ AbstractIterator
 ├─ AbstractSequentialIterator
 └─ UnmodifiableListIterator implements ListIterator

ForwardingObject
 ├─ ForwardingMap implements Map
 │	 ├─ EnumBiMap implements BiMap
 │	 ├─ EnumHashBiMap implements BiMap
 │	 ├─ ForwardingConcurrentMap implements ConcurrentMap
 │	 ├─ ForwardingSortedMap implements SortedMap
 │	 │	 └─ ForwardingNavigableMap implements NavigableMap
 │	 ├─ ForwardingNavigableMap.StandardDescendingMap
 │	 ├─ ImmutableClassToInstanceMap implements ClassToInstanceMap
 │	 ├─ ImmutableTypeToInstanceMap implements TypeToInstanceMap
 │	 ├─ MutableClassToInstanceMap implements ClassToInstanceMap
 │	 └─ MutableTypeToInstanceMap implements TypeToInstanceMap
 ├─ ForwardingCollection implements Iterable, Collection
 │	 ├─ ForwardingList implements List
 │	 ├─ ForwardingSet implements Set
 │	 │	 └─ ForwardingSortedSet implements SortedSet
 │	 │	 	└─ ForwardingNavigableSet implements NavigableSet
 │	 │	 		└─ ForwardingNavigableSet.StandardDescendingSet
 │	 ├─ ForwardingQueue implements Queue
 │	 │	 ├─ ForwardingDeque implements Deque
 │	 │	 │	└─ ForwardingBlockingDeque implements BlockingDeque
 │	 │	 └─ EvictingQueue
 │	 └─ ForwardingMultiset implements Multiset
 │		 └─ ForwardingSortedMultiset implements SortedMultiset
 ├─ ForwardingIterator implements Iterator
 │	 └─ ForwardingListIterator implements ListIterator
 ├─ ForwardingMap implements Map
 ├─ ForwardingMapEntry implements Map.Entry
 ├─ ForwardingMultimap implements Multimap
 │	 ├─ ForwardingListMultimap implements ListMultimap
 │	 └─ ForwardingSetMultimap implements SetMultimap
 │		 └─ ForwardingSortedSetMultimap implements SortedSetMultimap
 └─ ForwardingTable implements Table

/** 集合工具类 */
Collections2
Comparators
Iterables
Iterators
Lists
Sets
Queues
Maps
Multimaps
Multisets
ObjectArrays
Range
Streams
Tables

/** 构建器 */
ImmutableCollection.Builder
 ├─ ImmutableList.Builder
 ├─ ImmutableMultiset.Builder
 │	 └─	ImmutableSortedMultiset.Builder
 └─ ImmutableSet.Builder
     └─ ImmutableSortedSet.Builder
ImmutableMap.Builder
 ├─ ImmutableBiMap.Builder
 └─ ImmutableSortedMap.Builder
MultimapBuilder
 ├─ MultimapBuilder.ListMultimapBuilder
 └─ MultimapBuilder.SetMultimapBuilder
	 └─ MultimapBuilder.SortedSetMultimapBuilder
ImmutableMultimap.Builder
 ├─ ImmutableListMultimap.Builder
 └─ ImmutableSetMultimap.Builder
ImmutableRangeMap.Builder
ImmutableRangeSet.Builder
ImmutableTable.Builder
MinMaxPriorityQueue.Builder
ImmutableClassToInstanceMap.Builder
</pre>
								<h5>细节：关联可变集合和不可变集合</h5>
								<table class="table table-bordered table-responsive table-striped">
									<tbody>
									<tr>
										<td><b>可变集合接口</b><b></b></td>
										<td><b>属于</b><b>JDK</b><b>还是</b><b>Guava</b><b></b></td>
										<td><b>不可变版本</b><b></b></td>
									</tr>
									<tr>
										<td>Collection</td>
										<td>JDK</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableCollection.html" target="_blank">ImmutableCollection</a></td>
									</tr>
									<tr>
										<td>List</td>
										<td>JDK</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableList.html" target="_blank">ImmutableList</a></td>
									</tr>
									<tr>
										<td>Set</td>
										<td>JDK</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableSet.html" target="_blank">ImmutableSet</a></td>
									</tr>
									<tr>
										<td>SortedSet/NavigableSet</td>
										<td>JDK</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableSortedSet.html" target="_blank">ImmutableSortedSet</a></td>
									</tr>
									<tr>
										<td>Map</td>
										<td>JDK</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableMap.html" target="_blank">ImmutableMap</a></td>
									</tr>
									<tr>
										<td>SortedMap</td>
										<td>JDK</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableSortedMap.html" target="_blank">ImmutableSortedMap</a></td>
									</tr>
									<tr>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/Multiset.html" target="_blank">Multiset</a></td>
										<td>Guava</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableMultiset.html" target="_blank">ImmutableMultiset</a></td>
									</tr>
									<tr>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/SortedMultiset.html" target="_blank">SortedMultiset</a></td>
										<td>Guava</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableSortedMultiset.html" target="_blank">ImmutableSortedMultiset</a></td>
									</tr>
									<tr>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/Multimap.html" target="_blank">Multimap</a></td>
										<td>Guava</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableMultimap.html" target="_blank">ImmutableMultimap</a></td>
									</tr>
									<tr>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ListMultimap.html" target="_blank">ListMultimap</a></td>
										<td>Guava</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableListMultimap.html" target="_blank">ImmutableListMultimap</a></td>
									</tr>
									<tr>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/SetMultimap.html" target="_blank">SetMultimap</a></td>
										<td>Guava</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableSetMultimap.html" target="_blank">ImmutableSetMultimap</a></td>
									</tr>
									<tr>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/BiMap.html" target="_blank">BiMap</a></td>
										<td>Guava</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableBiMap.html" target="_blank">ImmutableBiMap</a></td>
									</tr>
									<tr>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ClassToInstanceMap.html" target="_blank">ClassToInstanceMap</a></td>
										<td>Guava</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableClassToInstanceMap.html" target="_blank">ImmutableClassToInstanceMap</a></td>
									</tr>
									<tr>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/Table.html" target="_blank">Table</a></td>
										<td>Guava</td>
										<td><a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ImmutableTable.html" target="_blank">ImmutableTable</a></td>
									</tr>
									</tbody>
								</table>

							</div>

							<div class="split-item">
								<p><b>常用的 Guava 集合类的使用</b></p>

							</div>
						</div>

						<a id="guava-cache" class="offset"></a>
						<div class="sub-item">
							<p>缓存的主要作用是暂时在内存中保存业务系统的数据处理结果，并且等待下次访问使用。</p>
							<pre class="brush: java;">
public interface Cache&lt;K, V> {
	V getIfPresent(Object key);	// 回去现有的缓存数据，如果不存在就返回 NULL
	V get(K key, Callable&lt;? extends V> loader) throws ExecutionException; // 当缓存不存在的时候回调
	void put(K key, V value);    // 存入
	long size();				 // 大小
	void cleanUp();				 // 缓存所需的任何挂起的维护操作
	void invalidate(Object key); // 使指定 Key 失效
	void invalidateAll();        // 清除所有缓存
	void invalidateAll(Iterable<?> keys); // 清除指定缓存
	void putAll(Map&lt;? extends K, ? extends V> m);       // 存入多个
	ImmutableMap&lt;K, V> getAllPresent(Iterable<?> keys); // 获取多个
	CacheStats stats();             // 获取统计信息(大小，命中率，加载新值的平均时间)
	ConcurrentMap&lt;K, V> asMap(); // 变成 ConcurrentMap
}
</pre>
							<p>Guava Cache 为了限制内存占用，通常都设定为自动回收元素。在某些场景下，尽管 LoadingCache 不回收元素，它也是很有用的，因为它会自动加载缓存。</p>
							<pre class="brush: java;">
LoadingCache&lt;String, Integer> loadingCache = CacheBuilder.newBuilder()
								.build(new CacheLoader&lt;String, Integer>() {
	@Override
	public Integer load(String key) throws Exception {
		LogUtil.log("execute");
		return 1;
	}
});

try {
	LogUtil.log(loadingCache.get("one")); // 执行 CacheLoader.load() 方法一次
	LogUtil.log(loadingCache.get("one")); // 不再执行 CacheLoader.load() 方法
} catch (ExecutionException e) {
	e.printStackTrace();
}
</pre>
							<p>下面的这几种情况可以考虑使用 Guava Cache：</p>
							<ul>
								<li><p>愿意消耗一些内存空间来提升速度；</p></li>
								<li><p>预料到某些键会被多次查询；</p></li>
								<li><p>缓存中存放的数据总量不会超出内存容量。</p></li>
							</ul>
							<p>Guava Cache 支持以下几种回收机制：基于容量的回收，基于时间的回收和基于引用的回收。</p>
							<pre class="brush: java;">
// 1.最大容量
Cache&lt;String, Integer> cache = CacheBuilder.newBuilder().maximumSize(2).build();
cache.put("one", 1);
cache.put("two", 2);
cache.put("three", 3);

LogUtil.log("1.最大容量：");

LogUtil.log(cache.getIfPresent("one"));     // null
LogUtil.log( cache.getIfPresent("two"));    // 2
LogUtil.log( cache.getIfPresent("three"));  // 3


LogUtil.log("2.过期时间：");
// 2.过期时间
cache = CacheBuilder.newBuilder().expireAfterWrite(2, TimeUnit.SECONDS).build();
cache.put("one", 1);

int count = 0;
while(count < 4) {
	count++;
	try {
		LogUtil.log(cache.getIfPresent("one"));
		Thread.sleep(1000);
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
}

LogUtil.log("3.过期时间 -- 访问过期：");

// 3.过期时间(某个元素在指定的时间没有访问就过期)
cache = CacheBuilder.newBuilder().expireAfterAccess(2, TimeUnit.SECONDS).build();
cache.put("one", 1);
cache.put("two", 2);

count = 0;
while(count < 5) {
	count++;
	LogUtil.log(cache.getIfPresent("one"));
	if(count == 1) {
		LogUtil.log(cache.getIfPresent("two")); // 第一次访问有数据
	}
	if(count == 4) {
		LogUtil.log(cache.getIfPresent("two")); // 超过 2 秒没有被访问后已经过期
	}
	try {
		Thread.sleep(1000);
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
}

LogUtil.log("4.基于引用的回收：");

// 4.弱引用
cache = CacheBuilder.newBuilder().weakValues().build();
Integer value = new Integer(1);
cache.put("one", value);
LogUtil.log(cache.getIfPresent("one"));
value = new Integer(2); // 原对象不再有强引用
System.gc();
LogUtil.log(cache.getIfPresent("one"));
</pre>
							<p>Guava Cache 还支持移除监听，当元素被移除时能被感知：</p>
							<pre class="brush: java;">
Cache&lt;String, Integer> cache = CacheBuilder.newBuilder().maximumSize(2).removalListener(new RemovalListener&lt;String, Integer>() {
	@Override
	public void onRemoval(RemovalNotification&lt;String, Integer> notification) {
		LogUtil.log("[" + notification.getKey() + ":" + notification.getValue() + "] is removed!");
	}
}).build();
cache.put("one", 1);
cache.put("two", 2);
cache.put("three", 3);
</pre>
						</div>

						<a id="guava-function" class="offset"></a>
						<div class="sub-item">

						</div>

						<a id="guava-thread" class="offset"></a>
						<div class="sub-item">

						</div>
						<a id="guava-string" class="offset"></a>
						<div class="sub-item">

						</div>

						<a id="guava-primitive" class="offset"></a>
						<div class="sub-item">

						</div>

						<a id="guava-range" class="offset"></a>
						<div class="sub-item">

						</div>

						<a id="guava-io" class="offset"></a>
						<div class="sub-item">

						</div>

						<a id="guava-hash" class="offset"></a>
						<div class="sub-item">

						</div>

						<a id="guava-event" class="offset"></a>
						<div class="sub-item">

						</div>

						<a id="guava-math" class="offset"></a>
						<div class="sub-item">

						</div>

						<a id="guava-reflection" class="offset"></a>
						<div class="sub-item">

						</div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="libs-JavaPoet"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">JavaPoet</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<pre class="brush: java;">compile 'com.squareup:javapoet:1.11.1'</pre>
							<p><b>JavaPoet</b> 是一个用来生成 <code>.java</code> 源文件的 Java API。</p>
							<p>当做如注解或者数据库模式、协议格式等事情时，生成源文件就比较有用处。</p>
							<p>GitHub 地址：<a href="https://github.com/square/javapoet/" target="_blank">https://github.com/square/javapoet/</a></p>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="commons-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">commons-</h3>
					</div>
					<div class="panel-body">
						<p>
							<span class="text-primary">说明：</span>
						</p>
						<p>
							jar包 --
							<a href="commons/commons-io-2.5/commons-io-2.5.jar">commons-io-2.5.jar</a>
						</p>
						<p>
							文档 --
							<a target="_blank" href="commons/commons-io-2.5/docs/index.html">apidocs</a>
						</p>
					</div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushBash.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushGroovy.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
