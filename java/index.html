<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--JAVA</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">JAVA</h3>
					</div>
					<div class="list-group">
						<a href="#" class="list-group-item">Java 文档</a>
						<a id="tttt" class="list-group-item active dropdown"
							data-toggle="collapse" data-parent="#accordion"
							href="#java-tools" aria-expanded="true">
							Java 工具<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-tools" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#java-javac" class="list-group-item"
								style="border-top: 1px solid #DDDDDD;">javac 工具</a>
							<a href="#java-java" class="list-group-item">java 工具</a>
							<a href="#java-jar" class="list-group-item">jar 工具</a>
							<a href="#java-examples" class="list-group-item">examples</a>
						</div>
						<a href="#java-syntax" class="list-group-item">Java 中的几个关键字</a>
						<a href="#java-class-loader" class="list-group-item">ClassLoader
							原理</a>
						<a href="#java-reflect" class="list-group-item">Java 反射</a>
						<a href="#java-annotation" class="list-group-item">Java 注解</a>
						<a href="#java-thread" class="list-group-item">多线程</a>
						<a href="#java-thread-pool" class="list-group-item">线程池</a>
						<a href="#java-memory" class="list-group-item">内存管理</a>
						<a href="#java-jni" class="list-group-item">Java 本地编程 -- JNI</a>
						<a href="#java-" class="list-group-item"></a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 id="java-docs" class="panel-title">Java-1.8 文档</h3>
					</div>
					<div class="panel-body">
						<p>
							<a target="_blank" href="./docs/docs-java/index.html">Java
								Platform Standard Edition 8 Documentation</a>
						</p>
						<p>
							<a target="_blank" href="./docs/docs-java/api/index.html">Java
								SE API</a>
							--
							<a target="_blank" href="./docs/docs-java/api-zh/index.html">JAVA
								SE 1.6中文版本 API</a>
						</p>

						<img src="images/java-construct.png" class="img img-responsive">
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-javac"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">javac 工具</h3>
					</div>
					<div class="panel-body">
						<p>
							实例参见: --
							<a href="#java-examples">examples</a>
						<pre class="brush: bash;">
$ javac [ options ] [ sourcefiles ] [ classes] [ @argfiles ]

# options -- 命令行选项
# sourcefiles -- 一个或多个要编译的源文件
# classes -- 一个或多个编译使用的注解类文件
# @argfiles -- 一个或多个对源文件进行列表的文件
</pre>
						<h5 class="text-primary">options</h5>
						<ul>
							<li>
								<p>
									<code>-classpath &lt;path&gt; </code>
									-- 指定查找用户类文件和注释处理程序的位置
								</p>
							</li>
							<li>
								<p>
									<code>-cp &lt;path&gt; </code>
									-- 指定查找用户类文件和注释处理程序的位置
								</p>
							</li>
							<li>
								<p>
									<code>-sourcepath &lt;path&gt; </code>
									-- 指定查找输入源文件的位置
								</p>
							</li>
							<li>
								<p>
									<code>-d &lt;dir&gt; </code>
									-- 指定放置生成的类文件的位置
								</p>
							</li>
							<li>
								<p>
									<code>-s &lt;dir&gt; </code>
									-- 指定放置生成的源文件的位置
								</p>
							</li>
							<li>
								<p>
									<code>-g</code>
									-- 生成所有调试信息
								</p>
							</li>
							<li>
								<p>
									<code>-g:non e</code>
									-- 不生成任何调试信息
								</p>
							</li>
							<li>
								<p>
									<code>-g:{lines,vars,source}</code>
									-- 只生成某些调试信息
								</p>
							</li>
							<li>
								<p>
									<code>-nowarn</code>
									-- 不生成任何警告
								</p>
							</li>
							<li>
								<p>
									<code>-verbose</code>
									-- 输出有关编译器正在执行的操作的消息
								</p>
							</li>
							<li>
								<p>
									<code>-deprecation</code>
									-- 输出使用已过时的 API 的源位置
								</p>
							</li>
							<li>
								<p>
									<code>-bootclasspath &lt;path&gt; </code>
									-- 覆盖引导类文件的位置
								</p>
							</li>
							<li>
								<p>
									<code>-extdirs &lt;dir&gt; </code>
									-- 覆盖所安装扩展的位置
								</p>
							</li>
							<li>
								<p>
									<code>-endorseddirs &lt;dir&gt; </code>
									-- 覆盖签名的标准路径的位置
								</p>
							</li>
							<li>
								<p>
									<code>-proc:{none,only}</code>
									-- 控制是否执行注释处理和/或编译。
								</p>
							</li>
							<li>
								<p>
									<code>-processor
										&lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] </code>
									-- 要运行的注释处理程序的名称; 绕过默认的搜索进程
								</p>
							</li>
							<li>
								<p>
									<code> -processorpath &lt;path&gt; </code>
									-- 指定查找注释处理程序的位置
								</p>
							</li>
							<li>
								<p>
									<code>-implicit:{none,class}</code>
									-- 指定是否为隐式引用文件生成类文件
								</p>
							</li>
							<li>
								<p>
									<code>-encoding &lt;encode&gt; </code>
									-- 指定源文件使用的字符编码
								</p>
							</li>
							<li>
								<p>
									<code>-source &lt;version&gt; </code>
									-- 提供与指定发行版的源兼容性
								</p>
							</li>
							<li>
								<p>
									<code>-target &lt;version&gt; </code>
									-- 生成特定 VM 版本的类文件
								</p>
							</li>
							<li>
								<p>
									<code>-version</code>
									-- 版本信息
								</p>
							</li>
							<li>
								<p>
									<code>-help</code>
									-- 输出标准选项的提要
								</p>
							</li>
							<li>
								<p>
									<code>-Akey[=value]</code>
									-- 传递给注释处理程序的选项
								</p>
							</li>
							<li>
								<p>
									<code>-X</code>
									-- 输出非标准选项的提要
								</p>
							</li>
							<li>
								<p>
									<code> -J &lt;tag&gt; </code>
									-- 直接将 &lt;tag&gt; 传递给运行时系统
								</p>
							</li>
							<li>
								<p>
									<code>-Werror</code>
									-- 出现警告时终止编译
								</p>
							</li>
						</ul>


					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-java"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">java 工具</h3>
					</div>
					<div class="panel-body">
						<p>
							实例参见: --
							<a href="#java-examples">examples</a>
						<pre class="brush: bash;">
$ java [options] classname [args]

$ java [options] -jar filename [args]
</pre>

						<p>Java启动命令可选项(options)大致可分为标准和非标准两种，非标准的可选项不保证在所有平台上都实现，并且未来的版本中可能会被修改且不告知，总之就是不稳定(Unstable)。不过有的非标准可选项还是非常有用的，后面我们会谈到。</p>
						<h5 class="text-primary">标准可选项(Standard options)</h5>
						<ul>
							<li>
								<p>
									<strong>-client</strong> 与 <strong>-server</strong><br>
									以clien或者server模式启动，二选一，Java运行时环境会依场景来优化自己的配置策略。值得指出的是64位的Java不支持client模式，默认就是server。不同平台的默认配置可以参考
									<a target="_blank"
										href="http://docs.oracle.com/javase/6/docs/technotes/guides/vm/server-class.html">Server-Class
										Machine Detection</a>
								</p>
							</li>
							<li>
								<p>
									<strong>-d32</strong> 与 <strong>-d64</strong> <br>
									程序运行在32位或者64位环境
								</p>
							</li>
							<li>
								<p>
									<strong>-cp</strong> 和 <strong>-classpath</strong><br>
									最重要的可选项之一，指定Java运行时环境搜索class的路径。<strong>-cp只是-classpath的简写，做相同的事情</strong>，用其中之一即可。多个路径用<strong>英文里面的分号</strong>分隔。如果-cp和-classpath都没有使用，CLASSPATH环境变量也没用设定，那么就是当前路径(.)。
								</p>
							</li>
							<li>
								<p>
									<strong>-Dproperty=value</strong><br>
									设定系统属性值，比如编码-Dfile.encoding=UTF-8。可以设定一些系统使用的属性，也可以用来向程序传递值，比如程序的根目录。
									可以通过
									<code>System.getProperty("keyname")</code>
									来获取属性。
								</p>
							</li>
							<li>
								<p>
									<strong>-help</strong>与<strong>-?</strong><br> 都是要求显示帮助信息
								</p>
							</li>
							<li>
								<p>
									<strong>-disableassertions[:[packagename]...|:classname]</strong>与<strong>-da[:[packagename]...|:classname]</strong><br>
									禁用断言，可以指定包名(注意包后面的三个点)或者class的名称。默认就是禁用的。da只是disableassertions的缩写，使用方法完全一样。
									禁用包:
									<code> da:org.slf4j...</code>
									<br> 禁用类:
									<code>da:org.slf4j.LoggerFactory</code>
								</p>
							</li>
							<li>
								<p>
									<strong>enableassertions[:packagename...|:classname]</strong>与<strong>ea[:packagename...|:classname]</strong><br>
									启用断言，可以指定包名(注意包后面的三个点)或者class的名称。ea只是enableassertions的缩写，使用方法完全一样。
									启用包:
									<code>ea:org.slf4j...</code>
									<br> 启用类:
									<code>ea:org.slf4j.LoggerFactory</code>
								</p>
							</li>
							<li>
								<p>
									<strong>disablesystemassertions</strong>与<strong>dsa</strong><br>
									禁用系统类(syetem class)断言
								</p>
							</li>
							<li>
								<p>
									<strong>enablesystemassertions</strong>与<strong>esa</strong><br>
									启用系统类(syetem class)断言
								</p>
							</li>
							<li>
								<p>
									<strong>-version</strong> 与 <strong>-showversion</strong><br>
									这两个都显示Java的版本信息，不过后者会把help的信息也显示出来。
								</p>
							</li>
							<li>
								<p>
									<strong>verbose:class</strong>, <strong>verbose:gc</strong>,
									"verbose:jni"<br>
									verbose:class显示class加载信息，verbose:gc显示Java垃圾回收的信息。verbose:jni显示JNI(Java
									Native Interface)信息。
								</p>
							</li>
							<li>
								<p>
									<strong>-agentlib:libname[=options]</strong>与<strong>-agentpath:pathname[=options]</strong><br>
									都是加载本地代理库(Native Agent
									Library)，-agentlib只需要library的名称，且会根据不同的操作系统转为对应的文件(Windows为DLL)。
									-agentpath指定library的绝对路径。
								</p>
							</li>
						</ul>
						<h5 class="text-primary">非标准可选项(Nonstandard Options)</h5>
						<p>非标准的可选项都以-X开始，其中的部分选项如下:</p>
						<ul>
							<li>
								<p>
									<strong>-X</strong><br> 显示所有非标准选项的信息。看看都有些什么非标准选项吧。
									<code>java -X</code>
									。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xms&lt;size&gt;</strong><br> 设置Java堆的初始化大小。例如
									-Xms1024m，Java堆的初始化大小就设置为1G。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xmx&lt;size&gt;</strong><br> 设置Java堆的最大值。例如
									-Xmx3072m，Java堆的最大值就设置为3G。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xss&lt;size&gt;</strong><br> 设置Java线程栈的值。例如
									-Xss128m，Java线程栈的值就设置为128兆。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xnoclassgc</strong><br> 禁用Java垃圾回收器。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xincgc</strong><br> 启用Java增量式垃圾回收器。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xmixed</strong><br> 解释模式和编译模式混合执行
								</p>
							</li>
							<li>
								<p>
									<strong>-Xint</strong><br> 仅解释模式执行
								</p>
							</li>
							<li>
								<p>
									<strong>-Xshare:on</strong>，<strong>-Xshare:off</strong>，<strong>-Xshare:auto</strong>
									设定类数据共享CDS(Class data
									sharing)是否开启。-Xshare:on要求一定要用共享的类数据；-Xshare:auto表示让系统自己判断
									是否有类共享数据，有就用，没有不用；-Xshare:off禁用共享类数据。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xcheck:jni</strong><br> 针对JNI函数做额外的检查
								</p>
							</li>
						</ul>
						<h5 class="text-primary">不稳定(Unstable)的选项</h5>
						<p>不稳定的选项当然是非标准的，都以-XX开头。这一类参数有很多，暂时只列其中的几个:</p>
						<ul>
							<li>
								<p>
									<strong>-XX:PermSize&lt;=size&gt;</strong>和<strong>-XX:MaxPermSize&lt;=size&gt;</strong><br>
									设置Java永久保存区域(Permanent Generation
									Space)的大小。PermSize设置初始值，MaxPermSize设置最大值。 <strong>
										该区域主要存储class的信息，且不会被 垃圾回收器回收</strong>，如果加载的class过多，就会报错:java.lang.OutOfMemoryError:
									PermGen space。 -XX:PermSize=64m
									-XX:MaxPermSize=128m，表示Java永久保存区域大小初始化问为64兆，最大为128兆。
								</p>
							</li>
							<li>
								<p>
									<strong>-XX:+UseParallelGC</strong><br> 开启并行Java回收器
								</p>
							</li>
							<li>
								<p>
									<strong>-XX:+PrintGCDetails</strong><br> 显示比
									<code>-verbose:gc</code>
									更多更准确的垃圾回收信息
								</p>
							</li>
							<li>
								<p>
									<strong>-XX:+TraceClassLoading</strong><br> 显示类加载以及卸载的信息
								</p>
							</li>
						</ul>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-jar"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">jar 工具</h3>
					</div>
					<div class="panel-body">
						<p>
							实例参见: --
							<a href="#java-examples">examples</a>
						<pre class="brush: bash;">
# 创建 jar
$ jar c[efmMnv0] [entrypoint] [jarfile] [manifest] [-C dir] file ... [-Joption ...] [@arg-file ...]

# 更新 jar
$ jar u[efmMnv0] [entrypoint] [jarfile] [manifest] [-C dir] file ... [-Joption ...] [@arg-file ...]

# 解压 jar
$ jar x[vf] [jarfile] file ... [-Joption ...] [@arg-file ...]

# 查看 jar 列出 jar 内容
$ jar t[vf] [jarfile] file ... [-Joption ...] [@arg-file ...]

# 为 jar 创建索引
$ jar i jarfile [-Joption ...] [@arg-file ...]
</pre>
						<h5 class="text-primary">example</h5>
						<pre class="brush: bash;">
$ jar [cuxti][efmMnv0] jarfile [-C dir] [@arg-file ...] # 前面5个参数必先其一
# f 指定jar包路径
# v 生成详细的报造，并输出至标准设备
# m 指定MANIFEST.MF配置文件位置
 -M 不产生所有文件的清单文件(Manifest.mf)
# 0 产生jar包时不对其中的内容进行压缩处理
# i 为指定的jar文件创建索引文件
# -C 表示转到相应的目录下执行jar命令,相当于cd到那个目录，然后不带-C执行jar命令

# 打成jar包
$ jar cvf build/libs/demo.jar -C build/classes/ cm

# 打成jar包, 在这里指定　MANIFEST.MF 配置文件为：config/manifest-config.txt
$ jar cvfm build/libs/demo.jar config/manifest-config.txt -C build/classes/ cm

# 列出 jar 内容
$ jar tvf build/libs/demo.jar
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-examples"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">examples</h3>
					</div>
					<div class="panel-body">
						<div class="row">
							<div class="col-md-7">
								<ul>
									<li>
										<p>
											只有源文件，不引用第三方jar，编译运行，打包：(还没有使用
											<code>libs/commons-lang3-3.5.jar</code>
											中的
											<code>StringUtils</code>
											类)
										</p>
										<pre class="brush: bash;">
# 编译 java 源代码
$ javac -d build/classes/ \
	src/cm/nate/model/Person.java \
	src/cm/nate/Main.java
# 要编译的源文件太多时，可以写入 res/source-list.txt 文件
$ javac -d build/classes @config/source-list.txt

# 直接运行class
$ java -cp "build/classes" cm.nate.Main

# 打成jar包
$ jar cvf build/libs/demo.jar -C build/classes/ cm

# 运行jar包
$ java -cp build/libs/demo.jar cm.nate.Main
</pre>
									</li>
									<li>
										<p>
											源文件引用第三方jar，编译运行，打包：(使用
											<code>libs/commons-lang3-3.5.jar</code>
											中的
											<code>StringUtils</code>
											类)
										</p>
										<pre class="brush: bash;">
# 编译 java 源代码
$ javac -d build/classes \
	-cp libs/commons-lang3-3.5.jar \
	@config/source-list.txt

# 直接运行class
$ java -cp \
	"build/classes:libs/commons-lang3-3.5.jar" \
 	cm.nate.Main

# 打成jar包
$ jar cvf build/libs/demo.jar -C build/classes/ cm

# 运行jar包
$ java -cp \
	build/libs/demo.jar:libs/commons-lang3-3.5.jar \
	cm.nate.Main
</pre>
									</li>
								</ul>
							</div>
							<div class="col-md-5">
								<p>目录结构如下:</p>
								<pre class="brush: bash;">
├── build
│   ├── classes
│   │   └── cm
│   │       └── nate
│   │           ├── Main.class
│   │           └── model
│   │               └── Person.class
│   ├── docs
│   └── libs
│       ├── demo.jar
│       └── libs
│           └── commons-lang3-3.5.jar
├── config
│   ├── manifest-config.txt
│   └── source-list.txt
├── libs
│   └── commons-lang3-3.5.jar
└── src
    └── cm
        └── nate
            ├── Main.java
            └── model
                └── Person.java
</pre>
							</div>
						</div>

						<ul>
							<li>
								<p>
									打包可运行的jar包(在
									<code>MANIFEST.MF</code>
									文件中指定主类),因为这里引用了第三方的jar，可以使用下面的两种方法：
								</p>
								<ol>
									<li>
										<p>
											在
											<code>manifest-config.txt</code>
											文件中指定
											<code>Class-Path(多个jar用空格分割)</code>
											和
											<code>Main-Class</code>
											,<span class="text-danger">注意最后有空行要保留</span>
										</p>
										<pre class="brush: bash;">
Class-Path: libs/commons-lang3-3.5.jar
Main-Class: cm.nate.Main
 
</pre>
										<p>
											要注意的是当前目录下要有
											<code>libs/commons-lang3-3.5.jar</code>
										</p>
										<pre class="brush: bash;">
# 编译 java 源代码
$ javac -d build/classes -cp libs/commons-lang3-3.5.jar @config/source-list.txt

# 直接运行class
$ java -cp "build/classes:libs/commons-lang3-3.5.jar" cm.nate.Main

# 打成jar包, 在这里指定　MANIFEST.MF 配置文件为：config/manifest-config.txt
$ jar cvfm build/libs/demo.jar config/manifest-config.txt -C build/classes/ cm

# 运行jar包，能运行是因为在当前目录下有 libs/commons-lang3-3.5.jar存在
$ java -jar build/libs/demo.jar
</pre>
									</li>
									<li>
										<p>
											在
											<code>manifest-config.txt</code>
											文件中指定
											<code>Main-Class</code>
											,<span class="text-danger">注意最后有空行要保留</span>
										</p>
										<pre class="brush: bash;">
Main-Class: cm.nate.Main
 
</pre>
										<p>要注意的是要解析依赖的jar包，然后打包的时候一起打包进去</p>
										<pre class="brush: bash;">
# 编译 java 源代码
$ javac -d build/classes -cp libs/commons-lang3-3.5.jar @config/source-list.txt

# 直接运行class
$ java -cp "build/classes:libs/commons-lang3-3.5.jar" cm.nate.Main

# 将依赖的jar 解压到 build/classes　目录下,下一步一起打包成自己的jar
$ unzip libs/commons-lang3-3.5.jar -d build/classes

# 打成jar包, 在这里指定　MANIFEST.MF 配置文件为：config/manifest-config.txt
$ jar cvf build/libs/demo.jar config/manifest-config.txt \
	-C build/classes/ cm -C build/classes org

# 运行jar包，能运行是因为依赖的jar包，所有的class被一起打包到 demo.jar中了
$ java -jar build/libs/demo.jar
</pre>
								</ol>
							</li>
						</ul>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-syntax"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Java 中的几个关键字</h3>
					</div>
					<div class="panel-body">
						<ul>
							<li>
								<a href="#java-syntax-static">static 关键字</a>
							</li>
							<li>
								<a href="#java-syntax-final">final 关键字</a>
							</li>
							<li>
								transient 关键字 -- 在成员变量前加此关键字，此成员变量不会被序列化
							</li>
							<li>
								synchronized 关键字 -- 参见: <a href="#java-thread">Java 多线程</a>
							</li>
						</ul>

						<a class="offset" id="java-syntax-static"></a>
						<div class="sub-item">
							<h5 class="text-primary">static 关键字</h5>
							<pre class="brush: java;">
// 静态导入指定成员
import static java.lang.System.out;
// 导入所有静态成员和静态方法
import static java.lang.System.*;

public class StaticDemo {
	// 静态成员
	public static final String TAG = "StaticDemo";

	// 静态代码块
	static {
		System.out.println("===静态代码块===");
	}
	
	// 静态内部类
	public static class Inner {
		public static void show(){
			System.out.println("===静态内部类===");
		}
	}
	
	// 静态方法
	public static void main(String[] args) {
		// 因为静态导入了 java.lang.System.out 这个成员，才能这样用
		out.println("===静态导包===");
		
		getenv();
		
		StaticDemo.Inner.show();
	}
}
</pre>
						</div>

						<a class="offset" id="java-syntax-final"></a>
						<div class="sub-item">
							<h5 class="text-primary">final 关键字</h5>
							<pre class="brush: java;">
// final 类, 不能被继承，没有子类
public final class FinalDemo {
	// final 成员, 不能修改
	public static final String TAG = "FinalDemo";

	// final 方法, 不能 Override
	public final void show() {
		System.out.println("===成员方法===");
	}

	// final 内部类
	public final class Inner {
		public void log() {
			System.out.println("===final 内部类===");
		}
	}

	// final 参数, jdk 1.6 中必须加 final, 才能在方法中的内部类中访问　arg 这个参数
	public void argument(final String arg) {
		Runnable thread = new Runnable() {
			public void run() {
				System.out.println("=== final 参数才能传入到方法的内部类中 ===" + arg);
			}
		};
		new Thread(thread).start();
	}

	public static void main(String[] args) {
		new FinalDemo().argument("xxxxxxxx");
	}
}
</pre>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-class-loader"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">ClassLoader 原理分析</h3>
					</div>
					<div class="panel-body">
						<p>类的加载过程指通过一个类的全限定名来获取描述此类的二进制字节流，并将其转化为方法区的数据结构，进而生成一个java.lang.Class对象作为方法区这个类各种数据访问的入口。这个过程通过Java中的类加载器(ClassLoader)来完成。</p>
						<p>
							类装载器是用来把类(class)装载进JVM的<strong>。</strong>JVM规范定义了两种类型的类装载器：<strong>启动内装载器</strong><strong>(bootstrap)</strong><strong>和用户自定义装载器</strong><strong>(user-defined
								class loader)</strong>。
						</p>
						<p class="h5 text-primary">一、Java默认提供的三个ClassLoader</p>
						<p>
							JVM在运行时会产生三个ClassLoader:Bootstrap&nbsp;ClassLoader、Extension&nbsp;ClassLoader和AppClassLoader（System
							ClassLoader）。</p>
						<p>
							1、&nbsp;<strong>Bootstrap ClassLoader</strong>（启动类加载器）负责将%JAVA_HOME%/lib目录中或-Xbootclasspath中参数指定的路径中的，并且是虚拟机识别的（按名称）类库加载到JVM中。
						</p>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;
							也可以通过-Xbootclasspath参数定义。该ClassLoader不能被Java代码实例化，因为它是JVM本身的一部分。</p>
						<p>
							2、<strong>Extension ClassLoader</strong>（扩展类加载器）负责加载%JAVA_HOME%/lib/ext中的所有类库;
						</p>
						<p>&nbsp;&nbsp;
							只要jar包放置这个位置，就会被虚拟机加载。一个常见的、类似的问题是，你将mysql的低版本驱动不小心放置在这儿，但你的Web应用程序的lib下有一个新的jdbc驱动，但怎么都报错，譬如不支持JDBC2.0的
							DataSource，这时你就要当心你的新jdbc可能并没有被加载。这就是ClassLoader的delegate现象。常见的有log4j、
							common-log、dbcp会出现问题，因为它们很容易被人塞到这个ext目录，或是Tomcat下的common/lib目录</p>
						<p>
							3、<strong>Application ClassLoader</strong>：也称为System
							ClassLoaer（加载%CLASSPATH%路径的类库）以及其它自定义的ClassLoader。缺省情况下，它是用户创建的任何ClassLoader的父ClassLoader。
						</p>
						<p>&nbsp;&nbsp;&nbsp; 我们创建的standalone应用的main
							class缺省情况下也是由它加载(通过Thread.currentThread().getContextClassLoader()查看)。实际开发中用ClassLoader更多时候是用其加载classpath下的资源，特别是配置文件，如ClassLoader.getResource()，比FileInputStream直接。</p>
						<p>类加载器 classloader 是具有层次结构的，也就是父子关系。其中，Bootstrap
							是所有类加载器的父亲。如下图所示：</p>
						<p>
							<img class="img-responsive center-block"
								src="images/java-class-loader-p1.png" alt="">
						</p>
						<p>
							<span style="font-size: 14px;"><span
								style="color: #ff0000;"><strong>注意：</strong></span>&nbsp;除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension
								ClassLoader和App ClassLoader）在内，但是Bootstrap
								ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap
								ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App
								ClassLoader类加载器。</span>
						</p>
						<p class="h5 text-primary">二、双亲委托模型</p>
						<p>Java中ClassLoader的加载采用了双亲委托机制，采用双亲委托机制加载类的时候采用如下的几个步骤：</p>
						<p>1、当前ClassLoader首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类；</p>
						<p class="alert alert-success">每个类加载器都有自己的加载缓存，当一个类被加载后就放入缓存，当下次加载时就可以直接返回了。</p>
						<p>2、当前classLoader的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到bootstrp
							ClassLoader.</p>
						<p>3、当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p>
						<p>
							&nbsp;&nbsp;&nbsp; <strong>JVM中类加载的机制——双亲委派模型。这个模型要求除了Bootstrap
								ClassLoader外，其余的类加载器都要有自己的父加载器。子加载器通过组合来复用父加载器的代码，而不是使用继承。在某个类加载器加载class文件时，它首先委托父加载器去加载这个类，依次传递到顶层类加载器(Bootstrap)。如果顶层加载不了（它的搜索范围中找不到此类），子加载器才会尝试加载这个类。</strong>
						</p>
						<p>
							<strong>&nbsp;&nbsp;</strong>&nbsp;&nbsp;
							当JVM请求某个ClassLoader实例使用这种模型来加载某个类时，首先检查该类是否已经被当前类加载器加载，如果没有被加载，则先委托给她的父类加载器即调用parent.loadClass()方法，这样一直请求调用到请求顶层类加载ClassLoader#findBootStrapClassOrNull,如果这个方法依然加载不了，则会调用ClassLoader#findClass()方法，这个方法再找不到则会抛出ClassNotFoundException异常，但是这里的异常会被捕获，然后返回给委托发起者，最后由当前类加载器的findClass()方法类加载类，如果找不到则抛出ClassNotFoundException异常。
						</p>
						<p>
							<strong>&nbsp;&nbsp; <span style="color: #ff0000;">Class查找的位置和顺序依次是：Cache、parent、self</span></strong>
						</p>

						<p class="h5 text-primary">三、ClassLoader加载类的原理</p>

						<h6 class="text-primary">1、原理介绍</h6>
						<p>
							ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap
							ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap
							ClassLoader试图加载，如果没加载到，则把任务转交给Extension
							ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader
							进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。
						</p>

						<h6 class="text-primary">2、为什么要使用双亲委托这种模型呢？</h6>
						<p>
							因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp
							ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。
						</p>
						<h6 class="text-primary">3、JVM在搜索类的时候，如何判断两个class相同呢？</h6>
						<p>
							JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。
						</p>
						<p>
							比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类，对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。
						</p>
						<p>
							<strong>在一个单虚拟机环境下，标识一个类有两个因素：class的全路径名、该类的ClassLoader。</strong>
						</p>
						<h6 class="text-primary">4、ClassLoader 体系架构</h6>
						<p>
							<img class="img-responsive center-block"
								src="images/java-class-loader-p2.png" alt="">
						</p>
						<p class="h5 text-primary">四、自定义ClassLoader</p>
						<p class="h5 text-primary">为什么我们需要自定义类加载？</p>
						<p>
							<span class="text-danger">主要原因：</span>1、需要加载外部的Class,JVM提供的默认ClassLoader只能加载指定目录下的.jar和.class,如果我们想加载其它位置的class或者jar时，这些默认的类加载器是加载不到的（如果是文件格式必须配置到classpath）。例如：我们需要加载网络上的一个class字节流；
						</p>
						<p>
							2、需要实现Class的隔离性。目前我们常用的Web服务器，如tomcat、jetty都实现了自己定义的类加载，这些类加载主要完成以下三个功能：</p>
						<ul>
							<li>A.实现加载Web应用指定目录下的jar和class</li>
							<li>B.实现部署在容器中的Web应用程共同使用的类库的共享</li>
							<li>C.实现部署在容器中各个Web应用程序自己私有类库的相互隔离</li>
						</ul>
						<p class="h5 text-primary">如何自定义类加载？</p>
						<ul>
							<li>继承java.lang.ClassLoader</li>
							<li>覆写父类的findClass()方法</li>
						</ul>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-reflect"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Java 反射机制</h3>
					</div>
					<div class="panel-body">
						<p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
						<p>反射机制主要提供了以下功能：</p>
						<ul>
							<li>在运行时判断任意一个对象所属的类；</li>
							<li>在运行时构造任意一个类的对象；</li>
							<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
							<li>在运行时调用任意一个对象的方法；</li>
							<li>生成动态代理。</li>
						</ul>
						<div class="panel panel-default">
							<div class="panel-heading">
								<a data-toggle="collapse" data-parent="#accordion"
									href="#java-example-reflect" aria-expanded="true"
									class="code-header">
									<span class="glyphicon glyphicon-plus"></span> View Code
								</a>
							</div>
							<div id="java-example-reflect" class="panel-collapse collapse"
								style="" aria-expanded="true">
								<pre class="brush: java;">
public class MyReflect {
	public static void main(String[] args) {
		MyReflect testReflect = new MyReflect();
		Class&lt;?> clazz = testReflect.getClass();
		
		System.out.println("完整类名: " + clazz.getName());
		System.out.println("类名: " + clazz.getSimpleName());
		System.out.println("类型名: " + clazz.getTypeName());
		System.out.println("ClassLoader名: "
				+ clazz.getClassLoader().getClass().getName());
		System.out.println("父类: " + clazz.getSuperclass().getName());
		
		/** 实例化一个对象，并操作这个对象 */
		try {
			// 第一种方法，实例化默认构造方法，调用set赋值
			Class&lt;?> myClass = Class.forName("cm.nate.reflect.MyReflect");
			MyReflect mr = (MyReflect) myClass.newInstance();
			mr.setName("hello");
			System.out.println(mr.getName());
			
			// 取得指定的构造函数 使用构造函数赋值
			@SuppressWarnings("unchecked")
			Constructor&lt;MyReflect> constructor = 
				(Constructor&lt;MyReflect>) myClass.getConstructor(String.class);
			MyReflect mr2 = constructor.newInstance("jiwanger");
			System.out.println(mr2.getName());
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		/** 取得本类的全部属性 */
		Field[] field = clazz.getDeclaredFields();
        for (int i = 0; i &lt; field.length; i++) {
            // 权限修饰符
            int mo = field[i].getModifiers();
            String priv = Modifier.toString(mo);
            // 属性类型
            Class&lt;?> type = field[i].getType();
            System.out.println(priv + " " + type.getName() + " " + field[i].getName() + ";");
        }
        
        /** 获取某个类的全部方法 */
        Method method[] = clazz.getMethods();
        for (int i = 0; i &lt; method.length; ++i) {
            Class&lt;?> returnType = method[i].getReturnType();
            Class&lt;?> para[] = method[i].getParameterTypes();
            int temp = method[i].getModifiers();
            System.out.print(Modifier.toString(temp) + " ");
            System.out.print(returnType.getName() + "  ");
            System.out.print(method[i].getName() + " ");
            System.out.print("(");
            for (int j = 0; j &lt; para.length; ++j) {
                System.out.print(para[j].getName() + " " + "arg" + j);
                if (j &lt; para.length - 1) {
                    System.out.print(",");
                }
            }
            Class&lt;?> exce[] = method[i].getExceptionTypes();
            if (exce.length > 0) {
                System.out.print(") throws ");
                for (int k = 0; k &lt; exce.length; ++k) {
                    System.out.print(exce[k].getName() + " ");
                    if (k &lt; exce.length - 1) {
                        System.out.print(",");
                    }
                }
            } else {
                System.out.print(")");
            }
            System.out.println();
        }
        
        /** 反射机制调用某个类的方法 */
        try {
			Class&lt;?> myClass = Class.forName("cm.nate.reflect.MyReflect");
			// 调用TestReflect类中的reflect1方法
			
			// Java 反射机制 - 调用某个类的方法1.
			// 调用TestReflect的reflect2方法
			MyReflect mr3 = (MyReflect) myClass.newInstance();
			Method method2 = myClass.getMethod("setName", String.class);
			method2.invoke(mr3, "张三");
			
			Method method3 = myClass.getMethod("getName");
			String name = (String) method3.invoke(mr3);
			System.out.println(name);
			
		}  catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public MyReflect(){}
	
	public MyReflect(String name){
		this.name = name;
	}

	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

}
</pre>
							</div>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-annotation"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Java 注解</h3>
					</div>
					<div class="panel-body">
						<p>Java 注解是附加在代码中的一些元信息，用于编译和运行时进行解析和使用，起到说明、配置的功能。注解不会影响代码的实际逻辑，仅仅起到辅助性的作用。包含在java.lang.annotation包中。注解的定义类似于接口的定义，使用@interface来定义，定义一个方法即为注解类型定义了一个元素，方法的声明不允许有参数或throw语句，返回值类型被限定为原始数据类型、字符串String、Class、enums、注解类型，或前面这些的数组，方法可以有默认值。注解并不直接影响代码的语义，但是他可以被看做是程序的工具或者类库。它会反过来对正在运行的程序语义有所影响。注解可以从源文件、class文件或者在运行时通过反射机制多种方式被读取。</p>
						<p>Java 元注解 -- 元注解是指注解的注解。包括 @Retention @Target @Document
							@Inherited 四种。</p>
						<table class="table table-responsive table-striped table-bordered">
							<thead>
								<tr>
									<th>注解</th>
									<th>说明</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>@Target</td>
									<td>定义注解的作用目标</td>
								</tr>
								<tr>
									<td>@Retention</td>
									<td>定义注解的保留策略。RetentionPolicy.SOURCE:注解仅存在于源码中，在class字节码文件中不包含；RetentionPolicy.CLASS:默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得;RetentionPolicy.RUNTIME:注解会在class字节码文件中存在，在运行时可以通过反射获取到。</td>
								</tr>
								<tr>
									<td>@Document</td>
									<td>说明该注解将被包含在 javadoc 中</td>
								</tr>
								<tr>
									<td>@Inherited</td>
									<td>说明子类可以继承父类中的该注解</td>
								</tr>
							</tbody>
						</table>

						<p>当注解未指定 Target 值时，则此注解可以用于任何元素之上，多个值使用 {} 包含并用逗号隔开，如下：</p>
						<pre class="brush: java;">@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})</pre>
						<table class="table table-responsive table-striped table-bordered">
							<thead>
								<tr>
									<th>Target 类型</th>
									<th>说明</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>ElementType.TYPE</td>
									<td>接口、类、枚举、注解</td>
								</tr>
								<tr>
									<td>ElementType.FIELD</td>
									<td>字段、枚举的常量</td>
								</tr>
								<tr>
									<td>ElementType.METHOD</td>
									<td>方法</td>
								</tr>
								<tr>
									<td>ElementType.CONSTRUCTOR</td>
									<td>构造函数</td>
								</tr>
								<tr>
									<td>ElementType.LOCAL_VARIABLE</td>
									<td>局部变量</td>
								</tr>
								<tr>
									<td>ElementType.ANNOTATION_TYPE</td>
									<td>注解</td>
								</tr>
								<tr>
									<td>ElementType.PACKAGE</td>
									<td>包</td>
								</tr>
								<tr>
									<td>ElementType.PARAMETER</td>
									<td>方法参数</td>
								</tr>
								<tr>
									<td>ElementType.TYPE_USE</td>
									<td>类型使用声明</td>
								</tr>
							</tbody>
						</table>
						<p class="text-primary">example</p>
						<ol>
							<li>
								<p>定义: FruitColor, FruitName, FruitProvider 三个注解类</p>
								<pre class="brush: java;">
/** 水果颜色注解 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitColor {
	/** 颜色枚举 */
	public enum Color {
		BULE, RED, GREEN
	};

	/** 颜色属性 */
	Color fruitColor() default Color.GREEN;
}

/** 水果名称注解 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitName {
    String value() default "";
}

/** 水果供应者注解 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitProvider {
    /** 供应商编号 */
    public int id() default -1;
    
    /** 供应商名称 */
    public String name() default "";
    
    /** 供应商地址 */
    public String address() default "";
}
</pre>
							</li>
							<li>
								<p>注解使用: Apple</p>
								<pre class="brush: java;">
public class Apple {

	@FruitName("Apple")
	private String appleName;

	@FruitColor(fruitColor = Color.RED)
	private String appleColor;

	@FruitProvider(id = 1, name = "陕西红富士集团", address = "陕西省西安市延安路89号红富士大厦")
	private String appleProvider;

	public void setAppleColor(String appleColor) {
		this.appleColor = appleColor;
	}

	public String getAppleColor() {
		return appleColor;
	}

	public void setAppleName(String appleName) {
		this.appleName = appleName;
	}

	public String getAppleName() {
		return appleName;
	}

	public void setAppleProvider(String appleProvider) {
		this.appleProvider = appleProvider;
	}

	public String getAppleProvider() {
		return appleProvider;
	}

	public void displayName() {
		System.out.println("水果的名字是：苹果");
	}
}
</pre>
							</li>
							<li>
								<p>注解处理器: FruitInfoUtil</p>
								<pre class="brush: java;">
public class FruitInfoUtil {
	public static void getFruitInfo(Class&lt;?> clazz) {

		String strFruitName = " 水果名称：";
		String strFruitColor = " 水果颜色：";
		String strFruitProvicer = "供应商信息：";

		Field[] fields = clazz.getDeclaredFields();

		for (Field field : fields) {
			if (field.isAnnotationPresent(FruitName.class)) {
				FruitName fruitName = (FruitName) field
						.getAnnotation(FruitName.class);
				strFruitName = strFruitName + fruitName.value();
				System.out.println(strFruitName);
			} else if (field.isAnnotationPresent(FruitColor.class)) {
				FruitColor fruitColor = (FruitColor) field
						.getAnnotation(FruitColor.class);
				strFruitColor = strFruitColor
						+ fruitColor.fruitColor().toString();
				System.out.println(strFruitColor);
			} else if (field.isAnnotationPresent(FruitProvider.class)) {
				FruitProvider fruitProvider = (FruitProvider) field
						.getAnnotation(FruitProvider.class);
				strFruitProvicer = " 供应商编号：" + fruitProvider.id() + " 供应商名称："
						+ fruitProvider.name() + " 供应商地址："
						+ fruitProvider.address();
				System.out.println(strFruitProvicer);
			}
		}
	}

	public static void main(String[] args) {
		getFruitInfo(Apple.class);
	}
}
</pre>
							</li>
						</ol>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-thread"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">多线程</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p width="100%">
								<img src="images/java-thread.png" class="center-block">
							</p>
							<h5 class="text-primary">线程的状态</h5>
							<ul>
								<li>
									<b>新建状态(New)</b> -- 新创建了一个线程对象。
								</li>
								<li>
									<b>就绪状态(Runnable)</b> --
									线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
								</li>
								<li>
									<b>运行状态(Running)</b> -- 就绪状态的线程获取了CPU，执行程序代码。
								</li>
								<li>
									<b>阻塞状态(Bolcked)</b> --
									阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
									<ol>
										<li>
											<b>等待阻塞</b> -- 运行的线程执行wait()方法，JVM会把该线程放入等待池中。
										</li>
										<li>
											<b>同步阻塞</b> -- 运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
										</li>
										<li>
											<b>其他阻塞</b> --
											运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
										</li>
									</ol>
								</li>
								<li>
									<b>死亡状态(Dead)</b> -- 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
								</li>
							</ul>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">关键字: synchronized</h5>
							<ul>
								<li>
									<p>无论 synchronized 关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果
										synchronized 作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。</p>
								</li>
								<li>
									<p>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。</p>
								</li>
								<li>
									<p>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p>
								</li>
							</ul>
							<p>
								<b>修饰一个代码块</b>
							</p>
							<ul>
								<li>
									一个线程访问一个对象中的 synchronized(this) 同步代码块时，其他试图访问该对象(<span
										class="text-danger">同一个对象实例</span>)的线程将被阻塞。
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#java-thread-e1" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="java-thread-e1" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
public static void main(String[] args) {
	Main context = new Main();

	SynThread mSynThread = context.new SynThread();

	new Thread(mSynThread).start();
	new Thread(mSynThread).start();
}

class SynThread implements Runnable {
	int count = 0;

	public void run() {
		synchronized (this) {
			try {
				for (int i = 0; i < 5; i++) {
					System.out.println(Thread.currentThread().getId() + "===run===" + count++);
					Thread.sleep(500);
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
</pre>
										</div>
									</div>
								</li>
								<li>
									当一个线程访问对象的一个 synchronized(this) 同步代码块时，另一个线程仍然可以访问该对象中的非
									synchronized(this) 同步代码块。
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#java-thread-e2" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="java-thread-e2" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
public static void main(String[] args) {
	Main context = new Main();

	SynThread mSynThread = context.new SynThread();

	new Thread(mSynThread).start();
	new Thread(mSynThread).start();
	
	for (int i = 0; i < 5; i++) {
		mSynThread.showCount();
	}
}

class SynThread implements Runnable {
	int count = 0;

	public void run() {
		synchronized (this) {
			try {
				for (int i = 0; i < 5; i++) {
					System.out.println(Thread.currentThread().getId() + "===run===" + count++);
					Thread.sleep(500);
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
	public void showCount(){
		try {
			Thread.sleep(500);
			System.out.println(Thread.currentThread().getId() + "==================count===" + count);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
</pre>
										</div>
									</div>
								</li>
								<li>
									当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁：
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#java-thread-e3" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="java-thread-e3" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
public static void main(String[] args) {
	Main context = new Main();

	SynThread mSynThread = context.new SynThread();

	new Thread(mSynThread).start();
	new Thread(mSynThread).start();
}

class SynThread implements Runnable {
	int count = 0;
	// 零长度的byte数组对象创建起来将比任何对象都经济
	private byte[] lock = new byte[0];
	
	public void run() {
		synchronized (lock) {
			try {
				for (int i = 0; i < 5; i++) {
					System.out.println(Thread.currentThread().getId() + "===run===" + count++);
					Thread.sleep(500);
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
</pre>
										</div>
									</div>
								</li>
							</ul>
							<p>
								<b>修饰一个方法</b>
							</p>
							<p>synchronized 关键字不能继承。方法上的 synchronized 关键字和如下代码等价:</p>
							<pre class="brush: java;">
public void method() {
	synchronized(this) {
	   // todo
	}
}
</pre>
							<p>
								<b>修饰一个静态的方法</b>
							</p>
							<p>静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。</p>
							<div class="panel panel-default">
								<div class="panel-heading">
									<a data-toggle="collapse" data-parent="#accordion"
										href="#java-thread-e4" aria-expanded="true"
										class="code-header">
										<span class="glyphicon glyphicon-plus"></span> View Code
									</a>
								</div>
								<div id="java-thread-e4" class="panel-collapse collapse"
									style="" aria-expanded="true">
									<pre class="brush: java;">
public class Main {
	public static void main(String[] args) {
		// 和前面不一样, 两个不同的 SynThread 对象实例
		new Thread(new SynThread()).start();
		new Thread(new SynThread()).start();
	}
}

class SynThread implements Runnable {
	static int count = 0;

	public void run() {
		test();
	}

	public synchronized static void test() {
		try {
			for (int i = 0; i < 5; i++) {
				System.out.println(Thread.currentThread().getId() + "===run===" + count++);
				Thread.sleep(500);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
</pre>
								</div>
							</div>
							<p>
								<b>修饰一个类</b>
							</p>
							<p>synchronized 作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。</p>
							<div class="panel panel-default">
								<div class="panel-heading">
									<a data-toggle="collapse" data-parent="#accordion"
										href="#java-thread-e5" aria-expanded="true"
										class="code-header">
										<span class="glyphicon glyphicon-plus"></span> View Code
									</a>
								</div>
								<div id="java-thread-e5" class="panel-collapse collapse"
									style="" aria-expanded="true">
									<pre class="brush: java;">
public static void main(String[] args) {
	Main context = new Main();

	new Thread(context.new SynThread()).start();
	new Thread(context.new SynThread()).start();
}

class SynThread implements Runnable {
	int count = 0;

	public void run() {
		synchronized (SynThread.class) {
			try {
				for (int i = 0; i < 5; i++) {
					System.out.println(Thread.currentThread().getId() + "===run===" + count++);
					Thread.sleep(500);
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

}
</pre>
								</div>
							</div>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">线程调度</h5>
							<ul>
								<li>
									<b>线程优先级</b> --
									Java线程有优先级，优先级高的线程会获得较多的运行机会。推荐使用Thread类有以下三个静态常量:
									<pre class="brush: java;">
// Thread类的 setPriority() 和 getPriority() 方法分别用来设置和获取线程的优先级。
static int MAX_PRIORITY;	// 线程可以具有的最高优先级，取值为10。 
static int MIN_PRIORITY;	// 线程可以具有的最低优先级，取值为1。
static int NORM_PRIORITY;	// 分配给线程的默认优先级，取值为5。 
</pre>
								</li>
								<li>
									<b>Thread.sleep(long millis)</b> --
									使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。
									<pre class="brush: java;">
class SleepThread extends Thread {
	@Override
	public void run() {
		try {
			System.out.println("sleep 2000 毫秒");
			sleep(1000);
			System.out.println("sleep 结束");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		super.run();
	}
	
}
</pre>
								</li>
								<li>
									<p>
										<b>wait 和 sleep 区别</b>
									</p>
									<ul>
										<li>他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。</li>
										<li>wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态
											，从而使线程立刻抛出InterruptedException。</li>
										<li>每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。
											sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。</li>
										<li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
										</li>
										<li>在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。
										</li>
									</ul>
									<p class="alert alert-danger">
										<b>综上所述: wait 和 sleep 最大区别:
											sleep()睡眠时，保持对象锁，仍然占有该锁；而wait()睡眠时，释放对象锁。</b>
									</p>
								</li>
								<li>
									<p>
										<b>Thread.yield()</b> --
										暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。yield()使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。但
										yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。
									</p>
								</li>
								<li>
									<b>Thread.join()</b> -- 调用 join() 方法的线程等待T线程终止再执行。
									<pre class="brush: java;">
Thread t = new Thread(new Runnable() {
	@Override
	public void run() {
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
});

t.start();
try {
	System.out.println("=====我在等待======");
	t.join();
	// 线程 t 执行完后都会执行此处代码
	System.out.println("=====我现在执行======");
} catch (InterruptedException e) {
	e.printStackTrace();
}
</pre>
								</li>
								<li>
									<b>Object的wait(), notify() 和 notifyAll()</b> --
									导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。
									<div class="alert alert-success"
										style="font-size: 14px; font-weight: bold;">
										<ul>
											<li>永远在synchronized的函数或对象里使用wait、notify和notifyAll，不然Java虚拟机会生成
												IllegalMonitorStateException。</li>
											<li>永远在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。
											</li>
											<li>永远在多线程间共享的对象（在生产者消费者模型里即缓冲区队列）上使用wait。</li>
											<li>基于前文提及的理由，更倾向用 notifyAll()，而不是 notify()。</li>
										</ul>
									</div>
									<p>
										<b>生产者-消费者模型</b>: 生产者生产到 10 个产品就停下来等消费者消费；消费者没有产品就通知并等待生产者生产。
										wait() 和 nofity() 方法只能用于 queue, 因为 synchronized (queue).
									</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#java-thread-e6" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="java-thread-e6" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
public class ProducerConsumerInJava {
	public static void main(String args[]) {
		Queue&lt;Integer> buffer = new LinkedList&lt;>();
		int maxSize = 10;
		Thread producer = new Producer(buffer, maxSize, "生产者");
		Thread consumer = new Consumer(buffer, "消费者");
		producer.start();
		consumer.start();
	}
}

// 生产产品，当有10 个产品的时候就停下来等消费者消费
class Producer extends Thread {
	private Queue&lt;Integer> queue;
	private int maxSize;

	public Producer(Queue&lt;Integer> queue, int maxSize, String name) {
		super(name);
		this.queue = queue;
		this.maxSize = maxSize;
	}

	@Override
	public void run() {
		while (true) {
			synchronized (queue) {
				while (queue.size() == maxSize) {
					try {
						System.out.println(getName() + ", 产品太多了，等消费者消费后再生产。");
						queue.wait();
					} catch (Exception ex) {
						ex.printStackTrace();
					}
				}
				Random random = new Random();
				int i = random.nextInt();
				try {
					// 生产一个产品要 1000 毫秒
					sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(getName() + "生成的产品: " + i);
				queue.add(i);
				queue.notifyAll();
			}
		}
	}
}

// 消费产品，无产品时就停下来，并通知生产者生产
class Consumer extends Thread {
	private Queue&lt;Integer> queue;

	public Consumer(Queue&lt;Integer> queue, String name) {
		super(name);
		this.queue = queue;
	}

	@Override
	public void run() {
		while (true) {
			synchronized (queue) {
				while (queue.isEmpty()) {
					System.out.println(getName() + ", 没有产品了，我等你生产!");
					try {
						queue.wait();
					} catch (Exception ex) {
						ex.printStackTrace();
					}
				}
				try {
					// 消费一个产品要 200 毫秒
					sleep(200);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(getName() + "消费的产品 : " + queue.remove());
				queue.notifyAll();
			}
		}
	}
}
</pre>
										</div>
									</div>
								</li>
							</ul>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-thread-pool"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Java 线程池</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
							<ul>
								<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
								<li>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下。</li>
								<li>提供定时执行、定期执行、单线程、并发数控制等功能。</li>
							</ul>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">ThreadPoolExecutor 类</h5>
							<p>ThreadPoolExecutor
								类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。</p>
							<p>ThreadPoolExecutor, AbstractExecutorService,
								ExecutorService 和 Executor 几个之间的关系:</p>
							<ul>
								<li>
									<b>Executor</b> 是一个顶层接口，在它里面只声明了一个方法execute(Runnable)
								</li>
								<li>
									<b>ExecutorService</b>
									接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等
								</li>
								<li>
									<b>AbstractExecutorService</b> 实现了 ExecutorService 接口，基本实现了
									ExecutorService</b> 中声明的所有方法
								</li>
								<li>
									<b>ThreadPoolExecutor</b> 继承了类 AbstractExecutorService
								</li>
							</ul>
							<p class="alert alert-success">
								<b>不推荐直接使用 ThreadPoolExecutor，而是使用 Executors
									类中提供的几个静态方法来创建线程池(见下面: <a href="#java-thread-pool-executors"
										class="text-danger">几种常用线程池</a>):
								</b>
							</p>
							<pre class="brush: java;">
// 创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE
Executors.newCachedThreadPool();
// 创建容量为1的缓冲池
Executors.newSingleThreadExecutor();
// 创建固定容量大小的缓冲池
Executors.newFixedThreadPool(int);
// 创建一个定长线程池，支持定时及周期性任务执行
Executors.newScheduledThreadPool(int)
</pre>
							<p>
								<b>构造方法</b>: (前面三个构造器都是调用的第四个构造器进行的初始化工作)
							</p>
							<pre class="brush: java;">
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, 
	TimeUnit unit, BlockingQueue&lt;Runnable> workQueue)

public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime, TimeUnit unit,
	BlockingQueue&lt;Runnable> workQueue, ThreadFactory threadFactory)
	
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,
    BlockingQueue&lt;Runnable> workQueue, RejectedExecutionHandler handler)

/**
 * corePoolSize: 核心池的大小，在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务
 * 		除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的
 *		意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。
 * maximumPoolSize: 线程池最大线程数，表示在线程池中最多能创建多少个线程
 * keepAliveTime: 表示线程没有任务执行时最多保持多久时间会终止，默认情况下，只有当线程池中的线程数大于corePoolSize时，
 * 		keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，
 * 		如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了
 * 		allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，
 * 		直到线程池中的线程数为0；
 * unit: 参数keepAliveTime的时间单位, java.util.concurrent.TimeUnit 类中定义
 * workQueue: 一个阻塞队列，用来存储等待执行的任务。LinkedBlockingQueue, SynchronousQueue 等
 * threadFactory: 线程工厂，主要用来创建线程
 * handler: 表示当拒绝处理任务时的策略，有以下四种取值：
 * 		ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。 
 * 		ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
 * 		ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
 * 		ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 
 */
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,
	BlockingQueue&lt;Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)
</pre>
							<p>
								<b>线程池状态</b>:
							</p>
							<pre class="brush: java;">
volatile int runState;// runState表示当前线程池的状态
// 当创建线程池后，初始时，线程池处于RUNNING状态
static final int RUNNING    = 0;
// 如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕
static final int SHUTDOWN   = 1;
// 如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务
static final int STOP       = 2;
// 当线程池处于SHUTDOWN或STOP状态,并且所有工作线程已经销毁,任务缓存队列已经清空或执行结束后,线程池被设置为TERMINATED状态
static final int TERMINATED = 3;
</pre>
							<p>
								<b>任务的执行</b>:
							</p>
							<ul>
								<li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li>
								<li>如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li>
								<li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li>
								<li>如果线程池中的线程数量大于
									corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>
							</ul>
							<p>
								<b>任务缓存队列及排队策略</b>:
							</p>
							<p>workQueue的类型为BlockingQueue&lt;Runnable>，通常可以取下面三种类型：
							<ol>
								<li>
									<b>ArrayBlockingQueue</b>：基于数组的先进先出队列，此队列创建时必须指定大小；
								</li>
								<li>
									<b>LinkedBlockingQueue</b>：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；
								</li>
								<li>
									<b>SynchronousQueue</b>：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。
								</li>
							</ol>
							<p>
								<b>任务拒绝策略:</b>
							</p>
							<p>当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</p>
							<pre class="brush: java;">
ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy: 也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy: 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy: 由调用线程处理该任务 
</pre>
							<p>
								<b>线程池的关闭:</b>
							</p>
							<p>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是 shutdown() 和
								shutdownNow()，其中：</p>
							<ul>
								<li>
									<code>shutdown()</code>
									: 不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
								</li>
								<li>
									<code>shutdownNow()</code>
									: 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务
								</li>
							</ul>
							<p>
								<b>线程池容量的动态调整:</b>
							</p>
							<p>ThreadPoolExecutor 提供了动态调整线程池容量大小的方法：setCorePoolSize() 和
								setMaximumPoolSize()</p>
							<ul>
								<li>
									<code>setCorePoolSize()</code>
									: 设置核心池大小
								</li>
								<li>
									<code>setMaximumPoolSize()</code>
									: 设置线程池最大能创建的线程数目大小
								</li>
							</ul>
						</div>

						<a id="java-thread-pool-executors" class="offset"></a>
						<div class="sub-item">
							<h5 class="text-primary">JDK 的几种常用线程池:</h5>
							<ul>
								<li>
									<b>newCachedThreadPool</b> --
									创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
									<pre class="brush: java;">
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
for (int i = 0; i < 10; i++) {
	final int index = i;
	try {
		Thread.sleep(300);
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
	cachedThreadPool.execute(new Runnable() {
		@Override
		public void run() {
			// 每次线程id都相同,当执行第二个任务时第一个任务已经完成,会复用执行第一个任务的线程,而不用每次新建线程。
			System.out.println("索引:" + index + "线程ID:" + Thread.currentThread().getId());
		}
	});
}
// 执行完后关闭, 这里的代码会先执行，但是关闭操作要队列中的线程执行完才会退出
cachedThreadPool.shutdown();
</pre>
								</li>
								<li>
									<b>newFixedThreadPool</b> -- 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
									<pre class="brush: java;">
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
for (int i = 0; i < 10; i++) {
	final int index = i;
	fixedThreadPool.execute(new Runnable() {

		@Override
		public void run() {
			try {
				// 因为线程池大小为3，每个任务输出index后sleep 1秒，所以每两秒打印3个数字。
				System.out.println("索引:" + index + "线程ID:" + Thread.currentThread().getId());
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	});
}
// 执行完后关闭, 这里的代码会先执行，但是关闭操作要队列中的线程执行完才会退出
fixedThreadPool.shutdown();
</pre>
								</li>
								<li>
									<b>newScheduledThreadPool</b> -- 创建一个定长线程池，支持定时及周期性任务执行。
									<pre class="brush: java;">
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
// 延迟3秒执行,
scheduledThreadPool.schedule(new Runnable() {

	@Override
	public void run() {
		System.out.println("线程ID:" + Thread.currentThread().getId());
	}
}, 3, TimeUnit.SECONDS);

// 延迟1秒后每300毫秒执行一次
scheduledThreadPool.scheduleAtFixedRate(new Runnable() {

	@Override
	public void run() {
		System.out.println("线程ID:" + Thread.currentThread().getId());
	}
}, 1, 300, TimeUnit.MILLISECONDS);
</pre>
								</li>
								<li>
									<b>newSingleThreadExecutor</b> --
									创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
									<pre class="brush: java;">
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
for (int i = 0; i < 10; i++) {
	final int index = i;
	singleThreadExecutor.execute(new Runnable() {

		@Override
		public void run() {
			try {
				System.out.println("索引:" + index + "线程ID:" + Thread.currentThread().getId());
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	});
}
// 执行完后关闭, 这里的代码会先执行，但是关闭操作要队列中的线程执行完才会退出
singleThreadExecutor.shutdown();
</pre>
								</li>
							</ul>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-memory"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">内存管理</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">Java运行时内存区</h5>
							<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规
								定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：</p>
							<p class="100%">
								<img src="images/java-memory.gif" class="center-block">
							</p>
							<p>
								<b>程序计数器</b>
							</p>
							<p>程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。</p>
							<p>多线程中，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响、独立存储，因此这块内存是
								线程私有 的。</p>
							<p>
								当线程正在执行的是一个Java方法，这个计数器记录的是在正在执行的虚拟机字节码指令的地址；当执行的是Native方法，这个计数器值为空。
							</p>
							<p>此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 。</p>

							<p>
								<b>Java虚拟机栈</b>
							</p>
							<p>Java虚拟机栈也是线程私有的
								，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链表、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
							<p>局部变量表中存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型(指向了一条字节码指令的地址)。</p>
							<p>如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
							<p>
								<b>本地方法栈</b>
							</p>
							<p>本地方法栈与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。</p>
							<p>会抛出stackOverflowError和OutOfMemoryError异常。</p>
							<p>
								<b>Java堆</b>
							</p>
							<p>Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例 。</p>
							<p>Java堆是垃圾收集器管理的主要区域。由于现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代和老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。</p>
							<p>Java堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。</p>
							<p>如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。</p>
							<p>
								<b>方法区</b>
							</p>
							<p>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 。</p>
							<p>相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，</p>
							<p>当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。</p>
							<p>运行时常量池：是方法区的一部分，它用于存放编译期生成的各种字面量和符号引用。</p>
							<p>
								<b>直接内存</b>
							</p>
							<p>直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>
							<p>直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存大小的限制，所有也可能会抛OutOfMemoryError异常。</p>

						</div>

						<div class="sub-item">
							<h5 class="text-primary">内存溢出</h5>
							<p>在JVM申请内存的过程中，会遇到无法申请到足够内存，从而导致内存溢出的情况。一般有以下几种情况：</p>
							<ul>
								<li>
									虚拟机栈和本地方法栈溢出
									<ul>
										<li>
											<p>StackOverflowError: 线程请求的栈深度大于虚拟机所允许的最大深度(循环递归)</p>
											<p>
												VM 参数:
												<code>-Xss128k</code>
											</p>
											<pre class="brush: java;">
public class JavaVMStackSOF {
	private int stackLength = 1;

	public void stackLeak() {
		stackLength++;
		stackLeak();
	}

	public static void main(String[] args) throws Throwable {
		JavaVMStackSOF oom = new JavaVMStackSOF();
		try {
			oom.stackLeak();
		} catch (Throwable e) {
			System.out.println("stack length:" + oom.stackLength);
			throw e;
		}
	}
}
</pre>
										</li>
										<li>
											<p>
												OutOfMemoryError: 虚拟机在扩展栈是无法申请到足够的内存空间，一般可以通过不停地创建线程引起此种情况,
												<span class="text-danger">此代码执行时有很大令操作系统卡死的风险，可能要强制关机。</span>
											</p>
											<p>
												VM 参数:
												<code>-Xss2M</code>
											</p>
											<pre class="brush: java;">
public class JavaVMStackOOM {
	private void dontStop() {
		while (true) {
		}
	}

	public void stackLeakByThread() {
		while (true) {
			Thread thread = new Thread(new Runnable() {
				@Override
				public void run() {
					dontStop();
				}
			});
			thread.start();
		}
	}

	public static void main(String[] args) throws Throwable {
		JavaVMStackOOM oom = new JavaVMStackOOM();
		// 此代码执行时有很大令操作系统卡死的风险
		// oom.stackLeakByThread();
	}
}
</pre>
										</li>
									</ul>
								</li>
								<li>
									<p>Java堆溢出: 当创建大量对象并且对象生命周期都很长的情况下，会引发OutOfMemoryError。</p>
									<p>Java堆存放的是对象实例，因此只要不断建立对象，并且保证GC
										Roots到对象之间有可达路径即可产生OOM异常。</p>
									<p>
										VM 参数:
										<code>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</code>
										(限制Java堆大小为20M，不可扩展, 参数
										<code>-XX:+HeapDumpOnOutOfMemoryError</code>
										让虚拟机在出现OOM异常的时候Dump出内存映像以便分析(生成.hprof文件，可使用 MAT 工具查看))
									</p>
									<pre class="brush: java;">
public class HeapOOM {
	public static void main(String[] args) {
		List&lt;Object> list = new ArrayList&lt;Object>();

		while (true) {
			list.add(new Object());
		}
	}
}
</pre>
								</li>
								<li>
									<p>运行时常量区溢出：OutOfMemoryError:PermGen
										space，这里一个典型的例子就是String的intern方法，当大量字符串使用intern时，会触发此内存溢出</p>
									<p>
										VM 参数:
										<code>-XX:PermSize=10M -XX:MaxPermSize=10M</code>
										(-XX:PermSize和-XX:MaxPermSize限制方法区大小即可限制常量池容量, <span
											class="text-danger">但Java8 移除了对这两个参数的支持, 此实例无法得到想要的结果</span>)
									</p>
									<pre class="brush: java;">
public class RuntimeConstantPoolOOM {
	public static void main(String[] args) {
		// 使用List保持着常量池引用，压制Full GC回收常量池行为
		List&lt;String> list = new ArrayList&lt;String>();
		// 10M的PermSize在integer范围内足够产生OOM了
		int i = 0;
		while (true) {
			list.add(String.valueOf(i++).intern());
		}
	}
}
</pre>
								</li>
								<li>
									<p>方法区溢出：方法区存放Class等元数据信息，如果产生大量的类(使用cglib)，那么就会引发此内存溢出，OutOfMemoryError:PermGen
										space，在使用Hibernate等框架时会容易引起此种情况。</p>
									<p>
										VM 参数:
										<code> -XX:PermSize=10M -XX:MaxPermSize=10M</code>
										(<span class="text-danger">Java8
											移除了对这两个参数的支持,此实例无法得到想要的结果</span>)
									</p>
									<pre class="brush: java;">
public class RuntimeConstantPoolOOM {
	public static void main(String[] args) {
		// 使用List保持着常量池引用，压制Full GC回收常量池行为
		List&lt;String> list = new ArrayList&lt;String>();
		// 10M的PermSize在integer范围内足够产生OOM了
		int i = 0;
		while (true) {
			list.add(String.valueOf(i++).intern());
		}
	}
}
</pre>
								</li>
								<li>
									<p>本机直接内存溢出:
										DirectByteBuffer也会抛OOM异常，但抛出异常时实际上并没有真正向操作系统申请分配内存，而是通过计算得知无法分配既会抛出
									</p>
									<p>
										VM 参数:
										<code>-Xmx20M -XX:MaxDirectMemorySize=10M</code>
										(<span class="text-danger">此实例无法运行</span>)
									</p>
									<pre class="brush: java;">
public class DirectMemoryOOM {
	private static final int _1MB = 1024 * 1024;
	
	public static void main(String[] args) throws Exception {
		Field unsafeField = Unsafe.class.getDeclaredFields()[0];
		unsafeField.setAccessible(true);
		Unsafe unsafe = (Unsafe) unsafeField.get(null);
		while (true) {
			unsafe.allocateMemory(_1MB);
		}
	}
}
</pre>
								</li>
							</ul>
						</div>

						<div class="sub-item">
							<h5 class="text-primary">Eclipse MAT 工具</h5>
							<p>Eclipse Memory Analyzer（MAT）一个功能丰富的 JAVA
								堆转储文件分析工具，可以用于发现内存漏洞和减少内存消耗。</p>

						</div>

						<div class="sub-item">
							<h5 class="text-primary">VisualVM 工具</h5>
							<p>VisualVM 是一款免费的\集成了多个JDK 命令行工具的可视化工具，它能为您提供强大的分析能力，对 Java
								应用程序做性能分析和调优。这些功能包括生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和 CPU 分析，同时它还支持在
								MBeans 上进行浏览和操作。</p>
							<p>
								VisualVM 是 JDK 自带的工具，位于
								<code>$JAVA_HOME/bin</code>
								目录下,命令行下直接运行
								<code>$ jvisualvm</code>
								就可启动，Visual GC 插件要手动安装。
							</p>
							<p>在内存分析上，Java VisualVM的最大好处是可通过安装Visual GC插件来分析GC（Gabage
								Collection）趋势、内存消耗详细状况。</p>
							<p width="100%">
								<img src="images/java-memory-gc.png"
									class="center-block img-responsive">
							</p>
							<p>
								<b>Visual GC 插件使用: (使用代码测试,下面的代码最终会引发 OOM异常。 VM 参数: <code>-Xms20m
										-Xmx20m</code>)
								</b>
							</p>
							<pre class="brush: java;">
public class HeapOOM {
	static class Test {}
	
	static List&lt;Object> list = new ArrayList&lt;Object>();
	
	public static void main(String[] args) {
		while (true) {
			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			list.add(new Test());
		}
	}
}
</pre>
							<p>根据对象的生命周期长短，把堆分为3个代：Young(年轻代)，Old(年老代)和
								Permanent(持久代)，根据不同代的特点采用不同的收集算法。</p>
							<ul>
								<li>
									<b>Young(年轻代)</b> -- 如图所示(最右侧三个框)年轻代分三个区。一个 Eden 区，两个 Survivor
									区(S0 和 S1)。大部分对象在 Eden 区中生成。当 Eden 区满时，新对象生成，并且在Eden申请空间失败时，引发
									GC 操作, 还存活的对象将被复制到 Survivor 区（两个中的一个），当这个 Survivor
									区满时，此区的存活对象将被复制到另外一个 Survivor 区，当这个 Survivor 去也满了的时候，从第一个
									Survivor 区复制过来的并且此时还存活的对象，将被复到 Old(年老区(如图中间块))。
								</li>
								<li>
									<b>Tenured / Old(年老代)</b> --
									年老代存放从年轻代复制过来的存活对象。一般来说年老代存放的都是生命期较长的对象。
								</li>
								<li>
									<b>Permanent(持久代)</b> --
									持久代用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过
									VM 参数:
									<code>-XX:MaxPermSize=SIZE</code>
									进行设置。
								</li>
							</ul>
							<p>GC 操作分类:</p>
							<ul>
								<li>
									<b>Minor GC</b> -- 从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor
									GC。
								</li>
								<li>
									<b>Major GC</b> -- 清理永久代。许多 Major GC 是由 Minor GC
									触发的，所以很多情况下将这两种 GC 分离是不太可能的。
								</li>
								<li>
									<b>FULL GC</b> -- 是清理整个堆空间—包括年轻代和永久代。引发 FULL GC 一般有如下几种情况:
									<ul>
										<li>上一次 GC 之后 Heap 的各域分配策略动态变化</li>
										<li>System.gc()被显示调用</li>
										<li>Perm(持久代) 域被写满</li>
										<li>Tenured / Old(年老代) 被写满</li>
									</ul>
								</li>
							</ul>
						</div>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="java-jni"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Java 本地编程 -- JNI</h3>
					</div>
					<div class="panel-body">
						<p><code>System.getProperty("java.library.path");</code></p>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Java</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>

		<a target="_blank" href="./docs/docs-java/api-zh/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-6 </a>
		<a target="_blank" href="./docs/docs-java/api/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-8 </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushBash.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
