<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--JAVA</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					style="position: fixed; top: 70px; width: 260px; height: 85%; overflow: auto; float: left;">
					<div class="panel-heading">
						<h3 class="panel-title">JAVA</h3>
					</div>
					<div class="list-group">
						<a href="#" class="list-group-item">Java 文档</a>
						<a id="tttt" class="list-group-item active dropup"
							data-toggle="collapse" data-parent="#accordion"
							href="#java-tools" aria-expanded="true">
							Java 工具<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-tools" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#java-javac" class="list-group-item"
								style="border-top: 1px solid #DDDDDD;">javac 工具</a>
							<a href="#java-java" class="list-group-item">java 工具</a>
							<a href="#java-jar" class="list-group-item">jar 工具</a>
							<a href="#java-examples" class="list-group-item">examples</a>
						</div>
						<a href="#java-class-loader" class="list-group-item">ClassLoader
							原理</a>
						<a href="#java-reflect" class="list-group-item">Java 反射</a>
						<a href="#java-annotation" class="list-group-item">Java 注解</a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 id="java-docs" class="panel-title">Java-1.8 文档</h3>
					</div>
					<div class="panel-body">
						<p>
							<a target="_blank" href="./docs/docs-java/index.html">Java
								Platform Standard Edition 8 Documentation</a>
						</p>
						<p>
							<a target="_blank" href="./docs/docs-java/api/index.html">Java
								SE API</a>
							--
							<a target="_blank" href="./docs/docs-java/api-zh/index.html">JAVA
								SE 1.6中文版本 API</a>
						</p>

						<img src="images/java-construct.png" class="img img-responsive">
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-javac"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">javac 工具</h3>
					</div>
					<div class="panel-body">
						<p>
							实例参见: --
							<a href="#java-examples">examples</a>
						<pre class="brush: bash;">
$ javac [ options ] [ sourcefiles ] [ classes] [ @argfiles ]

# options -- 命令行选项
# sourcefiles -- 一个或多个要编译的源文件
# classes -- 一个或多个编译使用的注解类文件
# @argfiles -- 一个或多个对源文件进行列表的文件
</pre>
						<h5 class="text-primary">options</h5>
						<ul>
							<li>
								<p>
									<code>-classpath &lt;path&gt; </code>
									-- 指定查找用户类文件和注释处理程序的位置
								</p>
							</li>
							<li>
								<p>
									<code>-cp &lt;path&gt; </code>
									-- 指定查找用户类文件和注释处理程序的位置
								</p>
							</li>
							<li>
								<p>
									<code>-sourcepath &lt;path&gt; </code>
									-- 指定查找输入源文件的位置
								</p>
							</li>
							<li>
								<p>
									<code>-d &lt;dir&gt; </code>
									-- 指定放置生成的类文件的位置
								</p>
							</li>
							<li>
								<p>
									<code>-s &lt;dir&gt; </code>
									-- 指定放置生成的源文件的位置
								</p>
							</li>
							<li>
								<p>
									<code>-g</code>
									-- 生成所有调试信息
								</p>
							</li>
							<li>
								<p>
									<code>-g:non e</code>
									-- 不生成任何调试信息
								</p>
							</li>
							<li>
								<p>
									<code>-g:{lines,vars,source}</code>
									-- 只生成某些调试信息
								</p>
							</li>
							<li>
								<p>
									<code>-nowarn</code>
									-- 不生成任何警告
								</p>
							</li>
							<li>
								<p>
									<code>-verbose</code>
									-- 输出有关编译器正在执行的操作的消息
								</p>
							</li>
							<li>
								<p>
									<code>-deprecation</code>
									-- 输出使用已过时的 API 的源位置
								</p>
							</li>
							<li>
								<p>
									<code>-bootclasspath &lt;path&gt; </code>
									-- 覆盖引导类文件的位置
								</p>
							</li>
							<li>
								<p>
									<code>-extdirs &lt;dir&gt; </code>
									-- 覆盖所安装扩展的位置
								</p>
							</li>
							<li>
								<p>
									<code>-endorseddirs &lt;dir&gt; </code>
									-- 覆盖签名的标准路径的位置
								</p>
							</li>
							<li>
								<p>
									<code>-proc:{none,only}</code>
									-- 控制是否执行注释处理和/或编译。
								</p>
							</li>
							<li>
								<p>
									<code>-processor
										&lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] </code>
									-- 要运行的注释处理程序的名称; 绕过默认的搜索进程
								</p>
							</li>
							<li>
								<p>
									<code> -processorpath &lt;path&gt; </code>
									-- 指定查找注释处理程序的位置
								</p>
							</li>
							<li>
								<p>
									<code>-implicit:{none,class}</code>
									-- 指定是否为隐式引用文件生成类文件
								</p>
							</li>
							<li>
								<p>
									<code>-encoding &lt;encode&gt; </code>
									-- 指定源文件使用的字符编码
								</p>
							</li>
							<li>
								<p>
									<code>-source &lt;version&gt; </code>
									-- 提供与指定发行版的源兼容性
								</p>
							</li>
							<li>
								<p>
									<code>-target &lt;version&gt; </code>
									-- 生成特定 VM 版本的类文件
								</p>
							</li>
							<li>
								<p>
									<code>-version</code>
									-- 版本信息
								</p>
							</li>
							<li>
								<p>
									<code>-help</code>
									-- 输出标准选项的提要
								</p>
							</li>
							<li>
								<p>
									<code>-Akey[=value]</code>
									-- 传递给注释处理程序的选项
								</p>
							</li>
							<li>
								<p>
									<code>-X</code>
									-- 输出非标准选项的提要
								</p>
							</li>
							<li>
								<p>
									<code> -J &lt;tag&gt; </code>
									-- 直接将 &lt;tag&gt; 传递给运行时系统
								</p>
							</li>
							<li>
								<p>
									<code>-Werror</code>
									-- 出现警告时终止编译
								</p>
							</li>
						</ul>


					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-java"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">java 工具</h3>
					</div>
					<div class="panel-body">
						<p>
							实例参见: --
							<a href="#java-examples">examples</a>
						<pre class="brush: bash;">
$ java [options] classname [args]

$ java [options] -jar filename [args]
</pre>

						<p>Java启动命令可选项(options)大致可分为标准和非标准两种，非标准的可选项不保证在所有平台上都实现，并且未来的版本中可能会被修改且不告知，总之就是不稳定(Unstable)。不过有的非标准可选项还是非常有用的，后面我们会谈到。</p>
						<h5 class="text-primary">标准可选项(Standard options)</h5>
						<ul>
							<li>
								<p>
									<strong>-client</strong> 与 <strong>-server</strong><br>
									以clien或者server模式启动，二选一，Java运行时环境会依场景来优化自己的配置策略。值得指出的是64位的Java不支持client模式，默认就是server。不同平台的默认配置可以参考
									<a target="_blank"
										href="http://docs.oracle.com/javase/6/docs/technotes/guides/vm/server-class.html">Server-Class
										Machine Detection</a>
								</p>
							</li>
							<li>
								<p>
									<strong>-d32</strong> 与 <strong>-d64</strong> <br>
									程序运行在32位或者64位环境
								</p>
							</li>
							<li>
								<p>
									<strong>-cp</strong> 和 <strong>-classpath</strong><br>
									最重要的可选项之一，指定Java运行时环境搜索class的路径。<strong>-cp只是-classpath的简写，做相同的事情</strong>，用其中之一即可。多个路径用<strong>英文里面的分号</strong>分隔。如果-cp和-classpath都没有使用，CLASSPATH环境变量也没用设定，那么就是当前路径(.)。
								</p>
							</li>
							<li>
								<p>
									<strong>-Dproperty=value</strong><br>
									设定系统属性值，比如编码-Dfile.encoding=UTF-8。可以设定一些系统使用的属性，也可以用来向程序传递值，比如程序的根目录。
									可以通过
									<code>System.getProperty("keyname")</code>
									来获取属性。
								</p>
							</li>
							<li>
								<p>
									<strong>-help</strong>与<strong>-?</strong><br> 都是要求显示帮助信息
								</p>
							</li>
							<li>
								<p>
									<strong>-disableassertions[:[packagename]...|:classname]</strong>与<strong>-da[:[packagename]...|:classname]</strong><br>
									禁用断言，可以指定包名(注意包后面的三个点)或者class的名称。默认就是禁用的。da只是disableassertions的缩写，使用方法完全一样。
									禁用包:
									<code> da:org.slf4j...</code>
									<br> 禁用类:
									<code>da:org.slf4j.LoggerFactory</code>
								</p>
							</li>
							<li>
								<p>
									<strong>enableassertions[:packagename...|:classname]</strong>与<strong>ea[:packagename...|:classname]</strong><br>
									启用断言，可以指定包名(注意包后面的三个点)或者class的名称。ea只是enableassertions的缩写，使用方法完全一样。
									启用包:
									<code>ea:org.slf4j...</code>
									<br> 启用类:
									<code>ea:org.slf4j.LoggerFactory</code>
								</p>
							</li>
							<li>
								<p>
									<strong>disablesystemassertions</strong>与<strong>dsa</strong><br>
									禁用系统类(syetem class)断言
								</p>
							</li>
							<li>
								<p>
									<strong>enablesystemassertions</strong>与<strong>esa</strong><br>
									启用系统类(syetem class)断言
								</p>
							</li>
							<li>
								<p>
									<strong>-version</strong> 与 <strong>-showversion</strong><br>
									这两个都显示Java的版本信息，不过后者会把help的信息也显示出来。
								</p>
							</li>
							<li>
								<p>
									<strong>verbose:class</strong>, <strong>verbose:gc</strong>,
									"verbose:jni"<br>
									verbose:class显示class加载信息，verbose:gc显示Java垃圾回收的信息。verbose:jni显示JNI(Java
									Native Interface)信息。
								</p>
							</li>
							<li>
								<p>
									<strong>-agentlib:libname[=options]</strong>与<strong>-agentpath:pathname[=options]</strong><br>
									都是加载本地代理库(Native Agent
									Library)，-agentlib只需要library的名称，且会根据不同的操作系统转为对应的文件(Windows为DLL)。
									-agentpath指定library的绝对路径。
								</p>
							</li>
						</ul>
						<h5 class="text-primary">非标准可选项(Nonstandard Options)</h5>
						<p>非标准的可选项都以-X开始，其中的部分选项如下:</p>
						<ul>
							<li>
								<p>
									<strong>-X</strong><br> 显示所有非标准选项的信息。看看都有些什么非标准选项吧。
									<code>java -X</code>
									。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xms&lt;size&gt;</strong><br> 设置Java堆的初始化大小。例如
									-Xms1024m，Java堆的初始化大小就设置为1G。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xmx&lt;size&gt;</strong><br> 设置Java堆的最大值。例如
									-Xmx3072m，Java堆的最大值就设置为3G。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xss&lt;size&gt;</strong><br> 设置Java线程栈的值。例如
									-Xss128m，Java线程栈的值就设置为128兆。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xnoclassgc</strong><br> 禁用Java垃圾回收器。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xincgc</strong><br> 启用Java增量式垃圾回收器。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xmixed</strong><br> 解释模式和编译模式混合执行
								</p>
							</li>
							<li>
								<p>
									<strong>-Xint</strong><br> 仅解释模式执行
								</p>
							</li>
							<li>
								<p>
									<strong>-Xshare:on</strong>，<strong>-Xshare:off</strong>，<strong>-Xshare:auto</strong>
									设定类数据共享CDS(Class data
									sharing)是否开启。-Xshare:on要求一定要用共享的类数据；-Xshare:auto表示让系统自己判断
									是否有类共享数据，有就用，没有不用；-Xshare:off禁用共享类数据。
								</p>
							</li>
							<li>
								<p>
									<strong>-Xcheck:jni</strong><br> 针对JNI函数做额外的检查
								</p>
							</li>
						</ul>
						<h5 class="text-primary">不稳定(Unstable)的选项</h5>
						<p>不稳定的选项当然是非标准的，都以-XX开头。这一类参数有很多，暂时只列其中的几个:</p>
						<ul>
							<li>
								<p>
									<strong>-XX:PermSize&lt;=size&gt;</strong>和<strong>-XX:MaxPermSize&lt;=size&gt;</strong><br>
									设置Java永久保存区域(Permanent Generation
									Space)的大小。PermSize设置初始值，MaxPermSize设置最大值。 <strong>
										该区域主要存储class的信息，且不会被 垃圾回收器回收</strong>，如果加载的class过多，就会报错:java.lang.OutOfMemoryError:
									PermGen space。 -XX:PermSize=64m
									-XX:MaxPermSize=128m，表示Java永久保存区域大小初始化问为64兆，最大为128兆。
								</p>
							</li>
							<li>
								<p>
									<strong>-XX:+UseParallelGC</strong><br> 开启并行Java回收器
								</p>
							</li>
							<li>
								<p>
									<strong>-XX:+PrintGCDetails</strong><br> 显示比
									<code>-verbose:gc</code>
									更多更准确的垃圾回收信息
								</p>
							</li>
							<li>
								<p>
									<strong>-XX:+TraceClassLoading</strong><br> 显示类加载以及卸载的信息
								</p>
							</li>
						</ul>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-jar"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">jar 工具</h3>
					</div>
					<div class="panel-body">
						<p>
							实例参见: --
							<a href="#java-examples">examples</a>
						<pre class="brush: bash;">
# 创建 jar
$ jar c[efmMnv0] [entrypoint] [jarfile] [manifest] [-C dir] file ... [-Joption ...] [@arg-file ...]

# 更新 jar
$ jar u[efmMnv0] [entrypoint] [jarfile] [manifest] [-C dir] file ... [-Joption ...] [@arg-file ...]

# 解压 jar
$ jar x[vf] [jarfile] file ... [-Joption ...] [@arg-file ...]

# 查看 jar 列出 jar 内容
$ jar t[vf] [jarfile] file ... [-Joption ...] [@arg-file ...]

# 为 jar 创建索引
$ jar i jarfile [-Joption ...] [@arg-file ...]
</pre>
						<h5 class="text-primary">example</h5>
						<pre class="brush: bash;">
$ jar [cuxti][efmMnv0] jarfile [-C dir] [@arg-file ...] # 前面5个参数必先其一
# f 指定jar包路径
# v 生成详细的报造，并输出至标准设备
# m 指定MANIFEST.MF配置文件位置
 -M 不产生所有文件的清单文件(Manifest.mf)
# 0 产生jar包时不对其中的内容进行压缩处理
# i 为指定的jar文件创建索引文件
# -C 表示转到相应的目录下执行jar命令,相当于cd到那个目录，然后不带-C执行jar命令

# 打成jar包
$ jar cvf build/libs/demo.jar -C build/classes/ cm

# 打成jar包, 在这里指定　MANIFEST.MF 配置文件为：config/manifest-config.txt
$ jar cvfm build/libs/demo.jar config/manifest-config.txt -C build/classes/ cm

# 列出 jar 内容
$ jar tvf build/libs/demo.jar
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-examples"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">examples</h3>
					</div>
					<div class="panel-body">
						<div class="row">
							<div class="col-md-7">
								<ul>
									<li>
										<p>
											只有源文件，不引用第三方jar，编译运行，打包：(还没有使用
											<code>libs/commons-lang3-3.5.jar</code>
											中的
											<code>StringUtils</code>
											类)
										</p>
										<pre class="brush: bash;">
# 编译 java 源代码
$ javac -d build/classes/ \
	src/cm/nate/model/Person.java \
	src/cm/nate/Main.java
# 要编译的源文件太多时，可以写入 res/source-list.txt 文件
$ javac -d build/classes @config/source-list.txt

# 直接运行class
$ java -cp "build/classes" cm.nate.Main

# 打成jar包
$ jar cvf build/libs/demo.jar -C build/classes/ cm

# 运行jar包
$ java -cp build/libs/demo.jar cm.nate.Main
</pre>
									</li>
									<li>
										<p>
											源文件引用第三方jar，编译运行，打包：(使用
											<code>libs/commons-lang3-3.5.jar</code>
											中的
											<code>StringUtils</code>
											类)
										</p>
										<pre class="brush: bash;">
# 编译 java 源代码
$ javac -d build/classes \
	-cp libs/commons-lang3-3.5.jar \
	@config/source-list.txt

# 直接运行class
$ java -cp \
	"build/classes:libs/commons-lang3-3.5.jar" \
 	cm.nate.Main

# 打成jar包
$ jar cvf build/libs/demo.jar -C build/classes/ cm

# 运行jar包
$ java -cp \
	build/libs/demo.jar:libs/commons-lang3-3.5.jar \
	cm.nate.Main
</pre>
									</li>
								</ul>
							</div>
							<div class="col-md-5">
								<p>目录结构如下:</p>
								<pre class="brush: bash;">
├── build
│   ├── classes
│   │   └── cm
│   │       └── nate
│   │           ├── Main.class
│   │           └── model
│   │               └── Person.class
│   ├── docs
│   └── libs
│       ├── demo.jar
│       └── libs
│           └── commons-lang3-3.5.jar
├── config
│   ├── manifest-config.txt
│   └── source-list.txt
├── libs
│   └── commons-lang3-3.5.jar
└── src
    └── cm
        └── nate
            ├── Main.java
            └── model
                └── Person.java
</pre>
							</div>
						</div>

						<ul>
							<li>
								<p>
									打包可运行的jar包(在
									<code>MANIFEST.MF</code>
									文件中指定主类),因为这里引用了第三方的jar，可以使用下面的两种方法：
								</p>
								<ol>
									<li>
										<p>
											在
											<code>manifest-config.txt</code>
											文件中指定
											<code>Class-Path(多个jar用空格分割)</code>
											和
											<code>Main-Class</code>
											,<span class="text-danger">注意最后有空行要保留</span>
										</p>
										<pre class="brush: bash;">
Class-Path: libs/commons-lang3-3.5.jar
Main-Class: cm.nate.Main
 
</pre>
										<p>
											要注意的是当前目录下要有
											<code>libs/commons-lang3-3.5.jar</code>
										</p>
										<pre class="brush: bash;">
# 编译 java 源代码
$ javac -d build/classes -cp libs/commons-lang3-3.5.jar @config/source-list.txt

# 直接运行class
$ java -cp "build/classes:libs/commons-lang3-3.5.jar" cm.nate.Main

# 打成jar包, 在这里指定　MANIFEST.MF 配置文件为：config/manifest-config.txt
$ jar cvfm build/libs/demo.jar config/manifest-config.txt -C build/classes/ cm

# 运行jar包，能运行是因为在当前目录下有 libs/commons-lang3-3.5.jar存在
$ java -jar build/libs/demo.jar
</pre>
									</li>
									<li>
										<p>
											在
											<code>manifest-config.txt</code>
											文件中指定
											<code>Main-Class</code>
											,<span class="text-danger">注意最后有空行要保留</span>
										</p>
										<pre class="brush: bash;">
Main-Class: cm.nate.Main
 
</pre>
										<p>要注意的是要解析依赖的jar包，然后打包的时候一起打包进去</p>
										<pre class="brush: bash;">
# 编译 java 源代码
$ javac -d build/classes -cp libs/commons-lang3-3.5.jar @config/source-list.txt

# 直接运行class
$ java -cp "build/classes:libs/commons-lang3-3.5.jar" cm.nate.Main

# 将依赖的jar 解压到 build/classes　目录下,下一步一起打包成自己的jar
$ unzip libs/commons-lang3-3.5.jar -d build/classes

# 打成jar包, 在这里指定　MANIFEST.MF 配置文件为：config/manifest-config.txt
$ jar cvf build/libs/demo.jar config/manifest-config.txt \
	-C build/classes/ cm -C build/classes org

# 运行jar包，能运行是因为依赖的jar包，所有的class被一起打包到 demo.jar中了
$ java -jar build/libs/demo.jar
</pre>
								</ol>
							</li>
						</ul>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-class-loader"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">ClassLoader 原理分析</h3>
					</div>
					<div class="panel-body">
						<p>类的加载过程指通过一个类的全限定名来获取描述此类的二进制字节流，并将其转化为方法区的数据结构，进而生成一个java.lang.Class对象作为方法区这个类各种数据访问的入口。这个过程通过Java中的类加载器(ClassLoader)来完成。</p>
						<p>
							类装载器是用来把类(class)装载进JVM的<strong>。</strong>JVM规范定义了两种类型的类装载器：<strong>启动内装载器</strong><strong>(bootstrap)</strong><strong>和用户自定义装载器</strong><strong>(user-defined
								class loader)</strong>。
						</p>
						<p class="h5 text-primary">一、Java默认提供的三个ClassLoader</p>
						<p>
							JVM在运行时会产生三个ClassLoader:Bootstrap&nbsp;ClassLoader、Extension&nbsp;ClassLoader和AppClassLoader（System
							ClassLoader）。</p>
						<p>
							1、&nbsp;<strong>Bootstrap ClassLoader</strong>（启动类加载器）负责将%JAVA_HOME%/lib目录中或-Xbootclasspath中参数指定的路径中的，并且是虚拟机识别的（按名称）类库加载到JVM中。
						</p>
						<p>&nbsp;&nbsp;&nbsp;&nbsp;
							也可以通过-Xbootclasspath参数定义。该ClassLoader不能被Java代码实例化，因为它是JVM本身的一部分。</p>
						<p>
							2、<strong>Extension ClassLoader</strong>（扩展类加载器）负责加载%JAVA_HOME%/lib/ext中的所有类库;
						</p>
						<p>&nbsp;&nbsp;
							只要jar包放置这个位置，就会被虚拟机加载。一个常见的、类似的问题是，你将mysql的低版本驱动不小心放置在这儿，但你的Web应用程序的lib下有一个新的jdbc驱动，但怎么都报错，譬如不支持JDBC2.0的
							DataSource，这时你就要当心你的新jdbc可能并没有被加载。这就是ClassLoader的delegate现象。常见的有log4j、
							common-log、dbcp会出现问题，因为它们很容易被人塞到这个ext目录，或是Tomcat下的common/lib目录</p>
						<p>
							3、<strong>Application ClassLoader</strong>：也称为System
							ClassLoaer（加载%CLASSPATH%路径的类库）以及其它自定义的ClassLoader。缺省情况下，它是用户创建的任何ClassLoader的父ClassLoader。
						</p>
						<p>&nbsp;&nbsp;&nbsp; 我们创建的standalone应用的main
							class缺省情况下也是由它加载(通过Thread.currentThread().getContextClassLoader()查看)。实际开发中用ClassLoader更多时候是用其加载classpath下的资源，特别是配置文件，如ClassLoader.getResource()，比FileInputStream直接。</p>
						<p>类加载器 classloader 是具有层次结构的，也就是父子关系。其中，Bootstrap
							是所有类加载器的父亲。如下图所示：</p>
						<p>
							<img class="img-responsive center-block"
								src="images/java-class-loader-p1.png" alt="">
						</p>
						<p>
							<span style="font-size: 14px;"><span
								style="color: #ff0000;"><strong>注意：</strong></span>&nbsp;除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension
								ClassLoader和App ClassLoader）在内，但是Bootstrap
								ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap
								ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App
								ClassLoader类加载器。</span>
						</p>
						<p class="h5 text-primary">二、双亲委托模型</p>
						<p>Java中ClassLoader的加载采用了双亲委托机制，采用双亲委托机制加载类的时候采用如下的几个步骤：</p>
						<p>1、当前ClassLoader首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类；</p>
						<p class="alert alert-success">每个类加载器都有自己的加载缓存，当一个类被加载后就放入缓存，当下次加载时就可以直接返回了。</p>
						<p>2、当前classLoader的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到bootstrp
							ClassLoader.</p>
						<p>3、当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p>
						<p>
							&nbsp;&nbsp;&nbsp; <strong>JVM中类加载的机制——双亲委派模型。这个模型要求除了Bootstrap
								ClassLoader外，其余的类加载器都要有自己的父加载器。子加载器通过组合来复用父加载器的代码，而不是使用继承。在某个类加载器加载class文件时，它首先委托父加载器去加载这个类，依次传递到顶层类加载器(Bootstrap)。如果顶层加载不了（它的搜索范围中找不到此类），子加载器才会尝试加载这个类。</strong>
						</p>
						<p>
							<strong>&nbsp;&nbsp;</strong>&nbsp;&nbsp;
							当JVM请求某个ClassLoader实例使用这种模型来加载某个类时，首先检查该类是否已经被当前类加载器加载，如果没有被加载，则先委托给她的父类加载器即调用parent.loadClass()方法，这样一直请求调用到请求顶层类加载ClassLoader#findBootStrapClassOrNull,如果这个方法依然加载不了，则会调用ClassLoader#findClass()方法，这个方法再找不到则会抛出ClassNotFoundException异常，但是这里的异常会被捕获，然后返回给委托发起者，最后由当前类加载器的findClass()方法类加载类，如果找不到则抛出ClassNotFoundException异常。
						</p>
						<p>
							<strong>&nbsp;&nbsp; <span style="color: #ff0000;">Class查找的位置和顺序依次是：Cache、parent、self</span></strong>
						</p>

						<p class="h5 text-primary">三、ClassLoader加载类的原理</p>

						<h6 class="text-primary">1、原理介绍</h6>
						<p>
							ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap
							ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap
							ClassLoader试图加载，如果没加载到，则把任务转交给Extension
							ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader
							进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。
						</p>

						<h6 class="text-primary">2、为什么要使用双亲委托这种模型呢？</h6>
						<p>
							因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp
							ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。
						</p>
						<h6 class="text-primary">3、JVM在搜索类的时候，如何判断两个class相同呢？</h6>
						<p>
							JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。
						</p>
						<p>
							比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类，对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。
						</p>
						<p>
							<strong>在一个单虚拟机环境下，标识一个类有两个因素：class的全路径名、该类的ClassLoader。</strong>
						</p>
						<h6 class="text-primary">4、ClassLoader 体系架构</h6>
						<p>
							<img class="img-responsive center-block"
								src="images/java-class-loader-p2.png" alt="">
						</p>
						<p class="h5 text-primary">四、自定义ClassLoader</p>
						<p class="h5 text-primary">为什么我们需要自定义类加载？</p>
						<p>
							<span class="text-danger">主要原因：</span>1、需要加载外部的Class,JVM提供的默认ClassLoader只能加载指定目录下的.jar和.class,如果我们想加载其它位置的class或者jar时，这些默认的类加载器是加载不到的（如果是文件格式必须配置到classpath）。例如：我们需要加载网络上的一个class字节流；
						</p>
						<p>
							2、需要实现Class的隔离性。目前我们常用的Web服务器，如tomcat、jetty都实现了自己定义的类加载，这些类加载主要完成以下三个功能：</p>
						<ul>
							<li>A.实现加载Web应用指定目录下的jar和class</li>
							<li>B.实现部署在容器中的Web应用程共同使用的类库的共享</li>
							<li>C.实现部署在容器中各个Web应用程序自己私有类库的相互隔离</li>
						</ul>
						<p class="h5 text-primary">如何自定义类加载？</p>
						<ul>
							<li>继承java.lang.ClassLoader</li>
							<li>覆写父类的findClass()方法</li>
						</ul>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-reflect"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 id="java-docs" class="panel-title">Java 反射机制</h3>
					</div>
					<div class="panel-body">
						<p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
						<p>反射机制主要提供了以下功能：</p>
						<ul>
							<li>在运行时判断任意一个对象所属的类；</li>
							<li>在运行时构造任意一个类的对象；</li>
							<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
							<li>在运行时调用任意一个对象的方法；</li>
							<li>生成动态代理。</li>
						</ul>
						<div class="panel panel-default">
							<div class="panel-heading">
								<a data-toggle="collapse" data-parent="#accordion"
									href="#java-example-reflect" aria-expanded="true"
									class="code-header">
									<span class="glyphicon glyphicon-plus"></span> View Code
								</a>
							</div>
							<div id="java-example-reflect" class="panel-collapse collapse"
								style="" aria-expanded="true">
								<pre class="brush: java;">
public class MyReflect {
	public static void main(String[] args) {
		MyReflect testReflect = new MyReflect();
		Class&lt;?> clazz = testReflect.getClass();
		
		System.out.println("完整类名: " + clazz.getName());
		System.out.println("类名: " + clazz.getSimpleName());
		System.out.println("类型名: " + clazz.getTypeName());
		System.out.println("ClassLoader名: "
				+ clazz.getClassLoader().getClass().getName());
		System.out.println("父类: " + clazz.getSuperclass().getName());
		
		/** 实例化一个对象，并操作这个对象 */
		try {
			// 第一种方法，实例化默认构造方法，调用set赋值
			Class&lt;?> myClass = Class.forName("cm.nate.reflect.MyReflect");
			MyReflect mr = (MyReflect) myClass.newInstance();
			mr.setName("hello");
			System.out.println(mr.getName());
			
			// 取得指定的构造函数 使用构造函数赋值
			@SuppressWarnings("unchecked")
			Constructor&lt;MyReflect> constructor = 
				(Constructor&lt;MyReflect>) myClass.getConstructor(String.class);
			MyReflect mr2 = constructor.newInstance("jiwanger");
			System.out.println(mr2.getName());
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		/** 取得本类的全部属性 */
		Field[] field = clazz.getDeclaredFields();
        for (int i = 0; i &lt; field.length; i++) {
            // 权限修饰符
            int mo = field[i].getModifiers();
            String priv = Modifier.toString(mo);
            // 属性类型
            Class&lt;?> type = field[i].getType();
            System.out.println(priv + " " + type.getName() + " " + field[i].getName() + ";");
        }
        
        /** 获取某个类的全部方法 */
        Method method[] = clazz.getMethods();
        for (int i = 0; i &lt; method.length; ++i) {
            Class&lt;?> returnType = method[i].getReturnType();
            Class&lt;?> para[] = method[i].getParameterTypes();
            int temp = method[i].getModifiers();
            System.out.print(Modifier.toString(temp) + " ");
            System.out.print(returnType.getName() + "  ");
            System.out.print(method[i].getName() + " ");
            System.out.print("(");
            for (int j = 0; j &lt; para.length; ++j) {
                System.out.print(para[j].getName() + " " + "arg" + j);
                if (j &lt; para.length - 1) {
                    System.out.print(",");
                }
            }
            Class&lt;?> exce[] = method[i].getExceptionTypes();
            if (exce.length > 0) {
                System.out.print(") throws ");
                for (int k = 0; k &lt; exce.length; ++k) {
                    System.out.print(exce[k].getName() + " ");
                    if (k &lt; exce.length - 1) {
                        System.out.print(",");
                    }
                }
            } else {
                System.out.print(")");
            }
            System.out.println();
        }
        
        /** 反射机制调用某个类的方法 */
        try {
			Class&lt;?> myClass = Class.forName("cm.nate.reflect.MyReflect");
			// 调用TestReflect类中的reflect1方法
			
			// Java 反射机制 - 调用某个类的方法1.
			// 调用TestReflect的reflect2方法
			MyReflect mr3 = (MyReflect) myClass.newInstance();
			Method method2 = myClass.getMethod("setName", String.class);
			method2.invoke(mr3, "张三");
			
			Method method3 = myClass.getMethod("getName");
			String name = (String) method3.invoke(mr3);
			System.out.println(name);
			
		}  catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public MyReflect(){}
	
	public MyReflect(String name){
		this.name = name;
	}

	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

}
</pre>
							</div>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-annotation"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 id="java-docs" class="panel-title">Java 注解</h3>
					</div>
					<div class="panel-body">
						<p>Java注解是附加在代码中的一些元信息，用于编译和运行时进行解析和使用，起到说明、配置的功能。注解不会影响代码的实际逻辑，仅仅起到辅助性的作用。包含在java.lang.annotation包中。注解的定义类似于接口的定义，使用@interface来定义，定义一个方法即为注解类型定义了一个元素，方法的声明不允许有参数或throw语句，返回值类型被限定为原始数据类型、字符串String、Class、enums、注解类型，或前面这些的数组，方法可以有默认值。注解并不直接影响代码的语义，但是他可以被看做是程序的工具或者类库。它会反过来对正在运行的程序语义有所影响。注解可以从源文件、class文件或者在运行时通过反射机制多种方式被读取。</p>
						<p>Java元注解 -- 元注解是指注解的注解。包括 @Retention @Target @Document
							@Inherited四种。</p>
						<table class="table table-responsive table-striped table-bordered">
							<thead>
								<tr>
									<th>注解</th>
									<th>说明</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>@Target</td>
									<td>定义注解的作用目标</td>
								</tr>
								<tr>
									<td>@Retention</td>
									<td>定义注解的保留策略。RetentionPolicy.SOURCE:注解仅存在于源码中，在class字节码文件中不包含；RetentionPolicy.CLASS:默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得;RetentionPolicy.RUNTIME:注解会在class字节码文件中存在，在运行时可以通过反射获取到。</td>
								</tr>
								<tr>
									<td>@Document</td>
									<td>说明该注解将被包含在javadoc中</td>
								</tr>
								<tr>
									<td>@Inherited</td>
									<td>说明子类可以继承父类中的该注解</td>
								</tr>
							</tbody>
						</table>

						<table class="table table-responsive table-striped table-bordered">
							<thead>
								<tr>
									<th>Target类型</th>
									<th>说明</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>ElementType.TYPE</td>
									<td>接口、类、枚举、注解</td>
								</tr>
								<tr>
									<td>ElementType.FIELD</td>
									<td>字段、枚举的常量</td>
								</tr>
								<tr>
									<td>ElementType.METHOD</td>
									<td>方法</td>
								</tr>
								<tr>
									<td>ElementType.PARAMETER</td>
									<td>方法参数</td>
								</tr>
								<tr>
									<td>ElementType.CONSTRUCTOR</td>
									<td>构造函数</td>
								</tr>
								<tr>
									<td>ElementType.LOCAL_VARIABLE</td>
									<td>局部变量</td>
								</tr>
								<tr>
									<td>ElementType.ANNOTATION_TYPE</td>
									<td>注解</td>
								</tr>
								<tr>
									<td>ElementType.PACKAGE</td>
									<td>包</td>
								</tr>
							</tbody>
						</table>
						<p class="text-primary">example</p>
						<ol>
							<li>
								<p>定义: FruitColor, FruitName, FruitProvider 三个注解类</p>
								<pre class="brush: java;">
/** 水果颜色注解 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitColor {
	/** 颜色枚举 */
	public enum Color {
		BULE, RED, GREEN
	};

	/** 颜色属性 */
	Color fruitColor() default Color.GREEN;
}

/** 水果名称注解 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitName {
    String value() default "";
}

/** 水果供应者注解 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitProvider {
    /** 供应商编号 */
    public int id() default -1;
    
    /** 供应商名称 */
    public String name() default "";
    
    /** 供应商地址 */
    public String address() default "";
}
</pre>
							</li>
							<li>
								<p>注解使用: Apple</p>
								<pre class="brush: java;">
public class Apple {

	@FruitName("Apple")
	private String appleName;

	@FruitColor(fruitColor = Color.RED)
	private String appleColor;

	@FruitProvider(id = 1, name = "陕西红富士集团", address = "陕西省西安市延安路89号红富士大厦")
	private String appleProvider;

	public void setAppleColor(String appleColor) {
		this.appleColor = appleColor;
	}

	public String getAppleColor() {
		return appleColor;
	}

	public void setAppleName(String appleName) {
		this.appleName = appleName;
	}

	public String getAppleName() {
		return appleName;
	}

	public void setAppleProvider(String appleProvider) {
		this.appleProvider = appleProvider;
	}

	public String getAppleProvider() {
		return appleProvider;
	}

	public void displayName() {
		System.out.println("水果的名字是：苹果");
	}
}
</pre>
							</li>
							<li>
								<p>注解处理器: FruitInfoUtil</p>
								<pre class="brush: java;">
public class FruitInfoUtil {
	public static void getFruitInfo(Class<?> clazz) {

		String strFruitName = " 水果名称：";
		String strFruitColor = " 水果颜色：";
		String strFruitProvicer = "供应商信息：";

		Field[] fields = clazz.getDeclaredFields();

		for (Field field : fields) {
			if (field.isAnnotationPresent(FruitName.class)) {
				FruitName fruitName = (FruitName) field
						.getAnnotation(FruitName.class);
				strFruitName = strFruitName + fruitName.value();
				System.out.println(strFruitName);
			} else if (field.isAnnotationPresent(FruitColor.class)) {
				FruitColor fruitColor = (FruitColor) field
						.getAnnotation(FruitColor.class);
				strFruitColor = strFruitColor
						+ fruitColor.fruitColor().toString();
				System.out.println(strFruitColor);
			} else if (field.isAnnotationPresent(FruitProvider.class)) {
				FruitProvider fruitProvider = (FruitProvider) field
						.getAnnotation(FruitProvider.class);
				strFruitProvicer = " 供应商编号：" + fruitProvider.id() + " 供应商名称："
						+ fruitProvider.name() + " 供应商地址："
						+ fruitProvider.address();
				System.out.println(strFruitProvicer);
			}
		}
	}

	public static void main(String[] args) {
		getFruitInfo(Apple.class);
	}
}
</pre>
							</li>
						</ol>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 id="java-docs" class="panel-title">Java</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 id="java-docs" class="panel-title">Java</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushBash.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
