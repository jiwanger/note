<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--MODEL</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">MODEL</h3>
					</div>
					<div class="list-group">
						<a href="#" class="list-group-item">简介</a>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#model-creator"
							aria-expanded="true">
							创建型模式<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="model-creator" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#model-factory-method" class="list-group-item">工厂方法模式</a>
							<a href="#model-abstract-factory" class="list-group-item">抽象工厂模式</a>
							<a href="#model-builder" class="list-group-item">建造者模式</a>
							<a href="#model-singleton" class="list-group-item">单态模式</a>
							<a href="#model-prototype" class="list-group-item">原型模式</a>
						</div>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#model-construct"
							aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							结构型模式<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="model-construct" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#model-adapter" class="list-group-item">适配器模式</a>
							<a href="#model-bridge" class="list-group-item">桥接模式</a>
							<a href="#model-filter" class="list-group-item">过滤器模式</a>
							<a href="#model-composite " class="list-group-item">组合模式</a>
							<a href="#model-decorator" class="list-group-item">装饰模式</a>
							<a href="#model-facade " class="list-group-item">外观模式</a>
							<a href="#model-flyweight" class="list-group-item">享元模式</a>
							<a href="#model-proxy" class="list-group-item">代理模式</a>
						</div>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#model-action"
							aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							行为型模式<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="model-action" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#model-duty-link" class="list-group-item">责任链模式</a>
							<a href="#model-command" class="list-group-item">命令模式</a>
							<a href="#model-interpreter " class="list-group-item">解释器模式</a>
							<a href="#model-iterator" class="list-group-item">迭代器模式</a>
							<a href="#model-mediator" class="list-group-item">中介者模式</a>
							<a href="#model-memento" class="list-group-item">备忘录模式</a>
							<a href="#model-observer" class="list-group-item">观察者模式</a>
							<a href="#model-state" class="list-group-item">状态模式</a>
							<a href="#model-null" class="list-group-item">空对象模式</a>
							<a href="#model-strategy" class="list-group-item">策略模式</a>
							<a href="#model-template-method" class="list-group-item">模板方法模式</a>
							<a href="#model-visitor" class="list-group-item">访问者模式</a>
						</div>

						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#model-j2ee" aria-expanded="true"
							style="border-top: 1px solid #DDDDDD;">
							J2EE 模式<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="model-j2ee" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#model-mvc" class="list-group-item">MVC 模式</a>
							<a href="#model-business-delegate" class="list-group-item">业务代表模式</a>
							<a href="#model-composite-entity " class="list-group-item">组合实体模式</a>
							<a href="#model-data-access-object" class="list-group-item">数据访问对象模式</a>
							<a href="#model-front-controller" class="list-group-item">前端控制器模式</a>
							<a href="#model-intercepting-filter" class="list-group-item">拦截过滤器模式</a>
							<a href="#model-service-locator" class="list-group-item">服务定位器模式</a>
							<a href="#model-transfer-object" class="list-group-item">传输对象模式</a>
						</div>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<a class="offset" id="model-intro"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<p>设计模式（Design
							pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
						</p>
						<p>
							设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。
							毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。
						</p>
						<h4 class="text-primary">设计模式的六大原则</h4>
						<p>
							<span><strong>1、开闭原则（Open Close Principle）</strong></span>
						</p>
						<p>
							开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
						</p>
						<p>
							<span><strong>2、里氏代换原则（Liskov Substitution
									Principle）</strong></span>
						</p>
						<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP
							是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
						<p>
							<span><strong>3、依赖倒转原则（Dependence Inversion
									Principle）</strong></span>
						</p>
						<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
						<p>
							<span><strong>4、接口隔离原则（Interface Segregation
									Principle）</strong></span>
						</p>
						<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
						<p>
							<span><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></span>
						</p>
						<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
						<p>
							<span><strong>6、合成复用原则（Composite Reuse Principle）</strong></span>
						</p>
						<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
						<table class="table table-bordered table-condensed">
							<tbody>
								<tr>
									<th style="width: 5%;">序号</th>
									<th style="width: 45%;">模式 &amp; 描述</th>
									<th>包括</th>
								</tr>
								<tr>
									<td>1</td>
									<td><b>创建型模式</b><br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>
									<td>
										<ul>
											<li>工厂模式（Factory Pattern）</li>
											<li>抽象工厂模式（Abstract Factory Pattern）</li>
											<li>单例模式（Singleton Pattern）</li>
											<li>建造者模式（Builder Pattern）</li>
											<li>原型模式（Prototype Pattern）</li>
										</ul>
									</td>
								</tr>
								<tr>
									<td>2</td>
									<td><b>结构型模式</b><br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
									<td>
										<ul>
											<li>适配器模式（Adapter Pattern）</li>
											<li>桥接模式（Bridge Pattern）</li>
											<li>过滤器模式（Filter、Criteria Pattern）</li>
											<li>组合模式（Composite Pattern）</li>
											<li>装饰器模式（Decorator Pattern）</li>
											<li>外观模式（Facade Pattern）</li>
											<li>享元模式（Flyweight Pattern）</li>
											<li>代理模式（Proxy Pattern）</li>
										</ul>
									</td>
								</tr>
								<tr>
									<td>3</td>
									<td><b>行为型模式</b><br>这些设计模式特别关注对象之间的通信。</td>
									<td>
										<ul>
											<li>责任链模式（Chain of Responsibility Pattern）</li>
											<li>命令模式（Command Pattern）</li>
											<li>解释器模式（Interpreter Pattern）</li>
											<li>迭代器模式（Iterator Pattern）</li>
											<li>中介者模式（Mediator Pattern）</li>
											<li>备忘录模式（Memento Pattern）</li>
											<li>观察者模式（Observer Pattern）</li>
											<li>状态模式（State Pattern）</li>
											<li>空对象模式（Null Object Pattern）</li>
											<li>策略模式（Strategy Pattern）</li>
											<li>模板模式（Template Pattern）</li>
											<li>访问者模式（Visitor Pattern）</li>
										</ul>
									</td>
								</tr>
								<tr>
									<td>4</td>
									<td><b>J2EE 模式</b><br>这些设计模式特别关注表示层。这些模式是由 Sun Java
										Center 鉴定的。</td>
									<td>
										<ul>
											<li>MVC 模式（MVC Pattern）</li>
											<li>业务代表模式（Business Delegate Pattern）</li>
											<li>组合实体模式（Composite Entity Pattern）</li>
											<li>数据访问对象模式（Data Access Object Pattern）</li>
											<li>前端控制器模式（Front Controller Pattern）</li>
											<li>拦截过滤器模式（Intercepting Filter Pattern）</li>
											<li>服务定位器模式（Service Locator Pattern）</li>
											<li>传输对象模式（Transfer Object Pattern）</li>
										</ul>
									</td>
								</tr>
							</tbody>
						</table>
						<img src="images/java-design-patterns.jpg" class="img-responsive">
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-factory-method"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">工厂方法模式</h3>
					</div>
					<div class="panel-body">
						<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>当一个类不知道它所必须创建的对象的类的时候。</li>
							<li>当一个类希望由它的子类来指定它所创建的对象的时候。</li>
							<li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且类希望将哪一个帮助子类是代理者这一信息局部化的时候。</li>
						</ol>

						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>Product -- 定义工厂方法所创建的对象的接口。</li>
							<li>ConcreteProduct -- 实现 Product 接口。</li>
							<li>Creator -- 声明工厂方法，该方法返回一个 Product 类型的对象， Creator
								也可以定义一个工厂方法的缺省实现，它返回一个缺省的 ConcreteProduct 对象。可以调用工厂方法以创建一个
								Product 对象。</li>
							<li>ConcreteCreator -- 重定义工厂方法以返回一个 ConcreteProduct 实例。</li>
						</ol>

						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class Main {
	public static void main(String[] args) {
		Main context = new Main();
		IWorkFactory studentWorkFactory = context.new StudentWorkFactory();
		studentWorkFactory.getWork().doWork();

		IWorkFactory teacherWorkFactory = context.new TeacherWorkFactory();
		teacherWorkFactory.getWork().doWork();
	}

	/** Product */
    public interface Work {
        void doWork();
    }
 
    /** ConcreteProduct */
    public class StudentWork implements Work {
        public void doWork() {
            System.out.println("学生做作业!");
        }
    }
 
    /** ConcreteProduct */
    public class TeacherWork implements Work {
        public void doWork() {
            System.out.println("老师改作业!");
        }
    }
 
    /** Creator */
    public interface IWorkFactory {
        Work getWork();
    }
 
    /** ConcreteCreator */
    public class StudentWorkFactory implements IWorkFactory {
        public Work getWork() {
        	return new StudentWork();
        }
    }
 
    /** ConcreteCreator */
    public class TeacherWorkFactory implements IWorkFactory {
        public Work getWork() {
            return new TeacherWork();
        }
    }
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-abstract-factory"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">抽象工厂模式</h3>
					</div>
					<div class="panel-body">
						<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>一个系统要独立于它的产品的创建、组合和表示时。</li>
							<li>一个系统要由多个产品系列中的一个来配置时。</li>
							<li>当你要强调一系列相关的产品对象的设计以便进行联合使用时。</li>
							<li>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>AbstractFactory -- 声明一个创建抽象产品对象的操作接口。</li>
							<li>ConcreteFactory -- 实现创建具体产品对象的操作。</li>
							<li>AbstractProduct -- 为一类产品对象声明一个接口。</li>
							<li>ConcreteProduct -- 定义一个将被相应的具体工厂创建的产品对象。实现
								AbstractProduct 接口。</li>
							<li>Client -- 仅使用由 AbstractFactory 和 AbstractProduct 类声明的接口。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class AbstractFactory {
	public static void main(String[] args) {
		AbstractFactory context = new AbstractFactory();
		IAnimalFactory blackAnimalFactory = context.new BlackAnimalFactory();
		ICat blackCat = blackAnimalFactory.createCat();
		blackCat.eat();
		IDog blackDog = blackAnimalFactory.createDog();
		blackDog.eat();

		IAnimalFactory whiteAnimalFactory = context.new WhiteAnimalFactory();
		ICat whiteCat = whiteAnimalFactory.createCat();
		whiteCat.eat();
		IDog whiteDog = whiteAnimalFactory.createDog();
		whiteDog.eat();
	}

	/** AbstractFactory */
	public interface IAnimalFactory {
		ICat createCat();

		IDog createDog();
	}

	/** ConcreteFactory */
	public class BlackAnimalFactory implements IAnimalFactory {
		public ICat createCat() {
			return new BlackCat();
		}

		public IDog createDog() {
			return new BlackDog();
		}
	}

	/** ConcreteFactory */
	public class WhiteAnimalFactory implements IAnimalFactory {
		public ICat createCat() {
			return new WhiteCat();
		}

		public IDog createDog() {
			return new WhiteDog();
		}
	}

	/** AbstractProduct */
	public interface ICat {
		void eat();
	}

	/** AbstractProduct */
	public interface IDog {
		void eat();
	}

	/** Product */
	public class BlackCat implements ICat {
		public void eat() {
			System.out.println("The black cat is eating!");
		}
	}
	
	/** Product */
	public class WhiteCat implements ICat {
		public void eat() {
			System.out.println("The white cat is eating!");
		}
	}
	
	/** Product */
	public class BlackDog implements IDog {
		public void eat() {
			System.out.println("The black dog is eating");
		}
	}
	
	/** Product */
	public class WhiteDog implements IDog {
		public void eat() {
			System.out.println("The white dog is eating!");
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-builder"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">建造者模式</h3>
					</div>
					<div class="panel-body">
						<p>将一个复杂对象的构造与它的表示分离，使用同样的构建过程可以创建不同的表示。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
							<li>当构造过程必须允许被构造的对象有不同的表示时。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>Builder -- 为创建一个 Product 对象的各个部件指定抽象接口。</li>
							<li>ConcreteBuilder -- 实现 Builder
								的接口以构造和装配该产品的各个部件。定义并明确它所创建的表示的提供一个检索产品的接口。</li>
							<li>Director -- 构造一个使用 Builder 接口的对象。</li>
							<li>Product -- 表示被构造的复杂对象。ConcreteBuilder
								创建该产品的内部表示并定义它的装配过程。包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class Builder {
	public static void main(String[] args) {
		Builder context = new Builder();
		PersonDirector pd = context.new PersonDirector();
		Person person = pd.constructPerson(context.new ManBuilder());
		System.out.println(person.getBody());
		System.out.println(person.getFoot());
		System.out.println(person.getHead());
	}

	/** Builder */
	public interface PersonBuilder {
		void buildHead();

		void buildBody();

		void buildFoot();

		Person buildPerson();
	}

	/** ConcreteBuilder */
	public class ManBuilder implements PersonBuilder {
		Person person;

		public ManBuilder() {
			person = new Man();
		}

		public void buildBody() {
			person.setBody("建造男人的身体");
		}

		public void buildFoot() {
			person.setFoot("建造男人的脚");
		}

		public void buildHead() {
			person.setHead("建造男人的头");
		}

		public Person buildPerson() {
			return person;
		}
	}

	/** Director */
	public class PersonDirector {
		public Person constructPerson(PersonBuilder pb) {
			pb.buildHead();
			pb.buildBody();
			pb.buildFoot();
			return pb.buildPerson();
		}
	}

	public class Man extends Person {

	}

	/** Product */
	public class Person {
		private String head;
		private String body;
		private String foot;

		public String getHead() {
			return head;
		}

		public void setHead(String head) {
			this.head = head;
		}

		public String getBody() {
			return body;
		}

		public void setBody(String body) {
			this.body = body;
		}

		public String getFoot() {
			return foot;
		}

		public void setFoot(String foot) {
			this.foot = foot;
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-singleton"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">单例模式</h3>
					</div>
					<div class="panel-body">
						<p>保证一个类仅有一个实例，仅提供一个访问它的全局访问点。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li>
							<li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>Singleton --
								定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作。可能负责创建它自己的唯一实例。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class Singleton {
    private static Singleton sing;

    private Singleton() {}
    
    public static Singleton getInstance() {
        if (sing == null) {
            sing = new Singleton();
        }
        return sing;
    }
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-prototype"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">原型模式</h3>
					</div>
					<div class="panel-body">
						<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>当一个系统应该独立于它的产品创建、构成和表示时。</li>
							<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。</li>
							<li>为了避免创建一个与产品类层次平行的工厂层次时。</li>
							<li>当一个类的实例只能有几个不同状态组合中的一种时。</li>
							<li>建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>Prototype -- 声明一个克隆自身的接口。</li>
							<li>ConcretePrototype -- 实现一个克隆自身的操作。</li>
							<li>Client -- 让一个原型克隆自身从而创建一个新的对象。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class MyPrototype {
	public static void main(String[] args) {
		MyPrototype context = new MyPrototype();
		Prototype pro = context.new ConcretePrototype("prototype");
		Prototype pro2 = (Prototype) pro.clone();
		System.out.println(pro.getName());
		System.out.println(pro2.getName());
	}

	public class Prototype implements Cloneable {
		private String name;

		public void setName(String name) {
			this.name = name;
		}

		public String getName() {
			return this.name;
		}

		public Object clone() {
			try {
				return super.clone();
			} catch (Exception e) {
				e.printStackTrace();
				return null;
			}
		}
	}

	public class ConcretePrototype extends Prototype {
		public ConcretePrototype(String name) {
			setName(name);
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-adapter"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">适配器模式</h3>
					</div>
					<div class="panel-body">
						<p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口的兼容而不能一起工作的那些类可以一起工作。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li>
							<li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li>
							<li>（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>Target -- 定义Client使用的与特定领域相关的接口。</li>
							<li>Client -- 与符合Target接口的对象协同。</li>
							<li>Adaptee -- 定义一个已经存在的接口，这个接口需要适配。</li>
							<li>Adapter -- 对Adaptee的接口与Target接口进行适配。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class MyAdapter {
	public static void main(String[] args) {
		MyAdapter context = new MyAdapter();
		Target target = context.new Adapter(context.new Adaptee());
		target.adapteeMethod();

		target.adapterMethod();
	}

	/** Target */
	public interface Target {
		void adapteeMethod();

		void adapterMethod();
	}

	/** Adaptee */
	public class Adaptee {
		public void adapteeMethod() {
			System.out.println("Adaptee method!");
		}
	}

	/** Adapter */
	public class Adapter implements Target {
		private Adaptee adaptee;

		public Adapter(Adaptee adaptee) {
			this.adaptee = adaptee;
		}

		public void adapteeMethod() {
			adaptee.adapteeMethod();
		}

		public void adapterMethod() {
			System.out.println("Adapter method!");
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-bridge"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">桥接模式</h3>
					</div>
					<div class="panel-body">
						<p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
							<li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li>
							<li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>抽象和实现的分离。</li>
							<li>优秀的扩展能力。</li>
							<li>实现细节对客户透明。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ol>
							<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class MyBridge {
	public static void main(String[] args) {
		MyBridge context = new MyBridge();
		// 使用 Shape 和 DrawAPI 类画出不同颜色的圆
		Shape redCircle = context.new Circle(100, 100, 10,
				context.new RedCircle());
		Shape greenCircle = context.new Circle(100, 100, 10,
				context.new GreenCircle());

		redCircle.draw();
		greenCircle.draw();
	}

	/** 创建桥接实现接口 */
	public interface DrawAPI {
		public void drawCircle(int radius, int x, int y);
	}

	/** 创建实现了 DrawAPI 接口的实体桥接实现类 */
	public class RedCircle implements DrawAPI {
		@Override
		public void drawCircle(int radius, int x, int y) {
			System.out.println("Drawing Circle[ color: red, radius: " + radius
					+ ", x: " + x + ", " + y + "]");
		}
	}

	public class GreenCircle implements DrawAPI {
		@Override
		public void drawCircle(int radius, int x, int y) {
			System.out.println("Drawing Circle[ color: green, radius: "
					+ radius + ", x: " + x + ", " + y + "]");
		}
	}

	/** 使用 DrawAPI 接口创建抽象类 Shape */
	public abstract class Shape {
		protected DrawAPI drawAPI;

		protected Shape(DrawAPI drawAPI) {
			this.drawAPI = drawAPI;
		}

		public abstract void draw();
	}

	/** 创建实现了 Shape 接口的实体类 */
	public class Circle extends Shape {
		private int x, y, radius;

		public Circle(int x, int y, int radius, DrawAPI drawAPI) {
			super(drawAPI);
			this.x = x;
			this.y = y;
			this.radius = radius;
		}

		public void draw() {
			drawAPI.drawCircle(radius, x, y);
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-filter"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">过滤器模式</h3>
					</div>
					<div class="panel-body">
						<p>过滤器模式（Filter Pattern）或标准模式（Criteria
							Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。</p>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class MyFilter {
	public static void main(String[] args) {
		MyFilter context = new MyFilter();
		// 使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表
		List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();

		persons.add(context.new Person("Robert", "Male", "Single"));
		persons.add(context.new Person("John", "Male", "Married"));
		persons.add(context.new Person("Laura", "Female", "Married"));
		persons.add(context.new Person("Diana", "Female", "Single"));
		persons.add(context.new Person("Mike", "Male", "Single"));
		persons.add(context.new Person("Bobby", "Male", "Single"));

		Criteria male = context.new CriteriaMale();
		Criteria female = context.new CriteriaFemale();
		Criteria single = context.new CriteriaSingle();
		Criteria singleMale = context.new AndCriteria(single, male);
		Criteria singleOrFemale = context.new OrCriteria(single, female);

		System.out.println("Males: ");
		printPersons(male.meetCriteria(persons));

		System.out.println("\nFemales: ");
		printPersons(female.meetCriteria(persons));

		System.out.println("\nSingle Males: ");
		printPersons(singleMale.meetCriteria(persons));

		System.out.println("\nSingle Or Females: ");
		printPersons(singleOrFemale.meetCriteria(persons));
	}

	public static void printPersons(List&lt;Person&gt; persons) {
		for (Person person : persons) {
			System.out.println("Person : [ Name : " + person.getName()
					+ ", Gender : " + person.getGender()
					+ ", Marital Status : " + person.getMaritalStatus() + " ]");
		}
	}

	/** 创建一个类，在该类上应用标准 */
	public class Person {
		private String name;
		private String gender;
		private String maritalStatus;

		public Person(String name, String gender, String maritalStatus) {
			this.name = name;
			this.gender = gender;
			this.maritalStatus = maritalStatus;
		}

		public String getName() {
			return name;
		}

		public String getGender() {
			return gender;
		}

		public String getMaritalStatus() {
			return maritalStatus;
		}
	}

	/** 为标准（Criteria）创建一个接口 */
	public interface Criteria {
		public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);
	}

	/** 创建实现了 Criteria 接口的实体类 */
	public class CriteriaMale implements Criteria {

		@Override
		public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
			List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;();
			for (Person person : persons) {
				if (person.getGender().equalsIgnoreCase("MALE")) {
					malePersons.add(person);
				}
			}
			return malePersons;
		}
	}

	public class CriteriaFemale implements Criteria {

		@Override
		public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
			List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;();
			for (Person person : persons) {
				if (person.getGender().equalsIgnoreCase("FEMALE")) {
					femalePersons.add(person);
				}
			}
			return femalePersons;
		}
	}

	public class CriteriaSingle implements Criteria {

		@Override
		public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
			List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;();
			for (Person person : persons) {
				if (person.getMaritalStatus().equalsIgnoreCase("SINGLE")) {
					singlePersons.add(person);
				}
			}
			return singlePersons;
		}
	}

	public class AndCriteria implements Criteria {

		private Criteria criteria;
		private Criteria otherCriteria;

		public AndCriteria(Criteria criteria, Criteria otherCriteria) {
			this.criteria = criteria;
			this.otherCriteria = otherCriteria;
		}

		@Override
		public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
			List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);
			return otherCriteria.meetCriteria(firstCriteriaPersons);
		}
	}

	public class OrCriteria implements Criteria {

		private Criteria criteria;
		private Criteria otherCriteria;

		public OrCriteria(Criteria criteria, Criteria otherCriteria) {
			this.criteria = criteria;
			this.otherCriteria = otherCriteria;
		}

		@Override
		public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
			List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);
			List&lt;Person&gt; otherCriteriaItems = otherCriteria
					.meetCriteria(persons);

			for (Person person : otherCriteriaItems) {
				if (!firstCriteriaItems.contains(person)) {
					firstCriteriaItems.add(person);
				}
			}
			return firstCriteriaItems;
		}
	}

}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-composite"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">组合模式</h3>
					</div>
					<div class="panel-body">
						<p>组合模式（Composite
							Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。
						</p>
						<p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>您想表示对象的部分-整体层次结构（树形结构）。</li>
							<li>您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>高层模块调用简单。</li>
							<li>节点自由增加。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class MyComposite {
	public static void main(String[] args) {
		MyComposite context = new MyComposite();
		
		/** 使用 Employee 类来创建和打印员工的层次结构 */
		Employee CEO = context.new Employee("John", "CEO", 30000);

		Employee headSales = context.new Employee("Robert", "Head Sales", 20000);

		Employee headMarketing = context.new Employee("Michel", "Head Marketing",
				20000);

		Employee clerk1 = context.new Employee("Laura", "Marketing", 10000);
		Employee clerk2 = context.new Employee("Bob", "Marketing", 10000);

		Employee salesExecutive1 = context.new Employee("Richard", "Sales", 10000);
		Employee salesExecutive2 = context.new Employee("Rob", "Sales", 10000);

		CEO.add(headSales);
		CEO.add(headMarketing);

		headSales.add(salesExecutive1);
		headSales.add(salesExecutive2);

		headMarketing.add(clerk1);
		headMarketing.add(clerk2);

		// 打印该组织的所有员工
		System.out.println(CEO);
		for (Employee headEmployee : CEO.getSubordinates()) {
			System.out.println(headEmployee);
			for (Employee employee : headEmployee.getSubordinates()) {
				System.out.println(employee);
			}
		}
	}

	/** 创建 Employee 类，该类带有 Employee 对象的列表 */
	public class Employee {
		private String name;
		private String dept;
		private int salary;
		private List&lt;Employee&gt; subordinates;

		// 构造函数
		public Employee(String name, String dept, int sal) {
			this.name = name;
			this.dept = dept;
			this.salary = sal;
			subordinates = new ArrayList&lt;Employee&gt;();
		}

		public void add(Employee e) {
			subordinates.add(e);
		}

		public void remove(Employee e) {
			subordinates.remove(e);
		}

		public List&lt;Employee&gt; getSubordinates() {
			return subordinates;
		}

		public String toString() {
			return ("Employee :[ Name : " + name + ", dept : " + dept
					+ ", salary :" + salary + " ]");
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-decorator"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">装饰模式</h3>
					</div>
					<div class="panel-body">
						<p>装饰器模式（Decorator
							Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。
						</p>
						<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
						</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>Component 类充当抽象角色，不应该具体实现。</li>
							<li>修饰类引用和继承 Component 类，具体扩展类重写父类方法。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle-circle"></span>优点:
						</h5>
						<ul>
							<li>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>多层装饰比较复杂。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public static void main(String[] args) {
		MyDecorator context = new MyDecorator();
		// 使用 RedShapeDecorator 来装饰 Shape 对象
		Shape circle = context.new Circle();

		Shape redCircle = context.new RedShapeDecorator(context.new Circle());

		Shape redRectangle = context.new RedShapeDecorator(context.new Rectangle());
		System.out.println("Circle with normal border");
		circle.draw();

		System.out.println("\nCircle of red border");
		redCircle.draw();

		System.out.println("\nRectangle of red border");
		redRectangle.draw();
	}

	/** 创建一个接口 */
	public interface Shape {
		void draw();
	}

	/** 创建实现接口的实体类 */
	public class Rectangle implements Shape {
		@Override
		public void draw() {
			System.out.println("Shape: Rectangle");
		}
	}

	public class Circle implements Shape {
		@Override
		public void draw() {
			System.out.println("Shape: Circle");
		}
	}

	/** 创建实现了 Shape 接口的抽象装饰类 */
	public abstract class ShapeDecorator implements Shape {
		protected Shape decoratedShape;

		public ShapeDecorator(Shape decoratedShape) {
			this.decoratedShape = decoratedShape;
		}

		public void draw() {
			decoratedShape.draw();
		}
	}

	/** 创建扩展了 ShapeDecorator 类的实体装饰 */
	public class RedShapeDecorator extends ShapeDecorator {
		public RedShapeDecorator(Shape decoratedShape) {
			super(decoratedShape);
		}

		@Override
		public void draw() {
			decoratedShape.draw();
			setRedBorder(decoratedShape);
		}

		private void setRedBorder(Shape decoratedShape) {
			System.out.println("Border Color: Red");
		}
	}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-facade"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">外观模式</h3>
					</div>
					<div class="panel-body">
						<p>外观模式（Facade
							Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>为复杂的模块或子系统提供外界访问的模块。</li>
							<li>客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>减少系统相互依赖。</li>
							<li>提高灵活性。</li>
							<li>提高了安全性。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class MyFacade {

	public static void main(String[] args) {
		// 使用该外观类画出各种类型的形状
		ShapeMaker shapeMaker = new MyFacade().new ShapeMaker();

		shapeMaker.drawCircle();
		shapeMaker.drawRectangle();
		shapeMaker.drawSquare();
	}

	/** 创建一个接口 */
	public interface Shape {
		void draw();
	}

	/** 创建实现接口的实体类 */
	public class Rectangle implements Shape {

		@Override
		public void draw() {
			System.out.println("Rectangle::draw()");
		}
	}

	public class Square implements Shape {

		@Override
		public void draw() {
			System.out.println("Square::draw()");
		}
	}

	public class Circle implements Shape {

		@Override
		public void draw() {
			System.out.println("Circle::draw()");
		}
	}

	/** 创建一个外观类 */
	public class ShapeMaker {
		private Shape circle;
		private Shape rectangle;
		private Shape square;

		public ShapeMaker() {
			circle = new Circle();
			rectangle = new Rectangle();
			square = new Square();
		}

		public void drawCircle() {
			circle.draw();
		}

		public void drawRectangle() {
			rectangle.draw();
		}

		public void drawSquare() {
			square.draw();
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-flyweight"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">享元模式</h3>
					</div>
					<div class="panel-body">
						<p>享元模式（Flyweight
							Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>系统中有大量对象。</li>
							<li>这些对象消耗大量内存。</li>
							<li>这些对象的状态大部分可以外部化。</li>
							<li>这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。</li>
							<li>系统不依赖于这些对象身份，这些对象是不可分辨的。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ul>
							<li>大大减少对象的创建，降低系统的内存，使效率提高。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>提高了系统的负责度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class MyFlyweight {
	private static final String colors[] = { "Red", "Green", "Blue", "White",
			"Black" };

	public static void main(String[] args) {
		// 使用该工厂，通过传递颜色信息来获取实体类的对象
		for (int i = 0; i < 20; ++i) {
			Circle circle = (Circle) ShapeFactory.getCircle(getRandomColor());
			circle.setX(getRandomX());
			circle.setY(getRandomY());
			circle.setRadius(100);
			circle.draw();
		}
	}

	private static String getRandomColor() {
		return colors[(int) (Math.random() * colors.length)];
	}

	private static int getRandomX() {
		return (int) (Math.random() * 100);
	}

	private static int getRandomY() {
		return (int) (Math.random() * 100);
	}

	/** 创建一个接口 */
	public interface Shape {
		void draw();
	}

}

/** 创建实现接口的实体类 */
class Circle implements Shape {
	private String color;
	private int x;
	private int y;
	private int radius;

	public Circle(String color) {
		this.color = color;
	}

	public void setX(int x) {
		this.x = x;
	}

	public void setY(int y) {
		this.y = y;
	}

	public void setRadius(int radius) {
		this.radius = radius;
	}

	@Override
	public void draw() {
		System.out.println("Circle: Draw() [Color : " + color + ", x : " + x
				+ ", y :" + y + ", radius :" + radius);
	}
}

/** 创建一个工厂，生成基于给定信息的实体类的对象 */
class ShapeFactory {
	private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap();

	public static Shape getCircle(String color) {
		Circle circle = (Circle) circleMap.get(color);

		if (circle == null) {
			circle = new Circle(color);
			circleMap.put(color, circle);
			System.out.println("Creating circle of color : " + color);
		}
		return circle;
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-proxy"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">代理模式</h3>
					</div>
					<div class="panel-body">
						<p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
						<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>想在访问一个类时做一些控制。</li>
							<li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li>
							<li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>职责清晰。</li>
							<li>高扩展性。</li>
							<li>智能化。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li>
							<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class MyProxy {
	public static void main(String[] args) {
		// 当被请求时，使用 ProxyImage 来获取 RealImage 类的对象
		Image image = new MyProxy().new ProxyImage("test_10mb.jpg");

		// 图像将从磁盘加载
		image.display();
		System.out.println("");
		// 图像将无法从磁盘加载
		image.display();
	}

	/** 创建一个接口 */
	public interface Image {
		void display();
	}

	/** 创建实现接口的实体类 */
	public class RealImage implements Image {

		private String fileName;

		public RealImage(String fileName) {
			this.fileName = fileName;
			loadFromDisk(fileName);
		}

		@Override
		public void display() {
			System.out.println("Displaying " + fileName);
		}

		private void loadFromDisk(String fileName) {
			System.out.println("Loading " + fileName);
		}
	}

	public class ProxyImage implements Image {

		private RealImage realImage;
		private String fileName;

		public ProxyImage(String fileName) {
			this.fileName = fileName;
		}

		@Override
		public void display() {
			if (realImage == null) {
				realImage = new RealImage(fileName);
			}
			realImage.display();
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-duty-link"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">责任链模式</h3>
					</div>
					<div class="panel-body">
						<p>顾名思义，责任链模式（Chain of Responsibility
							Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。</li>
							<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li>
							<li>可动态指定一组对象处理请求。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>降低耦合度。它将请求的发送者和接收者解耦。</li>
							<li>简化了对象。使得对象不需要知道链的结构。</li>
							<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</li>
							<li>增加新的请求处理类很方便。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>不能保证请求一定被接收。</li>
							<li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。</li>
							<li>可能不容易观察运行时的特征，有碍于除错。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-command"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">命令模式</h3>
					</div>
					<div class="panel-body">
						<p>命令模式（Command
							Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
						</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ul>
							<li>在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ul>
							<li>降低了系统耦合度。</li>
							<li>新的命令可以很容易添加到系统中去。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>使用命令模式可能会导致某些系统有过多的具体命令类。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-interpreter"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">解释器模式</h3>
					</div>
					<div class="panel-body">
						<p>解释器模式（Interpreter
							Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在
							SQL 解析、符号处理引擎等。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</li>
							<li>一些重复出现的问题可以用一种简单的语言来进行表达。</li>
							<li>一个简单语法需要解释的场景。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>可扩展性比较好，灵活。</li>
							<li>增加了新的解释表达式的方式。</li>
							<li>易于实现简单文法。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>可利用场景比较少。</li>
							<li>对于复杂的文法比较难维护。</li>
							<li>解释器模式会引起类膨胀。</li>
							<li>解释器模式采用递归调用方法。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-iterator"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">迭代器模式</h3>
					</div>
					<div class="panel-body">
						<p>迭代器模式（Iterator Pattern）是 Java 和 .Net
							编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>访问一个聚合对象的内容而无须暴露它的内部表示。</li>
							<li>需要为聚合对象提供多种遍历方式。</li>
							<li>为遍历不同的聚合结构提供一个统一的接口。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>它支持以不同的方式遍历一个聚合对象。</li>
							<li>迭代器简化了聚合类。</li>
							<li>在同一个聚合上可以有多个遍历。</li>
							<li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-mediator"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">中介者模式</h3>
					</div>
					<div class="panel-body">
						<p>中介者模式（Mediator
							Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。</li>
							<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>降低了类的复杂度，将一对多转化成了一对一。</li>
							<li>各个类之间的解耦。</li>
							<li>符合迪米特原则。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>中介者会庞大，变得复杂难以维护。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-memento"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">备忘录模式</h3>
					</div>
					<div class="panel-body">
						<p>备忘录模式（Memento
							Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>需要保存/恢复数据的相关状态场景。</li>
							<li>提供一个可回滚的操作。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。</li>
							<li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-observer"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">观察者模式</h3>
					</div>
					<div class="panel-body">
						<p>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>当一个抽象模型有两个方面,其中一个方面依赖于另一方面。将这二者封装为独立的对象中以使它们可以各自独立地改变和复用。</li>
							<li>当对一个对象的改变需要同时改变其它对象,而不知道具体有多少对象有待改变。</li>
							<li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>观察者和被观察者是抽象耦合的。</li>
							<li>建立一套触发机制。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
							<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
							<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>Subject -- 目标知道它的观察者。可以有任意多个观察者观察同一个目标。提供注册和删除观察者对象的接口。</li>
							<li>Obserser -- 为那些在目标发生改变时需获得通知的对象定义一个更新接口。</li>
							<li>ConcreteSubject --
								将有关状态存入各ConcreteObserver对象。当它的状态发生改变时,向它的各个观察者发出通知。</li>
							<li>ConcreteObserver --
								维护一个指向ConcreteSubject对象的引用。存储有关状态，这些状态应与目标的状态保持一致。实现Observer的更新接口，使自身状态与目标的状态保持一致。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-state"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">状态模式</h3>
					</div>
					<div class="panel-body">
						<p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。</p>
						<p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>行为随状态改变而改变的场景。</li>
							<li>条件、分支语句的代替者。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>封装了转换规则。</li>
							<li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li>
							<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li>
							<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li>
							<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>状态模式的使用必然会增加系统类和对象的个数。</li>
							<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
							<li>状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。
							</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-null"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">空对象模式</h3>
					</div>
					<div class="panel-body">
						<p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null
							对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。</p>
						<p>
							在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。</p>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-strategy"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">策略模式</h3>
					</div>
					<div class="panel-body">
						<p>在策略模式（Strategy
							Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
						<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变
							context 对象的执行算法。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
							<li>一个系统需要动态地在几种算法中选择一种。</li>
							<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>算法可以自由切换。</li>
							<li>避免使用多重条件判断。</li>
							<li>扩展性良好。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>策略类会增多。</li>
							<li>所有策略类都需要对外暴露。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-template-method"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">模板方法模式</h3>
					</div>
					<div class="panel-body">
						<p>在模板模式（Template
							Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>有多个子类共有的方法，且逻辑相同。</li>
							<li>重要的、复杂的方法，可以考虑作为模板方法。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>封装不变部分，扩展可变部分。</li>
							<li>提取公共代码，便于维护。</li>
							<li>行为由父类控制，子类实现。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-visitor"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">访问者模式</h3>
					</div>
					<div class="panel-body">
						<p>在访问者模式（Visitor
							Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</li>
							<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li>符合单一职责原则。</li>
							<li>优秀的扩展性。</li>
							<li>灵活性。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li>具体元素对访问者公布细节，违反了迪米特原则。</li>
							<li>具体元素变更比较困难。</li>
							<li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-mvc"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">MVC 模式</h3>
					</div>
					<div class="panel-body">
						<p>MVC 模式代表 Model-View-Controller（模型-视图-控制器）
							模式。这种模式用于应用程序的分层开发。</p>
						<ul>
							<li>
								<b>Model（模型）</b> - 模型代表一个存取数据的对象或 JAVA
								POJO。它也可以带有逻辑，在数据变化时更新控制器。
							</li>
							<li>
								<b>View（视图）</b> - 视图代表模型包含的数据的可视化。
							</li>
							<li>
								<b>Controller（控制器）</b> -
								控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。
							</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class MyMVC {
	static MyMVC context = new MyMVC();

	public static void main(String[] args) {
		// 使用 StudentController 方法来演示 MVC 设计模式的用法

		// 从数据可获取学生记录
		Student model = retriveStudentFromDatabase();

		// 创建一个视图：把学生详细信息输出到控制台
		StudentView view = context.new StudentView();

		StudentController controller = context.new StudentController(model, view);

		controller.updateView();

		// 更新模型数据
		controller.setStudentName("John");

		controller.updateView();
	}

	private static Student retriveStudentFromDatabase() {
		Student student = context.new Student();
		student.setName("Robert");
		student.setRollNo("10");
		return student;
	}

	/** 创建模型 */
	public class Student {
		private String rollNo;
		private String name;

		public String getRollNo() {
			return rollNo;
		}

		public void setRollNo(String rollNo) {
			this.rollNo = rollNo;
		}

		public String getName() {
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}
	}

	/** 创建视图 */
	public class StudentView {
		public void printStudentDetails(String studentName, String studentRollNo) {
			System.out.println("Student: ");
			System.out.println("Name: " + studentName);
			System.out.println("Roll No: " + studentRollNo);
		}
	}

	/** 创建控制器 */
	public class StudentController {
		private Student model;
		private StudentView view;

		public StudentController(Student model, StudentView view) {
			this.model = model;
			this.view = view;
		}

		public void setStudentName(String name) {
			model.setName(name);
		}

		public String getStudentName() {
			return model.getName();
		}

		public void setStudentRollNo(String rollNo) {
			model.setRollNo(rollNo);
		}

		public String getStudentRollNo() {
			return model.getRollNo();
		}

		public void updateView() {
			view.printStudentDetails(model.getName(), model.getRollNo());
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-business-delegate"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">业务代表模式</h3>
					</div>
					<div class="panel-body">

						<p>业务代表模式（Business Delegate
							Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。</p>
						<ul>
							<li>
								<b>客户端（Client）</b> - 表示层代码可以是 JSP、servlet 或 UI java 代码。
							</li>
							<li>
								<b>业务代表（Business Delegate）</b> - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。
							</li>
							<li>
								<b>查询服务（LookUp Service）</b> -
								查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。
							</li>
							<li>
								<b>业务服务（Business Service）</b> -
								业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。
							</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-composite-entity"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">组合实体模式</h3>
					</div>
					<div class="panel-body">
						<p>组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB
							实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean
							管理的。以下是组合实体 bean 的参与者。</p>
						<ul>
							<li>
								<b>组合实体（Composite Entity）</b> - 它是主要的实体
								bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。
							</li>
							<li>
								<b>粗粒度对象（Coarse-Grained Object）</b> -
								该对象包含以来对象。它有自己的生命周期，也能管理依赖对象的生命周期。
							</li>
							<li>
								<b>依赖对象（Dependent Object）</b> - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。
							</li>
							<li>
								<b>策略（Strategies）</b> - 策略表示如何实现组合实体。
							</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li></li>
							<li></li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-ok-circle"></span>优点:
						</h5>
						<ol>
							<li></li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-remove-circle"></span>缺点:
						</h5>
						<ul>
							<li></li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-data-access-object"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">数据访问对象模式</h3>
					</div>
					<div class="panel-body">
						<p>数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API
							或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。</p>
						<ul>
							<li>
								<b>数据访问对象接口（Data Access Object Interface）</b> -
								该接口定义了在一个模型对象上要执行的标准操作。
							</li>
							<li>
								<b>数据访问对象实体类（Data Access Object concrete class）</b> -
								该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。
							</li>
							<li>
								<b>模型对象/数值对象（Model Object/Value Object）</b> - 该对象是简单的 POJO，包含了
								get/set 方法来存储通过使用 DAO 类检索到的数据。
							</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-front-controller"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">前端控制器模式</h3>
					</div>
					<div class="panel-body">
						<p>前端控制器模式（Front Controller
							Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。</p>
						<ul>
							<li>
								<b>前端控制器（Front Controller）</b> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于
								web 的应用程序，也可以是基于桌面的应用程序。
							</li>
							<li>
								<b>调度器（Dispatcher）</b> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。
							</li>
							<li>
								<b>视图（View）</b> - 视图是为请求而创建的对象。
							</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-intercepting-filter"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">拦截过滤器模式</h3>
					</div>
					<div class="panel-body">
						<p>拦截过滤器模式（Intercepting Filter
							Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。</p>
						<ul>
							<li>
								<b>过滤器（Filter）</b> - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。
							</li>
							<li>
								<b>过滤器链（Filter Chain）</b> - 过滤器链带有多个过滤器，并在 Target
								上按照定义的顺序执行这些过滤器。
							</li>
							<li>
								<b>Target</b> - Target 对象是请求处理程序。
							</li>
							<li>
								<b>过滤管理器（Filter Manager）</b> - 过滤管理器管理过滤器和过滤器链。
							</li>
							<li>
								<b>客户端（Client）</b> - Client 是向 Target 对象发送请求的对象。
							</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-service-locator"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">服务定位器模式</h3>
					</div>
					<div class="panel-body">
						<p>服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI
							查询定位各种服务的时候。考虑到为某个服务查找 JNDI
							的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI
							中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。</p>
						<ul>
							<li>
								<b>服务（Service）</b> - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。
							</li>
							<li>
								<b>Context / 初始的 Context</b> - JNDI Context 带有对要查找的服务的引用。
							</li>
							<li>
								<b>服务定位器（Service Locator）</b> - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。
							</li>
							<li>
								<b>缓存（Cache）</b> - 缓存存储服务的引用，以便复用它们。
							</li>
							<li>
								<b>客户端（Client）</b> - Client 是通过 ServiceLocator 调用服务的对象。
							</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-transfer-object"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">传输对象模式</h3>
					</div>
					<div class="panel-body">
						<p>传输对象模式（Transfer Object
							Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有
							getter/setter 方法的简单的 POJO
							类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充
							POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。</p>
						<ul>
							<li>
								<b>业务对象（Business Object）</b> - 为传输对象填充数据的业务服务。
							</li>
							<li>
								<b>传输对象（Transfer Object）</b> - 简单的 POJO，只有设置/获取属性的方法。
							</li>
							<li>
								<b>客户端（Client）</b> - 客户端可以发送请求或者发送传输对象到业务对象。
							</li>
						</ul>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
