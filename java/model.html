<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--MODEL</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					style="position: fixed; top: 70px; width: 260px; height: 85%; overflow: auto; float: left;">
					<div class="panel-heading">
						<h3 class="panel-title">MODEL</h3>
					</div>
					<div class="list-group">
						<a href="#" class="list-group-item">简介</a>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#model-creator"
							aria-expanded="true">
							创建型模式<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="model-creator" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#model-factory-method" class="list-group-item">工厂方法模式</a>
							<a href="#model-abstract-factory" class="list-group-item">抽象工厂模式</a>
							<a href="#model-builder" class="list-group-item">建造者模式</a>
							<a href="#model-singleton" class="list-group-item">单态模式</a>
							<a href="#model-prototype" class="list-group-item">原型模式</a>
						</div>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#model-construct"
							aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							结构型模式<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="model-construct" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#model-adapter" class="list-group-item">适配器模式</a>
							<a href="#model-bridge" class="list-group-item">桥接模式</a>
							<a href="#model-group" class="list-group-item">组合模式</a>
							<a href="#model-embellish" class="list-group-item">装饰模式</a>
							<a href="#model-surface" class="list-group-item">外观模式</a>
							<a href="#model-flyweight" class="list-group-item">享元模式</a>
							<a href="#model-proxy" class="list-group-item">代理模式</a>
						</div>
						<a class="list-group-item active dropup" data-toggle="collapse"
							data-parent="#accordion" href="#model-action"
							aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							行为型模式<span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="model-action" class="panel-collapse collapse in"
							role="tabpanel">
							<a href="#model-duty-link" class="list-group-item">责任链模式</a>
							<a href="#model-command" class="list-group-item">命令模式</a>
							<a href="#model-explain" class="list-group-item">解释器模式</a>
							<a href="#model-itoractor" class="list-group-item">迭代器模式</a>
							<a href="#model-medium" class="list-group-item">中介者模式</a>
							<a href="#model-memoir" class="list-group-item">备忘录模式</a>
							<a href="#model-observe" class="list-group-item">观察者模式</a>
							<a href="#model-state" class="list-group-item">状态模式</a>
							<a href="#model-strategy" class="list-group-item">策略模式</a>
							<a href="#model-model-method" class="list-group-item">模板方法模式</a>
							<a href="#model-visitor" class="list-group-item">访问者模式</a>
						</div>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<a class="offset" id="model-intro"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body"></div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-factory-method"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">工厂方法模式</h3>
					</div>
					<div class="panel-body">
						<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>当一个类不知道它所必须创建的对象的类的时候。</li>
							<li>当一个类希望由它的子类来指定它所创建的对象的时候。</li>
							<li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且类希望将哪一个帮助子类是代理者这一信息局部化的时候。</li>
						</ol>

						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>Product -- 定义工厂方法所创建的对象的接口。</li>
							<li>ConcreteProduct -- 实现 Product 接口。</li>
							<li>Creator -- 声明工厂方法，该方法返回一个 Product 类型的对象， Creator
								也可以定义一个工厂方法的缺省实现，它返回一个缺省的 ConcreteProduct 对象。可以调用工厂方法以创建一个
								Product 对象。</li>
							<li>ConcreteCreator -- 重定义工厂方法以返回一个 ConcreteProduct 实例。</li>
						</ol>

						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class Main {
	public static void main(String[] args) {
		Main context = new Main();
		IWorkFactory studentWorkFactory = context.new StudentWorkFactory();
		studentWorkFactory.getWork().doWork();

		IWorkFactory teacherWorkFactory = context.new TeacherWorkFactory();
		teacherWorkFactory.getWork().doWork();
	}

	/** Product */
    public interface Work {
        void doWork();
    }
 
    /** ConcreteProduct */
    public class StudentWork implements Work {
        public void doWork() {
            System.out.println("学生做作业!");
        }
    }
 
    /** ConcreteProduct */
    public class TeacherWork implements Work {
        public void doWork() {
            System.out.println("老师改作业!");
        }
    }
 
    /** Creator */
    public interface IWorkFactory {
        Work getWork();
    }
 
    /** ConcreteCreator */
    public class StudentWorkFactory implements IWorkFactory {
        public Work getWork() {
        	return new StudentWork();
        }
    }
 
    /** ConcreteCreator */
    public class TeacherWorkFactory implements IWorkFactory {
        public Work getWork() {
            return new TeacherWork();
        }
    }
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-abstract-factory"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">抽象工厂模式</h3>
					</div>
					<div class="panel-body">
						<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>一个系统要独立于它的产品的创建、组合和表示时。</li>
							<li>一个系统要由多个产品系列中的一个来配置时。</li>
							<li>当你要强调一系列相关的产品对象的设计以便进行联合使用时。</li>
							<li>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>AbstractFactory -- 声明一个创建抽象产品对象的操作接口。</li>
							<li>ConcreteFactory -- 实现创建具体产品对象的操作。</li>
							<li>AbstractProduct -- 为一类产品对象声明一个接口。</li>
							<li>ConcreteProduct -- 定义一个将被相应的具体工厂创建的产品对象。实现
								AbstractProduct 接口。</li>
							<li>Client -- 仅使用由 AbstractFactory 和 AbstractProduct 类声明的接口。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class AbstractFactory {
	public static void main(String[] args) {
		AbstractFactory context = new AbstractFactory();
		IAnimalFactory blackAnimalFactory = context.new BlackAnimalFactory();
		ICat blackCat = blackAnimalFactory.createCat();
		blackCat.eat();
		IDog blackDog = blackAnimalFactory.createDog();
		blackDog.eat();

		IAnimalFactory whiteAnimalFactory = context.new WhiteAnimalFactory();
		ICat whiteCat = whiteAnimalFactory.createCat();
		whiteCat.eat();
		IDog whiteDog = whiteAnimalFactory.createDog();
		whiteDog.eat();
	}

	/** AbstractFactory */
	public interface IAnimalFactory {
		ICat createCat();

		IDog createDog();
	}

	/** ConcreteFactory */
	public class BlackAnimalFactory implements IAnimalFactory {
		public ICat createCat() {
			return new BlackCat();
		}

		public IDog createDog() {
			return new BlackDog();
		}
	}

	/** ConcreteFactory */
	public class WhiteAnimalFactory implements IAnimalFactory {
		public ICat createCat() {
			return new WhiteCat();
		}

		public IDog createDog() {
			return new WhiteDog();
		}
	}

	/** AbstractProduct */
	public interface ICat {
		void eat();
	}

	/** AbstractProduct */
	public interface IDog {
		void eat();
	}

	/** Product */
	public class BlackCat implements ICat {
		public void eat() {
			System.out.println("The black cat is eating!");
		}
	}
	
	/** Product */
	public class WhiteCat implements ICat {
		public void eat() {
			System.out.println("The white cat is eating!");
		}
	}
	
	/** Product */
	public class BlackDog implements IDog {
		public void eat() {
			System.out.println("The black dog is eating");
		}
	}
	
	/** Product */
	public class WhiteDog implements IDog {
		public void eat() {
			System.out.println("The white dog is eating!");
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-builder"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">建造者模式</h3>
					</div>
					<div class="panel-body">
						<p>将一个复杂对象的构造与它的表示分离，使用同样的构建过程可以创建不同的表示。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
							<li>当构造过程必须允许被构造的对象有不同的表示时。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>Builder -- 为创建一个 Product 对象的各个部件指定抽象接口。</li>
							<li>ConcreteBuilder -- 实现 Builder
								的接口以构造和装配该产品的各个部件。定义并明确它所创建的表示的提供一个检索产品的接口。</li>
							<li>Director -- 构造一个使用 Builder 接口的对象。</li>
							<li>Product -- 表示被构造的复杂对象。ConcreteBuilder
								创建该产品的内部表示并定义它的装配过程。包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class Builder {
	public static void main(String[] args) {
		Builder context = new Builder();
		PersonDirector pd = context.new PersonDirector();
		Person person = pd.constructPerson(context.new ManBuilder());
		System.out.println(person.getBody());
		System.out.println(person.getFoot());
		System.out.println(person.getHead());
	}

	/** Builder */
	public interface PersonBuilder {
		void buildHead();

		void buildBody();

		void buildFoot();

		Person buildPerson();
	}

	/** ConcreteBuilder */
	public class ManBuilder implements PersonBuilder {
		Person person;

		public ManBuilder() {
			person = new Man();
		}

		public void buildBody() {
			person.setBody("建造男人的身体");
		}

		public void buildFoot() {
			person.setFoot("建造男人的脚");
		}

		public void buildHead() {
			person.setHead("建造男人的头");
		}

		public Person buildPerson() {
			return person;
		}
	}

	/** Director */
	public class PersonDirector {
		public Person constructPerson(PersonBuilder pb) {
			pb.buildHead();
			pb.buildBody();
			pb.buildFoot();
			return pb.buildPerson();
		}
	}

	public class Man extends Person {

	}

	/** Product */
	public class Person {
		private String head;
		private String body;
		private String foot;

		public String getHead() {
			return head;
		}

		public void setHead(String head) {
			this.head = head;
		}

		public String getBody() {
			return body;
		}

		public void setBody(String body) {
			this.body = body;
		}

		public String getFoot() {
			return foot;
		}

		public void setFoot(String foot) {
			this.foot = foot;
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="model-singleton"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">单例模式</h3>
					</div>
					<div class="panel-body">
						<p>保证一个类仅有一个实例，仅提供一个访问它的全局访问点。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li>
							<li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>Singleton --
								定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作。可能负责创建它自己的唯一实例。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class Singleton {
    private static Singleton sing;

    private Singleton() {}
    
    public static Singleton getInstance() {
        if (sing == null) {
            sing = new Singleton();
        }
        return sing;
    }
}
</pre>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="model-prototype"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">原型模式</h3>
					</div>
					<div class="panel-body">
						<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li>当一个系统应该独立于它的产品创建、构成和表示时。</li>
							<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。</li>
							<li>为了避免创建一个与产品类层次平行的工厂层次时。</li>
							<li>当一个类的实例只能有几个不同状态组合中的一种时。</li>
							<li>建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li>Prototype -- 声明一个克隆自身的接口。</li>
							<li>ConcretePrototype -- 实现一个克隆自身的操作。</li>
							<li>Client -- 让一个原型克隆自身从而创建一个新的对象。</li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">
public class MyPrototype {
	public static void main(String[] args) {
		MyPrototype context = new MyPrototype();
		Prototype pro = context.new ConcretePrototype("prototype");
		Prototype pro2 = (Prototype) pro.clone();
		System.out.println(pro.getName());
		System.out.println(pro2.getName());
	}

	public class Prototype implements Cloneable {
		private String name;

		public void setName(String name) {
			this.name = name;
		}

		public String getName() {
			return this.name;
		}

		public Object clone() {
			try {
				return super.clone();
			} catch (Exception e) {
				e.printStackTrace();
				return null;
			}
		}
	}

	public class ConcretePrototype extends Prototype {
		public ConcretePrototype(String name) {
			setName(name);
		}
	}
}
</pre>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="model-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">模式</h3>
					</div>
					<div class="panel-body">
						<p></p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li></li>
							<li></li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li></li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="model-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">模式</h3>
					</div>
					<div class="panel-body">
						<p></p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li></li>
							<li></li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li></li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="model-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">模式</h3>
					</div>
					<div class="panel-body">
						<p></p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li></li>
							<li></li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li></li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->
				
				<!-- item start -->
				<a class="offset" id="model-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">模式</h3>
					</div>
					<div class="panel-body">
						<p></p>
						<h5>
							<span class="glyphicon glyphicon-th-list"></span>适用性:
						</h5>
						<ol>
							<li></li>
							<li></li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-user"></span>参与者:
						</h5>
						<ol>
							<li></li>
						</ol>
						<h5>
							<span class="glyphicon glyphicon-fire"></span>实例:
						</h5>
						<pre class="brush: java;">

</pre>
					</div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
