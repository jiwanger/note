<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.6.0_51) on Mon Dec 09 16:12:58 PST 2013 -->
<title>Node (JavaFX 2.2)</title>
<meta name="date" content="2013-12-09">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script>window.ohcglobal || document.write('<script src="../../../../../en/dcommon/js/global.js">\x3C/script>')</script><script src='../../../../../en/dcommon/js/disclaimer.js' defer></script></head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Node (JavaFX 2.2)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="Node.html#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Node.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em>JavaFX&nbsp;2.2</em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="ImageCursorBuilder.html" title="class in javafx.scene"><span class="strong">Prev Class</span></a></li>
<li><a href="Node.FocusedProperty.html" title="class in javafx.scene"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?javafx%252Fscene%252FNode.html" target="_top">Frames</a></li>
<li><a href="Node.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="Node.html#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="Node.html#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="Node.html#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="Node.html#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">javafx.scene</div>
<h2 title="Class Node" class="title">Class Node</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>javafx.scene.Node</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../event/EventTarget.html" title="interface in javafx.event">EventTarget</a></dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="canvas/Canvas.html" title="class in javafx.scene.canvas">Canvas</a>, <a href="image/ImageView.html" title="class in javafx.scene.image">ImageView</a>, <a href="media/MediaView.html" title="class in javafx.scene.media">MediaView</a>, <a href="Parent.html" title="class in javafx.scene">Parent</a>, <a href="shape/Shape.html" title="class in javafx.scene.shape">Shape</a></dd>
</dl>
<hr>
<br>
<pre>@IDProperty(value="id")
public abstract class <span class="strong">Node</span>
extends java.lang.Object
implements <a href="../event/EventTarget.html" title="interface in javafx.event">EventTarget</a></pre>
<div class="block">Base class for scene graph nodes. A scene graph is a set of tree data structures
 where every item has zero or one parent, and each item is either
 a "leaf" with zero sub-items or a "branch" with zero or more sub-items.
 <p>
 Each item in the scene graph is called a <code>Node</code>. Branch nodes are
 of type <a href="Parent.html" title="class in javafx.scene"><code>Parent</code></a>, whose concrete subclasses are <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>,
 <a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>, and <a href="control/Control.html" title="class in javafx.scene.control"><code>Control</code></a>,
 or subclasses thereof.
 <p>
 Leaf nodes are classes such as
 <a href="shape/Rectangle.html" title="class in javafx.scene.shape"><code>Rectangle</code></a>, <a href="text/Text.html" title="class in javafx.scene.text"><code>Text</code></a>,
 <a href="image/ImageView.html" title="class in javafx.scene.image"><code>ImageView</code></a>, <a href="media/MediaView.html" title="class in javafx.scene.media"><code>MediaView</code></a>,
 or other such leaf classes which cannot have children. Only a single node within
 each scene graph tree will have no parent, which is referred to as the "root" node.
 <p>
 There may be several trees in the scene graph. Some trees may be part of
 a <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>, in which case they are eligible to be displayed.
 Other trees might not be part of any <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>.
 <p>
 A node may occur at most once anywhere in the scene graph. Specifically,
 a node must appear no more than once in all of the following:
 as the root node of a <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>,
 the children ObservableList of a <a href="Parent.html" title="class in javafx.scene"><code>Parent</code></a>,
 or as the clip of a <a href="Node.html" title="class in javafx.scene"><code>Node</code></a>.
 <p>
 The scene graph must not have cycles. A cycle would exist if a node is
 an ancestor of itself in the tree, considering the <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> content
 ObservableList, <a href="Parent.html" title="class in javafx.scene"><code>Parent</code></a> children ObservableList, and <a href="Node.html" title="class in javafx.scene"><code>Node</code></a> clip relationships
 mentioned above.
 <p>
 If a program adds a child node to a Parent (including Group, Region, etc)
 and that node is already a child of a different Parent or the root of a Scene,
 the node is automatically (and silently) removed from its former parent.
 If a program attempts to modify the scene graph in any other way that violates
 the above rules, an exception is thrown, the modification attempt is ignored
 and the scene graph is restored to its previous state.
 <p>
 It is possible to rearrange the structure of the scene graph, for
 example, to move a subtree from one location in the scene graph to
 another. In order to do this, one would normally remove the subtree from
 its old location before inserting it at the new location. However, the
 subtree will be automatically removed as described above if the application
 doesn't explicitly remove it.
 <p>
 Node objects may be constructed and modified on any thread as long they are
 not yet attached to a <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>. An application must attach nodes to a
 Scene, and modify nodes that are already attached to a Scene, on the JavaFX
 Application Thread.

 <h4>String ID</h4>
 <p>
 Each node in the scene graph can be given a unique <a href="Node.html#idProperty()"><code>id</code></a>. This id is
 much like the "id" attribute of an HTML tag in that it is up to the designer
 and developer to ensure that the <code>id</code> is unique within the scene graph.
 A convenience function called <a href="Node.html#lookup(java.lang.String)"><code>lookup(String)</code></a> can be used to find
 a node with a unique id within the scene graph, or within a subtree of the
 scene graph. The id can also be used identify nodes for applying styles; see
 the CSS section below.

 <h4>Coordinate System</h4>
 <p>
 The <code>Node</code> class defines a traditional computer graphics "local"
 coordinate system in which the <code>x</code> axis increases to the right and the
 <code>y</code> axis increases downwards.  The concrete node classes for shapes
 provide variables for defining the geometry and location of the shape
 within this local coordinate space.  For example,
 <a href="shape/Rectangle.html" title="class in javafx.scene.shape"><code>Rectangle</code></a> provides <code>x</code>, <code>y</code>,
 <code>width</code>, <code>height</code> variables while
 <a href="shape/Circle.html" title="class in javafx.scene.shape"><code>Circle</code></a> provides <code>centerX</code>, <code>centerY</code>,
 and <code>radius</code>.
 <p>
 At the device pixel level, integer coordinates map onto the corners and
 cracks between the pixels and the centers of the pixels appear at the
 midpoints between integer pixel locations.  Because all coordinate values
 are specified with floating point numbers, coordinates can precisely
 point to these corners (when the floating point values have exact integer
 values) or to any location on the pixel.  For example, a coordinate of
 <code>(0.5, 0.5)</code> would point to the center of the upper left pixel on the
 <code>Stage</code>.  Similarly, a rectangle at <code>(0, 0)</code> with dimensions
 of <code>10</code> by <code>10</code> would span from the upper left corner of the
 upper left pixel on the <code>Stage</code> to the lower right corner of the
 10th pixel on the 10th scanline.  The pixel center of the last pixel
 inside that rectangle would be at the coordinates <code>(9.5, 9.5)</code>.
 <p>
 In practice, most nodes have transformations applied to their coordinate
 system as mentioned below.  As a result, the information above describing
 the alignment of device coordinates to the pixel grid is relative to
 the transformed coordinates, not the local coordinates of the nodes.
 The <a href="shape/Shape.html" title="class in javafx.scene.shape"><code>Shape</code></a> class describes some additional
 important context-specific information about coordinate mapping and how
 it can affect rendering.

 <h4>Transformations</h4>
 <p>
 Any <code>Node</code> can have transformations applied to it. These include
 translation, rotation, scaling, or shearing.
 <p>
 A <b>translation</b> transformation is one which shifts the origin of the
 node's coordinate space along either the x or y axis. For example, if you
 create a <a href="shape/Rectangle.html" title="class in javafx.scene.shape"><code>Rectangle</code></a> which is drawn at the origin
 (x=0, y=0) and has a width of 100 and a height of 50, and then apply a
 <a href="transform/Translate.html" title="class in javafx.scene.transform"><code>Translate</code></a> with a shift of 10 along the x axis
 (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain
 100 points wide and 50 tall. Note that the origin was shifted, not the
 <code>x</code> variable of the rectangle.
 <p>
 A common node transform is a translation by an integer distance, most often
 used to lay out nodes on the stage.  Such integer translations maintain the
 device pixel mapping so that local coordinates that are integers still
 map to the cracks between pixels.
 <p>
 A <b>rotation</b> transformation is one which rotates the coordinate space of
 the node about a specified "pivot" point, causing the node to appear rotated.
 For example, if you create a <a href="shape/Rectangle.html" title="class in javafx.scene.shape"><code>Rectangle</code></a> which is
 drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and
 you apply a <a href="transform/Rotate.html" title="class in javafx.scene.transform"><code>Rotate</code></a> with a 90 degree rotation
 (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then
 the rectangle will be drawn as if its x and y were zero but its height was
 100 and its width -30. That is, it is as if a pin is being stuck at the top
 left corner and the rectangle is rotating 90 degrees clockwise around that
 pin. If the pivot point is instead placed in the center of the rectangle
 (at point x=50, y=15) then the rectangle will instead appear to rotate about
 its center.
 <p>
 Note that as with all transformations, the x, y, width, and height variables
 of the rectangle (which remain relative to the local coordinate space) have
 not changed, but rather the transformation alters the entire coordinate space
 of the rectangle.
 <p>
 A <b>scaling</b> transformation causes a node to either appear larger or
 smaller depending on the scaling factor. Scaling alters the coordinate space
 of the node such that each unit of distance along the axis in local
 coordinates is multipled by the scale factor. As with rotation
 transformations, scaling transformations are applied about a "pivot" point.
 You can think of this as the point in the Node around which you "zoom".  For
 example, if you create a <a href="shape/Rectangle.html" title="class in javafx.scene.shape"><code>Rectangle</code></a> with a
 <code>strokeWidth</code> of 5, and a width and height of 50, and you apply a
 <a href="transform/Scale.html" title="class in javafx.scene.transform"><code>Scale</code></a> with scale factors (x=2.0, y=2.0) and
 a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle
 (including the stroke) will double in size, growing to the right and
 downwards from the origin.
 <p>
 A <b>shearing</b> transformation, sometimes called a skew, effectively
 rotates one axis so that the x and y axes are no longer perpendicular.
 <p>
 Multiple transformations may be applied to a node by specifying an ordered
 chain of transforms.  The order in which the transforms are applied is
 defined by the ObservableList specified in the <a href="Node.html#getTransforms()"><code>transforms</code></a> variable.

 <h4>Bounding Rectangles</h4>
 <p>
 Since every <code>Node</code> has transformations, every Node's geometric
 bounding rectangle can be described differently depending on whether
 transformations are accounted for or not.
 <p>
 Each <code>Node</code> has a read-only <a href="Node.html#boundsInLocalProperty()"><code>boundsInLocal</code></a>
 variable which specifies the bounding rectangle of the <code>Node</code> in
 untransformed local coordinates. <code>boundsInLocal</code> includes the
 Node's shape geometry, including any space required for a
 non-zero stroke that may fall outside the local position/size variables,
 and its <a href="Node.html#clipProperty()"><code>clip</code></a> and <a href="Node.html#effectProperty()"><code>effect</code></a> variables.
 <p>
 Each <code>Node</code> also has a read-only <a href="Node.html#boundsInParentProperty()"><code>boundsInParent</code></a> variable which
 specifies the bounding rectangle of the <code>Node</code> after all transformations
 have been applied, including those set in <a href="Node.html#getTransforms()"><code>transforms</code></a>,
 <a href="Node.html#scaleXProperty()"><code>scaleX</code></a>/<a href="Node.html#scaleYProperty()"><code>scaleY</code></a>, <a href="Node.html#rotateProperty()"><code>rotate</code></a>,
 <a href="Node.html#translateXProperty()"><code>translateX</code></a>/<a href="Node.html#translateYProperty()"><code>translateY</code></a>, and <a href="Node.html#layoutXProperty()"><code>layoutX</code></a>/<a href="Node.html#layoutYProperty()"><code>layoutY</code></a>.
 It is called "boundsInParent" because the rectangle will be relative to the
 parent's coordinate system.  This is the 'visual' bounds of the node.
 <p>
 Finally, the <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> variable defines the rectangular bounds of
 the <code>Node</code> that should be used as the basis for layout calculations and
 may differ from the visual bounds of the node.  For shapes, Text, and ImageView,
 layoutBounds by default includes only the shape geometry, including space required
 for a non-zero <code>strokeWidth</code>, but does <i>not</i> include the effect,
 clip, or any transforms. For resizable classes (Regions and Controls)
 layoutBounds will always map to <code>0,0 width x height</code>.

 <p> The image shows a node with transformation (rotation by 20 degrees)
 and its bounds. The red rectangle represents <code>boundsInParent</code> in the
 coordinate space of the Node's parent. The green rectangle represents <code>boundsInLocal</code>
 in coordinate space of the Node. </p>
 <p> <img src="doc-files/bounds-complex.png"/> </p>

 <p> The images show a filled and stroked rectangle and their bounds. The
 first rectangle <code>[x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:0]</code>
 has the following bounds bounds: <code>[x:10.0 y:10.0 width:100.0 height:100.0]</code>.

 The second rectangle <code>[x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:5]</code>
 has the following bounds: <code>[x:5.0 y:5.0 width:110.0 height:110.0]</code>.

 Since neither of the rectangles has any transformation applied,
 <code>boundsInParent</code> and <code>boundsInLocal</code> are the same. </p>
 <p> <img src="doc-files/bounds.png"/> </p>

 
 <h4>CSS</h4>
 <p>
 The <code>Node</code> class contains <code>id</code>, <code>styleClass</code>, and
 <code>style</code> variables that are used in styling this node from
 CSS. The <code>id</code> and <code>styleClass</code> variables are used in
 CSS style sheets to identify nodes to which styles should be
 applied. The <code>style</code> variable contains style properties and
 values that are applied directly to this node.
 <p>
 For further information about CSS and how to apply CSS styles
 to nodes, see the <a href="doc-files/cssref.html">CSS Reference
 Guide</a>.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== PROPERTY SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="property_summary">
<!--   -->
</a>
<h3>Property Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Property Summary table, listing properties, and an explanation">
<caption><span>Properties</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Type</th>
<th class="colLast" scope="col">Property and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="effect/BlendMode.html" title="enum in javafx.scene.effect">BlendMode</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#blendModeProperty">blendMode</a></strong></code>
<div class="block">The <a href="effect/BlendMode.html" title="enum in javafx.scene.effect"><code>BlendMode</code></a> used to blend this individual node
 into the scene behind it.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#boundsInLocalProperty">boundsInLocal</a></strong></code>
<div class="block">The rectangular bounds of this <code>Node</code> in the node's
 untransformed local coordinate space.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#boundsInParentProperty">boundsInParent</a></strong></code>
<div class="block">The rectangular bounds of this <code>Node</code> which include its transforms.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="CacheHint.html" title="enum in javafx.scene">CacheHint</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#cacheHintProperty">cacheHint</a></strong></code>
<div class="block">Additional hint for controlling bitmap caching.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#cacheProperty">cache</a></strong></code>
<div class="block">A performance hint to the system to indicate that this <code>Node</code>
 should be cached as a bitmap.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="Node.html" title="class in javafx.scene">Node</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#clipProperty">clip</a></strong></code>
<div class="block">Specifies a <code>Node</code> to use to define the the clipping shape for this
 Node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="Cursor.html" title="class in javafx.scene">Cursor</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#cursorProperty">cursor</a></strong></code>
<div class="block">Defines the mouse cursor for this <code>Node</code> and subnodes.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="DepthTest.html" title="enum in javafx.scene">DepthTest</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#depthTestProperty">depthTest</a></strong></code>
<div class="block">Indicates whether depth testing is used when rendering this node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#disabledProperty">disabled</a></strong></code>
<div class="block">Indicates whether or not this <code>Node</code> is disabled.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#disableProperty">disable</a></strong></code>
<div class="block">Sets the individual disabled state of this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="effect/Effect.html" title="class in javafx.scene.effect">Effect</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#effectProperty">effect</a></strong></code>
<div class="block">Specifies an effect to apply to this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventDispatcher.html" title="interface in javafx.event">EventDispatcher</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#eventDispatcherProperty">eventDispatcher</a></strong></code>
<div class="block">Specifies the event dispatcher for this node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#focusedProperty">focused</a></strong></code>
<div class="block">Indicates whether this <code>Node</code> currently has the input focus.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#focusTraversableProperty">focusTraversable</a></strong></code>
<div class="block">Specifies whether this <code>Node</code> should be a part of focus traversal
 cycle.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#hoverProperty">hover</a></strong></code>
<div class="block">Whether or not this <code>Node</code> is being hovered over.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/StringProperty.html" title="class in javafx.beans.property">StringProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#idProperty">id</a></strong></code>
<div class="block">The id of this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="input/InputMethodRequests.html" title="interface in javafx.scene.input">InputMethodRequests</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#inputMethodRequestsProperty">inputMethodRequests</a></strong></code>
<div class="block">Property holding InputMethodRequests.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#layoutBoundsProperty">layoutBounds</a></strong></code>
<div class="block">The rectangular bounds that should be used for layout calculations for
 this node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#layoutXProperty">layoutX</a></strong></code>
<div class="block">Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#layoutYProperty">layoutY</a></strong></code>
<div class="block">Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#localToParentTransformProperty">localToParentTransform</a></strong></code>
<div class="block">An affine transform that holds the computed local-to-parent transform.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#localToSceneTransformProperty">localToSceneTransform</a></strong></code>
<div class="block">An affine transform that holds the computed local-to-scene transform.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#managedProperty">managed</a></strong></code>
<div class="block">Defines whether or not this node's layout will be managed by it's parent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#mouseTransparentProperty">mouseTransparent</a></strong></code>
<div class="block">If <code>true</code>, this node (together with all its children) is completely
 transparent to mouse events.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ContextMenuEvent.html" title="class in javafx.scene.input">ContextMenuEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onContextMenuRequestedProperty">onContextMenuRequested</a></strong></code>
<div class="block">Defines a function to be called when a context menu
 has been requested on this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragDetectedProperty">onDragDetected</a></strong></code>
<div class="block">Defines a function to be called when drag gesture has been
 detected.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragDoneProperty">onDragDone</a></strong></code>
<div class="block">Defines a function to be called when this <code>Node</code> is a
 drag and drop gesture source after its data has
 been dropped on a drop target.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragDroppedProperty">onDragDropped</a></strong></code>
<div class="block">Defines a function to be called when the mouse button is released
 on this <code>Node</code> during drag and drop gesture.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragEnteredProperty">onDragEntered</a></strong></code>
<div class="block">Defines a function to be called when drag gesture
 enters this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragExitedProperty">onDragExited</a></strong></code>
<div class="block">Defines a function to be called when drag gesture
 exits this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragOverProperty">onDragOver</a></strong></code>
<div class="block">Defines a function to be called when drag gesture progresses within
 this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/InputMethodEvent.html" title="class in javafx.scene.input">InputMethodEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onInputMethodTextChangedProperty">onInputMethodTextChanged</a></strong></code>
<div class="block">Defines a function to be called when this <code>Node</code>
 has input focus and the input method text has changed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onKeyPressedProperty">onKeyPressed</a></strong></code>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been pressed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onKeyReleasedProperty">onKeyReleased</a></strong></code>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been released.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onKeyTypedProperty">onKeyTyped</a></strong></code>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been typed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseClickedProperty">onMouseClicked</a></strong></code>
<div class="block">Defines a function to be called when a mouse button has been clicked
 (pressed and released) on this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseDragEnteredProperty">onMouseDragEntered</a></strong></code>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 enters this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseDragExitedProperty">onMouseDragExited</a></strong></code>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 leaves this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseDraggedProperty">onMouseDragged</a></strong></code>
<div class="block">Defines a function to be called when a mouse button is pressed
 on this <code>Node</code> and then dragged.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseDragOverProperty">onMouseDragOver</a></strong></code>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 progresses within this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseDragReleasedProperty">onMouseDragReleased</a></strong></code>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 ends (by releasing mouse button) within this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseEnteredProperty">onMouseEntered</a></strong></code>
<div class="block">Defines a function to be called when the mouse enters this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseExitedProperty">onMouseExited</a></strong></code>
<div class="block">Defines a function to be called when the mouse exits this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseMovedProperty">onMouseMoved</a></strong></code>
<div class="block">Defines a function to be called when mouse cursor moves within
 this <code>Node</code> but no buttons have been pushed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMousePressedProperty">onMousePressed</a></strong></code>
<div class="block">Defines a function to be called when a mouse button
 has been pressed on this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseReleasedProperty">onMouseReleased</a></strong></code>
<div class="block">Defines a function to be called when a mouse button
 has been released on this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onRotateProperty">onRotate</a></strong></code>
<div class="block">Defines a function to be called when user performs a rotation action.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onRotationFinishedProperty">onRotationFinished</a></strong></code>
<div class="block">Defines a function to be called when a rotation gesture ends.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onRotationStartedProperty">onRotationStarted</a></strong></code>
<div class="block">Defines a function to be called when a rotation gesture is detected.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onScrollFinishedProperty">onScrollFinished</a></strong></code>
<div class="block">Defines a function to be called when a scrolling gesture ends.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onScrollProperty">onScroll</a></strong></code>
<div class="block">Defines a function to be called when user performs a scrolling action.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onScrollStartedProperty">onScrollStarted</a></strong></code>
<div class="block">Defines a function to be called when a scrolling gesture is detected.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onSwipeDownProperty">onSwipeDown</a></strong></code>
<div class="block">Defines a function to be called when a downward swipe gesture
 centered over this node happens.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onSwipeLeftProperty">onSwipeLeft</a></strong></code>
<div class="block">Defines a function to be called when a leftward swipe gesture
 centered over this node happens.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onSwipeRightProperty">onSwipeRight</a></strong></code>
<div class="block">Defines a function to be called when an rightward swipe gesture
 centered over this node happens.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onSwipeUpProperty">onSwipeUp</a></strong></code>
<div class="block">Defines a function to be called when an upward swipe gesture
 centered over this node happens.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onTouchMovedProperty">onTouchMoved</a></strong></code>
<div class="block">Defines a function to be called when a touch point is moved.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onTouchPressedProperty">onTouchPressed</a></strong></code>
<div class="block">Defines a function to be called when a new touch point is pressed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onTouchReleasedProperty">onTouchReleased</a></strong></code>
<div class="block">Defines a function to be called when a touch point is released.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onTouchStationaryProperty">onTouchStationary</a></strong></code>
<div class="block">Defines a function to be called when a touch point stays pressed and
 still.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onZoomFinishedProperty">onZoomFinished</a></strong></code>
<div class="block">Defines a function to be called when a zooming gesture ends.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onZoomProperty">onZoom</a></strong></code>
<div class="block">Defines a function to be called when user performs a zooming action.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onZoomStartedProperty">onZoomStarted</a></strong></code>
<div class="block">Defines a function to be called when a zooming gesture is detected.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#opacityProperty">opacity</a></strong></code>
<div class="block">Specifies how opaque (that is, solid) the <code>Node</code> appears.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="Parent.html" title="class in javafx.scene">Parent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#parentProperty">parent</a></strong></code>
<div class="block">The parent of this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#pickOnBoundsProperty">pickOnBounds</a></strong></code>
<div class="block">Defines how the picking computation is done for this node when
 triggered by a <code>MouseEvent</code> or a <code>contains</code> function call.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#pressedProperty">pressed</a></strong></code>
<div class="block">Whether or not the <code>Node</code> is pressed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#rotateProperty">rotate</a></strong></code>
<div class="block">Defines the angle of rotation about the <code>Node</code>'s center, measured in
 degrees.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../geometry/Point3D.html" title="class in javafx.geometry">Point3D</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#rotationAxisProperty">rotationAxis</a></strong></code>
<div class="block">Defines the axis of rotation of this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#scaleXProperty">scaleX</a></strong></code>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the X axis of this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#scaleYProperty">scaleY</a></strong></code>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the Y axis of this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#scaleZProperty">scaleZ</a></strong></code>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the Z axis of this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="Scene.html" title="class in javafx.scene">Scene</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#sceneProperty">scene</a></strong></code>
<div class="block">The <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> that this <code>Node</code> is part of.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/StringProperty.html" title="class in javafx.beans.property">StringProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#styleProperty">style</a></strong></code>
<div class="block">A string representation of the CSS style associated with this
 specific <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#translateXProperty">translateX</a></strong></code>
<div class="block">Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#translateYProperty">translateY</a></strong></code>
<div class="block">Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#translateZProperty">translateZ</a></strong></code>
<div class="block">Defines the Z coordinate of the translation that is added to the
 transformed coordinates of this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#visibleProperty">visible</a></strong></code>
<div class="block">Specifies whether this <code>Node</code> and any subnodes should be rendered
 as part of the scene graph.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colLast" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected </code></td>
<td class="colLast"><code><strong><a href="Node.html#Node()">Node</a></strong>()</code>
<div class="block">Creates a new instance of Node.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;T extends <a href="../event/Event.html" title="class in javafx.event">Event</a>&gt;&nbsp;<br>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#addEventFilter(javafx.event.EventType, javafx.event.EventHandler)">addEventFilter</a></strong>(<a href="../event/EventType.html" title="class in javafx.event">EventType</a>&lt;T&gt;&nbsp;eventType,
              <a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super T&gt;&nbsp;eventFilter)</code>
<div class="block">Registers an event filter to this node.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;T extends <a href="../event/Event.html" title="class in javafx.event">Event</a>&gt;&nbsp;<br>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)">addEventHandler</a></strong>(<a href="../event/EventType.html" title="class in javafx.event">EventType</a>&lt;T&gt;&nbsp;eventType,
               <a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super T&gt;&nbsp;eventHandler)</code>
<div class="block">Registers an event handler to this node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#autosize()">autosize</a></strong>()</code>
<div class="block">If the node is resizable, will set its layout bounds to its current preferred
 width and height.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="effect/BlendMode.html" title="enum in javafx.scene.effect">BlendMode</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#blendModeProperty()">blendModeProperty</a></strong>()</code>
<div class="block">The <a href="effect/BlendMode.html" title="enum in javafx.scene.effect"><code>BlendMode</code></a> used to blend this individual node
 into the scene behind it.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#boundsInLocalProperty()">boundsInLocalProperty</a></strong>()</code>
<div class="block">The rectangular bounds of this <code>Node</code> in the node's
 untransformed local coordinate space.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#boundsInParentProperty()">boundsInParentProperty</a></strong>()</code>
<div class="block">The rectangular bounds of this <code>Node</code> which include its transforms.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventDispatchChain.html" title="interface in javafx.event">EventDispatchChain</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#buildEventDispatchChain(javafx.event.EventDispatchChain)">buildEventDispatchChain</a></strong>(<a href="../event/EventDispatchChain.html" title="interface in javafx.event">EventDispatchChain</a>&nbsp;tail)</code>
<div class="block">Construct an event dispatch chain for this node.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="CacheHint.html" title="enum in javafx.scene">CacheHint</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#cacheHintProperty()">cacheHintProperty</a></strong>()</code>
<div class="block">Additional hint for controlling bitmap caching.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#cacheProperty()">cacheProperty</a></strong>()</code>
<div class="block">A performance hint to the system to indicate that this <code>Node</code>
 should be cached as a bitmap.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="Node.html" title="class in javafx.scene">Node</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#clipProperty()">clipProperty</a></strong>()</code>
<div class="block">Specifies a <code>Node</code> to use to define the the clipping shape for this
 Node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#contains(double, double)">contains</a></strong>(double&nbsp;localX,
        double&nbsp;localY)</code>
<div class="block">Returns <code>true</code> if the given point (specified in the local
 coordinate space of this <code>Node</code>) is contained within the shape of
 this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#contains(javafx.geometry.Point2D)">contains</a></strong>(<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;localPoint)</code>
<div class="block">Returns <code>true</code> if the given point (specified in the local
 coordinate space of this <code>Node</code>) is contained within the shape of
 this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="Cursor.html" title="class in javafx.scene">Cursor</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#cursorProperty()">cursorProperty</a></strong>()</code>
<div class="block">Defines the mouse cursor for this <code>Node</code> and subnodes.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="DepthTest.html" title="enum in javafx.scene">DepthTest</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#depthTestProperty()">depthTestProperty</a></strong>()</code>
<div class="block">Indicates whether depth testing is used when rendering this node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#disabledProperty()">disabledProperty</a></strong>()</code>
<div class="block">Indicates whether or not this <code>Node</code> is disabled.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#disableProperty()">disableProperty</a></strong>()</code>
<div class="block">Sets the individual disabled state of this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="effect/Effect.html" title="class in javafx.scene.effect">Effect</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#effectProperty()">effectProperty</a></strong>()</code>
<div class="block">Specifies an effect to apply to this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventDispatcher.html" title="interface in javafx.event">EventDispatcher</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#eventDispatcherProperty()">eventDispatcherProperty</a></strong>()</code>
<div class="block">Specifies the event dispatcher for this node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#fireEvent(javafx.event.Event)">fireEvent</a></strong>(<a href="../event/Event.html" title="class in javafx.event">Event</a>&nbsp;event)</code>
<div class="block">Fires the specified event.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#focusedProperty()">focusedProperty</a></strong>()</code>
<div class="block">Indicates whether this <code>Node</code> currently has the input focus.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#focusTraversableProperty()">focusTraversableProperty</a></strong>()</code>
<div class="block">Specifies whether this <code>Node</code> should be a part of focus traversal
 cycle.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#getBaselineOffset()">getBaselineOffset</a></strong>()</code>
<div class="block">The 'alphabetic' (or 'roman') baseline offset from the node's layoutBounds.minY location
 that should be used when this node is being vertically aligned by baseline with
 other nodes.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="effect/BlendMode.html" title="enum in javafx.scene.effect">BlendMode</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getBlendMode()">getBlendMode</a></strong>()</code>
<div class="block">Gets the value of the property blendMode.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getBoundsInLocal()">getBoundsInLocal</a></strong>()</code>
<div class="block">Gets the value of the property boundsInLocal.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getBoundsInParent()">getBoundsInParent</a></strong>()</code>
<div class="block">Gets the value of the property boundsInParent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="CacheHint.html" title="enum in javafx.scene">CacheHint</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getCacheHint()">getCacheHint</a></strong>()</code>
<div class="block">Gets the value of the property cacheHint.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="Node.html" title="class in javafx.scene">Node</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getClip()">getClip</a></strong>()</code>
<div class="block">Gets the value of the property clip.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../geometry/Orientation.html" title="enum in javafx.geometry">Orientation</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getContentBias()">getContentBias</a></strong>()</code>
<div class="block">Returns the orientation of a node's resizing bias for layout purposes.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="Cursor.html" title="class in javafx.scene">Cursor</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getCursor()">getCursor</a></strong>()</code>
<div class="block">Gets the value of the property cursor.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="DepthTest.html" title="enum in javafx.scene">DepthTest</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getDepthTest()">getDepthTest</a></strong>()</code>
<div class="block">Gets the value of the property depthTest.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="effect/Effect.html" title="class in javafx.scene.effect">Effect</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getEffect()">getEffect</a></strong>()</code>
<div class="block">Gets the value of the property effect.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventDispatcher.html" title="interface in javafx.event">EventDispatcher</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getEventDispatcher()">getEventDispatcher</a></strong>()</code>
<div class="block">Gets the value of the property eventDispatcher.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="Node.html#getId()">getId</a></strong>()</code>
<div class="block">The id of this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="input/InputMethodRequests.html" title="interface in javafx.scene.input">InputMethodRequests</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getInputMethodRequests()">getInputMethodRequests</a></strong>()</code>
<div class="block">Gets the value of the property inputMethodRequests.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getLayoutBounds()">getLayoutBounds</a></strong>()</code>
<div class="block">Gets the value of the property layoutBounds.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#getLayoutX()">getLayoutX</a></strong>()</code>
<div class="block">Gets the value of the property layoutX.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#getLayoutY()">getLayoutY</a></strong>()</code>
<div class="block">Gets the value of the property layoutY.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getLocalToParentTransform()">getLocalToParentTransform</a></strong>()</code>
<div class="block">Gets the value of the property localToParentTransform.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getLocalToSceneTransform()">getLocalToSceneTransform</a></strong>()</code>
<div class="block">Gets the value of the property localToSceneTransform.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ContextMenuEvent.html" title="class in javafx.scene.input">ContextMenuEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnContextMenuRequested()">getOnContextMenuRequested</a></strong>()</code>
<div class="block">Gets the value of the property onContextMenuRequested.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnDragDetected()">getOnDragDetected</a></strong>()</code>
<div class="block">Gets the value of the property onDragDetected.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnDragDone()">getOnDragDone</a></strong>()</code>
<div class="block">Gets the value of the property onDragDone.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnDragDropped()">getOnDragDropped</a></strong>()</code>
<div class="block">Gets the value of the property onDragDropped.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnDragEntered()">getOnDragEntered</a></strong>()</code>
<div class="block">Gets the value of the property onDragEntered.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnDragExited()">getOnDragExited</a></strong>()</code>
<div class="block">Gets the value of the property onDragExited.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnDragOver()">getOnDragOver</a></strong>()</code>
<div class="block">Gets the value of the property onDragOver.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/InputMethodEvent.html" title="class in javafx.scene.input">InputMethodEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnInputMethodTextChanged()">getOnInputMethodTextChanged</a></strong>()</code>
<div class="block">Gets the value of the property onInputMethodTextChanged.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnKeyPressed()">getOnKeyPressed</a></strong>()</code>
<div class="block">Gets the value of the property onKeyPressed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnKeyReleased()">getOnKeyReleased</a></strong>()</code>
<div class="block">Gets the value of the property onKeyReleased.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnKeyTyped()">getOnKeyTyped</a></strong>()</code>
<div class="block">Gets the value of the property onKeyTyped.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnMouseClicked()">getOnMouseClicked</a></strong>()</code>
<div class="block">Gets the value of the property onMouseClicked.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnMouseDragEntered()">getOnMouseDragEntered</a></strong>()</code>
<div class="block">Gets the value of the property onMouseDragEntered.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnMouseDragExited()">getOnMouseDragExited</a></strong>()</code>
<div class="block">Gets the value of the property onMouseDragExited.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnMouseDragged()">getOnMouseDragged</a></strong>()</code>
<div class="block">Gets the value of the property onMouseDragged.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnMouseDragOver()">getOnMouseDragOver</a></strong>()</code>
<div class="block">Gets the value of the property onMouseDragOver.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnMouseDragReleased()">getOnMouseDragReleased</a></strong>()</code>
<div class="block">Gets the value of the property onMouseDragReleased.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnMouseEntered()">getOnMouseEntered</a></strong>()</code>
<div class="block">Gets the value of the property onMouseEntered.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnMouseExited()">getOnMouseExited</a></strong>()</code>
<div class="block">Gets the value of the property onMouseExited.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnMouseMoved()">getOnMouseMoved</a></strong>()</code>
<div class="block">Gets the value of the property onMouseMoved.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnMousePressed()">getOnMousePressed</a></strong>()</code>
<div class="block">Gets the value of the property onMousePressed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnMouseReleased()">getOnMouseReleased</a></strong>()</code>
<div class="block">Gets the value of the property onMouseReleased.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnRotate()">getOnRotate</a></strong>()</code>
<div class="block">Gets the value of the property onRotate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnRotationFinished()">getOnRotationFinished</a></strong>()</code>
<div class="block">Gets the value of the property onRotationFinished.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnRotationStarted()">getOnRotationStarted</a></strong>()</code>
<div class="block">Gets the value of the property onRotationStarted.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnScroll()">getOnScroll</a></strong>()</code>
<div class="block">Gets the value of the property onScroll.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnScrollFinished()">getOnScrollFinished</a></strong>()</code>
<div class="block">Gets the value of the property onScrollFinished.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnScrollStarted()">getOnScrollStarted</a></strong>()</code>
<div class="block">Gets the value of the property onScrollStarted.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnSwipeDown()">getOnSwipeDown</a></strong>()</code>
<div class="block">Gets the value of the property onSwipeDown.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnSwipeLeft()">getOnSwipeLeft</a></strong>()</code>
<div class="block">Gets the value of the property onSwipeLeft.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnSwipeRight()">getOnSwipeRight</a></strong>()</code>
<div class="block">Gets the value of the property onSwipeRight.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnSwipeUp()">getOnSwipeUp</a></strong>()</code>
<div class="block">Gets the value of the property onSwipeUp.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnTouchMoved()">getOnTouchMoved</a></strong>()</code>
<div class="block">Gets the value of the property onTouchMoved.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnTouchPressed()">getOnTouchPressed</a></strong>()</code>
<div class="block">Gets the value of the property onTouchPressed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnTouchReleased()">getOnTouchReleased</a></strong>()</code>
<div class="block">Gets the value of the property onTouchReleased.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnTouchStationary()">getOnTouchStationary</a></strong>()</code>
<div class="block">Gets the value of the property onTouchStationary.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnZoom()">getOnZoom</a></strong>()</code>
<div class="block">Gets the value of the property onZoom.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnZoomFinished()">getOnZoomFinished</a></strong>()</code>
<div class="block">Gets the value of the property onZoomFinished.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOnZoomStarted()">getOnZoomStarted</a></strong>()</code>
<div class="block">Gets the value of the property onZoomStarted.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#getOpacity()">getOpacity</a></strong>()</code>
<div class="block">Gets the value of the property opacity.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="Parent.html" title="class in javafx.scene">Parent</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getParent()">getParent</a></strong>()</code>
<div class="block">Gets the value of the property parent.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../collections/ObservableMap.html" title="interface in javafx.collections">ObservableMap</a>&lt;java.lang.Object,java.lang.Object&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getProperties()">getProperties</a></strong>()</code>
<div class="block">Returns an observable map of properties on this node for use primarily
 by application developers.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#getRotate()">getRotate</a></strong>()</code>
<div class="block">Gets the value of the property rotate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../geometry/Point3D.html" title="class in javafx.geometry">Point3D</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getRotationAxis()">getRotationAxis</a></strong>()</code>
<div class="block">Gets the value of the property rotationAxis.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#getScaleX()">getScaleX</a></strong>()</code>
<div class="block">Gets the value of the property scaleX.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#getScaleY()">getScaleY</a></strong>()</code>
<div class="block">Gets the value of the property scaleY.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#getScaleZ()">getScaleZ</a></strong>()</code>
<div class="block">Gets the value of the property scaleZ.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="Scene.html" title="class in javafx.scene">Scene</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#getScene()">getScene</a></strong>()</code>
<div class="block">Gets the value of the property scene.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="Node.html#getStyle()">getStyle</a></strong>()</code>
<div class="block">A string representation of the CSS style associated with this
 specific <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../collections/ObservableList.html" title="interface in javafx.collections">ObservableList</a>&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getStyleClass()">getStyleClass</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../collections/ObservableList.html" title="interface in javafx.collections">ObservableList</a>&lt;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#getTransforms()">getTransforms</a></strong>()</code>
<div class="block">Defines the ObservableList of <a href="transform/Transform.html" title="class in javafx.scene.transform"><code>Transform</code></a> objects
 to be applied to this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#getTranslateX()">getTranslateX</a></strong>()</code>
<div class="block">Gets the value of the property translateX.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#getTranslateY()">getTranslateY</a></strong>()</code>
<div class="block">Gets the value of the property translateY.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#getTranslateZ()">getTranslateZ</a></strong>()</code>
<div class="block">Gets the value of the property translateZ.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="Node.html#getUserData()">getUserData</a></strong>()</code>
<div class="block">Returns a previously set Object property, or null if no such property
 has been set using the <a href="Node.html#setUserData(java.lang.Object)"><code>setUserData(java.lang.Object)</code></a> method.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#hasProperties()">hasProperties</a></strong>()</code>
<div class="block">Tests if Node has properties.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#hoverProperty()">hoverProperty</a></strong>()</code>
<div class="block">Whether or not this <code>Node</code> is being hovered over.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/StringProperty.html" title="class in javafx.beans.property">StringProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#idProperty()">idProperty</a></strong>()</code>
<div class="block">The id of this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="input/InputMethodRequests.html" title="interface in javafx.scene.input">InputMethodRequests</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#inputMethodRequestsProperty()">inputMethodRequestsProperty</a></strong>()</code>
<div class="block">Property holding InputMethodRequests.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#intersects(javafx.geometry.Bounds)">intersects</a></strong>(<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;localBounds)</code>
<div class="block">Returns <code>true</code> if the given bounds (specified in the local
 coordinate space of this <code>Node</code>) intersects the shape of this
 <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#intersects(double, double, double, double)">intersects</a></strong>(double&nbsp;localX,
          double&nbsp;localY,
          double&nbsp;localWidth,
          double&nbsp;localHeight)</code>
<div class="block">Returns <code>true</code> if the given rectangle (specified in the local
 coordinate space of this <code>Node</code>) intersects the shape of this
 <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isCache()">isCache</a></strong>()</code>
<div class="block">Gets the value of the property cache.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isDisable()">isDisable</a></strong>()</code>
<div class="block">Gets the value of the property disable.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isDisabled()">isDisabled</a></strong>()</code>
<div class="block">Gets the value of the property disabled.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isFocused()">isFocused</a></strong>()</code>
<div class="block">Gets the value of the property focused.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isFocusTraversable()">isFocusTraversable</a></strong>()</code>
<div class="block">Gets the value of the property focusTraversable.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isHover()">isHover</a></strong>()</code>
<div class="block">Gets the value of the property hover.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isManaged()">isManaged</a></strong>()</code>
<div class="block">Gets the value of the property managed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isMouseTransparent()">isMouseTransparent</a></strong>()</code>
<div class="block">Gets the value of the property mouseTransparent.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isPickOnBounds()">isPickOnBounds</a></strong>()</code>
<div class="block">Gets the value of the property pickOnBounds.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isPressed()">isPressed</a></strong>()</code>
<div class="block">Gets the value of the property pressed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isResizable()">isResizable</a></strong>()</code>
<div class="block">Indicates whether this node is a type which can be resized by its parent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="Node.html#isVisible()">isVisible</a></strong>()</code>
<div class="block">Gets the value of the property visible.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#layoutBoundsProperty()">layoutBoundsProperty</a></strong>()</code>
<div class="block">The rectangular bounds that should be used for layout calculations for
 this node.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#layoutXProperty()">layoutXProperty</a></strong>()</code>
<div class="block">Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#layoutYProperty()">layoutYProperty</a></strong>()</code>
<div class="block">Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#localToParent(javafx.geometry.Bounds)">localToParent</a></strong>(<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;localBounds)</code>
<div class="block">Transforms a bounds from the local coordinate space of this
 <code>Node</code> into the coordinate space of its parent.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#localToParent(double, double)">localToParent</a></strong>(double&nbsp;localX,
             double&nbsp;localY)</code>
<div class="block">Transforms a point from the local coordinate space of this <code>Node</code>
 into the coordinate space of its parent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#localToParent(javafx.geometry.Point2D)">localToParent</a></strong>(<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;localPoint)</code>
<div class="block">Transforms a point from the local coordinate space of this <code>Node</code>
 into the coordinate space of its parent.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#localToParentTransformProperty()">localToParentTransformProperty</a></strong>()</code>
<div class="block">An affine transform that holds the computed local-to-parent transform.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#localToScene(javafx.geometry.Bounds)">localToScene</a></strong>(<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;localBounds)</code>
<div class="block">Transforms a bounds from the local coordinate space of this
 <code>Node</code> into the coordinate space of its <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#localToScene(double, double)">localToScene</a></strong>(double&nbsp;localX,
            double&nbsp;localY)</code>
<div class="block">Transforms a point from the local coordinate space of this <code>Node</code>
 into the coordinate space of its <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#localToScene(javafx.geometry.Point2D)">localToScene</a></strong>(<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;localPoint)</code>
<div class="block">Transforms a point from the local coordinate space of this <code>Node</code>
 into the coordinate space of its <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#localToSceneTransformProperty()">localToSceneTransformProperty</a></strong>()</code>
<div class="block">An affine transform that holds the computed local-to-scene transform.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="Node.html" title="class in javafx.scene">Node</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#lookup(java.lang.String)">lookup</a></strong>(java.lang.String&nbsp;selector)</code>
<div class="block">Finds this <code>Node</code>, or the first sub-node, based on the given CSS selector.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="Node.html" title="class in javafx.scene">Node</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#lookupAll(java.lang.String)">lookupAll</a></strong>(java.lang.String&nbsp;selector)</code>
<div class="block">Finds all <code>Node</code>s, including this one and any children, which match
 the given CSS selector.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#managedProperty()">managedProperty</a></strong>()</code>
<div class="block">Defines whether or not this node's layout will be managed by it's parent.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#maxHeight(double)">maxHeight</a></strong>(double&nbsp;width)</code>
<div class="block">Returns the node's maximum height for use in layout calculations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#maxWidth(double)">maxWidth</a></strong>(double&nbsp;height)</code>
<div class="block">Returns the node's maximum width for use in layout calculations.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#minHeight(double)">minHeight</a></strong>(double&nbsp;width)</code>
<div class="block">Returns the node's minimum height for use in layout calculations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#minWidth(double)">minWidth</a></strong>(double&nbsp;height)</code>
<div class="block">Returns the node's minimum width for use in layout calculations.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#mouseTransparentProperty()">mouseTransparentProperty</a></strong>()</code>
<div class="block">If <code>true</code>, this node (together with all its children) is completely
 transparent to mouse events.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ContextMenuEvent.html" title="class in javafx.scene.input">ContextMenuEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onContextMenuRequestedProperty()">onContextMenuRequestedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a context menu
 has been requested on this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragDetectedProperty()">onDragDetectedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when drag gesture has been
 detected.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragDoneProperty()">onDragDoneProperty</a></strong>()</code>
<div class="block">Defines a function to be called when this <code>Node</code> is a
 drag and drop gesture source after its data has
 been dropped on a drop target.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragDroppedProperty()">onDragDroppedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when the mouse button is released
 on this <code>Node</code> during drag and drop gesture.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragEnteredProperty()">onDragEnteredProperty</a></strong>()</code>
<div class="block">Defines a function to be called when drag gesture
 enters this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragExitedProperty()">onDragExitedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when drag gesture
 exits this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onDragOverProperty()">onDragOverProperty</a></strong>()</code>
<div class="block">Defines a function to be called when drag gesture progresses within
 this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/InputMethodEvent.html" title="class in javafx.scene.input">InputMethodEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onInputMethodTextChangedProperty()">onInputMethodTextChangedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when this <code>Node</code>
 has input focus and the input method text has changed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onKeyPressedProperty()">onKeyPressedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been pressed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onKeyReleasedProperty()">onKeyReleasedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been released.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onKeyTypedProperty()">onKeyTypedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been typed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseClickedProperty()">onMouseClickedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a mouse button has been clicked
 (pressed and released) on this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseDragEnteredProperty()">onMouseDragEnteredProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 enters this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseDragExitedProperty()">onMouseDragExitedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 leaves this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseDraggedProperty()">onMouseDraggedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a mouse button is pressed
 on this <code>Node</code> and then dragged.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseDragOverProperty()">onMouseDragOverProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 progresses within this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseDragReleasedProperty()">onMouseDragReleasedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 ends (by releasing mouse button) within this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseEnteredProperty()">onMouseEnteredProperty</a></strong>()</code>
<div class="block">Defines a function to be called when the mouse enters this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseExitedProperty()">onMouseExitedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when the mouse exits this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseMovedProperty()">onMouseMovedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when mouse cursor moves within
 this <code>Node</code> but no buttons have been pushed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMousePressedProperty()">onMousePressedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a mouse button
 has been pressed on this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onMouseReleasedProperty()">onMouseReleasedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a mouse button
 has been released on this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onRotateProperty()">onRotateProperty</a></strong>()</code>
<div class="block">Defines a function to be called when user performs a rotation action.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onRotationFinishedProperty()">onRotationFinishedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a rotation gesture ends.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onRotationStartedProperty()">onRotationStartedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a rotation gesture is detected.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onScrollFinishedProperty()">onScrollFinishedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a scrolling gesture ends.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onScrollProperty()">onScrollProperty</a></strong>()</code>
<div class="block">Defines a function to be called when user performs a scrolling action.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onScrollStartedProperty()">onScrollStartedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a scrolling gesture is detected.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onSwipeDownProperty()">onSwipeDownProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a downward swipe gesture
 centered over this node happens.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onSwipeLeftProperty()">onSwipeLeftProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a leftward swipe gesture
 centered over this node happens.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onSwipeRightProperty()">onSwipeRightProperty</a></strong>()</code>
<div class="block">Defines a function to be called when an rightward swipe gesture
 centered over this node happens.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onSwipeUpProperty()">onSwipeUpProperty</a></strong>()</code>
<div class="block">Defines a function to be called when an upward swipe gesture
 centered over this node happens.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onTouchMovedProperty()">onTouchMovedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a touch point is moved.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onTouchPressedProperty()">onTouchPressedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a new touch point is pressed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onTouchReleasedProperty()">onTouchReleasedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a touch point is released.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onTouchStationaryProperty()">onTouchStationaryProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a touch point stays pressed and
 still.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onZoomFinishedProperty()">onZoomFinishedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a zooming gesture ends.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onZoomProperty()">onZoomProperty</a></strong>()</code>
<div class="block">Defines a function to be called when user performs a zooming action.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#onZoomStartedProperty()">onZoomStartedProperty</a></strong>()</code>
<div class="block">Defines a function to be called when a zooming gesture is detected.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#opacityProperty()">opacityProperty</a></strong>()</code>
<div class="block">Specifies how opaque (that is, solid) the <code>Node</code> appears.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="Parent.html" title="class in javafx.scene">Parent</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#parentProperty()">parentProperty</a></strong>()</code>
<div class="block">The parent of this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#parentToLocal(javafx.geometry.Bounds)">parentToLocal</a></strong>(<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;parentBounds)</code>
<div class="block">Transforms a rectangle from the coordinate space of the parent into the
 local coordinate space of this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#parentToLocal(double, double)">parentToLocal</a></strong>(double&nbsp;parentX,
             double&nbsp;parentY)</code>
<div class="block">Transforms a point from the coordinate space of the parent into the
 local coordinate space of this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#parentToLocal(javafx.geometry.Point2D)">parentToLocal</a></strong>(<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;parentPoint)</code>
<div class="block">Transforms a point from the coordinate space of the parent into the
 local coordinate space of this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#pickOnBoundsProperty()">pickOnBoundsProperty</a></strong>()</code>
<div class="block">Defines how the picking computation is done for this node when
 triggered by a <code>MouseEvent</code> or a <code>contains</code> function call.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#prefHeight(double)">prefHeight</a></strong>(double&nbsp;width)</code>
<div class="block">Returns the node's preferred height for use in layout calculations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="Node.html#prefWidth(double)">prefWidth</a></strong>(double&nbsp;height)</code>
<div class="block">Returns the node's preferred width for use in layout calculations.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#pressedProperty()">pressedProperty</a></strong>()</code>
<div class="block">Whether or not the <code>Node</code> is pressed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#relocate(double, double)">relocate</a></strong>(double&nbsp;x,
        double&nbsp;y)</code>
<div class="block">Sets the node's layoutX and layoutY translation properties in order to
 relocate this node to the x,y location in the parent.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&lt;T extends <a href="../event/Event.html" title="class in javafx.event">Event</a>&gt;&nbsp;<br>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#removeEventFilter(javafx.event.EventType, javafx.event.EventHandler)">removeEventFilter</a></strong>(<a href="../event/EventType.html" title="class in javafx.event">EventType</a>&lt;T&gt;&nbsp;eventType,
                 <a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super T&gt;&nbsp;eventFilter)</code>
<div class="block">Unregisters a previously registered event filter from this node.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&lt;T extends <a href="../event/Event.html" title="class in javafx.event">Event</a>&gt;&nbsp;<br>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#removeEventHandler(javafx.event.EventType, javafx.event.EventHandler)">removeEventHandler</a></strong>(<a href="../event/EventType.html" title="class in javafx.event">EventType</a>&lt;T&gt;&nbsp;eventType,
                  <a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super T&gt;&nbsp;eventHandler)</code>
<div class="block">Unregisters a previously registered event handler from this node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#requestFocus()">requestFocus</a></strong>()</code>
<div class="block">Requests that this <code>Node</code> get the input focus, and that this
 <code>Node</code>'s top-level ancestor become the focused window.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#resize(double, double)">resize</a></strong>(double&nbsp;width,
      double&nbsp;height)</code>
<div class="block">If the node is resizable, will set its layout bounds to the specified
 width and height.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#resizeRelocate(double, double, double, double)">resizeRelocate</a></strong>(double&nbsp;x,
              double&nbsp;y,
              double&nbsp;width,
              double&nbsp;height)</code>
<div class="block">If the node is resizable, will set its layout bounds to the specified
 width and height.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#rotateProperty()">rotateProperty</a></strong>()</code>
<div class="block">Defines the angle of rotation about the <code>Node</code>'s center, measured in
 degrees.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../geometry/Point3D.html" title="class in javafx.geometry">Point3D</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#rotationAxisProperty()">rotationAxisProperty</a></strong>()</code>
<div class="block">Defines the axis of rotation of this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#scaleXProperty()">scaleXProperty</a></strong>()</code>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the X axis of this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#scaleYProperty()">scaleYProperty</a></strong>()</code>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the Y axis of this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#scaleZProperty()">scaleZProperty</a></strong>()</code>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the Z axis of this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="Scene.html" title="class in javafx.scene">Scene</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="Node.html#sceneProperty()">sceneProperty</a></strong>()</code>
<div class="block">The <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> that this <code>Node</code> is part of.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#sceneToLocal(javafx.geometry.Bounds)">sceneToLocal</a></strong>(<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;sceneBounds)</code>
<div class="block">Transforms a rectangle from the coordinate space of the
 <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> into the local coordinate space of this
 <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#sceneToLocal(double, double)">sceneToLocal</a></strong>(double&nbsp;sceneX,
            double&nbsp;sceneY)</code>
<div class="block">Transforms a point from the coordinate space of the <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>
 into the local coordinate space of this <code>Node</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#sceneToLocal(javafx.geometry.Point2D)">sceneToLocal</a></strong>(<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;scenePoint)</code>
<div class="block">Transforms a point from the coordinate space of the <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>
 into the local coordinate space of this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setBlendMode(javafx.scene.effect.BlendMode)">setBlendMode</a></strong>(<a href="effect/BlendMode.html" title="enum in javafx.scene.effect">BlendMode</a>&nbsp;value)</code>
<div class="block">Sets the value of the property blendMode.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setCache(boolean)">setCache</a></strong>(boolean&nbsp;value)</code>
<div class="block">Sets the value of the property cache.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setCacheHint(javafx.scene.CacheHint)">setCacheHint</a></strong>(<a href="CacheHint.html" title="enum in javafx.scene">CacheHint</a>&nbsp;value)</code>
<div class="block">Sets the value of the property cacheHint.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setClip(javafx.scene.Node)">setClip</a></strong>(<a href="Node.html" title="class in javafx.scene">Node</a>&nbsp;value)</code>
<div class="block">Sets the value of the property clip.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setCursor(javafx.scene.Cursor)">setCursor</a></strong>(<a href="Cursor.html" title="class in javafx.scene">Cursor</a>&nbsp;value)</code>
<div class="block">Sets the value of the property cursor.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setDepthTest(javafx.scene.DepthTest)">setDepthTest</a></strong>(<a href="DepthTest.html" title="enum in javafx.scene">DepthTest</a>&nbsp;value)</code>
<div class="block">Sets the value of the property depthTest.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setDisable(boolean)">setDisable</a></strong>(boolean&nbsp;value)</code>
<div class="block">Sets the value of the property disable.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setDisabled(boolean)">setDisabled</a></strong>(boolean&nbsp;value)</code>
<div class="block">Sets the value of the property disabled.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setEffect(javafx.scene.effect.Effect)">setEffect</a></strong>(<a href="effect/Effect.html" title="class in javafx.scene.effect">Effect</a>&nbsp;value)</code>
<div class="block">Sets the value of the property effect.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setEventDispatcher(javafx.event.EventDispatcher)">setEventDispatcher</a></strong>(<a href="../event/EventDispatcher.html" title="interface in javafx.event">EventDispatcher</a>&nbsp;value)</code>
<div class="block">Sets the value of the property eventDispatcher.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected &lt;T extends <a href="../event/Event.html" title="class in javafx.event">Event</a>&gt;&nbsp;<br>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setEventHandler(javafx.event.EventType, javafx.event.EventHandler)">setEventHandler</a></strong>(<a href="../event/EventType.html" title="class in javafx.event">EventType</a>&lt;T&gt;&nbsp;eventType,
               <a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super T&gt;&nbsp;eventHandler)</code>
<div class="block">Sets the handler to use for this event type.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setFocused(boolean)">setFocused</a></strong>(boolean&nbsp;value)</code>
<div class="block">Sets the value of the property focused.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setFocusTraversable(boolean)">setFocusTraversable</a></strong>(boolean&nbsp;value)</code>
<div class="block">Sets the value of the property focusTraversable.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setHover(boolean)">setHover</a></strong>(boolean&nbsp;value)</code>
<div class="block">Sets the value of the property hover.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setId(java.lang.String)">setId</a></strong>(java.lang.String&nbsp;value)</code>
<div class="block">Sets the value of the property id.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setInputMethodRequests(javafx.scene.input.InputMethodRequests)">setInputMethodRequests</a></strong>(<a href="input/InputMethodRequests.html" title="interface in javafx.scene.input">InputMethodRequests</a>&nbsp;value)</code>
<div class="block">Sets the value of the property inputMethodRequests.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setLayoutX(double)">setLayoutX</a></strong>(double&nbsp;value)</code>
<div class="block">Sets the value of the property layoutX.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setLayoutY(double)">setLayoutY</a></strong>(double&nbsp;value)</code>
<div class="block">Sets the value of the property layoutY.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setManaged(boolean)">setManaged</a></strong>(boolean&nbsp;value)</code>
<div class="block">Sets the value of the property managed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setMouseTransparent(boolean)">setMouseTransparent</a></strong>(boolean&nbsp;value)</code>
<div class="block">Sets the value of the property mouseTransparent.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnContextMenuRequested(javafx.event.EventHandler)">setOnContextMenuRequested</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ContextMenuEvent.html" title="class in javafx.scene.input">ContextMenuEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onContextMenuRequested.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnDragDetected(javafx.event.EventHandler)">setOnDragDetected</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onDragDetected.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnDragDone(javafx.event.EventHandler)">setOnDragDone</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onDragDone.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnDragDropped(javafx.event.EventHandler)">setOnDragDropped</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onDragDropped.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnDragEntered(javafx.event.EventHandler)">setOnDragEntered</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onDragEntered.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnDragExited(javafx.event.EventHandler)">setOnDragExited</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onDragExited.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnDragOver(javafx.event.EventHandler)">setOnDragOver</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onDragOver.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnInputMethodTextChanged(javafx.event.EventHandler)">setOnInputMethodTextChanged</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/InputMethodEvent.html" title="class in javafx.scene.input">InputMethodEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onInputMethodTextChanged.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnKeyPressed(javafx.event.EventHandler)">setOnKeyPressed</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onKeyPressed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnKeyReleased(javafx.event.EventHandler)">setOnKeyReleased</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onKeyReleased.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnKeyTyped(javafx.event.EventHandler)">setOnKeyTyped</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onKeyTyped.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnMouseClicked(javafx.event.EventHandler)">setOnMouseClicked</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onMouseClicked.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnMouseDragEntered(javafx.event.EventHandler)">setOnMouseDragEntered</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onMouseDragEntered.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnMouseDragExited(javafx.event.EventHandler)">setOnMouseDragExited</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onMouseDragExited.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnMouseDragged(javafx.event.EventHandler)">setOnMouseDragged</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onMouseDragged.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnMouseDragOver(javafx.event.EventHandler)">setOnMouseDragOver</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onMouseDragOver.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnMouseDragReleased(javafx.event.EventHandler)">setOnMouseDragReleased</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onMouseDragReleased.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnMouseEntered(javafx.event.EventHandler)">setOnMouseEntered</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onMouseEntered.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnMouseExited(javafx.event.EventHandler)">setOnMouseExited</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onMouseExited.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnMouseMoved(javafx.event.EventHandler)">setOnMouseMoved</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onMouseMoved.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnMousePressed(javafx.event.EventHandler)">setOnMousePressed</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onMousePressed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnMouseReleased(javafx.event.EventHandler)">setOnMouseReleased</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onMouseReleased.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnRotate(javafx.event.EventHandler)">setOnRotate</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onRotate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnRotationFinished(javafx.event.EventHandler)">setOnRotationFinished</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onRotationFinished.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnRotationStarted(javafx.event.EventHandler)">setOnRotationStarted</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onRotationStarted.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnScroll(javafx.event.EventHandler)">setOnScroll</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onScroll.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnScrollFinished(javafx.event.EventHandler)">setOnScrollFinished</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onScrollFinished.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnScrollStarted(javafx.event.EventHandler)">setOnScrollStarted</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onScrollStarted.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnSwipeDown(javafx.event.EventHandler)">setOnSwipeDown</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onSwipeDown.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnSwipeLeft(javafx.event.EventHandler)">setOnSwipeLeft</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onSwipeLeft.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnSwipeRight(javafx.event.EventHandler)">setOnSwipeRight</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onSwipeRight.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnSwipeUp(javafx.event.EventHandler)">setOnSwipeUp</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onSwipeUp.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnTouchMoved(javafx.event.EventHandler)">setOnTouchMoved</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onTouchMoved.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnTouchPressed(javafx.event.EventHandler)">setOnTouchPressed</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onTouchPressed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnTouchReleased(javafx.event.EventHandler)">setOnTouchReleased</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onTouchReleased.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnTouchStationary(javafx.event.EventHandler)">setOnTouchStationary</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onTouchStationary.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnZoom(javafx.event.EventHandler)">setOnZoom</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onZoom.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnZoomFinished(javafx.event.EventHandler)">setOnZoomFinished</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onZoomFinished.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOnZoomStarted(javafx.event.EventHandler)">setOnZoomStarted</a></strong>(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&nbsp;value)</code>
<div class="block">Sets the value of the property onZoomStarted.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setOpacity(double)">setOpacity</a></strong>(double&nbsp;value)</code>
<div class="block">Sets the value of the property opacity.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setPickOnBounds(boolean)">setPickOnBounds</a></strong>(boolean&nbsp;value)</code>
<div class="block">Sets the value of the property pickOnBounds.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setPressed(boolean)">setPressed</a></strong>(boolean&nbsp;value)</code>
<div class="block">Sets the value of the property pressed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setRotate(double)">setRotate</a></strong>(double&nbsp;value)</code>
<div class="block">Sets the value of the property rotate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setRotationAxis(javafx.geometry.Point3D)">setRotationAxis</a></strong>(<a href="../geometry/Point3D.html" title="class in javafx.geometry">Point3D</a>&nbsp;value)</code>
<div class="block">Sets the value of the property rotationAxis.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setScaleX(double)">setScaleX</a></strong>(double&nbsp;value)</code>
<div class="block">Sets the value of the property scaleX.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setScaleY(double)">setScaleY</a></strong>(double&nbsp;value)</code>
<div class="block">Sets the value of the property scaleY.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setScaleZ(double)">setScaleZ</a></strong>(double&nbsp;value)</code>
<div class="block">Sets the value of the property scaleZ.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setStyle(java.lang.String)">setStyle</a></strong>(java.lang.String&nbsp;value)</code>
<div class="block">A string representation of the CSS style associated with this
 specific <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setTranslateX(double)">setTranslateX</a></strong>(double&nbsp;value)</code>
<div class="block">Sets the value of the property translateX.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setTranslateY(double)">setTranslateY</a></strong>(double&nbsp;value)</code>
<div class="block">Sets the value of the property translateY.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setTranslateZ(double)">setTranslateZ</a></strong>(double&nbsp;value)</code>
<div class="block">Sets the value of the property translateZ.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setUserData(java.lang.Object)">setUserData</a></strong>(java.lang.Object&nbsp;value)</code>
<div class="block">Convenience method for setting a single Object property that can be
 retrieved at a later date.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#setVisible(boolean)">setVisible</a></strong>(boolean&nbsp;value)</code>
<div class="block">Sets the value of the property visible.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#snapshot(javafx.util.Callback, javafx.scene.SnapshotParameters, javafx.scene.image.WritableImage)">snapshot</a></strong>(<a href="../util/Callback.html" title="interface in javafx.util">Callback</a>&lt;<a href="SnapshotResult.html" title="class in javafx.scene">SnapshotResult</a>,java.lang.Void&gt;&nbsp;callback,
        <a href="SnapshotParameters.html" title="class in javafx.scene">SnapshotParameters</a>&nbsp;params,
        <a href="image/WritableImage.html" title="class in javafx.scene.image">WritableImage</a>&nbsp;image)</code>
<div class="block">Takes a snapshot of this node at the next frame and calls the
 specified callback method when the image is ready.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="image/WritableImage.html" title="class in javafx.scene.image">WritableImage</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#snapshot(javafx.scene.SnapshotParameters, javafx.scene.image.WritableImage)">snapshot</a></strong>(<a href="SnapshotParameters.html" title="class in javafx.scene">SnapshotParameters</a>&nbsp;params,
        <a href="image/WritableImage.html" title="class in javafx.scene.image">WritableImage</a>&nbsp;image)</code>
<div class="block">Takes a snapshot of this node and returns the rendered image when
 it is ready.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="input/Dragboard.html" title="class in javafx.scene.input">Dragboard</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#startDragAndDrop(javafx.scene.input.TransferMode...)">startDragAndDrop</a></strong>(<a href="input/TransferMode.html" title="enum in javafx.scene.input">TransferMode</a>...&nbsp;transferModes)</code>
<div class="block">Confirms a potential drag and drop gesture that is recognized over this
 <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#startFullDrag()">startFullDrag</a></strong>()</code>
<div class="block">Starts a full press-drag-release gesture with this node as gesture
 source.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/StringProperty.html" title="class in javafx.beans.property">StringProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#styleProperty()">styleProperty</a></strong>()</code>
<div class="block">A string representation of the CSS style associated with this
 specific <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#toBack()">toBack</a></strong>()</code>
<div class="block">Moves this <code>Node</code> to the back of its sibling nodes in terms of
 z-order.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="Node.html#toFront()">toFront</a></strong>()</code>
<div class="block">Moves this <code>Node</code> to the front of its sibling nodes in terms of
 z-order.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="Node.html#toString()">toString</a></strong>()</code>
<div class="block">Returns a string representation for the object.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#translateXProperty()">translateXProperty</a></strong>()</code>
<div class="block">Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#translateYProperty()">translateYProperty</a></strong>()</code>
<div class="block">Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#translateZProperty()">translateZProperty</a></strong>()</code>
<div class="block">Defines the Z coordinate of the translation that is added to the
 transformed coordinates of this <code>Node</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a></code></td>
<td class="colLast"><code><strong><a href="Node.html#visibleProperty()">visibleProperty</a></strong>()</code>
<div class="block">Specifies whether this <code>Node</code> and any subnodes should be rendered
 as part of the scene graph.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ PROPERTY DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="property_detail">
<!--   -->
</a>
<h3>Property Detail</h3>
<a name="parentProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parent</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="Parent.html" title="class in javafx.scene">Parent</a>&gt; parentProperty</pre>
<div class="block">The parent of this <code>Node</code>. If this <code>Node</code> has not been added
 to a scene graph, then parent will be null.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getParent()"><code>getParent()</code></a></dd></dl>
</li>
</ul>
<a name="sceneProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scene</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="Scene.html" title="class in javafx.scene">Scene</a>&gt; sceneProperty</pre>
<div class="block">The <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> that this <code>Node</code> is part of. If the Node is not
 part of a scene, then this variable will be null.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getScene()"><code>getScene()</code></a></dd></dl>
</li>
</ul>
<a name="idProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>id</h4>
<pre>public final&nbsp;<a href="../beans/property/StringProperty.html" title="class in javafx.beans.property">StringProperty</a> idProperty</pre>
<div class="block">The id of this <code>Node</code>. This simple string identifier is useful for
 finding a specific Node within the scene graph. While the id of a Node
 should be unique within the scene graph, this uniqueness is not enforced.
 This is analogous to the "id" attribute on an HTML element 
 (<a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">CSS ID Specification</a>).
 <p>
     For example, if a Node is given the id of "myId", then the lookup method can
     be used to find this node as follows: <code>scene.lookup("#myId");</code>.
 </p></div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getId()"><code>getId()</code></a>, 
<a href="Node.html#setId(java.lang.String)"><code>setId(String)</code></a></dd></dl>
</li>
</ul>
<a name="styleProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>style</h4>
<pre>public final&nbsp;<a href="../beans/property/StringProperty.html" title="class in javafx.beans.property">StringProperty</a> styleProperty</pre>
<div class="block">A string representation of the CSS style associated with this
 specific <code>Node</code>. This is analogous to the "style" attribute of an
 HTML element. Note that, like the HTML style attribute, this
 variable contains style properties and values and not the
 selector portion of a style rule.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>empty string</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getStyle()"><code>getStyle()</code></a>, 
<a href="Node.html#setStyle(java.lang.String)"><code>setStyle(String)</code></a></dd></dl>
</li>
</ul>
<a name="visibleProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>visible</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a> visibleProperty</pre>
<div class="block">Specifies whether this <code>Node</code> and any subnodes should be rendered
 as part of the scene graph. A node may be visible and yet not be shown
 in the rendered scene if, for instance, it is off the screen or obscured
 by another Node. Invisible nodes never receive mouse events or
 keyboard focus and never maintain keyboard focus when they become
 invisible.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>true</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isVisible()"><code>isVisible()</code></a>, 
<a href="Node.html#setVisible(boolean)"><code>setVisible(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="cursorProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cursor</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="Cursor.html" title="class in javafx.scene">Cursor</a>&gt; cursorProperty</pre>
<div class="block">Defines the mouse cursor for this <code>Node</code> and subnodes. If null,
 then the cursor of the first parent node with a non-null cursor will be
 used. If no Node in the scene graph defines a cursor, then the cursor
 of the <code>Scene</code> will be used.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getCursor()"><code>getCursor()</code></a>, 
<a href="Node.html#setCursor(javafx.scene.Cursor)"><code>setCursor(Cursor)</code></a></dd></dl>
</li>
</ul>
<a name="opacityProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>opacity</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a> opacityProperty</pre>
<div class="block">Specifies how opaque (that is, solid) the <code>Node</code> appears. A Node
 with 0% opacity is fully translucent. That is, while it is still
 <a href="Node.html#visibleProperty()"><code>visible</code></a> and rendered, you generally won't be able to see it. The
 exception to this rule is when the <code>Node</code> is combined with a
 blending mode and blend effect in which case a translucent Node may still
 have an impact in rendering. An opacity of 50% will render the node as
 being 50% transparent.
 <p>
 A <a href="Node.html#visibleProperty()"><code>visible</code></a> node with any opacity setting still receives mouse
 events and can receive keyboard focus. For example, if you want to have
 a large invisible rectangle overlay all <code>Node</code>s in the scene graph
 in order to intercept mouse events but not be visible to the user, you could
 create a large <code>Rectangle</code> that had an opacity of 0%.
 <p>
 Opacity is specified as a value between 0 and 1. Values less than 0 are
 treated as 0, values greater than 1 are treated as 1.
 <p>
 On some platforms ImageView might not support opacity variable.

 <p>
 There is a known limitation of mixing opacity < 1.0 with a 3D Transform.
 Opacity/Blending is essentially a 2D image operation. The result of
 an opacity < 1.0 set on a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children
 will cause its children to be rendered in order without Z-buffering
 applied between those children.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOpacity()"><code>getOpacity()</code></a>, 
<a href="Node.html#setOpacity(double)"><code>setOpacity(double)</code></a></dd></dl>
</li>
</ul>
<a name="blendModeProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blendMode</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="effect/BlendMode.html" title="enum in javafx.scene.effect">BlendMode</a>&gt; blendModeProperty</pre>
<div class="block">The <a href="effect/BlendMode.html" title="enum in javafx.scene.effect"><code>BlendMode</code></a> used to blend this individual node
 into the scene behind it. If this node happens to be a Group then all of the
 children will be composited individually into a temporary buffer using their
 own blend modes and then that temporary buffer will be composited into the
 scene using the specified blend mode.

 A value of <code>null</code> is treated as pass-though this means no effect on a
 parent such as a Group and the equivalent of SRC_OVER for a single Node.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getBlendMode()"><code>getBlendMode()</code></a>, 
<a href="Node.html#setBlendMode(javafx.scene.effect.BlendMode)"><code>setBlendMode(BlendMode)</code></a></dd></dl>
</li>
</ul>
<a name="clipProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clip</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="Node.html" title="class in javafx.scene">Node</a>&gt; clipProperty</pre>
<div class="block">Specifies a <code>Node</code> to use to define the the clipping shape for this
 Node. This clipping Node is not a child of this <code>Node</code> in the scene
 graph sense. Rather, it is used to define the clip for this <code>Node</code>.
 <p>
 For example, you can use an <a href="image/ImageView.html" title="class in javafx.scene.image"><code>ImageView</code></a> Node as
 a mask to represent the Clip. Or you could use one of the geometric shape
 Nodes such as <a href="shape/Rectangle.html" title="class in javafx.scene.shape"><code>Rectangle</code></a> or
 <a href="shape/Circle.html" title="class in javafx.scene.shape"><code>Circle</code></a>. Or you could use a
 <a href="text/Text.html" title="class in javafx.scene.text"><code>Text</code></a> node to represent the Clip.
 <p>
 See the class documentation for <a href="Node.html" title="class in javafx.scene"><code>Node</code></a> for scene graph structure
 restrictions on setting the clip. If these restrictions are violated by
 a change to the clip variable, the change is ignored and the
 previous value of the clip variable is restored.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SHAPE_CLIP"><code>ConditionalFeature.SHAPE_CLIP</code></a>
 for more information.
 <p>
 There is a known limitation of mixing Clip with a 3D Transform.
 Clipping is essentially a 2D image operation. The result of
 a Clip set on a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children
 will cause its children to be rendered in order without Z-buffering
 applied between those children.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getClip()"><code>getClip()</code></a>, 
<a href="Node.html#setClip(javafx.scene.Node)"><code>setClip(Node)</code></a></dd></dl>
</li>
</ul>
<a name="cacheProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cache</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a> cacheProperty</pre>
<div class="block">A performance hint to the system to indicate that this <code>Node</code>
 should be cached as a bitmap. Rendering a bitmap representation of a node
 will be faster than rendering primitives in many cases, especially in the
 case of primitives with effects applied (such as a blur). However, it
 also increases memory usage. This hint indicates whether that trade-off
 (increased memory usage for increased performance) is worthwhile. Also
 note that on some platforms such as GPU accelerated platforms there is
 little benefit to caching Nodes as bitmaps when blurs and other effects
 are used since they are very fast to render on the GPU.

 The <a href="Node.html#cacheHintProperty()"><code>cacheHintProperty()</code></a> variable provides additional options for enabling
 more aggressive bitmap caching.

 <p>
 Caching may be disabled for any node that has a 3D transform on itself,
 any of its ancestors, or any of its descendants.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#cacheHintProperty()"><code>cacheHintProperty()</code></a>, 
<a href="Node.html#isCache()"><code>isCache()</code></a>, 
<a href="Node.html#setCache(boolean)"><code>setCache(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="cacheHintProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cacheHint</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="CacheHint.html" title="enum in javafx.scene">CacheHint</a>&gt; cacheHintProperty</pre>
<div class="block">Additional hint for controlling bitmap caching.
 <p>
 Under certain circumstances, such as animating nodes that are very
 expensive to render, it is desirable to be able to perform
 transformations on the node without having to regenerate the cached
 bitmap.  An option in such cases is to perform the transforms on the
 cached bitmap itself.
 <p>
 This technique can provide a dramatic improvement to animation
 performance, though may also result in a reduction in visual quality.
 The <code>cacheHint</code> variable provides a hint to the system about how
 and when that trade-off (visual quality for animation performance) is
 acceptable.
 <p>
 It is possible to enable the cacheHint only at times when your node is
 animating.  In this way, expensive nodes can appear on screen with full
 visual quality, yet still animate smoothly.
 <p>
 Example:
 <pre><code>
        expensiveNode.setCache(true);
        expensiveNode.setCacheHint(CacheHint.QUALITY);
        ...
        // Do an animation
        expensiveNode.setCacheHint(CacheHint.SPEED);
        new Timeline(
            new KeyFrame(Duration.seconds(2),
                new KeyValue(expensiveNode.scaleXProperty(), 2.0),
                new KeyValue(expensiveNode.scaleYProperty(), 2.0),
                new KeyValue(expensiveNode.rotateProperty(), 360),
                new KeyValue(expensiveNode.cacheHintProperty(), CacheHint.QUALITY)
            )
        ).play();
     </code></pre>

 Note that <code>cacheHint</code> is only a hint to the system.  Depending on
 the details of the node or the transform, this hint may be ignored.

 <p>
 If <code>Node.cache</code> is false, cacheHint is ignored.
 Caching may be disabled for any node that has a 3D transform on itself,
 any of its ancestors, or any of its descendants.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>JavaFX 1.3</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>CacheHint.DEFAULT</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#cacheProperty()"><code>cacheProperty()</code></a>, 
<a href="Node.html#getCacheHint()"><code>getCacheHint()</code></a>, 
<a href="Node.html#setCacheHint(javafx.scene.CacheHint)"><code>setCacheHint(CacheHint)</code></a></dd></dl>
</li>
</ul>
<a name="effectProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>effect</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="effect/Effect.html" title="class in javafx.scene.effect">Effect</a>&gt; effectProperty</pre>
<div class="block">Specifies an effect to apply to this <code>Node</code>.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#EFFECT"><code>ConditionalFeature.EFFECT</code></a>
 for more information.

 <p>
 There is a known limitation of mixing Effect with a 3D Transform. Effect is
 essentially a 2D image operation. The result of an Effect set on
 a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children will cause its children
 to be rendered in order without Z-buffering applied between those
 children.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getEffect()"><code>getEffect()</code></a>, 
<a href="Node.html#setEffect(javafx.scene.effect.Effect)"><code>setEffect(Effect)</code></a></dd></dl>
</li>
</ul>
<a name="depthTestProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>depthTest</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="DepthTest.html" title="enum in javafx.scene">DepthTest</a>&gt; depthTestProperty</pre>
<div class="block">Indicates whether depth testing is used when rendering this node.
 If the depthTest flag is <code>DepthTest.DISABLE</code>, then depth testing
 is disabled for this node.
 If the depthTest flag is <code>DepthTest.ENABLE</code>, then depth testing
 is enabled for this node.
 If the depthTest flag is <code>DepthTest.INHERIT</code>, then depth testing
 is enabled for this node if it is enabled for the parent node or the
 parent node is null.
 <p>
 The depthTest flag is only used when the depthBuffer flag for
 the <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> is true (meaning that the
 <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> has an associated depth buffer)
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.
<p>
 See the constructor in Scene with depthBuffer as one of its input
 arguments.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>INHERIT</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>, 
<a href="Node.html#getDepthTest()"><code>getDepthTest()</code></a>, 
<a href="Node.html#setDepthTest(javafx.scene.DepthTest)"><code>setDepthTest(DepthTest)</code></a></dd></dl>
</li>
</ul>
<a name="disableProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>disable</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a> disableProperty</pre>
<div class="block">Sets the individual disabled state of this <code>Node</code>. Setting
 <code>disable</code> to true will cause this <code>Node</code> and any subnodes to
 become disabled. This variable should be used only to set the disabled
 state of a <code>Node</code>.  For querying the disabled state of a
 <code>Node</code>, the <a href="Node.html#disabledProperty()"><code>disabled</code></a> variable should instead be used,
 since it is possible that a <code>Node</code> was disabled as a result of an
 ancestor being disabled even if the individual <code>disable</code> state on
 this <code>Node</code> is <code>false</code>.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isDisable()"><code>isDisable()</code></a>, 
<a href="Node.html#setDisable(boolean)"><code>setDisable(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="pickOnBoundsProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pickOnBounds</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a> pickOnBoundsProperty</pre>
<div class="block">Defines how the picking computation is done for this node when
 triggered by a <code>MouseEvent</code> or a <code>contains</code> function call.

 If <code>pickOnBounds</code> is true, then picking is computed by
 intersecting with the bounds of this node, else picking is computed
 by intersecting with the geometric shape of this node.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isPickOnBounds()"><code>isPickOnBounds()</code></a>, 
<a href="Node.html#setPickOnBounds(boolean)"><code>setPickOnBounds(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="disabledProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>disabled</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a> disabledProperty</pre>
<div class="block">Indicates whether or not this <code>Node</code> is disabled.  A <code>Node</code>
 will become disabled if <a href="Node.html#disableProperty()"><code>disable</code></a> is set to <code>true</code> on either
 itself or one of its ancestors in the scene graph.
 <p>
 A disabled <code>Node</code> should render itself differently to indicate its
 disabled state to the user.
 Such disabled rendering is dependent on the implementation of the
 <code>Node</code>. The shape classes contained in <code>javafx.scene.shape</code>
 do not implement such rendering by default, therefore applications using
 shapes for handling input must implement appropriate disabled rendering
 themselves. The user-interface controls defined in
 <code>javafx.scene.control</code> will implement disabled-sensitive rendering,
 however.
 <p>
 A disabled <code>Node</code> does not receive mouse or key events.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isDisabled()"><code>isDisabled()</code></a>, 
<a href="Node.html#setDisabled(boolean)"><code>setDisabled(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="onDragEnteredProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragEntered</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt; onDragEnteredProperty</pre>
<div class="block">Defines a function to be called when drag gesture
 enters this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragEntered()"><code>getOnDragEntered()</code></a>, 
<a href="Node.html#setOnDragEntered(javafx.event.EventHandler)"><code>setOnDragEntered(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onDragExitedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragExited</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt; onDragExitedProperty</pre>
<div class="block">Defines a function to be called when drag gesture
 exits this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragExited()"><code>getOnDragExited()</code></a>, 
<a href="Node.html#setOnDragExited(javafx.event.EventHandler)"><code>setOnDragExited(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onDragOverProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragOver</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt; onDragOverProperty</pre>
<div class="block">Defines a function to be called when drag gesture progresses within
 this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragOver()"><code>getOnDragOver()</code></a>, 
<a href="Node.html#setOnDragOver(javafx.event.EventHandler)"><code>setOnDragOver(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onDragDroppedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragDropped</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt; onDragDroppedProperty</pre>
<div class="block">Defines a function to be called when the mouse button is released
 on this <code>Node</code> during drag and drop gesture. Transfer of data from
 the <a href="input/DragEvent.html" title="class in javafx.scene.input"><code>DragEvent</code></a>'s <a href="input/DragEvent.html#dragboard"><code>dragboard</code></a> should
 happen in this function.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragDropped()"><code>getOnDragDropped()</code></a>, 
<a href="Node.html#setOnDragDropped(javafx.event.EventHandler)"><code>setOnDragDropped(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onDragDoneProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragDone</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt; onDragDoneProperty</pre>
<div class="block">Defines a function to be called when this <code>Node</code> is a
 drag and drop gesture source after its data has
 been dropped on a drop target. The <code>transferMode</code> of the
 event shows what just happened at the drop target.
 If <code>transferMode</code> has the value <code>MOVE</code>, then the source can
 clear out its data. Clearing the source's data gives the appropriate
 appearance to a user that the data has been moved by the drag and drop
 gesture. A <code>transferMode</code> that has the value <code>NONE</code>
 indicates that no data was transferred during the drag and drop gesture.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragDone()"><code>getOnDragDone()</code></a>, 
<a href="Node.html#setOnDragDone(javafx.event.EventHandler)"><code>setOnDragDone(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="managedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>managed</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a> managedProperty</pre>
<div class="block">Defines whether or not this node's layout will be managed by it's parent.
 If the node is managed, it's parent will factor the node's geometry
 into its own preferred size and <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>
 calculations and will lay it
 out during the scene's layout pass.  If a managed node's layoutBounds
 changes, it will automatically trigger relayout up the scene-graph
 to the nearest layout root (which is typically the scene's root node).
 <p>
 If the node is unmanaged, its parent will ignore the child in both preferred
 size computations and layout.   Changes in layoutBounds will not trigger
 relayout above it.   If an unmanaged node is of type <a href="Parent.html" title="class in javafx.scene"><code>Parent</code></a>,
 it will act as a "layout root", meaning that calls to <a href="Parent.html#requestLayout()"><code>Parent.requestLayout()</code></a>
 beneath it will cause only the branch rooted by the node to be relayed out,
 thereby isolating layout changes to that root and below.  It's the application's
 responsibility to set the size and position of an unmanaged node.
 <p>
 By default all nodes are managed.
 </p></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isManaged()"><code>isManaged()</code></a>, 
<a href="Node.html#setManaged(boolean)"><code>setManaged(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="layoutXProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>layoutX</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a> layoutXProperty</pre>
<div class="block">Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.  The value should be computed as the
 offset required to adjust the position of the node from its current
 <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds minX</code></a> position (which might not be 0) to the desired location.

 <p>For example, if <code>textnode</code> should be positioned at <code>finalX</code>
 <code><pre>
     textnode.setLayoutX(finalX - textnode.getLayoutBounds().getMinX());
 </pre></code>
 <p>
 Failure to subtract <code>layoutBounds minX</code> may result in misplacement
 of the node.  The <a href="Node.html#relocate(double, double)"><code>relocate(x, y)</code></a> method will automatically do the
 correct computation and should generally be used over setting layoutX directly.
 <p>
 The node's final translation will be computed as <code>layoutX</code> + <a href="Node.html#translateXProperty()"><code>translateX</code></a>,
 where <code>layoutX</code> establishes the node's stable position
 and <code>translateX</code> optionally makes dynamic adjustments to that
 position.
 <p>
 If the node is managed and has a <a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>
 as its parent, then the layout region will set <code>layoutX</code> according to its
 own layout policy.   If the node is unmanaged or parented by a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>,
 then the application may set <code>layoutX</code> directly to position it.
 <p></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getLayoutX()"><code>getLayoutX()</code></a>, 
<a href="Node.html#setLayoutX(double)"><code>setLayoutX(double)</code></a></dd></dl>
</li>
</ul>
<a name="layoutYProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>layoutY</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a> layoutYProperty</pre>
<div class="block">Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.  The value should be computed as the
 offset required to adjust the position of the node from its current
 <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds minY</code></a> position (which might not be 0) to the desired location.

 <p>For example, if <code>textnode</code> should be positioned at <code>finalY</code>
 <code><pre>
     textnode.setLayoutY(finalY - textnode.getLayoutBounds().getMinY());
 </pre></code>
 <p>
 Failure to subtract <code>layoutBounds minY</code> may result in misplacement
 of the node.  The <a href="Node.html#relocate(double, double)"><code>relocate(x, y)</code></a> method will automatically do the
 correct computation and should generally be used over setting layoutY directly.
 <p>
 The node's final translation will be computed as <code>layoutY</code> + <a href="Node.html#translateYProperty()"><code>translateY</code></a>,
 where <code>layoutY</code> establishes the node's stable position
 and <code>translateY</code> optionally makes dynamic adjustments to that
 position.
 <p>
 If the node is managed and has a <a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>
 as its parent, then the region will set <code>layoutY</code> according to its
 own layout policy.   If the node is unmanaged or parented by a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>,
 then the application may set <code>layoutY</code> directly to position it.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getLayoutY()"><code>getLayoutY()</code></a>, 
<a href="Node.html#setLayoutY(double)"><code>setLayoutY(double)</code></a></dd></dl>
</li>
</ul>
<a name="boundsInParentProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boundsInParent</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt; boundsInParentProperty</pre>
<div class="block">The rectangular bounds of this <code>Node</code> which include its transforms.
 <code>boundsInParent</code> is calculated by
 taking the local bounds (defined by <a href="Node.html#boundsInLocalProperty()"><code>boundsInLocal</code></a>) and applying
 the transform created by setting the following additional variables
 <ol>
 <li><a href="Node.html#getTransforms()"><code>transforms</code></a> ObservableList</li>
 <li><a href="Node.html#scaleXProperty()"><code>scaleX</code></a>, <a href="Node.html#scaleYProperty()"><code>scaleY</code></a></li>
 <li><a href="Node.html#rotateProperty()"><code>rotate</code></a></li>
 <li><a href="Node.html#layoutXProperty()"><code>layoutX</code></a>, <a href="Node.html#layoutYProperty()"><code>layoutY</code></a></li>
 <li><a href="Node.html#translateXProperty()"><code>translateX</code></a>, <a href="Node.html#translateYProperty()"><code>translateY</code></a></li>
 </ol>
 <p>
 The resulting bounds will be conceptually in the coordinate space of the
 <code>Node</code>'s parent, however the node need not have a parent to calculate
 these bounds.
 <p>
 Note that this method does not take the node's visibility into account;
 the computation is based on the geometry of this <code>Node</code> only.
 <p>
 This property will always have a non-null value.
 <p>
 Note that boundsInParent is automatically recomputed whenever the
 geometry of a node changes, or when any of the following the change:
 transforms ObservableList, translateX, translateY, layoutX, layoutY,
 scaleX, scaleY, or the rotate variable. For this reason, it is an error
 to bind any of these values in a node to an expression that depends upon
 this variable. For example, the x or y variables of a shape, or
 translateX, translateY should never be bound to boundsInParent
 for the purpose of positioning the node.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getBoundsInParent()"><code>getBoundsInParent()</code></a></dd></dl>
</li>
</ul>
<a name="boundsInLocalProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boundsInLocal</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt; boundsInLocalProperty</pre>
<div class="block">The rectangular bounds of this <code>Node</code> in the node's
 untransformed local coordinate space.  For nodes that extend
 <a href="shape/Shape.html" title="class in javafx.scene.shape"><code>Shape</code></a>, the local bounds will also include
 space required for a non-zero stroke that may fall outside the shape's
 geometry that is defined by position and size attributes.
 The local bounds will also include any clipping set with <a href="Node.html#clipProperty()"><code>clip</code></a>
 as well as effects set with <a href="Node.html#effectProperty()"><code>effect</code></a>.

 <p>
 Note that this method does not take the node's visibility into account;
 the computation is based on the geometry of this <code>Node</code> only.
 <p>
 This property will always have a non-null value.
 <p>
 Note that boundsInLocal is automatically recomputed whenever the
 geometry of a node changes. For this reason, it is an error to bind any
 of these values in a node to an expression that depends upon this variable.
 For example, the x or y variables of a shape should never be bound
 to boundsInLocal for the purpose of positioning the node.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getBoundsInLocal()"><code>getBoundsInLocal()</code></a></dd></dl>
</li>
</ul>
<a name="layoutBoundsProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>layoutBounds</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt; layoutBoundsProperty</pre>
<div class="block">The rectangular bounds that should be used for layout calculations for
 this node. <code>layoutBounds</code> may differ from the visual bounds
 of the node and is computed differently depending on the node type.
 <p>
 If the node type is resizable (<a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>,
 <a href="control/Control.html" title="class in javafx.scene.control"><code>Control</code></a>, or <a href="web/WebView.html" title="class in javafx.scene.web"><code>WebView</code></a>)
 then the layoutBounds will always be <code>0,0 width x height</code>.
 If the node type is not resizable (<a href="shape/Shape.html" title="class in javafx.scene.shape"><code>Shape</code></a>,
 <a href="text/Text.html" title="class in javafx.scene.text"><code>Text</code></a>, or <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>), then the layoutBounds
 are computed based on the node's geometric properties and does not include the
 node's clip, effect, or transforms.  See individual class documentation
 for details.
 <p>
 Note that the <a href="Node.html#layoutXProperty()"><code>layoutX</code></a>, <a href="Node.html#layoutYProperty()"><code>layoutY</code></a>, <a href="Node.html#translateXProperty()"><code>translateX</code></a>, and
 <a href="Node.html#translateYProperty()"><code>translateY</code></a> variables are not included in the layoutBounds.
 This is important because layout code must first determine the current
 size and location of the node (using layoutBounds) and then set
 <code>layoutX</code> and <code>layoutY</code> to adjust the translation of the
 node so that it will have the desired layout position.
 <p>
 Because the computation of layoutBounds is often tied to a node's
 geometric variables, it is an error to bind any such variables to an
 expression that depends upon <code>layoutBounds</code>. For example, the
 x or y variables of a shape should never be bound to layoutBounds
 for the purpose of positioning the node.
 <p>
 The layoutBounds will never be null.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getLayoutBounds()"><code>getLayoutBounds()</code></a></dd></dl>
</li>
</ul>
<a name="translateXProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>translateX</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a> translateXProperty</pre>
<div class="block">Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform.
 <p>
 The node's final translation will be computed as <a href="Node.html#layoutXProperty()"><code>layoutX</code></a> + <code>translateX</code>,
 where <code>layoutX</code> establishes the node's stable position and <code>translateX</code>
 optionally makes dynamic adjustments to that position.
<p>
 This variable can be used to alter the location of a node without disturbing
 its <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>, which makes it useful for animating a node's location.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getTranslateX()"><code>getTranslateX()</code></a>, 
<a href="Node.html#setTranslateX(double)"><code>setTranslateX(double)</code></a></dd></dl>
</li>
</ul>
<a name="translateYProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>translateY</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a> translateYProperty</pre>
<div class="block">Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform.
 <p>
 The node's final translation will be computed as <a href="Node.html#layoutYProperty()"><code>layoutY</code></a> + <code>translateY</code>,
 where <code>layoutY</code> establishes the node's stable position and <code>translateY</code>
 optionally makes dynamic adjustments to that position.
<p>
 This variable can be used to alter the location of a node without disturbing
 its <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>, which makes it useful for animating a node's location.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getTranslateY()"><code>getTranslateY()</code></a>, 
<a href="Node.html#setTranslateY(double)"><code>setTranslateY(double)</code></a></dd></dl>
</li>
</ul>
<a name="translateZProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>translateZ</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a> translateZProperty</pre>
<div class="block">Defines the Z coordinate of the translation that is added to the
 transformed coordinates of this <code>Node</code>.  This value will be added
 to any translation defined by the <code>transforms</code> ObservableList and
 <code>layoutZ</code>.
<p>
 This variable can be used to alter the location of a Node without
 disturbing its layout bounds, which makes it useful for animating a
 node's location.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>JavaFX 1.3</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getTranslateZ()"><code>getTranslateZ()</code></a>, 
<a href="Node.html#setTranslateZ(double)"><code>setTranslateZ(double)</code></a></dd></dl>
</li>
</ul>
<a name="scaleXProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scaleX</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a> scaleXProperty</pre>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the X axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getScaleX()"><code>getScaleX()</code></a>, 
<a href="Node.html#setScaleX(double)"><code>setScaleX(double)</code></a></dd></dl>
</li>
</ul>
<a name="scaleYProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scaleY</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a> scaleYProperty</pre>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the Y axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getScaleY()"><code>getScaleY()</code></a>, 
<a href="Node.html#setScaleY(double)"><code>setScaleY(double)</code></a></dd></dl>
</li>
</ul>
<a name="scaleZProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scaleZ</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a> scaleZProperty</pre>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the Z axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 rectangular bounds formed by taking <a href="Node.html#boundsInLocalProperty()"><code>boundsInLocal</code></a> and applying
 all the transforms in the <a href="Node.html#getTransforms()"><code>transforms</code></a> ObservableList.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>JavaFX 1.3</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getScaleZ()"><code>getScaleZ()</code></a>, 
<a href="Node.html#setScaleZ(double)"><code>setScaleZ(double)</code></a></dd></dl>
</li>
</ul>
<a name="rotateProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotate</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a> rotateProperty</pre>
<div class="block">Defines the angle of rotation about the <code>Node</code>'s center, measured in
 degrees. This is used to rotate the <code>Node</code>.
 <p>
 This rotation factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for rotating the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the rotation occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.
 <p>
 Note that because the pivot point is computed as the center of this
 <code>Node</code>'s layout bounds, any change to the layout bounds will cause
 the pivot point to change, which can move the object. For a leaf node,
 any change to the geometry will cause the layout bounds to change.
 For a group node, any change to any of its children, including a
 change in a child's geometry, clip, effect, position, orientation, or
 scale, will cause the group's layout bounds to change. If this movement
 of the pivot point is not
 desired, applications should instead use the Node's <a href="Node.html#getTransforms()"><code>transforms</code></a>
 ObservableList, and add a <a href="transform/Rotate.html" title="class in javafx.scene.transform"><code>Rotate</code></a> transform,
 which has a user-specifiable pivot point.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>0.0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getRotate()"><code>getRotate()</code></a>, 
<a href="Node.html#setRotate(double)"><code>setRotate(double)</code></a></dd></dl>
</li>
</ul>
<a name="rotationAxisProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotationAxis</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../geometry/Point3D.html" title="class in javafx.geometry">Point3D</a>&gt; rotationAxisProperty</pre>
<div class="block">Defines the axis of rotation of this <code>Node</code>.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>JavaFX 1.3</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>Rotate.Z_AXIS</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getRotationAxis()"><code>getRotationAxis()</code></a>, 
<a href="Node.html#setRotationAxis(javafx.geometry.Point3D)"><code>setRotationAxis(Point3D)</code></a></dd></dl>
</li>
</ul>
<a name="localToParentTransformProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localToParentTransform</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&gt; localToParentTransformProperty</pre>
<div class="block">An affine transform that holds the computed local-to-parent transform.
 This is the concatenation of all transforms in this node, including all
 of the convenience transforms.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getLocalToParentTransform()"><code>getLocalToParentTransform()</code></a></dd></dl>
</li>
</ul>
<a name="localToSceneTransformProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localToSceneTransform</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&gt; localToSceneTransformProperty</pre>
<div class="block">An affine transform that holds the computed local-to-scene transform.
 This is the concatenation of all transforms in this node's parents and
 in this node, including all of the convenience transforms.

 <p>
 Note that when you register a listener or a binding to this property,
 it needs to listen for invalidation on all its parents to the root node.
 This means that registering a listener on this
 property on many nodes may negatively affect performance of
 transformation changes in their common parents.
 </p></div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getLocalToSceneTransform()"><code>getLocalToSceneTransform()</code></a></dd></dl>
</li>
</ul>
<a name="mouseTransparentProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mouseTransparent</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a> mouseTransparentProperty</pre>
<div class="block">If <code>true</code>, this node (together with all its children) is completely
 transparent to mouse events. When choosing target for mouse event, nodes
 with <code>mouseTransparent</code> set to <code>true</code> and their subtrees
 won't be taken into account.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isMouseTransparent()"><code>isMouseTransparent()</code></a>, 
<a href="Node.html#setMouseTransparent(boolean)"><code>setMouseTransparent(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="hoverProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hover</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a> hoverProperty</pre>
<div class="block">Whether or not this <code>Node</code> is being hovered over. Typically this is
 due to the mouse being over the node, though it could be due to a pen
 hovering on a graphics tablet or other form of input.

 <p>Note that current implementation of hover relies on mouse enter and
 exit events to determine whether this Node is in the hover state; this
 means that this feature is currently supported only on systems that
 have a mouse. Future implementations may provide alternative means of
 supporting hover.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isHover()"><code>isHover()</code></a>, 
<a href="Node.html#setHover(boolean)"><code>setHover(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="pressedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pressed</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a> pressedProperty</pre>
<div class="block">Whether or not the <code>Node</code> is pressed. Typically this is true when
 the primary mouse button is down, though subclasses may define other
 mouse button state or key state to cause the node to be "pressed".</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isPressed()"><code>isPressed()</code></a>, 
<a href="Node.html#setPressed(boolean)"><code>setPressed(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="onContextMenuRequestedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onContextMenuRequested</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ContextMenuEvent.html" title="class in javafx.scene.input">ContextMenuEvent</a>&gt;&gt; onContextMenuRequestedProperty</pre>
<div class="block">Defines a function to be called when a context menu
 has been requested on this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnContextMenuRequested()"><code>getOnContextMenuRequested()</code></a>, 
<a href="Node.html#setOnContextMenuRequested(javafx.event.EventHandler)"><code>setOnContextMenuRequested(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onMouseClickedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseClicked</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt; onMouseClickedProperty</pre>
<div class="block">Defines a function to be called when a mouse button has been clicked
 (pressed and released) on this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseClicked()"><code>getOnMouseClicked()</code></a>, 
<a href="Node.html#setOnMouseClicked(javafx.event.EventHandler)"><code>setOnMouseClicked(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onMouseDraggedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseDragged</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt; onMouseDraggedProperty</pre>
<div class="block">Defines a function to be called when a mouse button is pressed
 on this <code>Node</code> and then dragged.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseDragged()"><code>getOnMouseDragged()</code></a>, 
<a href="Node.html#setOnMouseDragged(javafx.event.EventHandler)"><code>setOnMouseDragged(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onMouseEnteredProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseEntered</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt; onMouseEnteredProperty</pre>
<div class="block">Defines a function to be called when the mouse enters this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseEntered()"><code>getOnMouseEntered()</code></a>, 
<a href="Node.html#setOnMouseEntered(javafx.event.EventHandler)"><code>setOnMouseEntered(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onMouseExitedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseExited</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt; onMouseExitedProperty</pre>
<div class="block">Defines a function to be called when the mouse exits this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseExited()"><code>getOnMouseExited()</code></a>, 
<a href="Node.html#setOnMouseExited(javafx.event.EventHandler)"><code>setOnMouseExited(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onMouseMovedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseMoved</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt; onMouseMovedProperty</pre>
<div class="block">Defines a function to be called when mouse cursor moves within
 this <code>Node</code> but no buttons have been pushed.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseMoved()"><code>getOnMouseMoved()</code></a>, 
<a href="Node.html#setOnMouseMoved(javafx.event.EventHandler)"><code>setOnMouseMoved(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onMousePressedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMousePressed</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt; onMousePressedProperty</pre>
<div class="block">Defines a function to be called when a mouse button
 has been pressed on this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMousePressed()"><code>getOnMousePressed()</code></a>, 
<a href="Node.html#setOnMousePressed(javafx.event.EventHandler)"><code>setOnMousePressed(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onMouseReleasedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseReleased</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt; onMouseReleasedProperty</pre>
<div class="block">Defines a function to be called when a mouse button
 has been released on this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseReleased()"><code>getOnMouseReleased()</code></a>, 
<a href="Node.html#setOnMouseReleased(javafx.event.EventHandler)"><code>setOnMouseReleased(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onDragDetectedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragDetected</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt; onDragDetectedProperty</pre>
<div class="block">Defines a function to be called when drag gesture has been
 detected. This is the right place to start drag and drop operation.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragDetected()"><code>getOnDragDetected()</code></a>, 
<a href="Node.html#setOnDragDetected(javafx.event.EventHandler)"><code>setOnDragDetected(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onMouseDragOverProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseDragOver</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt; onMouseDragOverProperty</pre>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 progresses within this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseDragOver()"><code>getOnMouseDragOver()</code></a>, 
<a href="Node.html#setOnMouseDragOver(javafx.event.EventHandler)"><code>setOnMouseDragOver(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onMouseDragReleasedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseDragReleased</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt; onMouseDragReleasedProperty</pre>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 ends (by releasing mouse button) within this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseDragReleased()"><code>getOnMouseDragReleased()</code></a>, 
<a href="Node.html#setOnMouseDragReleased(javafx.event.EventHandler)"><code>setOnMouseDragReleased(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onMouseDragEnteredProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseDragEntered</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt; onMouseDragEnteredProperty</pre>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 enters this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseDragEntered()"><code>getOnMouseDragEntered()</code></a>, 
<a href="Node.html#setOnMouseDragEntered(javafx.event.EventHandler)"><code>setOnMouseDragEntered(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onMouseDragExitedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseDragExited</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt; onMouseDragExitedProperty</pre>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 leaves this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseDragExited()"><code>getOnMouseDragExited()</code></a>, 
<a href="Node.html#setOnMouseDragExited(javafx.event.EventHandler)"><code>setOnMouseDragExited(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onScrollStartedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onScrollStarted</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt; onScrollStartedProperty</pre>
<div class="block">Defines a function to be called when a scrolling gesture is detected.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnScrollStarted()"><code>getOnScrollStarted()</code></a>, 
<a href="Node.html#setOnScrollStarted(javafx.event.EventHandler)"><code>setOnScrollStarted(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onScrollProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onScroll</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt; onScrollProperty</pre>
<div class="block">Defines a function to be called when user performs a scrolling action.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnScroll()"><code>getOnScroll()</code></a>, 
<a href="Node.html#setOnScroll(javafx.event.EventHandler)"><code>setOnScroll(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onScrollFinishedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onScrollFinished</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt; onScrollFinishedProperty</pre>
<div class="block">Defines a function to be called when a scrolling gesture ends.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnScrollFinished()"><code>getOnScrollFinished()</code></a>, 
<a href="Node.html#setOnScrollFinished(javafx.event.EventHandler)"><code>setOnScrollFinished(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onRotationStartedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onRotationStarted</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt; onRotationStartedProperty</pre>
<div class="block">Defines a function to be called when a rotation gesture is detected.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnRotationStarted()"><code>getOnRotationStarted()</code></a>, 
<a href="Node.html#setOnRotationStarted(javafx.event.EventHandler)"><code>setOnRotationStarted(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onRotateProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onRotate</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt; onRotateProperty</pre>
<div class="block">Defines a function to be called when user performs a rotation action.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnRotate()"><code>getOnRotate()</code></a>, 
<a href="Node.html#setOnRotate(javafx.event.EventHandler)"><code>setOnRotate(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onRotationFinishedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onRotationFinished</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt; onRotationFinishedProperty</pre>
<div class="block">Defines a function to be called when a rotation gesture ends.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnRotationFinished()"><code>getOnRotationFinished()</code></a>, 
<a href="Node.html#setOnRotationFinished(javafx.event.EventHandler)"><code>setOnRotationFinished(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onZoomStartedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onZoomStarted</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt; onZoomStartedProperty</pre>
<div class="block">Defines a function to be called when a zooming gesture is detected.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnZoomStarted()"><code>getOnZoomStarted()</code></a>, 
<a href="Node.html#setOnZoomStarted(javafx.event.EventHandler)"><code>setOnZoomStarted(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onZoomProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onZoom</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt; onZoomProperty</pre>
<div class="block">Defines a function to be called when user performs a zooming action.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnZoom()"><code>getOnZoom()</code></a>, 
<a href="Node.html#setOnZoom(javafx.event.EventHandler)"><code>setOnZoom(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onZoomFinishedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onZoomFinished</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt; onZoomFinishedProperty</pre>
<div class="block">Defines a function to be called when a zooming gesture ends.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnZoomFinished()"><code>getOnZoomFinished()</code></a>, 
<a href="Node.html#setOnZoomFinished(javafx.event.EventHandler)"><code>setOnZoomFinished(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onSwipeUpProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onSwipeUp</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt; onSwipeUpProperty</pre>
<div class="block">Defines a function to be called when an upward swipe gesture
 centered over this node happens.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnSwipeUp()"><code>getOnSwipeUp()</code></a>, 
<a href="Node.html#setOnSwipeUp(javafx.event.EventHandler)"><code>setOnSwipeUp(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onSwipeDownProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onSwipeDown</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt; onSwipeDownProperty</pre>
<div class="block">Defines a function to be called when a downward swipe gesture
 centered over this node happens.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnSwipeDown()"><code>getOnSwipeDown()</code></a>, 
<a href="Node.html#setOnSwipeDown(javafx.event.EventHandler)"><code>setOnSwipeDown(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onSwipeLeftProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onSwipeLeft</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt; onSwipeLeftProperty</pre>
<div class="block">Defines a function to be called when a leftward swipe gesture
 centered over this node happens.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnSwipeLeft()"><code>getOnSwipeLeft()</code></a>, 
<a href="Node.html#setOnSwipeLeft(javafx.event.EventHandler)"><code>setOnSwipeLeft(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onSwipeRightProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onSwipeRight</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt; onSwipeRightProperty</pre>
<div class="block">Defines a function to be called when an rightward swipe gesture
 centered over this node happens.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnSwipeRight()"><code>getOnSwipeRight()</code></a>, 
<a href="Node.html#setOnSwipeRight(javafx.event.EventHandler)"><code>setOnSwipeRight(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onTouchPressedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onTouchPressed</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt; onTouchPressedProperty</pre>
<div class="block">Defines a function to be called when a new touch point is pressed.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnTouchPressed()"><code>getOnTouchPressed()</code></a>, 
<a href="Node.html#setOnTouchPressed(javafx.event.EventHandler)"><code>setOnTouchPressed(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onTouchMovedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onTouchMoved</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt; onTouchMovedProperty</pre>
<div class="block">Defines a function to be called when a touch point is moved.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnTouchMoved()"><code>getOnTouchMoved()</code></a>, 
<a href="Node.html#setOnTouchMoved(javafx.event.EventHandler)"><code>setOnTouchMoved(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onTouchReleasedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onTouchReleased</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt; onTouchReleasedProperty</pre>
<div class="block">Defines a function to be called when a touch point is released.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnTouchReleased()"><code>getOnTouchReleased()</code></a>, 
<a href="Node.html#setOnTouchReleased(javafx.event.EventHandler)"><code>setOnTouchReleased(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onTouchStationaryProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onTouchStationary</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt; onTouchStationaryProperty</pre>
<div class="block">Defines a function to be called when a touch point stays pressed and
 still.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnTouchStationary()"><code>getOnTouchStationary()</code></a>, 
<a href="Node.html#setOnTouchStationary(javafx.event.EventHandler)"><code>setOnTouchStationary(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onKeyPressedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onKeyPressed</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt; onKeyPressedProperty</pre>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been pressed. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnKeyPressed()"><code>getOnKeyPressed()</code></a>, 
<a href="Node.html#setOnKeyPressed(javafx.event.EventHandler)"><code>setOnKeyPressed(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onKeyReleasedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onKeyReleased</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt; onKeyReleasedProperty</pre>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been released. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnKeyReleased()"><code>getOnKeyReleased()</code></a>, 
<a href="Node.html#setOnKeyReleased(javafx.event.EventHandler)"><code>setOnKeyReleased(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onKeyTypedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onKeyTyped</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt; onKeyTypedProperty</pre>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been typed. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnKeyTyped()"><code>getOnKeyTyped()</code></a>, 
<a href="Node.html#setOnKeyTyped(javafx.event.EventHandler)"><code>setOnKeyTyped(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="onInputMethodTextChangedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onInputMethodTextChanged</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/InputMethodEvent.html" title="class in javafx.scene.input">InputMethodEvent</a>&gt;&gt; onInputMethodTextChangedProperty</pre>
<div class="block">Defines a function to be called when this <code>Node</code>
 has input focus and the input method text has changed.  If this
 function is not defined in this <code>Node</code>, then it
 receives the result string of the input method composition as a
 series of <code>onKeyTyped</code> function calls.
 </p>
 When the <code>Node</code> loses the input focus, the JavaFX runtime
 automatically commits the existing composed text if any.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnInputMethodTextChanged()"><code>getOnInputMethodTextChanged()</code></a>, 
<a href="Node.html#setOnInputMethodTextChanged(javafx.event.EventHandler)"><code>setOnInputMethodTextChanged(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="inputMethodRequestsProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inputMethodRequests</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="input/InputMethodRequests.html" title="interface in javafx.scene.input">InputMethodRequests</a>&gt; inputMethodRequestsProperty</pre>
<div class="block">Property holding InputMethodRequests.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>InputMethodRequestsProperty</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getInputMethodRequests()"><code>getInputMethodRequests()</code></a>, 
<a href="Node.html#setInputMethodRequests(javafx.scene.input.InputMethodRequests)"><code>setInputMethodRequests(InputMethodRequests)</code></a></dd></dl>
</li>
</ul>
<a name="focusedProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>focused</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a> focusedProperty</pre>
<div class="block">Indicates whether this <code>Node</code> currently has the input focus.
 To have the input focus, a node must be the <code>Scene</code>'s focus
 owner, and the scene must be in a <code>Stage</code> that is visible
 and active. See <a href="Node.html#requestFocus()"><code>requestFocus()</code></a> for more information.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isFocused()"><code>isFocused()</code></a>, 
<a href="Node.html#setFocused(boolean)"><code>setFocused(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="focusTraversableProperty">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>focusTraversable</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a> focusTraversableProperty</pre>
<div class="block">Specifies whether this <code>Node</code> should be a part of focus traversal
 cycle. When this property is <code>true</code> focus can be moved to this
 <code>Node</code> and from this <code>Node</code> using regular focus traversal
 keys. On a desktop such keys are usually <code>TAB</code> for moving focus
 forward and <code>SHIFT+TAB</code> for moving focus backward.

 When a <code>Scene</code> is created, the system gives focus to a
 <code>Node</code> whose <code>focusTraversable</code> variable is true
 and that is eligible to receive the focus,
 unless the focus had been set explicitly via a call
 to <a href="Node.html#requestFocus()"><code>requestFocus()</code></a>.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isFocusTraversable()"><code>isFocusTraversable()</code></a>, 
<a href="Node.html#setFocusTraversable(boolean)"><code>setFocusTraversable(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="eventDispatcherProperty">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>eventDispatcher</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventDispatcher.html" title="interface in javafx.event">EventDispatcher</a>&gt; eventDispatcherProperty</pre>
<div class="block">Specifies the event dispatcher for this node. The default event
 dispatcher sends the received events to the registered event handlers and
 filters. When replacing the value with a new <code>EventDispatcher</code>,
 the new dispatcher should forward events to the replaced dispatcher
 to maintain the node's default event handling behavior.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getEventDispatcher()"><code>getEventDispatcher()</code></a>, 
<a href="Node.html#setEventDispatcher(javafx.event.EventDispatcher)"><code>setEventDispatcher(EventDispatcher)</code></a></dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Node()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Node</h4>
<pre>protected&nbsp;Node()</pre>
<div class="block">Creates a new instance of Node.</div>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="getProperties()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProperties</h4>
<pre>public final&nbsp;<a href="../collections/ObservableMap.html" title="interface in javafx.collections">ObservableMap</a>&lt;java.lang.Object,java.lang.Object&gt;&nbsp;getProperties()</pre>
<div class="block">Returns an observable map of properties on this node for use primarily
 by application developers.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>an observable map of properties on this node for use primarily
 by application developers</dd></dl>
</li>
</ul>
<a name="hasProperties()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasProperties</h4>
<pre>public&nbsp;boolean&nbsp;hasProperties()</pre>
<div class="block">Tests if Node has properties.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true if node has properties.</dd></dl>
</li>
</ul>
<a name="setUserData(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUserData</h4>
<pre>public&nbsp;void&nbsp;setUserData(java.lang.Object&nbsp;value)</pre>
<div class="block">Convenience method for setting a single Object property that can be
 retrieved at a later date. This is functionally equivalent to calling
 the getProperties().put(Object key, Object value) method. This can later
 be retrieved by calling <a href="Node.html#getUserData()"><code>getUserData()</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>value</code> - The value to be stored - this can later be retrieved by calling
          <a href="Node.html#getUserData()"><code>getUserData()</code></a>.</dd></dl>
</li>
</ul>
<a name="getUserData()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUserData</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getUserData()</pre>
<div class="block">Returns a previously set Object property, or null if no such property
 has been set using the <a href="Node.html#setUserData(java.lang.Object)"><code>setUserData(java.lang.Object)</code></a> method.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>The Object that was previously set, or null if no property
          has been set or if null was set.</dd></dl>
</li>
</ul>
<a name="getParent()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getParent</h4>
<pre>public final&nbsp;<a href="Parent.html" title="class in javafx.scene">Parent</a>&nbsp;getParent()</pre>
<div class="block">Gets the value of the property parent.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>The parent of this <code>Node</code>. If this <code>Node</code> has not been added
 to a scene graph, then parent will be null.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="parentProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parentProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="Parent.html" title="class in javafx.scene">Parent</a>&gt;&nbsp;parentProperty()</pre>
<div class="block">The parent of this <code>Node</code>. If this <code>Node</code> has not been added
 to a scene graph, then parent will be null.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getParent()"><code>getParent()</code></a></dd></dl>
</li>
</ul>
<a name="getScene()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getScene</h4>
<pre>public final&nbsp;<a href="Scene.html" title="class in javafx.scene">Scene</a>&nbsp;getScene()</pre>
<div class="block">Gets the value of the property scene.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>The <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> that this <code>Node</code> is part of. If the Node is not
 part of a scene, then this variable will be null.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="sceneProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sceneProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="Scene.html" title="class in javafx.scene">Scene</a>&gt;&nbsp;sceneProperty()</pre>
<div class="block">The <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> that this <code>Node</code> is part of. If the Node is not
 part of a scene, then this variable will be null.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getScene()"><code>getScene()</code></a></dd></dl>
</li>
</ul>
<a name="setId(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setId</h4>
<pre>public final&nbsp;void&nbsp;setId(java.lang.String&nbsp;value)</pre>
<div class="block">Sets the value of the property id.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>The id of this <code>Node</code>. This simple string identifier is useful for
 finding a specific Node within the scene graph. While the id of a Node
 should be unique within the scene graph, this uniqueness is not enforced.
 This is analogous to the "id" attribute on an HTML element 
 (<a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">CSS ID Specification</a>).
 <p>
     For example, if a Node is given the id of "myId", then the lookup method can
     be used to find this node as follows: <code>scene.lookup("#myId");</code>.
 </p></dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="getId()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getId</h4>
<pre>public final&nbsp;java.lang.String&nbsp;getId()</pre>
<div class="block">The id of this <code>Node</code>. This simple string identifier is useful for
 finding a specific Node within the scene graph. While the id of a Node
 should be unique within the scene graph, this uniqueness is not enforced.
 This is analogous to the "id" attribute on an HTML element 
 (<a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">CSS ID Specification</a>).</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the id assigned to this <code>Node</code> using the <code>setId</code> 
         method or <code>null</code>, if no id has been assigned.</dd><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="idProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/StringProperty.html" title="class in javafx.beans.property">StringProperty</a>&nbsp;idProperty()</pre>
<div class="block">The id of this <code>Node</code>. This simple string identifier is useful for
 finding a specific Node within the scene graph. While the id of a Node
 should be unique within the scene graph, this uniqueness is not enforced.
 This is analogous to the "id" attribute on an HTML element 
 (<a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">CSS ID Specification</a>).
 <p>
     For example, if a Node is given the id of "myId", then the lookup method can
     be used to find this node as follows: <code>scene.lookup("#myId");</code>.
 </p></div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getId()"><code>getId()</code></a>, 
<a href="Node.html#setId(java.lang.String)"><code>setId(String)</code></a></dd></dl>
</li>
</ul>
<a name="getStyleClass()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStyleClass</h4>
<pre>public final&nbsp;<a href="../collections/ObservableList.html" title="interface in javafx.collections">ObservableList</a>&lt;java.lang.String&gt;&nbsp;getStyleClass()</pre>
</li>
</ul>
<a name="setStyle(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setStyle</h4>
<pre>public final&nbsp;void&nbsp;setStyle(java.lang.String&nbsp;value)</pre>
<div class="block">A string representation of the CSS style associated with this
 specific <code>Node</code>. This is analogous to the "style" attribute of an
 HTML element. Note that, like the HTML style attribute, this
 variable contains style properties and values and not the
 selector portion of a style rule.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>value</code> - The inline CSS style to use for this <code>Node</code>.
         <code>null</code> is implicitly converted to an empty String.</dd><dt><span class="strong">Default value:</span></dt>
  <dd>empty string</dd></dl>
</li>
</ul>
<a name="getStyle()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStyle</h4>
<pre>public final&nbsp;java.lang.String&nbsp;getStyle()</pre>
<div class="block">A string representation of the CSS style associated with this
 specific <code>Node</code>. This is analogous to the "style" attribute of an
 HTML element. Note that, like the HTML style attribute, this
 variable contains style properties and values and not the
 selector portion of a style rule.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>The inline CSS style associated with this <code>Node</code>.
         If this <code>Node</code> does not have an inline style,
         an empty String is returned.</dd><dt><span class="strong">Default value:</span></dt>
  <dd>empty string</dd></dl>
</li>
</ul>
<a name="styleProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>styleProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/StringProperty.html" title="class in javafx.beans.property">StringProperty</a>&nbsp;styleProperty()</pre>
<div class="block">A string representation of the CSS style associated with this
 specific <code>Node</code>. This is analogous to the "style" attribute of an
 HTML element. Note that, like the HTML style attribute, this
 variable contains style properties and values and not the
 selector portion of a style rule.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>empty string</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getStyle()"><code>getStyle()</code></a>, 
<a href="Node.html#setStyle(java.lang.String)"><code>setStyle(String)</code></a></dd></dl>
</li>
</ul>
<a name="setVisible(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setVisible</h4>
<pre>public final&nbsp;void&nbsp;setVisible(boolean&nbsp;value)</pre>
<div class="block">Sets the value of the property visible.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies whether this <code>Node</code> and any subnodes should be rendered
 as part of the scene graph. A node may be visible and yet not be shown
 in the rendered scene if, for instance, it is off the screen or obscured
 by another Node. Invisible nodes never receive mouse events or
 keyboard focus and never maintain keyboard focus when they become
 invisible.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>true</dd></dl>
</li>
</ul>
<a name="isVisible()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isVisible</h4>
<pre>public final&nbsp;boolean&nbsp;isVisible()</pre>
<div class="block">Gets the value of the property visible.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies whether this <code>Node</code> and any subnodes should be rendered
 as part of the scene graph. A node may be visible and yet not be shown
 in the rendered scene if, for instance, it is off the screen or obscured
 by another Node. Invisible nodes never receive mouse events or
 keyboard focus and never maintain keyboard focus when they become
 invisible.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>true</dd></dl>
</li>
</ul>
<a name="visibleProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>visibleProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a>&nbsp;visibleProperty()</pre>
<div class="block">Specifies whether this <code>Node</code> and any subnodes should be rendered
 as part of the scene graph. A node may be visible and yet not be shown
 in the rendered scene if, for instance, it is off the screen or obscured
 by another Node. Invisible nodes never receive mouse events or
 keyboard focus and never maintain keyboard focus when they become
 invisible.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>true</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isVisible()"><code>isVisible()</code></a>, 
<a href="Node.html#setVisible(boolean)"><code>setVisible(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setCursor(javafx.scene.Cursor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCursor</h4>
<pre>public final&nbsp;void&nbsp;setCursor(<a href="Cursor.html" title="class in javafx.scene">Cursor</a>&nbsp;value)</pre>
<div class="block">Sets the value of the property cursor.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the mouse cursor for this <code>Node</code> and subnodes. If null,
 then the cursor of the first parent node with a non-null cursor will be
 used. If no Node in the scene graph defines a cursor, then the cursor
 of the <code>Scene</code> will be used.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="getCursor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCursor</h4>
<pre>public final&nbsp;<a href="Cursor.html" title="class in javafx.scene">Cursor</a>&nbsp;getCursor()</pre>
<div class="block">Gets the value of the property cursor.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the mouse cursor for this <code>Node</code> and subnodes. If null,
 then the cursor of the first parent node with a non-null cursor will be
 used. If no Node in the scene graph defines a cursor, then the cursor
 of the <code>Scene</code> will be used.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="cursorProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cursorProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="Cursor.html" title="class in javafx.scene">Cursor</a>&gt;&nbsp;cursorProperty()</pre>
<div class="block">Defines the mouse cursor for this <code>Node</code> and subnodes. If null,
 then the cursor of the first parent node with a non-null cursor will be
 used. If no Node in the scene graph defines a cursor, then the cursor
 of the <code>Scene</code> will be used.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getCursor()"><code>getCursor()</code></a>, 
<a href="Node.html#setCursor(javafx.scene.Cursor)"><code>setCursor(Cursor)</code></a></dd></dl>
</li>
</ul>
<a name="setOpacity(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOpacity</h4>
<pre>public final&nbsp;void&nbsp;setOpacity(double&nbsp;value)</pre>
<div class="block">Sets the value of the property opacity.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies how opaque (that is, solid) the <code>Node</code> appears. A Node
 with 0% opacity is fully translucent. That is, while it is still
 <a href="Node.html#visibleProperty()"><code>visible</code></a> and rendered, you generally won't be able to see it. The
 exception to this rule is when the <code>Node</code> is combined with a
 blending mode and blend effect in which case a translucent Node may still
 have an impact in rendering. An opacity of 50% will render the node as
 being 50% transparent.
 <p>
 A <a href="Node.html#visibleProperty()"><code>visible</code></a> node with any opacity setting still receives mouse
 events and can receive keyboard focus. For example, if you want to have
 a large invisible rectangle overlay all <code>Node</code>s in the scene graph
 in order to intercept mouse events but not be visible to the user, you could
 create a large <code>Rectangle</code> that had an opacity of 0%.
 <p>
 Opacity is specified as a value between 0 and 1. Values less than 0 are
 treated as 0, values greater than 1 are treated as 1.
 <p>
 On some platforms ImageView might not support opacity variable.

 <p>
 There is a known limitation of mixing opacity < 1.0 with a 3D Transform.
 Opacity/Blending is essentially a 2D image operation. The result of
 an opacity < 1.0 set on a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children
 will cause its children to be rendered in order without Z-buffering
 applied between those children.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd></dl>
</li>
</ul>
<a name="getOpacity()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOpacity</h4>
<pre>public final&nbsp;double&nbsp;getOpacity()</pre>
<div class="block">Gets the value of the property opacity.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies how opaque (that is, solid) the <code>Node</code> appears. A Node
 with 0% opacity is fully translucent. That is, while it is still
 <a href="Node.html#visibleProperty()"><code>visible</code></a> and rendered, you generally won't be able to see it. The
 exception to this rule is when the <code>Node</code> is combined with a
 blending mode and blend effect in which case a translucent Node may still
 have an impact in rendering. An opacity of 50% will render the node as
 being 50% transparent.
 <p>
 A <a href="Node.html#visibleProperty()"><code>visible</code></a> node with any opacity setting still receives mouse
 events and can receive keyboard focus. For example, if you want to have
 a large invisible rectangle overlay all <code>Node</code>s in the scene graph
 in order to intercept mouse events but not be visible to the user, you could
 create a large <code>Rectangle</code> that had an opacity of 0%.
 <p>
 Opacity is specified as a value between 0 and 1. Values less than 0 are
 treated as 0, values greater than 1 are treated as 1.
 <p>
 On some platforms ImageView might not support opacity variable.

 <p>
 There is a known limitation of mixing opacity < 1.0 with a 3D Transform.
 Opacity/Blending is essentially a 2D image operation. The result of
 an opacity < 1.0 set on a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children
 will cause its children to be rendered in order without Z-buffering
 applied between those children.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd></dl>
</li>
</ul>
<a name="opacityProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>opacityProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a>&nbsp;opacityProperty()</pre>
<div class="block">Specifies how opaque (that is, solid) the <code>Node</code> appears. A Node
 with 0% opacity is fully translucent. That is, while it is still
 <a href="Node.html#visibleProperty()"><code>visible</code></a> and rendered, you generally won't be able to see it. The
 exception to this rule is when the <code>Node</code> is combined with a
 blending mode and blend effect in which case a translucent Node may still
 have an impact in rendering. An opacity of 50% will render the node as
 being 50% transparent.
 <p>
 A <a href="Node.html#visibleProperty()"><code>visible</code></a> node with any opacity setting still receives mouse
 events and can receive keyboard focus. For example, if you want to have
 a large invisible rectangle overlay all <code>Node</code>s in the scene graph
 in order to intercept mouse events but not be visible to the user, you could
 create a large <code>Rectangle</code> that had an opacity of 0%.
 <p>
 Opacity is specified as a value between 0 and 1. Values less than 0 are
 treated as 0, values greater than 1 are treated as 1.
 <p>
 On some platforms ImageView might not support opacity variable.

 <p>
 There is a known limitation of mixing opacity < 1.0 with a 3D Transform.
 Opacity/Blending is essentially a 2D image operation. The result of
 an opacity < 1.0 set on a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children
 will cause its children to be rendered in order without Z-buffering
 applied between those children.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOpacity()"><code>getOpacity()</code></a>, 
<a href="Node.html#setOpacity(double)"><code>setOpacity(double)</code></a></dd></dl>
</li>
</ul>
<a name="setBlendMode(javafx.scene.effect.BlendMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setBlendMode</h4>
<pre>public final&nbsp;void&nbsp;setBlendMode(<a href="effect/BlendMode.html" title="enum in javafx.scene.effect">BlendMode</a>&nbsp;value)</pre>
<div class="block">Sets the value of the property blendMode.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>The <a href="effect/BlendMode.html" title="enum in javafx.scene.effect"><code>BlendMode</code></a> used to blend this individual node
 into the scene behind it. If this node happens to be a Group then all of the
 children will be composited individually into a temporary buffer using their
 own blend modes and then that temporary buffer will be composited into the
 scene using the specified blend mode.

 A value of <code>null</code> is treated as pass-though this means no effect on a
 parent such as a Group and the equivalent of SRC_OVER for a single Node.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="getBlendMode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBlendMode</h4>
<pre>public final&nbsp;<a href="effect/BlendMode.html" title="enum in javafx.scene.effect">BlendMode</a>&nbsp;getBlendMode()</pre>
<div class="block">Gets the value of the property blendMode.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>The <a href="effect/BlendMode.html" title="enum in javafx.scene.effect"><code>BlendMode</code></a> used to blend this individual node
 into the scene behind it. If this node happens to be a Group then all of the
 children will be composited individually into a temporary buffer using their
 own blend modes and then that temporary buffer will be composited into the
 scene using the specified blend mode.

 A value of <code>null</code> is treated as pass-though this means no effect on a
 parent such as a Group and the equivalent of SRC_OVER for a single Node.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="blendModeProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blendModeProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="effect/BlendMode.html" title="enum in javafx.scene.effect">BlendMode</a>&gt;&nbsp;blendModeProperty()</pre>
<div class="block">The <a href="effect/BlendMode.html" title="enum in javafx.scene.effect"><code>BlendMode</code></a> used to blend this individual node
 into the scene behind it. If this node happens to be a Group then all of the
 children will be composited individually into a temporary buffer using their
 own blend modes and then that temporary buffer will be composited into the
 scene using the specified blend mode.

 A value of <code>null</code> is treated as pass-though this means no effect on a
 parent such as a Group and the equivalent of SRC_OVER for a single Node.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getBlendMode()"><code>getBlendMode()</code></a>, 
<a href="Node.html#setBlendMode(javafx.scene.effect.BlendMode)"><code>setBlendMode(BlendMode)</code></a></dd></dl>
</li>
</ul>
<a name="setClip(javafx.scene.Node)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setClip</h4>
<pre>public final&nbsp;void&nbsp;setClip(<a href="Node.html" title="class in javafx.scene">Node</a>&nbsp;value)</pre>
<div class="block">Sets the value of the property clip.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies a <code>Node</code> to use to define the the clipping shape for this
 Node. This clipping Node is not a child of this <code>Node</code> in the scene
 graph sense. Rather, it is used to define the clip for this <code>Node</code>.
 <p>
 For example, you can use an <a href="image/ImageView.html" title="class in javafx.scene.image"><code>ImageView</code></a> Node as
 a mask to represent the Clip. Or you could use one of the geometric shape
 Nodes such as <a href="shape/Rectangle.html" title="class in javafx.scene.shape"><code>Rectangle</code></a> or
 <a href="shape/Circle.html" title="class in javafx.scene.shape"><code>Circle</code></a>. Or you could use a
 <a href="text/Text.html" title="class in javafx.scene.text"><code>Text</code></a> node to represent the Clip.
 <p>
 See the class documentation for <a href="Node.html" title="class in javafx.scene"><code>Node</code></a> for scene graph structure
 restrictions on setting the clip. If these restrictions are violated by
 a change to the clip variable, the change is ignored and the
 previous value of the clip variable is restored.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SHAPE_CLIP"><code>ConditionalFeature.SHAPE_CLIP</code></a>
 for more information.
 <p>
 There is a known limitation of mixing Clip with a 3D Transform.
 Clipping is essentially a 2D image operation. The result of
 a Clip set on a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children
 will cause its children to be rendered in order without Z-buffering
 applied between those children.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="getClip()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClip</h4>
<pre>public final&nbsp;<a href="Node.html" title="class in javafx.scene">Node</a>&nbsp;getClip()</pre>
<div class="block">Gets the value of the property clip.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies a <code>Node</code> to use to define the the clipping shape for this
 Node. This clipping Node is not a child of this <code>Node</code> in the scene
 graph sense. Rather, it is used to define the clip for this <code>Node</code>.
 <p>
 For example, you can use an <a href="image/ImageView.html" title="class in javafx.scene.image"><code>ImageView</code></a> Node as
 a mask to represent the Clip. Or you could use one of the geometric shape
 Nodes such as <a href="shape/Rectangle.html" title="class in javafx.scene.shape"><code>Rectangle</code></a> or
 <a href="shape/Circle.html" title="class in javafx.scene.shape"><code>Circle</code></a>. Or you could use a
 <a href="text/Text.html" title="class in javafx.scene.text"><code>Text</code></a> node to represent the Clip.
 <p>
 See the class documentation for <a href="Node.html" title="class in javafx.scene"><code>Node</code></a> for scene graph structure
 restrictions on setting the clip. If these restrictions are violated by
 a change to the clip variable, the change is ignored and the
 previous value of the clip variable is restored.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SHAPE_CLIP"><code>ConditionalFeature.SHAPE_CLIP</code></a>
 for more information.
 <p>
 There is a known limitation of mixing Clip with a 3D Transform.
 Clipping is essentially a 2D image operation. The result of
 a Clip set on a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children
 will cause its children to be rendered in order without Z-buffering
 applied between those children.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="clipProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clipProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="Node.html" title="class in javafx.scene">Node</a>&gt;&nbsp;clipProperty()</pre>
<div class="block">Specifies a <code>Node</code> to use to define the the clipping shape for this
 Node. This clipping Node is not a child of this <code>Node</code> in the scene
 graph sense. Rather, it is used to define the clip for this <code>Node</code>.
 <p>
 For example, you can use an <a href="image/ImageView.html" title="class in javafx.scene.image"><code>ImageView</code></a> Node as
 a mask to represent the Clip. Or you could use one of the geometric shape
 Nodes such as <a href="shape/Rectangle.html" title="class in javafx.scene.shape"><code>Rectangle</code></a> or
 <a href="shape/Circle.html" title="class in javafx.scene.shape"><code>Circle</code></a>. Or you could use a
 <a href="text/Text.html" title="class in javafx.scene.text"><code>Text</code></a> node to represent the Clip.
 <p>
 See the class documentation for <a href="Node.html" title="class in javafx.scene"><code>Node</code></a> for scene graph structure
 restrictions on setting the clip. If these restrictions are violated by
 a change to the clip variable, the change is ignored and the
 previous value of the clip variable is restored.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SHAPE_CLIP"><code>ConditionalFeature.SHAPE_CLIP</code></a>
 for more information.
 <p>
 There is a known limitation of mixing Clip with a 3D Transform.
 Clipping is essentially a 2D image operation. The result of
 a Clip set on a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children
 will cause its children to be rendered in order without Z-buffering
 applied between those children.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getClip()"><code>getClip()</code></a>, 
<a href="Node.html#setClip(javafx.scene.Node)"><code>setClip(Node)</code></a></dd></dl>
</li>
</ul>
<a name="setCache(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCache</h4>
<pre>public final&nbsp;void&nbsp;setCache(boolean&nbsp;value)</pre>
<div class="block">Sets the value of the property cache.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>A performance hint to the system to indicate that this <code>Node</code>
 should be cached as a bitmap. Rendering a bitmap representation of a node
 will be faster than rendering primitives in many cases, especially in the
 case of primitives with effects applied (such as a blur). However, it
 also increases memory usage. This hint indicates whether that trade-off
 (increased memory usage for increased performance) is worthwhile. Also
 note that on some platforms such as GPU accelerated platforms there is
 little benefit to caching Nodes as bitmaps when blurs and other effects
 are used since they are very fast to render on the GPU.

 The <a href="Node.html#cacheHintProperty()"><code>cacheHintProperty()</code></a> variable provides additional options for enabling
 more aggressive bitmap caching.

 <p>
 Caching may be disabled for any node that has a 3D transform on itself,
 any of its ancestors, or any of its descendants.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="isCache()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isCache</h4>
<pre>public final&nbsp;boolean&nbsp;isCache()</pre>
<div class="block">Gets the value of the property cache.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>A performance hint to the system to indicate that this <code>Node</code>
 should be cached as a bitmap. Rendering a bitmap representation of a node
 will be faster than rendering primitives in many cases, especially in the
 case of primitives with effects applied (such as a blur). However, it
 also increases memory usage. This hint indicates whether that trade-off
 (increased memory usage for increased performance) is worthwhile. Also
 note that on some platforms such as GPU accelerated platforms there is
 little benefit to caching Nodes as bitmaps when blurs and other effects
 are used since they are very fast to render on the GPU.

 The <a href="Node.html#cacheHintProperty()"><code>cacheHintProperty()</code></a> variable provides additional options for enabling
 more aggressive bitmap caching.

 <p>
 Caching may be disabled for any node that has a 3D transform on itself,
 any of its ancestors, or any of its descendants.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="cacheProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cacheProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a>&nbsp;cacheProperty()</pre>
<div class="block">A performance hint to the system to indicate that this <code>Node</code>
 should be cached as a bitmap. Rendering a bitmap representation of a node
 will be faster than rendering primitives in many cases, especially in the
 case of primitives with effects applied (such as a blur). However, it
 also increases memory usage. This hint indicates whether that trade-off
 (increased memory usage for increased performance) is worthwhile. Also
 note that on some platforms such as GPU accelerated platforms there is
 little benefit to caching Nodes as bitmaps when blurs and other effects
 are used since they are very fast to render on the GPU.

 The <a href="Node.html#cacheHintProperty()"><code>cacheHintProperty()</code></a> variable provides additional options for enabling
 more aggressive bitmap caching.

 <p>
 Caching may be disabled for any node that has a 3D transform on itself,
 any of its ancestors, or any of its descendants.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#cacheHintProperty()"><code>cacheHintProperty()</code></a>, 
<a href="Node.html#isCache()"><code>isCache()</code></a>, 
<a href="Node.html#setCache(boolean)"><code>setCache(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setCacheHint(javafx.scene.CacheHint)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCacheHint</h4>
<pre>public final&nbsp;void&nbsp;setCacheHint(<a href="CacheHint.html" title="enum in javafx.scene">CacheHint</a>&nbsp;value)</pre>
<div class="block">Sets the value of the property cacheHint.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Additional hint for controlling bitmap caching.
 <p>
 Under certain circumstances, such as animating nodes that are very
 expensive to render, it is desirable to be able to perform
 transformations on the node without having to regenerate the cached
 bitmap.  An option in such cases is to perform the transforms on the
 cached bitmap itself.
 <p>
 This technique can provide a dramatic improvement to animation
 performance, though may also result in a reduction in visual quality.
 The <code>cacheHint</code> variable provides a hint to the system about how
 and when that trade-off (visual quality for animation performance) is
 acceptable.
 <p>
 It is possible to enable the cacheHint only at times when your node is
 animating.  In this way, expensive nodes can appear on screen with full
 visual quality, yet still animate smoothly.
 <p>
 Example:
 <pre><code>
        expensiveNode.setCache(true);
        expensiveNode.setCacheHint(CacheHint.QUALITY);
        ...
        // Do an animation
        expensiveNode.setCacheHint(CacheHint.SPEED);
        new Timeline(
            new KeyFrame(Duration.seconds(2),
                new KeyValue(expensiveNode.scaleXProperty(), 2.0),
                new KeyValue(expensiveNode.scaleYProperty(), 2.0),
                new KeyValue(expensiveNode.rotateProperty(), 360),
                new KeyValue(expensiveNode.cacheHintProperty(), CacheHint.QUALITY)
            )
        ).play();
     </code></pre>

 Note that <code>cacheHint</code> is only a hint to the system.  Depending on
 the details of the node or the transform, this hint may be ignored.

 <p>
 If <code>Node.cache</code> is false, cacheHint is ignored.
 Caching may be disabled for any node that has a 3D transform on itself,
 any of its ancestors, or any of its descendants.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>CacheHint.DEFAULT</dd></dl>
</li>
</ul>
<a name="getCacheHint()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCacheHint</h4>
<pre>public final&nbsp;<a href="CacheHint.html" title="enum in javafx.scene">CacheHint</a>&nbsp;getCacheHint()</pre>
<div class="block">Gets the value of the property cacheHint.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Additional hint for controlling bitmap caching.
 <p>
 Under certain circumstances, such as animating nodes that are very
 expensive to render, it is desirable to be able to perform
 transformations on the node without having to regenerate the cached
 bitmap.  An option in such cases is to perform the transforms on the
 cached bitmap itself.
 <p>
 This technique can provide a dramatic improvement to animation
 performance, though may also result in a reduction in visual quality.
 The <code>cacheHint</code> variable provides a hint to the system about how
 and when that trade-off (visual quality for animation performance) is
 acceptable.
 <p>
 It is possible to enable the cacheHint only at times when your node is
 animating.  In this way, expensive nodes can appear on screen with full
 visual quality, yet still animate smoothly.
 <p>
 Example:
 <pre><code>
        expensiveNode.setCache(true);
        expensiveNode.setCacheHint(CacheHint.QUALITY);
        ...
        // Do an animation
        expensiveNode.setCacheHint(CacheHint.SPEED);
        new Timeline(
            new KeyFrame(Duration.seconds(2),
                new KeyValue(expensiveNode.scaleXProperty(), 2.0),
                new KeyValue(expensiveNode.scaleYProperty(), 2.0),
                new KeyValue(expensiveNode.rotateProperty(), 360),
                new KeyValue(expensiveNode.cacheHintProperty(), CacheHint.QUALITY)
            )
        ).play();
     </code></pre>

 Note that <code>cacheHint</code> is only a hint to the system.  Depending on
 the details of the node or the transform, this hint may be ignored.

 <p>
 If <code>Node.cache</code> is false, cacheHint is ignored.
 Caching may be disabled for any node that has a 3D transform on itself,
 any of its ancestors, or any of its descendants.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>CacheHint.DEFAULT</dd></dl>
</li>
</ul>
<a name="cacheHintProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cacheHintProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="CacheHint.html" title="enum in javafx.scene">CacheHint</a>&gt;&nbsp;cacheHintProperty()</pre>
<div class="block">Additional hint for controlling bitmap caching.
 <p>
 Under certain circumstances, such as animating nodes that are very
 expensive to render, it is desirable to be able to perform
 transformations on the node without having to regenerate the cached
 bitmap.  An option in such cases is to perform the transforms on the
 cached bitmap itself.
 <p>
 This technique can provide a dramatic improvement to animation
 performance, though may also result in a reduction in visual quality.
 The <code>cacheHint</code> variable provides a hint to the system about how
 and when that trade-off (visual quality for animation performance) is
 acceptable.
 <p>
 It is possible to enable the cacheHint only at times when your node is
 animating.  In this way, expensive nodes can appear on screen with full
 visual quality, yet still animate smoothly.
 <p>
 Example:
 <pre><code>
        expensiveNode.setCache(true);
        expensiveNode.setCacheHint(CacheHint.QUALITY);
        ...
        // Do an animation
        expensiveNode.setCacheHint(CacheHint.SPEED);
        new Timeline(
            new KeyFrame(Duration.seconds(2),
                new KeyValue(expensiveNode.scaleXProperty(), 2.0),
                new KeyValue(expensiveNode.scaleYProperty(), 2.0),
                new KeyValue(expensiveNode.rotateProperty(), 360),
                new KeyValue(expensiveNode.cacheHintProperty(), CacheHint.QUALITY)
            )
        ).play();
     </code></pre>

 Note that <code>cacheHint</code> is only a hint to the system.  Depending on
 the details of the node or the transform, this hint may be ignored.

 <p>
 If <code>Node.cache</code> is false, cacheHint is ignored.
 Caching may be disabled for any node that has a 3D transform on itself,
 any of its ancestors, or any of its descendants.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>JavaFX 1.3</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>CacheHint.DEFAULT</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#cacheProperty()"><code>cacheProperty()</code></a>, 
<a href="Node.html#getCacheHint()"><code>getCacheHint()</code></a>, 
<a href="Node.html#setCacheHint(javafx.scene.CacheHint)"><code>setCacheHint(CacheHint)</code></a></dd></dl>
</li>
</ul>
<a name="setEffect(javafx.scene.effect.Effect)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setEffect</h4>
<pre>public final&nbsp;void&nbsp;setEffect(<a href="effect/Effect.html" title="class in javafx.scene.effect">Effect</a>&nbsp;value)</pre>
<div class="block">Sets the value of the property effect.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies an effect to apply to this <code>Node</code>.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#EFFECT"><code>ConditionalFeature.EFFECT</code></a>
 for more information.

 <p>
 There is a known limitation of mixing Effect with a 3D Transform. Effect is
 essentially a 2D image operation. The result of an Effect set on
 a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children will cause its children
 to be rendered in order without Z-buffering applied between those
 children.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="getEffect()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEffect</h4>
<pre>public final&nbsp;<a href="effect/Effect.html" title="class in javafx.scene.effect">Effect</a>&nbsp;getEffect()</pre>
<div class="block">Gets the value of the property effect.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies an effect to apply to this <code>Node</code>.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#EFFECT"><code>ConditionalFeature.EFFECT</code></a>
 for more information.

 <p>
 There is a known limitation of mixing Effect with a 3D Transform. Effect is
 essentially a 2D image operation. The result of an Effect set on
 a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children will cause its children
 to be rendered in order without Z-buffering applied between those
 children.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>null</dd></dl>
</li>
</ul>
<a name="effectProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>effectProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="effect/Effect.html" title="class in javafx.scene.effect">Effect</a>&gt;&nbsp;effectProperty()</pre>
<div class="block">Specifies an effect to apply to this <code>Node</code>.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#EFFECT"><code>ConditionalFeature.EFFECT</code></a>
 for more information.

 <p>
 There is a known limitation of mixing Effect with a 3D Transform. Effect is
 essentially a 2D image operation. The result of an Effect set on
 a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a> node with 3D transformed children will cause its children
 to be rendered in order without Z-buffering applied between those
 children.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>null</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getEffect()"><code>getEffect()</code></a>, 
<a href="Node.html#setEffect(javafx.scene.effect.Effect)"><code>setEffect(Effect)</code></a></dd></dl>
</li>
</ul>
<a name="setDepthTest(javafx.scene.DepthTest)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDepthTest</h4>
<pre>public final&nbsp;void&nbsp;setDepthTest(<a href="DepthTest.html" title="enum in javafx.scene">DepthTest</a>&nbsp;value)</pre>
<div class="block">Sets the value of the property depthTest.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Indicates whether depth testing is used when rendering this node.
 If the depthTest flag is <code>DepthTest.DISABLE</code>, then depth testing
 is disabled for this node.
 If the depthTest flag is <code>DepthTest.ENABLE</code>, then depth testing
 is enabled for this node.
 If the depthTest flag is <code>DepthTest.INHERIT</code>, then depth testing
 is enabled for this node if it is enabled for the parent node or the
 parent node is null.
 <p>
 The depthTest flag is only used when the depthBuffer flag for
 the <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> is true (meaning that the
 <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> has an associated depth buffer)
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.
<p>
 See the constructor in Scene with depthBuffer as one of its input
 arguments.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>INHERIT</dd></dl>
</li>
</ul>
<a name="getDepthTest()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDepthTest</h4>
<pre>public final&nbsp;<a href="DepthTest.html" title="enum in javafx.scene">DepthTest</a>&nbsp;getDepthTest()</pre>
<div class="block">Gets the value of the property depthTest.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Indicates whether depth testing is used when rendering this node.
 If the depthTest flag is <code>DepthTest.DISABLE</code>, then depth testing
 is disabled for this node.
 If the depthTest flag is <code>DepthTest.ENABLE</code>, then depth testing
 is enabled for this node.
 If the depthTest flag is <code>DepthTest.INHERIT</code>, then depth testing
 is enabled for this node if it is enabled for the parent node or the
 parent node is null.
 <p>
 The depthTest flag is only used when the depthBuffer flag for
 the <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> is true (meaning that the
 <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> has an associated depth buffer)
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.
<p>
 See the constructor in Scene with depthBuffer as one of its input
 arguments.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>INHERIT</dd></dl>
</li>
</ul>
<a name="depthTestProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>depthTestProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="DepthTest.html" title="enum in javafx.scene">DepthTest</a>&gt;&nbsp;depthTestProperty()</pre>
<div class="block">Indicates whether depth testing is used when rendering this node.
 If the depthTest flag is <code>DepthTest.DISABLE</code>, then depth testing
 is disabled for this node.
 If the depthTest flag is <code>DepthTest.ENABLE</code>, then depth testing
 is enabled for this node.
 If the depthTest flag is <code>DepthTest.INHERIT</code>, then depth testing
 is enabled for this node if it is enabled for the parent node or the
 parent node is null.
 <p>
 The depthTest flag is only used when the depthBuffer flag for
 the <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> is true (meaning that the
 <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> has an associated depth buffer)
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.
<p>
 See the constructor in Scene with depthBuffer as one of its input
 arguments.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>INHERIT</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>, 
<a href="Node.html#getDepthTest()"><code>getDepthTest()</code></a>, 
<a href="Node.html#setDepthTest(javafx.scene.DepthTest)"><code>setDepthTest(DepthTest)</code></a></dd></dl>
</li>
</ul>
<a name="setDisable(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDisable</h4>
<pre>public final&nbsp;void&nbsp;setDisable(boolean&nbsp;value)</pre>
<div class="block">Sets the value of the property disable.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Sets the individual disabled state of this <code>Node</code>. Setting
 <code>disable</code> to true will cause this <code>Node</code> and any subnodes to
 become disabled. This variable should be used only to set the disabled
 state of a <code>Node</code>.  For querying the disabled state of a
 <code>Node</code>, the <a href="Node.html#disabledProperty()"><code>disabled</code></a> variable should instead be used,
 since it is possible that a <code>Node</code> was disabled as a result of an
 ancestor being disabled even if the individual <code>disable</code> state on
 this <code>Node</code> is <code>false</code>.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="isDisable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isDisable</h4>
<pre>public final&nbsp;boolean&nbsp;isDisable()</pre>
<div class="block">Gets the value of the property disable.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Sets the individual disabled state of this <code>Node</code>. Setting
 <code>disable</code> to true will cause this <code>Node</code> and any subnodes to
 become disabled. This variable should be used only to set the disabled
 state of a <code>Node</code>.  For querying the disabled state of a
 <code>Node</code>, the <a href="Node.html#disabledProperty()"><code>disabled</code></a> variable should instead be used,
 since it is possible that a <code>Node</code> was disabled as a result of an
 ancestor being disabled even if the individual <code>disable</code> state on
 this <code>Node</code> is <code>false</code>.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="disableProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>disableProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a>&nbsp;disableProperty()</pre>
<div class="block">Sets the individual disabled state of this <code>Node</code>. Setting
 <code>disable</code> to true will cause this <code>Node</code> and any subnodes to
 become disabled. This variable should be used only to set the disabled
 state of a <code>Node</code>.  For querying the disabled state of a
 <code>Node</code>, the <a href="Node.html#disabledProperty()"><code>disabled</code></a> variable should instead be used,
 since it is possible that a <code>Node</code> was disabled as a result of an
 ancestor being disabled even if the individual <code>disable</code> state on
 this <code>Node</code> is <code>false</code>.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isDisable()"><code>isDisable()</code></a>, 
<a href="Node.html#setDisable(boolean)"><code>setDisable(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setPickOnBounds(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPickOnBounds</h4>
<pre>public final&nbsp;void&nbsp;setPickOnBounds(boolean&nbsp;value)</pre>
<div class="block">Sets the value of the property pickOnBounds.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines how the picking computation is done for this node when
 triggered by a <code>MouseEvent</code> or a <code>contains</code> function call.

 If <code>pickOnBounds</code> is true, then picking is computed by
 intersecting with the bounds of this node, else picking is computed
 by intersecting with the geometric shape of this node.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="isPickOnBounds()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPickOnBounds</h4>
<pre>public final&nbsp;boolean&nbsp;isPickOnBounds()</pre>
<div class="block">Gets the value of the property pickOnBounds.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines how the picking computation is done for this node when
 triggered by a <code>MouseEvent</code> or a <code>contains</code> function call.

 If <code>pickOnBounds</code> is true, then picking is computed by
 intersecting with the bounds of this node, else picking is computed
 by intersecting with the geometric shape of this node.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="pickOnBoundsProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pickOnBoundsProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a>&nbsp;pickOnBoundsProperty()</pre>
<div class="block">Defines how the picking computation is done for this node when
 triggered by a <code>MouseEvent</code> or a <code>contains</code> function call.

 If <code>pickOnBounds</code> is true, then picking is computed by
 intersecting with the bounds of this node, else picking is computed
 by intersecting with the geometric shape of this node.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isPickOnBounds()"><code>isPickOnBounds()</code></a>, 
<a href="Node.html#setPickOnBounds(boolean)"><code>setPickOnBounds(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setDisabled(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDisabled</h4>
<pre>protected final&nbsp;void&nbsp;setDisabled(boolean&nbsp;value)</pre>
<div class="block">Sets the value of the property disabled.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Indicates whether or not this <code>Node</code> is disabled.  A <code>Node</code>
 will become disabled if <a href="Node.html#disableProperty()"><code>disable</code></a> is set to <code>true</code> on either
 itself or one of its ancestors in the scene graph.
 <p>
 A disabled <code>Node</code> should render itself differently to indicate its
 disabled state to the user.
 Such disabled rendering is dependent on the implementation of the
 <code>Node</code>. The shape classes contained in <code>javafx.scene.shape</code>
 do not implement such rendering by default, therefore applications using
 shapes for handling input must implement appropriate disabled rendering
 themselves. The user-interface controls defined in
 <code>javafx.scene.control</code> will implement disabled-sensitive rendering,
 however.
 <p>
 A disabled <code>Node</code> does not receive mouse or key events.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="isDisabled()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isDisabled</h4>
<pre>public final&nbsp;boolean&nbsp;isDisabled()</pre>
<div class="block">Gets the value of the property disabled.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Indicates whether or not this <code>Node</code> is disabled.  A <code>Node</code>
 will become disabled if <a href="Node.html#disableProperty()"><code>disable</code></a> is set to <code>true</code> on either
 itself or one of its ancestors in the scene graph.
 <p>
 A disabled <code>Node</code> should render itself differently to indicate its
 disabled state to the user.
 Such disabled rendering is dependent on the implementation of the
 <code>Node</code>. The shape classes contained in <code>javafx.scene.shape</code>
 do not implement such rendering by default, therefore applications using
 shapes for handling input must implement appropriate disabled rendering
 themselves. The user-interface controls defined in
 <code>javafx.scene.control</code> will implement disabled-sensitive rendering,
 however.
 <p>
 A disabled <code>Node</code> does not receive mouse or key events.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="disabledProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>disabledProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a>&nbsp;disabledProperty()</pre>
<div class="block">Indicates whether or not this <code>Node</code> is disabled.  A <code>Node</code>
 will become disabled if <a href="Node.html#disableProperty()"><code>disable</code></a> is set to <code>true</code> on either
 itself or one of its ancestors in the scene graph.
 <p>
 A disabled <code>Node</code> should render itself differently to indicate its
 disabled state to the user.
 Such disabled rendering is dependent on the implementation of the
 <code>Node</code>. The shape classes contained in <code>javafx.scene.shape</code>
 do not implement such rendering by default, therefore applications using
 shapes for handling input must implement appropriate disabled rendering
 themselves. The user-interface controls defined in
 <code>javafx.scene.control</code> will implement disabled-sensitive rendering,
 however.
 <p>
 A disabled <code>Node</code> does not receive mouse or key events.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isDisabled()"><code>isDisabled()</code></a>, 
<a href="Node.html#setDisabled(boolean)"><code>setDisabled(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="lookup(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lookup</h4>
<pre>public&nbsp;<a href="Node.html" title="class in javafx.scene">Node</a>&nbsp;lookup(java.lang.String&nbsp;selector)</pre>
<div class="block">Finds this <code>Node</code>, or the first sub-node, based on the given CSS selector.
 If this node is a <code>Parent</code>, then this function will traverse down
 into the branch until it finds a match. If more than one sub-node matches the
 specified selector, this function returns the first of them.
 <p>
     For example, if a Node is given the id of "myId", then the lookup method can
     be used to find this node as follows: <code>scene.lookup("#myId");</code>.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>selector</code> - The css selector of the node to find</dd>
<dt><span class="strong">Returns:</span></dt><dd>The first node, starting from this <code>Node</code>, which matches
         the CSS <code>selector</code>, null if none is found.</dd></dl>
</li>
</ul>
<a name="lookupAll(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lookupAll</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="Node.html" title="class in javafx.scene">Node</a>&gt;&nbsp;lookupAll(java.lang.String&nbsp;selector)</pre>
<div class="block">Finds all <code>Node</code>s, including this one and any children, which match
 the given CSS selector. If no matches are found, an empty unmodifiable set is
 returned. The set is explicitly unordered.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>selector</code> - The css selector of the nodes to find</dd>
<dt><span class="strong">Returns:</span></dt><dd>All nodes, starting from and including this <code>Node</code>, which match
         the CSS <code>selector</code>. The returned set is always unordered and
         unmodifiable, and never null.</dd></dl>
</li>
</ul>
<a name="toBack()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toBack</h4>
<pre>public&nbsp;void&nbsp;toBack()</pre>
<div class="block">Moves this <code>Node</code> to the back of its sibling nodes in terms of
 z-order.  This is accomplished by moving this <code>Node</code> to the
 first position in its parent's <code>content</code> ObservableList.
 This function has no effect if this <code>Node</code> is not part of a group.</div>
</li>
</ul>
<a name="toFront()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toFront</h4>
<pre>public&nbsp;void&nbsp;toFront()</pre>
<div class="block">Moves this <code>Node</code> to the front of its sibling nodes in terms of
 z-order.  This is accomplished by moving this <code>Node</code> to the
 last position in its parent's <code>content</code> ObservableList.
 This function has no effect if this <code>Node</code> is not part of a group.</div>
</li>
</ul>
<a name="snapshot(javafx.scene.SnapshotParameters, javafx.scene.image.WritableImage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>snapshot</h4>
<pre>public&nbsp;<a href="image/WritableImage.html" title="class in javafx.scene.image">WritableImage</a>&nbsp;snapshot(<a href="SnapshotParameters.html" title="class in javafx.scene">SnapshotParameters</a>&nbsp;params,
                     <a href="image/WritableImage.html" title="class in javafx.scene.image">WritableImage</a>&nbsp;image)</pre>
<div class="block">Takes a snapshot of this node and returns the rendered image when
 it is ready.
 CSS and layout processing will be done for the node, and any of its
 children, prior to rendering it.
 The entire destination image is cleared to the fill <code>Paint</code>
 specified by the SnapshotParameters. This node is then rendered to
 the image.
 If the viewport specified by the SnapshotParameters is null, the
 upper-left pixel of the <code>boundsInParent</code> of this
 node, after first applying the transform specified by the
 SnapshotParameters,
 is mapped to the upper-left pixel (0,0) in the image.
 If a non-null viewport is specified,
 the upper-left pixel of the viewport is mapped to upper-left pixel
 (0,0) in the image.
 In both cases, this mapping to (0,0) of the image is done with an integer
 translation. The portion of the node that is outside of the rendered
 image will be clipped by the image.

 <p>
 When taking a snapshot of a scene that is being animated, either
 explicitly by the application or implicitly (such as chart animation),
 the snapshot will be rendered based on the state of the scene graph at
 the moment the snapshot is taken and will not reflect any subsequent
 animation changes.
 </p>

 <p>
 NOTE: In order for CSS and layout to function correctly, the node
 must be part of a Scene (the Scene may be attached to a Stage, but need
 not be).
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>params</code> - the snapshot parameters containing attributes that
 will control the rendering. If the SnapshotParameters object is null,
 then the Scene's attributes will be used if this node is part of a scene,
 or default attributes will be used if this node is not part of a scene.</dd><dd><code>image</code> - the writable image that will be used to hold the rendered node.
 It may be null in which case a new WritableImage will be constructed.
 The new image is constructed using integer width and
 height values that are derived either from the transformed bounds of this
 Node or from the size of the viewport as specified in the
 SnapShotParameters. These integer values are chosen such that the image
 will wholly contain the bounds of this Node or the specified viewport.
 If the image is non-null, the node will be rendered into the
 existing image.
 In this case, the width and height of the image determine the area
 that is rendered instead of the width and height of the bounds or
 viewport.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the rendered image</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if this method is called on a thread
     other than the JavaFX Application Thread.</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd></dl>
</li>
</ul>
<a name="snapshot(javafx.util.Callback, javafx.scene.SnapshotParameters, javafx.scene.image.WritableImage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>snapshot</h4>
<pre>public&nbsp;void&nbsp;snapshot(<a href="../util/Callback.html" title="interface in javafx.util">Callback</a>&lt;<a href="SnapshotResult.html" title="class in javafx.scene">SnapshotResult</a>,java.lang.Void&gt;&nbsp;callback,
            <a href="SnapshotParameters.html" title="class in javafx.scene">SnapshotParameters</a>&nbsp;params,
            <a href="image/WritableImage.html" title="class in javafx.scene.image">WritableImage</a>&nbsp;image)</pre>
<div class="block">Takes a snapshot of this node at the next frame and calls the
 specified callback method when the image is ready.
 CSS and layout processing will be done for the node, and any of its
 children, prior to rendering it.
 The entire destination image is cleared to the fill <code>Paint</code>
 specified by the SnapshotParameters. This node is then rendered to
 the image.
 If the viewport specified by the SnapshotParameters is null, the
 upper-left pixel of the <code>boundsInParent</code> of this
 node, after first applying the transform specified by the
 SnapshotParameters,
 is mapped to the upper-left pixel (0,0) in the image.
 If a non-null viewport is specified,
 the upper-left pixel of the viewport is mapped to upper-left pixel
 (0,0) in the image.
 In both cases, this mapping to (0,0) of the image is done with an integer
 translation. The portion of the node that is outside of the rendered
 image will be clipped by the image.

 <p>
 This is an asynchronous call, which means that other
 events or animation might be processed before the node is rendered.
 If any such events modify the node, or any of its children, that
 modification will be reflected in the rendered image (just like it
 will also be reflected in the frame rendered to the Stage, if this node
 is part of a live scene graph).
 </p>

 <p>
 When taking a snapshot of a node that is being animated, either
 explicitly by the application or implicitly (such as chart animation),
 the snapshot will be rendered based on the state of the scene graph at
 the moment the snapshot is taken and will not reflect any subsequent
 animation changes.
 </p>

 <p>
 NOTE: In order for CSS and layout to function correctly, the node
 must be part of a Scene (the Scene may be attached to a Stage, but need
 not be).
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>callback</code> - a class whose call method will be called when the image
 is ready. The SnapshotResult that is passed into the call method of
 the callback will contain the rendered image, the source node
 that was rendered, and a copy of the SnapshotParameters.
 The callback parameter must not be null.</dd><dd><code>params</code> - the snapshot parameters containing attributes that
 will control the rendering. If the SnapshotParameters object is null,
 then the Scene's attributes will be used if this node is part of a scene,
 or default attributes will be used if this node is not part of a scene.</dd><dd><code>image</code> - the writable image that will be used to hold the rendered node.
 It may be null in which case a new WritableImage will be constructed.
 The new image is constructed using integer width and
 height values that are derived either from the transformed bounds of this
 Node or from the size of the viewport as specified in the
 SnapShotParameters. These integer values are chosen such that the image
 will wholly contain the bounds of this Node or the specified viewport.
 If the image is non-null, the node will be rendered into the
 existing image.
 In this case, the width and height of the image determine the area
 that is rendered instead of the width and height of the bounds or
 viewport.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if this method is called on a thread
     other than the JavaFX Application Thread.</dd>
<dd><code>java.lang.NullPointerException</code> - if the callback parameter is null.</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd></dl>
</li>
</ul>
<a name="setOnDragEntered(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnDragEntered</h4>
<pre>public final&nbsp;void&nbsp;setOnDragEntered(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onDragEntered.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when drag gesture
 enters this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnDragEntered()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnDragEntered</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;getOnDragEntered()</pre>
<div class="block">Gets the value of the property onDragEntered.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when drag gesture
 enters this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onDragEnteredProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragEnteredProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;&nbsp;onDragEnteredProperty()</pre>
<div class="block">Defines a function to be called when drag gesture
 enters this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragEntered()"><code>getOnDragEntered()</code></a>, 
<a href="Node.html#setOnDragEntered(javafx.event.EventHandler)"><code>setOnDragEntered(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnDragExited(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnDragExited</h4>
<pre>public final&nbsp;void&nbsp;setOnDragExited(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onDragExited.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when drag gesture
 exits this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnDragExited()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnDragExited</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;getOnDragExited()</pre>
<div class="block">Gets the value of the property onDragExited.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when drag gesture
 exits this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onDragExitedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragExitedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;&nbsp;onDragExitedProperty()</pre>
<div class="block">Defines a function to be called when drag gesture
 exits this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragExited()"><code>getOnDragExited()</code></a>, 
<a href="Node.html#setOnDragExited(javafx.event.EventHandler)"><code>setOnDragExited(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnDragOver(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnDragOver</h4>
<pre>public final&nbsp;void&nbsp;setOnDragOver(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onDragOver.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when drag gesture progresses within
 this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnDragOver()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnDragOver</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;getOnDragOver()</pre>
<div class="block">Gets the value of the property onDragOver.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when drag gesture progresses within
 this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onDragOverProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragOverProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;&nbsp;onDragOverProperty()</pre>
<div class="block">Defines a function to be called when drag gesture progresses within
 this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragOver()"><code>getOnDragOver()</code></a>, 
<a href="Node.html#setOnDragOver(javafx.event.EventHandler)"><code>setOnDragOver(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnDragDropped(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnDragDropped</h4>
<pre>public final&nbsp;void&nbsp;setOnDragDropped(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onDragDropped.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when the mouse button is released
 on this <code>Node</code> during drag and drop gesture. Transfer of data from
 the <a href="input/DragEvent.html" title="class in javafx.scene.input"><code>DragEvent</code></a>'s <a href="input/DragEvent.html#dragboard"><code>dragboard</code></a> should
 happen in this function.</dd></dl>
</li>
</ul>
<a name="getOnDragDropped()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnDragDropped</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;getOnDragDropped()</pre>
<div class="block">Gets the value of the property onDragDropped.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when the mouse button is released
 on this <code>Node</code> during drag and drop gesture. Transfer of data from
 the <a href="input/DragEvent.html" title="class in javafx.scene.input"><code>DragEvent</code></a>'s <a href="input/DragEvent.html#dragboard"><code>dragboard</code></a> should
 happen in this function.</dd></dl>
</li>
</ul>
<a name="onDragDroppedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragDroppedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;&nbsp;onDragDroppedProperty()</pre>
<div class="block">Defines a function to be called when the mouse button is released
 on this <code>Node</code> during drag and drop gesture. Transfer of data from
 the <a href="input/DragEvent.html" title="class in javafx.scene.input"><code>DragEvent</code></a>'s <a href="input/DragEvent.html#dragboard"><code>dragboard</code></a> should
 happen in this function.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragDropped()"><code>getOnDragDropped()</code></a>, 
<a href="Node.html#setOnDragDropped(javafx.event.EventHandler)"><code>setOnDragDropped(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnDragDone(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnDragDone</h4>
<pre>public final&nbsp;void&nbsp;setOnDragDone(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onDragDone.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when this <code>Node</code> is a
 drag and drop gesture source after its data has
 been dropped on a drop target. The <code>transferMode</code> of the
 event shows what just happened at the drop target.
 If <code>transferMode</code> has the value <code>MOVE</code>, then the source can
 clear out its data. Clearing the source's data gives the appropriate
 appearance to a user that the data has been moved by the drag and drop
 gesture. A <code>transferMode</code> that has the value <code>NONE</code>
 indicates that no data was transferred during the drag and drop gesture.</dd></dl>
</li>
</ul>
<a name="getOnDragDone()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnDragDone</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&nbsp;getOnDragDone()</pre>
<div class="block">Gets the value of the property onDragDone.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when this <code>Node</code> is a
 drag and drop gesture source after its data has
 been dropped on a drop target. The <code>transferMode</code> of the
 event shows what just happened at the drop target.
 If <code>transferMode</code> has the value <code>MOVE</code>, then the source can
 clear out its data. Clearing the source's data gives the appropriate
 appearance to a user that the data has been moved by the drag and drop
 gesture. A <code>transferMode</code> that has the value <code>NONE</code>
 indicates that no data was transferred during the drag and drop gesture.</dd></dl>
</li>
</ul>
<a name="onDragDoneProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragDoneProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/DragEvent.html" title="class in javafx.scene.input">DragEvent</a>&gt;&gt;&nbsp;onDragDoneProperty()</pre>
<div class="block">Defines a function to be called when this <code>Node</code> is a
 drag and drop gesture source after its data has
 been dropped on a drop target. The <code>transferMode</code> of the
 event shows what just happened at the drop target.
 If <code>transferMode</code> has the value <code>MOVE</code>, then the source can
 clear out its data. Clearing the source's data gives the appropriate
 appearance to a user that the data has been moved by the drag and drop
 gesture. A <code>transferMode</code> that has the value <code>NONE</code>
 indicates that no data was transferred during the drag and drop gesture.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragDone()"><code>getOnDragDone()</code></a>, 
<a href="Node.html#setOnDragDone(javafx.event.EventHandler)"><code>setOnDragDone(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="startDragAndDrop(javafx.scene.input.TransferMode...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startDragAndDrop</h4>
<pre>public&nbsp;<a href="input/Dragboard.html" title="class in javafx.scene.input">Dragboard</a>&nbsp;startDragAndDrop(<a href="input/TransferMode.html" title="enum in javafx.scene.input">TransferMode</a>...&nbsp;transferModes)</pre>
<div class="block">Confirms a potential drag and drop gesture that is recognized over this
 <code>Node</code>.
 Can be called only from a DRAG_DETECTED event handler. The returned
 <a href="input/Dragboard.html" title="class in javafx.scene.input"><code>Dragboard</code></a> is used to transfer data during
 the drag and drop gesture. Placing this <code>Node</code>'s data on the
 <a href="input/Dragboard.html" title="class in javafx.scene.input"><code>Dragboard</code></a> also identifies this <code>Node</code> as the source of
 the drag and drop gesture.
 More detail about drag and drop gestures is described in the overivew
 of <a href="input/DragEvent.html" title="class in javafx.scene.input"><code>DragEvent</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>transferModes</code> - The supported <code>TransferMode</code>(s) of this <code>Node</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>A <code>Dragboard</code> to place this <code>Node</code>'s data on</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if drag and drop cannot be started at this
 moment (it's called outside of <code>DRAG_DETECTED</code> event handling or
 this node is not in scene).</dd><dt><span class="strong">See Also:</span></dt><dd><a href="input/DragEvent.html" title="class in javafx.scene.input"><code>DragEvent</code></a></dd></dl>
</li>
</ul>
<a name="startFullDrag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startFullDrag</h4>
<pre>public&nbsp;void&nbsp;startFullDrag()</pre>
<div class="block">Starts a full press-drag-release gesture with this node as gesture
 source. This method can be called only from a <code>DRAG_DETECTED</code> mouse
 event handler. More detail about dragging gestures can be found
 in the overview of <a href="input/MouseEvent.html" title="class in javafx.scene.input"><code>MouseEvent</code></a> and <a href="input/MouseDragEvent.html" title="class in javafx.scene.input"><code>MouseDragEvent</code></a>.</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if the full press-drag-release gesture
 cannot be started at this moment (it's called outside of
 <code>DRAG_DETECTED</code> event handling or this node is not in scene).</dd><dt><span class="strong">See Also:</span></dt><dd><a href="input/MouseEvent.html" title="class in javafx.scene.input"><code>MouseEvent</code></a>, 
<a href="input/MouseDragEvent.html" title="class in javafx.scene.input"><code>MouseDragEvent</code></a></dd></dl>
</li>
</ul>
<a name="setManaged(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setManaged</h4>
<pre>public final&nbsp;void&nbsp;setManaged(boolean&nbsp;value)</pre>
<div class="block">Sets the value of the property managed.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines whether or not this node's layout will be managed by it's parent.
 If the node is managed, it's parent will factor the node's geometry
 into its own preferred size and <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>
 calculations and will lay it
 out during the scene's layout pass.  If a managed node's layoutBounds
 changes, it will automatically trigger relayout up the scene-graph
 to the nearest layout root (which is typically the scene's root node).
 <p>
 If the node is unmanaged, its parent will ignore the child in both preferred
 size computations and layout.   Changes in layoutBounds will not trigger
 relayout above it.   If an unmanaged node is of type <a href="Parent.html" title="class in javafx.scene"><code>Parent</code></a>,
 it will act as a "layout root", meaning that calls to <a href="Parent.html#requestLayout()"><code>Parent.requestLayout()</code></a>
 beneath it will cause only the branch rooted by the node to be relayed out,
 thereby isolating layout changes to that root and below.  It's the application's
 responsibility to set the size and position of an unmanaged node.
 <p>
 By default all nodes are managed.
 </p></dd></dl>
</li>
</ul>
<a name="isManaged()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isManaged</h4>
<pre>public final&nbsp;boolean&nbsp;isManaged()</pre>
<div class="block">Gets the value of the property managed.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines whether or not this node's layout will be managed by it's parent.
 If the node is managed, it's parent will factor the node's geometry
 into its own preferred size and <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>
 calculations and will lay it
 out during the scene's layout pass.  If a managed node's layoutBounds
 changes, it will automatically trigger relayout up the scene-graph
 to the nearest layout root (which is typically the scene's root node).
 <p>
 If the node is unmanaged, its parent will ignore the child in both preferred
 size computations and layout.   Changes in layoutBounds will not trigger
 relayout above it.   If an unmanaged node is of type <a href="Parent.html" title="class in javafx.scene"><code>Parent</code></a>,
 it will act as a "layout root", meaning that calls to <a href="Parent.html#requestLayout()"><code>Parent.requestLayout()</code></a>
 beneath it will cause only the branch rooted by the node to be relayed out,
 thereby isolating layout changes to that root and below.  It's the application's
 responsibility to set the size and position of an unmanaged node.
 <p>
 By default all nodes are managed.
 </p></dd></dl>
</li>
</ul>
<a name="managedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>managedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a>&nbsp;managedProperty()</pre>
<div class="block">Defines whether or not this node's layout will be managed by it's parent.
 If the node is managed, it's parent will factor the node's geometry
 into its own preferred size and <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>
 calculations and will lay it
 out during the scene's layout pass.  If a managed node's layoutBounds
 changes, it will automatically trigger relayout up the scene-graph
 to the nearest layout root (which is typically the scene's root node).
 <p>
 If the node is unmanaged, its parent will ignore the child in both preferred
 size computations and layout.   Changes in layoutBounds will not trigger
 relayout above it.   If an unmanaged node is of type <a href="Parent.html" title="class in javafx.scene"><code>Parent</code></a>,
 it will act as a "layout root", meaning that calls to <a href="Parent.html#requestLayout()"><code>Parent.requestLayout()</code></a>
 beneath it will cause only the branch rooted by the node to be relayed out,
 thereby isolating layout changes to that root and below.  It's the application's
 responsibility to set the size and position of an unmanaged node.
 <p>
 By default all nodes are managed.
 </p></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isManaged()"><code>isManaged()</code></a>, 
<a href="Node.html#setManaged(boolean)"><code>setManaged(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setLayoutX(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setLayoutX</h4>
<pre>public final&nbsp;void&nbsp;setLayoutX(double&nbsp;value)</pre>
<div class="block">Sets the value of the property layoutX.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.  The value should be computed as the
 offset required to adjust the position of the node from its current
 <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds minX</code></a> position (which might not be 0) to the desired location.

 <p>For example, if <code>textnode</code> should be positioned at <code>finalX</code>
 <code><pre>
     textnode.setLayoutX(finalX - textnode.getLayoutBounds().getMinX());
 </pre></code>
 <p>
 Failure to subtract <code>layoutBounds minX</code> may result in misplacement
 of the node.  The <a href="Node.html#relocate(double, double)"><code>relocate(x, y)</code></a> method will automatically do the
 correct computation and should generally be used over setting layoutX directly.
 <p>
 The node's final translation will be computed as <code>layoutX</code> + <a href="Node.html#translateXProperty()"><code>translateX</code></a>,
 where <code>layoutX</code> establishes the node's stable position
 and <code>translateX</code> optionally makes dynamic adjustments to that
 position.
 <p>
 If the node is managed and has a <a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>
 as its parent, then the layout region will set <code>layoutX</code> according to its
 own layout policy.   If the node is unmanaged or parented by a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>,
 then the application may set <code>layoutX</code> directly to position it.
 <p></dd></dl>
</li>
</ul>
<a name="getLayoutX()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLayoutX</h4>
<pre>public final&nbsp;double&nbsp;getLayoutX()</pre>
<div class="block">Gets the value of the property layoutX.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.  The value should be computed as the
 offset required to adjust the position of the node from its current
 <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds minX</code></a> position (which might not be 0) to the desired location.

 <p>For example, if <code>textnode</code> should be positioned at <code>finalX</code>
 <code><pre>
     textnode.setLayoutX(finalX - textnode.getLayoutBounds().getMinX());
 </pre></code>
 <p>
 Failure to subtract <code>layoutBounds minX</code> may result in misplacement
 of the node.  The <a href="Node.html#relocate(double, double)"><code>relocate(x, y)</code></a> method will automatically do the
 correct computation and should generally be used over setting layoutX directly.
 <p>
 The node's final translation will be computed as <code>layoutX</code> + <a href="Node.html#translateXProperty()"><code>translateX</code></a>,
 where <code>layoutX</code> establishes the node's stable position
 and <code>translateX</code> optionally makes dynamic adjustments to that
 position.
 <p>
 If the node is managed and has a <a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>
 as its parent, then the layout region will set <code>layoutX</code> according to its
 own layout policy.   If the node is unmanaged or parented by a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>,
 then the application may set <code>layoutX</code> directly to position it.
 <p></dd></dl>
</li>
</ul>
<a name="layoutXProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>layoutXProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a>&nbsp;layoutXProperty()</pre>
<div class="block">Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.  The value should be computed as the
 offset required to adjust the position of the node from its current
 <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds minX</code></a> position (which might not be 0) to the desired location.

 <p>For example, if <code>textnode</code> should be positioned at <code>finalX</code>
 <code><pre>
     textnode.setLayoutX(finalX - textnode.getLayoutBounds().getMinX());
 </pre></code>
 <p>
 Failure to subtract <code>layoutBounds minX</code> may result in misplacement
 of the node.  The <a href="Node.html#relocate(double, double)"><code>relocate(x, y)</code></a> method will automatically do the
 correct computation and should generally be used over setting layoutX directly.
 <p>
 The node's final translation will be computed as <code>layoutX</code> + <a href="Node.html#translateXProperty()"><code>translateX</code></a>,
 where <code>layoutX</code> establishes the node's stable position
 and <code>translateX</code> optionally makes dynamic adjustments to that
 position.
 <p>
 If the node is managed and has a <a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>
 as its parent, then the layout region will set <code>layoutX</code> according to its
 own layout policy.   If the node is unmanaged or parented by a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>,
 then the application may set <code>layoutX</code> directly to position it.
 <p></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getLayoutX()"><code>getLayoutX()</code></a>, 
<a href="Node.html#setLayoutX(double)"><code>setLayoutX(double)</code></a></dd></dl>
</li>
</ul>
<a name="setLayoutY(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setLayoutY</h4>
<pre>public final&nbsp;void&nbsp;setLayoutY(double&nbsp;value)</pre>
<div class="block">Sets the value of the property layoutY.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.  The value should be computed as the
 offset required to adjust the position of the node from its current
 <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds minY</code></a> position (which might not be 0) to the desired location.

 <p>For example, if <code>textnode</code> should be positioned at <code>finalY</code>
 <code><pre>
     textnode.setLayoutY(finalY - textnode.getLayoutBounds().getMinY());
 </pre></code>
 <p>
 Failure to subtract <code>layoutBounds minY</code> may result in misplacement
 of the node.  The <a href="Node.html#relocate(double, double)"><code>relocate(x, y)</code></a> method will automatically do the
 correct computation and should generally be used over setting layoutY directly.
 <p>
 The node's final translation will be computed as <code>layoutY</code> + <a href="Node.html#translateYProperty()"><code>translateY</code></a>,
 where <code>layoutY</code> establishes the node's stable position
 and <code>translateY</code> optionally makes dynamic adjustments to that
 position.
 <p>
 If the node is managed and has a <a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>
 as its parent, then the region will set <code>layoutY</code> according to its
 own layout policy.   If the node is unmanaged or parented by a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>,
 then the application may set <code>layoutY</code> directly to position it.</dd></dl>
</li>
</ul>
<a name="getLayoutY()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLayoutY</h4>
<pre>public final&nbsp;double&nbsp;getLayoutY()</pre>
<div class="block">Gets the value of the property layoutY.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.  The value should be computed as the
 offset required to adjust the position of the node from its current
 <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds minY</code></a> position (which might not be 0) to the desired location.

 <p>For example, if <code>textnode</code> should be positioned at <code>finalY</code>
 <code><pre>
     textnode.setLayoutY(finalY - textnode.getLayoutBounds().getMinY());
 </pre></code>
 <p>
 Failure to subtract <code>layoutBounds minY</code> may result in misplacement
 of the node.  The <a href="Node.html#relocate(double, double)"><code>relocate(x, y)</code></a> method will automatically do the
 correct computation and should generally be used over setting layoutY directly.
 <p>
 The node's final translation will be computed as <code>layoutY</code> + <a href="Node.html#translateYProperty()"><code>translateY</code></a>,
 where <code>layoutY</code> establishes the node's stable position
 and <code>translateY</code> optionally makes dynamic adjustments to that
 position.
 <p>
 If the node is managed and has a <a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>
 as its parent, then the region will set <code>layoutY</code> according to its
 own layout policy.   If the node is unmanaged or parented by a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>,
 then the application may set <code>layoutY</code> directly to position it.</dd></dl>
</li>
</ul>
<a name="layoutYProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>layoutYProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a>&nbsp;layoutYProperty()</pre>
<div class="block">Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform for the purpose of layout.  The value should be computed as the
 offset required to adjust the position of the node from its current
 <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds minY</code></a> position (which might not be 0) to the desired location.

 <p>For example, if <code>textnode</code> should be positioned at <code>finalY</code>
 <code><pre>
     textnode.setLayoutY(finalY - textnode.getLayoutBounds().getMinY());
 </pre></code>
 <p>
 Failure to subtract <code>layoutBounds minY</code> may result in misplacement
 of the node.  The <a href="Node.html#relocate(double, double)"><code>relocate(x, y)</code></a> method will automatically do the
 correct computation and should generally be used over setting layoutY directly.
 <p>
 The node's final translation will be computed as <code>layoutY</code> + <a href="Node.html#translateYProperty()"><code>translateY</code></a>,
 where <code>layoutY</code> establishes the node's stable position
 and <code>translateY</code> optionally makes dynamic adjustments to that
 position.
 <p>
 If the node is managed and has a <a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>
 as its parent, then the region will set <code>layoutY</code> according to its
 own layout policy.   If the node is unmanaged or parented by a <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>,
 then the application may set <code>layoutY</code> directly to position it.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getLayoutY()"><code>getLayoutY()</code></a>, 
<a href="Node.html#setLayoutY(double)"><code>setLayoutY(double)</code></a></dd></dl>
</li>
</ul>
<a name="relocate(double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>relocate</h4>
<pre>public&nbsp;void&nbsp;relocate(double&nbsp;x,
            double&nbsp;y)</pre>
<div class="block">Sets the node's layoutX and layoutY translation properties in order to
 relocate this node to the x,y location in the parent.
 <p>
 This method does not alter translateX or translateY, which if also set
 will be added to layoutX and layoutY, adjusting the final location by
 corresponding amounts.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>x</code> - the target x coordinate location</dd><dd><code>y</code> - the target y coordinate location</dd></dl>
</li>
</ul>
<a name="isResizable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isResizable</h4>
<pre>public&nbsp;boolean&nbsp;isResizable()</pre>
<div class="block">Indicates whether this node is a type which can be resized by its parent.
 If this method returns true, then the parent will resize the node (ideally
 within its size range) by calling node.resize(width,height) during the
 layout pass.  All Regions, Controls, and WebView are resizable classes
 which depend on their parents resizing them during layout once all sizing
 and CSS styling information has been applied.
 <p>
 If this method returns false, then the parent cannot resize it during
 layout (resize() is a no-op) and it should return its layoutBounds for
 minimum, preferred, and maximum sizes.  Group, Text, and all Shapes are not
 resizable and hence depend on the application to establish their sizing
 by setting appropriate properties (e.g.  width/height for Rectangle,
 text on Text, and so on).  Non-resizable nodes may still be relocated
 during layout.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>whether or not this node type can be resized by its parent during layout</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getContentBias()"><code>getContentBias()</code></a>, 
<a href="Node.html#minWidth(double)"><code>minWidth(double)</code></a>, 
<a href="Node.html#minHeight(double)"><code>minHeight(double)</code></a>, 
<a href="Node.html#prefWidth(double)"><code>prefWidth(double)</code></a>, 
<a href="Node.html#prefHeight(double)"><code>prefHeight(double)</code></a>, 
<a href="Node.html#maxWidth(double)"><code>maxWidth(double)</code></a>, 
<a href="Node.html#maxHeight(double)"><code>maxHeight(double)</code></a>, 
<a href="Node.html#resize(double, double)"><code>resize(double, double)</code></a>, 
<a href="Node.html#getLayoutBounds()"><code>getLayoutBounds()</code></a></dd></dl>
</li>
</ul>
<a name="getContentBias()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getContentBias</h4>
<pre>public&nbsp;<a href="../geometry/Orientation.html" title="enum in javafx.geometry">Orientation</a>&nbsp;getContentBias()</pre>
<div class="block">Returns the orientation of a node's resizing bias for layout purposes.
 If the node type has no bias, returns null.  If the node is resizable and
 it's height depends on its width, returns HORIZONTAL, else if its width
 depends on its height, returns VERTICAL.
 <p>
 Resizable subclasses should override this method to return an 
 appropriate value.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>orientation of width/height dependency or null if there is none</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isResizable()"><code>isResizable()</code></a>, 
<a href="Node.html#minWidth(double)"><code>minWidth(double)</code></a>, 
<a href="Node.html#minHeight(double)"><code>minHeight(double)</code></a>, 
<a href="Node.html#prefWidth(double)"><code>prefWidth(double)</code></a>, 
<a href="Node.html#prefHeight(double)"><code>prefHeight(double)</code></a>, 
<a href="Node.html#maxWidth(double)"><code>maxWidth(double)</code></a>, 
<a href="Node.html#maxHeight(double)"><code>maxHeight(double)</code></a></dd></dl>
</li>
</ul>
<a name="minWidth(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minWidth</h4>
<pre>public&nbsp;double&nbsp;minWidth(double&nbsp;height)</pre>
<div class="block">Returns the node's minimum width for use in layout calculations.
 If the node is resizable, its parent should not resize its width any
 smaller than this value.  If the node is not resizable, returns its
 layoutBounds width.
 <p>
 Layout code which calls this method should first check the content-bias
 of the node.  If the node has a vertical content-bias, then callers
 should pass in a height value that the minimum width should be based on.
 If the node has either a horizontal or null content-bias, then the caller
 should pass in -1.
 <p>
 Node subclasses with a vertical content-bias should honor the height
 parameter whether -1 or a positive value.   All other subclasses may ignore
 the height parameter (which will likely be -1).
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>height</code> - the height that should be used if minimum width depends on it</dd>
<dt><span class="strong">Returns:</span></dt><dd>the minimum width that the node should be resized to during layout</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isResizable()"><code>isResizable()</code></a>, 
<a href="Node.html#getContentBias()"><code>getContentBias()</code></a></dd></dl>
</li>
</ul>
<a name="minHeight(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minHeight</h4>
<pre>public&nbsp;double&nbsp;minHeight(double&nbsp;width)</pre>
<div class="block">Returns the node's minimum height for use in layout calculations.
 If the node is resizable, its parent should not resize its height any
 smaller than this value.  If the node is not resizable, returns its
 layoutBounds height.
 <p>
 Layout code which calls this method should first check the content-bias
 of the node.  If the node has a horizontal content-bias, then callers
 should pass in a width value that the minimum height should be based on.
 If the node has either a vertical or null content-bias, then the caller
 should pass in -1.
 <p>
 Node subclasses with a horizontal content-bias should honor the width
 parameter whether -1 or a positive value.   All other subclasses may ignore
 the width parameter (which will likely be -1).
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>width</code> - the width that should be used if minimum height depends on it</dd>
<dt><span class="strong">Returns:</span></dt><dd>the minimum height that the node should be resized to during layout</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isResizable()"><code>isResizable()</code></a>, 
<a href="Node.html#getContentBias()"><code>getContentBias()</code></a></dd></dl>
</li>
</ul>
<a name="prefWidth(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prefWidth</h4>
<pre>public&nbsp;double&nbsp;prefWidth(double&nbsp;height)</pre>
<div class="block">Returns the node's preferred width for use in layout calculations.
 If the node is resizable, its parent should treat this value as the
 node's ideal width within its range.  If the node is not resizable,
 just returns its layoutBounds width, which should be treated as the rigid
 width of the node.
 <p>
 Layout code which calls this method should first check the content-bias
 of the node.  If the node has a vertical content-bias, then callers
 should pass in a height value that the preferred width should be based on.
 If the node has either a horizontal or null content-bias, then the caller
 should pass in -1.
 <p>
 Node subclasses with a vertical content-bias should honor the height
 parameter whether -1 or a positive value.   All other subclasses may ignore
 the height parameter (which will likely be -1).
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>height</code> - the height that should be used if preferred width depends on it</dd>
<dt><span class="strong">Returns:</span></dt><dd>the preferred width that the node should be resized to during layout</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isResizable()"><code>isResizable()</code></a>, 
<a href="Node.html#getContentBias()"><code>getContentBias()</code></a>, 
<a href="Node.html#autosize()"><code>autosize()</code></a></dd></dl>
</li>
</ul>
<a name="prefHeight(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prefHeight</h4>
<pre>public&nbsp;double&nbsp;prefHeight(double&nbsp;width)</pre>
<div class="block">Returns the node's preferred height for use in layout calculations.
 If the node is resizable, its parent should treat this value as the
 node's ideal height within its range.  If the node is not resizable,
 just returns its layoutBounds height, which should be treated as the rigid
 height of the node.
 <p>
 Layout code which calls this method should first check the content-bias
 of the node.  If the node has a horizontal content-bias, then callers
 should pass in a width value that the preferred height should be based on.
 If the node has either a vertical or null content-bias, then the caller
 should pass in -1.
 <p>
 Node subclasses with a horizontal content-bias should honor the height
 parameter whether -1 or a positive value.   All other subclasses may ignore
 the height parameter (which will likely be -1).
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>width</code> - the width that should be used if preferred height depends on it</dd>
<dt><span class="strong">Returns:</span></dt><dd>the preferred height that the node should be resized to during layout</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getContentBias()"><code>getContentBias()</code></a>, 
<a href="Node.html#autosize()"><code>autosize()</code></a></dd></dl>
</li>
</ul>
<a name="maxWidth(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maxWidth</h4>
<pre>public&nbsp;double&nbsp;maxWidth(double&nbsp;height)</pre>
<div class="block">Returns the node's maximum width for use in layout calculations.
 If the node is resizable, its parent should not resize its width any
 larger than this value.  A value of Double.MAX_VALUE indicates the
 parent may expand the node's width beyond its preferred without limits.
 <p>
 If the node is not resizable, returns its layoutBounds width.
 <p>
 Layout code which calls this method should first check the content-bias
 of the node.  If the node has a vertical content-bias, then callers
 should pass in a height value that the maximum width should be based on.
 If the node has either a horizontal or null content-bias, then the caller
 should pass in -1.
 <p>
 Node subclasses with a vertical content-bias should honor the height
 parameter whether -1 or a positive value.   All other subclasses may ignore
 the height parameter (which will likely be -1).
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>height</code> - the height that should be used if maximum width depends on it</dd>
<dt><span class="strong">Returns:</span></dt><dd>the maximum width that the node should be resized to during layout</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isResizable()"><code>isResizable()</code></a>, 
<a href="Node.html#getContentBias()"><code>getContentBias()</code></a></dd></dl>
</li>
</ul>
<a name="maxHeight(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maxHeight</h4>
<pre>public&nbsp;double&nbsp;maxHeight(double&nbsp;width)</pre>
<div class="block">Returns the node's maximum height for use in layout calculations.
 If the node is resizable, its parent should not resize its height any
 larger than this value.  A value of Double.MAX_VALUE indicates the
 parent may expand the node's height beyond its preferred without limits.
 <p>
 If the node is not resizable, returns its layoutBounds height.
 <p>
 Layout code which calls this method should first check the content-bias
 of the node.  If the node has a horizontal content-bias, then callers
 should pass in a width value that the maximum height should be based on.
 If the node has either a vertical or null content-bias, then the caller
 should pass in -1.
 <p>
 Node subclasses with a horizontal content-bias should honor the width
 parameter whether -1 or a positive value.   All other subclasses may ignore
 the width parameter (which will likely be -1).
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>width</code> - the width that should be used if maximum height depends on it</dd>
<dt><span class="strong">Returns:</span></dt><dd>the maximum height that the node should be resized to during layout</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isResizable()"><code>isResizable()</code></a>, 
<a href="Node.html#getContentBias()"><code>getContentBias()</code></a></dd></dl>
</li>
</ul>
<a name="resize(double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resize</h4>
<pre>public&nbsp;void&nbsp;resize(double&nbsp;width,
          double&nbsp;height)</pre>
<div class="block">If the node is resizable, will set its layout bounds to the specified
 width and height.   If the node is not resizable, this method is a no-op.
 <p>
 This method should generally only be called by parent nodes from their
 layoutChildren() methods.   All Parent classes will automatically resize
 resizable children, so resizing done directly by the application will be
 overridden by the node's parent, unless the child is unmanaged.
 <p>
 Parents are responsible for ensuring the width and height values fall
 within the resizable node's preferred range.  The autosize() method may
 be used if the parent just needs to resize the node to its preferred size.
 
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>width</code> - the target layout bounds width</dd><dd><code>height</code> - the target layout bounds height</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isResizable()"><code>isResizable()</code></a>, 
<a href="Node.html#getContentBias()"><code>getContentBias()</code></a>, 
<a href="Node.html#autosize()"><code>autosize()</code></a>, 
<a href="Node.html#minWidth(double)"><code>minWidth(double)</code></a>, 
<a href="Node.html#minHeight(double)"><code>minHeight(double)</code></a>, 
<a href="Node.html#prefWidth(double)"><code>prefWidth(double)</code></a>, 
<a href="Node.html#prefHeight(double)"><code>prefHeight(double)</code></a>, 
<a href="Node.html#maxWidth(double)"><code>maxWidth(double)</code></a>, 
<a href="Node.html#maxHeight(double)"><code>maxHeight(double)</code></a>, 
<a href="Node.html#getLayoutBounds()"><code>getLayoutBounds()</code></a></dd></dl>
</li>
</ul>
<a name="autosize()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>autosize</h4>
<pre>public final&nbsp;void&nbsp;autosize()</pre>
<div class="block">If the node is resizable, will set its layout bounds to its current preferred
 width and height. If the node is not resizable, this method is a no-op.
 <p>
 This method automatically queries the node's content-bias and if it's
 horizontal, will pass in the node's preferred width to get the preferred
 height; if vertical, will pass in the node's preferred height to get the width,
 and if null, will compute the preferred width/height independently.
 <p></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isResizable()"><code>isResizable()</code></a>, 
<a href="Node.html#getContentBias()"><code>getContentBias()</code></a></dd></dl>
</li>
</ul>
<a name="resizeRelocate(double, double, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resizeRelocate</h4>
<pre>public&nbsp;void&nbsp;resizeRelocate(double&nbsp;x,
                  double&nbsp;y,
                  double&nbsp;width,
                  double&nbsp;height)</pre>
<div class="block">If the node is resizable, will set its layout bounds to the specified
 width and height.   If the node is not resizable, the resize step is skipped.
 <p>
 Once the node has been resized (if resizable) then sets the node's layoutX
 and layoutY translation properties in order to relocate it to x,y in the
 parent's coordinate space.
 <p>
 This method should generally only be called by parent nodes from their
 layoutChildren() methods.   All Parent classes will automatically resize
 resizable children, so resizing done directly by the application will be
 overridden by the node's parent, unless the child is unmanaged.
 <p>
 Parents are responsible for ensuring the width and height values fall
 within the resizable node's preferred range.  The autosize() and relocate()
 methods may be used if the parent just needs to resize the node to its
 preferred size and reposition it.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>x</code> - the target x coordinate location</dd><dd><code>y</code> - the target y coordinate location</dd><dd><code>width</code> - the target layout bounds width</dd><dd><code>height</code> - the target layout bounds height</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isResizable()"><code>isResizable()</code></a>, 
<a href="Node.html#getContentBias()"><code>getContentBias()</code></a>, 
<a href="Node.html#autosize()"><code>autosize()</code></a>, 
<a href="Node.html#minWidth(double)"><code>minWidth(double)</code></a>, 
<a href="Node.html#minHeight(double)"><code>minHeight(double)</code></a>, 
<a href="Node.html#prefWidth(double)"><code>prefWidth(double)</code></a>, 
<a href="Node.html#prefHeight(double)"><code>prefHeight(double)</code></a>, 
<a href="Node.html#maxWidth(double)"><code>maxWidth(double)</code></a>, 
<a href="Node.html#maxHeight(double)"><code>maxHeight(double)</code></a></dd></dl>
</li>
</ul>
<a name="getBaselineOffset()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBaselineOffset</h4>
<pre>public&nbsp;double&nbsp;getBaselineOffset()</pre>
<div class="block">The 'alphabetic' (or 'roman') baseline offset from the node's layoutBounds.minY location
 that should be used when this node is being vertically aligned by baseline with
 other nodes.  By default this returns the layoutBounds height of the node.  Subclasses
 which contain text should override this method to return their actual text baseline offset.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>offset of text baseline from layoutBounds.minY</dd></dl>
</li>
</ul>
<a name="getBoundsInParent()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBoundsInParent</h4>
<pre>public final&nbsp;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;getBoundsInParent()</pre>
<div class="block">Gets the value of the property boundsInParent.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>The rectangular bounds of this <code>Node</code> which include its transforms.
 <code>boundsInParent</code> is calculated by
 taking the local bounds (defined by <a href="Node.html#boundsInLocalProperty()"><code>boundsInLocal</code></a>) and applying
 the transform created by setting the following additional variables
 <ol>
 <li><a href="Node.html#getTransforms()"><code>transforms</code></a> ObservableList</li>
 <li><a href="Node.html#scaleXProperty()"><code>scaleX</code></a>, <a href="Node.html#scaleYProperty()"><code>scaleY</code></a></li>
 <li><a href="Node.html#rotateProperty()"><code>rotate</code></a></li>
 <li><a href="Node.html#layoutXProperty()"><code>layoutX</code></a>, <a href="Node.html#layoutYProperty()"><code>layoutY</code></a></li>
 <li><a href="Node.html#translateXProperty()"><code>translateX</code></a>, <a href="Node.html#translateYProperty()"><code>translateY</code></a></li>
 </ol>
 <p>
 The resulting bounds will be conceptually in the coordinate space of the
 <code>Node</code>'s parent, however the node need not have a parent to calculate
 these bounds.
 <p>
 Note that this method does not take the node's visibility into account;
 the computation is based on the geometry of this <code>Node</code> only.
 <p>
 This property will always have a non-null value.
 <p>
 Note that boundsInParent is automatically recomputed whenever the
 geometry of a node changes, or when any of the following the change:
 transforms ObservableList, translateX, translateY, layoutX, layoutY,
 scaleX, scaleY, or the rotate variable. For this reason, it is an error
 to bind any of these values in a node to an expression that depends upon
 this variable. For example, the x or y variables of a shape, or
 translateX, translateY should never be bound to boundsInParent
 for the purpose of positioning the node.</dd></dl>
</li>
</ul>
<a name="boundsInParentProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boundsInParentProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt;&nbsp;boundsInParentProperty()</pre>
<div class="block">The rectangular bounds of this <code>Node</code> which include its transforms.
 <code>boundsInParent</code> is calculated by
 taking the local bounds (defined by <a href="Node.html#boundsInLocalProperty()"><code>boundsInLocal</code></a>) and applying
 the transform created by setting the following additional variables
 <ol>
 <li><a href="Node.html#getTransforms()"><code>transforms</code></a> ObservableList</li>
 <li><a href="Node.html#scaleXProperty()"><code>scaleX</code></a>, <a href="Node.html#scaleYProperty()"><code>scaleY</code></a></li>
 <li><a href="Node.html#rotateProperty()"><code>rotate</code></a></li>
 <li><a href="Node.html#layoutXProperty()"><code>layoutX</code></a>, <a href="Node.html#layoutYProperty()"><code>layoutY</code></a></li>
 <li><a href="Node.html#translateXProperty()"><code>translateX</code></a>, <a href="Node.html#translateYProperty()"><code>translateY</code></a></li>
 </ol>
 <p>
 The resulting bounds will be conceptually in the coordinate space of the
 <code>Node</code>'s parent, however the node need not have a parent to calculate
 these bounds.
 <p>
 Note that this method does not take the node's visibility into account;
 the computation is based on the geometry of this <code>Node</code> only.
 <p>
 This property will always have a non-null value.
 <p>
 Note that boundsInParent is automatically recomputed whenever the
 geometry of a node changes, or when any of the following the change:
 transforms ObservableList, translateX, translateY, layoutX, layoutY,
 scaleX, scaleY, or the rotate variable. For this reason, it is an error
 to bind any of these values in a node to an expression that depends upon
 this variable. For example, the x or y variables of a shape, or
 translateX, translateY should never be bound to boundsInParent
 for the purpose of positioning the node.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getBoundsInParent()"><code>getBoundsInParent()</code></a></dd></dl>
</li>
</ul>
<a name="getBoundsInLocal()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBoundsInLocal</h4>
<pre>public final&nbsp;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;getBoundsInLocal()</pre>
<div class="block">Gets the value of the property boundsInLocal.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>The rectangular bounds of this <code>Node</code> in the node's
 untransformed local coordinate space.  For nodes that extend
 <a href="shape/Shape.html" title="class in javafx.scene.shape"><code>Shape</code></a>, the local bounds will also include
 space required for a non-zero stroke that may fall outside the shape's
 geometry that is defined by position and size attributes.
 The local bounds will also include any clipping set with <a href="Node.html#clipProperty()"><code>clip</code></a>
 as well as effects set with <a href="Node.html#effectProperty()"><code>effect</code></a>.

 <p>
 Note that this method does not take the node's visibility into account;
 the computation is based on the geometry of this <code>Node</code> only.
 <p>
 This property will always have a non-null value.
 <p>
 Note that boundsInLocal is automatically recomputed whenever the
 geometry of a node changes. For this reason, it is an error to bind any
 of these values in a node to an expression that depends upon this variable.
 For example, the x or y variables of a shape should never be bound
 to boundsInLocal for the purpose of positioning the node.</dd></dl>
</li>
</ul>
<a name="boundsInLocalProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boundsInLocalProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt;&nbsp;boundsInLocalProperty()</pre>
<div class="block">The rectangular bounds of this <code>Node</code> in the node's
 untransformed local coordinate space.  For nodes that extend
 <a href="shape/Shape.html" title="class in javafx.scene.shape"><code>Shape</code></a>, the local bounds will also include
 space required for a non-zero stroke that may fall outside the shape's
 geometry that is defined by position and size attributes.
 The local bounds will also include any clipping set with <a href="Node.html#clipProperty()"><code>clip</code></a>
 as well as effects set with <a href="Node.html#effectProperty()"><code>effect</code></a>.

 <p>
 Note that this method does not take the node's visibility into account;
 the computation is based on the geometry of this <code>Node</code> only.
 <p>
 This property will always have a non-null value.
 <p>
 Note that boundsInLocal is automatically recomputed whenever the
 geometry of a node changes. For this reason, it is an error to bind any
 of these values in a node to an expression that depends upon this variable.
 For example, the x or y variables of a shape should never be bound
 to boundsInLocal for the purpose of positioning the node.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getBoundsInLocal()"><code>getBoundsInLocal()</code></a></dd></dl>
</li>
</ul>
<a name="getLayoutBounds()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLayoutBounds</h4>
<pre>public final&nbsp;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;getLayoutBounds()</pre>
<div class="block">Gets the value of the property layoutBounds.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>The rectangular bounds that should be used for layout calculations for
 this node. <code>layoutBounds</code> may differ from the visual bounds
 of the node and is computed differently depending on the node type.
 <p>
 If the node type is resizable (<a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>,
 <a href="control/Control.html" title="class in javafx.scene.control"><code>Control</code></a>, or <a href="web/WebView.html" title="class in javafx.scene.web"><code>WebView</code></a>)
 then the layoutBounds will always be <code>0,0 width x height</code>.
 If the node type is not resizable (<a href="shape/Shape.html" title="class in javafx.scene.shape"><code>Shape</code></a>,
 <a href="text/Text.html" title="class in javafx.scene.text"><code>Text</code></a>, or <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>), then the layoutBounds
 are computed based on the node's geometric properties and does not include the
 node's clip, effect, or transforms.  See individual class documentation
 for details.
 <p>
 Note that the <a href="Node.html#layoutXProperty()"><code>layoutX</code></a>, <a href="Node.html#layoutYProperty()"><code>layoutY</code></a>, <a href="Node.html#translateXProperty()"><code>translateX</code></a>, and
 <a href="Node.html#translateYProperty()"><code>translateY</code></a> variables are not included in the layoutBounds.
 This is important because layout code must first determine the current
 size and location of the node (using layoutBounds) and then set
 <code>layoutX</code> and <code>layoutY</code> to adjust the translation of the
 node so that it will have the desired layout position.
 <p>
 Because the computation of layoutBounds is often tied to a node's
 geometric variables, it is an error to bind any such variables to an
 expression that depends upon <code>layoutBounds</code>. For example, the
 x or y variables of a shape should never be bound to layoutBounds
 for the purpose of positioning the node.
 <p>
 The layoutBounds will never be null.</dd></dl>
</li>
</ul>
<a name="layoutBoundsProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>layoutBoundsProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&gt;&nbsp;layoutBoundsProperty()</pre>
<div class="block">The rectangular bounds that should be used for layout calculations for
 this node. <code>layoutBounds</code> may differ from the visual bounds
 of the node and is computed differently depending on the node type.
 <p>
 If the node type is resizable (<a href="layout/Region.html" title="class in javafx.scene.layout"><code>Region</code></a>,
 <a href="control/Control.html" title="class in javafx.scene.control"><code>Control</code></a>, or <a href="web/WebView.html" title="class in javafx.scene.web"><code>WebView</code></a>)
 then the layoutBounds will always be <code>0,0 width x height</code>.
 If the node type is not resizable (<a href="shape/Shape.html" title="class in javafx.scene.shape"><code>Shape</code></a>,
 <a href="text/Text.html" title="class in javafx.scene.text"><code>Text</code></a>, or <a href="Group.html" title="class in javafx.scene"><code>Group</code></a>), then the layoutBounds
 are computed based on the node's geometric properties and does not include the
 node's clip, effect, or transforms.  See individual class documentation
 for details.
 <p>
 Note that the <a href="Node.html#layoutXProperty()"><code>layoutX</code></a>, <a href="Node.html#layoutYProperty()"><code>layoutY</code></a>, <a href="Node.html#translateXProperty()"><code>translateX</code></a>, and
 <a href="Node.html#translateYProperty()"><code>translateY</code></a> variables are not included in the layoutBounds.
 This is important because layout code must first determine the current
 size and location of the node (using layoutBounds) and then set
 <code>layoutX</code> and <code>layoutY</code> to adjust the translation of the
 node so that it will have the desired layout position.
 <p>
 Because the computation of layoutBounds is often tied to a node's
 geometric variables, it is an error to bind any such variables to an
 expression that depends upon <code>layoutBounds</code>. For example, the
 x or y variables of a shape should never be bound to layoutBounds
 for the purpose of positioning the node.
 <p>
 The layoutBounds will never be null.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getLayoutBounds()"><code>getLayoutBounds()</code></a></dd></dl>
</li>
</ul>
<a name="contains(double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contains</h4>
<pre>public&nbsp;boolean&nbsp;contains(double&nbsp;localX,
               double&nbsp;localY)</pre>
<div class="block">Returns <code>true</code> if the given point (specified in the local
 coordinate space of this <code>Node</code>) is contained within the shape of
 this <code>Node</code>. Note that this method does not take visibility into
 account; the test is based on the geometry of this <code>Node</code> only.</div>
</li>
</ul>
<a name="contains(javafx.geometry.Point2D)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contains</h4>
<pre>public&nbsp;boolean&nbsp;contains(<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;localPoint)</pre>
<div class="block">Returns <code>true</code> if the given point (specified in the local
 coordinate space of this <code>Node</code>) is contained within the shape of
 this <code>Node</code>. Note that this method does not take visibility into
 account; the test is based on the geometry of this <code>Node</code> only.</div>
</li>
</ul>
<a name="intersects(double, double, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersects</h4>
<pre>public&nbsp;boolean&nbsp;intersects(double&nbsp;localX,
                 double&nbsp;localY,
                 double&nbsp;localWidth,
                 double&nbsp;localHeight)</pre>
<div class="block">Returns <code>true</code> if the given rectangle (specified in the local
 coordinate space of this <code>Node</code>) intersects the shape of this
 <code>Node</code>. Note that this method does not take visibility into
 account; the test is based on the geometry of this <code>Node</code> only.
 The default behavior of this function is simply to check if the
 given coordinates intersect with the local bounds.</div>
</li>
</ul>
<a name="intersects(javafx.geometry.Bounds)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersects</h4>
<pre>public&nbsp;boolean&nbsp;intersects(<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;localBounds)</pre>
<div class="block">Returns <code>true</code> if the given bounds (specified in the local
 coordinate space of this <code>Node</code>) intersects the shape of this
 <code>Node</code>. Note that this method does not take visibility into
 account; the test is based on the geometry of this <code>Node</code> only.
 The default behavior of this function is simply to check if the
 given coordinates intersect with the local bounds.</div>
</li>
</ul>
<a name="sceneToLocal(double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sceneToLocal</h4>
<pre>public&nbsp;<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;sceneToLocal(double&nbsp;sceneX,
                   double&nbsp;sceneY)</pre>
<div class="block">Transforms a point from the coordinate space of the <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>
 into the local coordinate space of this <code>Node</code>.</div>
</li>
</ul>
<a name="sceneToLocal(javafx.geometry.Point2D)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sceneToLocal</h4>
<pre>public&nbsp;<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;sceneToLocal(<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;scenePoint)</pre>
<div class="block">Transforms a point from the coordinate space of the <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>
 into the local coordinate space of this <code>Node</code>.</div>
</li>
</ul>
<a name="sceneToLocal(javafx.geometry.Bounds)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sceneToLocal</h4>
<pre>public&nbsp;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;sceneToLocal(<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;sceneBounds)</pre>
<div class="block">Transforms a rectangle from the coordinate space of the
 <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a> into the local coordinate space of this
 <code>Node</code>.</div>
</li>
</ul>
<a name="localToScene(double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localToScene</h4>
<pre>public&nbsp;<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;localToScene(double&nbsp;localX,
                   double&nbsp;localY)</pre>
<div class="block">Transforms a point from the local coordinate space of this <code>Node</code>
 into the coordinate space of its <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>.</div>
</li>
</ul>
<a name="localToScene(javafx.geometry.Point2D)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localToScene</h4>
<pre>public&nbsp;<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;localToScene(<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;localPoint)</pre>
<div class="block">Transforms a point from the local coordinate space of this <code>Node</code>
 into the coordinate space of its <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>.</div>
</li>
</ul>
<a name="localToScene(javafx.geometry.Bounds)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localToScene</h4>
<pre>public&nbsp;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;localToScene(<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;localBounds)</pre>
<div class="block">Transforms a bounds from the local coordinate space of this
 <code>Node</code> into the coordinate space of its <a href="Scene.html" title="class in javafx.scene"><code>Scene</code></a>.</div>
</li>
</ul>
<a name="parentToLocal(double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parentToLocal</h4>
<pre>public&nbsp;<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;parentToLocal(double&nbsp;parentX,
                    double&nbsp;parentY)</pre>
<div class="block">Transforms a point from the coordinate space of the parent into the
 local coordinate space of this <code>Node</code>.</div>
</li>
</ul>
<a name="parentToLocal(javafx.geometry.Point2D)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parentToLocal</h4>
<pre>public&nbsp;<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;parentToLocal(<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;parentPoint)</pre>
<div class="block">Transforms a point from the coordinate space of the parent into the
 local coordinate space of this <code>Node</code>.</div>
</li>
</ul>
<a name="parentToLocal(javafx.geometry.Bounds)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parentToLocal</h4>
<pre>public&nbsp;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;parentToLocal(<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;parentBounds)</pre>
<div class="block">Transforms a rectangle from the coordinate space of the parent into the
 local coordinate space of this <code>Node</code>.</div>
</li>
</ul>
<a name="localToParent(double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localToParent</h4>
<pre>public&nbsp;<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;localToParent(double&nbsp;localX,
                    double&nbsp;localY)</pre>
<div class="block">Transforms a point from the local coordinate space of this <code>Node</code>
 into the coordinate space of its parent.</div>
</li>
</ul>
<a name="localToParent(javafx.geometry.Point2D)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localToParent</h4>
<pre>public&nbsp;<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;localToParent(<a href="../geometry/Point2D.html" title="class in javafx.geometry">Point2D</a>&nbsp;localPoint)</pre>
<div class="block">Transforms a point from the local coordinate space of this <code>Node</code>
 into the coordinate space of its parent.</div>
</li>
</ul>
<a name="localToParent(javafx.geometry.Bounds)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localToParent</h4>
<pre>public&nbsp;<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;localToParent(<a href="../geometry/Bounds.html" title="class in javafx.geometry">Bounds</a>&nbsp;localBounds)</pre>
<div class="block">Transforms a bounds from the local coordinate space of this
 <code>Node</code> into the coordinate space of its parent.</div>
</li>
</ul>
<a name="getTransforms()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTransforms</h4>
<pre>public final&nbsp;<a href="../collections/ObservableList.html" title="interface in javafx.collections">ObservableList</a>&lt;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&gt;&nbsp;getTransforms()</pre>
<div class="block">Defines the ObservableList of <a href="transform/Transform.html" title="class in javafx.scene.transform"><code>Transform</code></a> objects
 to be applied to this <code>Node</code>. This ObservableList of transforms is applied
 before <a href="Node.html#translateXProperty()"><code>translateX</code></a>, <a href="Node.html#translateYProperty()"><code>translateY</code></a>, <a href="Node.html#scaleXProperty()"><code>scaleX</code></a>, and
 <a href="Node.html#scaleYProperty()"><code>scaleY</code></a>, <a href="Node.html#rotateProperty()"><code>rotate</code></a> transforms.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>empty</dd></dl>
</li>
</ul>
<a name="setTranslateX(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTranslateX</h4>
<pre>public final&nbsp;void&nbsp;setTranslateX(double&nbsp;value)</pre>
<div class="block">Sets the value of the property translateX.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform.
 <p>
 The node's final translation will be computed as <a href="Node.html#layoutXProperty()"><code>layoutX</code></a> + <code>translateX</code>,
 where <code>layoutX</code> establishes the node's stable position and <code>translateX</code>
 optionally makes dynamic adjustments to that position.
<p>
 This variable can be used to alter the location of a node without disturbing
 its <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>, which makes it useful for animating a node's location.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>0</dd></dl>
</li>
</ul>
<a name="getTranslateX()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTranslateX</h4>
<pre>public final&nbsp;double&nbsp;getTranslateX()</pre>
<div class="block">Gets the value of the property translateX.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform.
 <p>
 The node's final translation will be computed as <a href="Node.html#layoutXProperty()"><code>layoutX</code></a> + <code>translateX</code>,
 where <code>layoutX</code> establishes the node's stable position and <code>translateX</code>
 optionally makes dynamic adjustments to that position.
<p>
 This variable can be used to alter the location of a node without disturbing
 its <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>, which makes it useful for animating a node's location.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>0</dd></dl>
</li>
</ul>
<a name="translateXProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>translateXProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a>&nbsp;translateXProperty()</pre>
<div class="block">Defines the x coordinate of the translation that is added to this <code>Node</code>'s
 transform.
 <p>
 The node's final translation will be computed as <a href="Node.html#layoutXProperty()"><code>layoutX</code></a> + <code>translateX</code>,
 where <code>layoutX</code> establishes the node's stable position and <code>translateX</code>
 optionally makes dynamic adjustments to that position.
<p>
 This variable can be used to alter the location of a node without disturbing
 its <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>, which makes it useful for animating a node's location.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getTranslateX()"><code>getTranslateX()</code></a>, 
<a href="Node.html#setTranslateX(double)"><code>setTranslateX(double)</code></a></dd></dl>
</li>
</ul>
<a name="setTranslateY(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTranslateY</h4>
<pre>public final&nbsp;void&nbsp;setTranslateY(double&nbsp;value)</pre>
<div class="block">Sets the value of the property translateY.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform.
 <p>
 The node's final translation will be computed as <a href="Node.html#layoutYProperty()"><code>layoutY</code></a> + <code>translateY</code>,
 where <code>layoutY</code> establishes the node's stable position and <code>translateY</code>
 optionally makes dynamic adjustments to that position.
<p>
 This variable can be used to alter the location of a node without disturbing
 its <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>, which makes it useful for animating a node's location.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>0</dd></dl>
</li>
</ul>
<a name="getTranslateY()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTranslateY</h4>
<pre>public final&nbsp;double&nbsp;getTranslateY()</pre>
<div class="block">Gets the value of the property translateY.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform.
 <p>
 The node's final translation will be computed as <a href="Node.html#layoutYProperty()"><code>layoutY</code></a> + <code>translateY</code>,
 where <code>layoutY</code> establishes the node's stable position and <code>translateY</code>
 optionally makes dynamic adjustments to that position.
<p>
 This variable can be used to alter the location of a node without disturbing
 its <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>, which makes it useful for animating a node's location.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>0</dd></dl>
</li>
</ul>
<a name="translateYProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>translateYProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a>&nbsp;translateYProperty()</pre>
<div class="block">Defines the y coordinate of the translation that is added to this <code>Node</code>'s
 transform.
 <p>
 The node's final translation will be computed as <a href="Node.html#layoutYProperty()"><code>layoutY</code></a> + <code>translateY</code>,
 where <code>layoutY</code> establishes the node's stable position and <code>translateY</code>
 optionally makes dynamic adjustments to that position.
<p>
 This variable can be used to alter the location of a node without disturbing
 its <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>, which makes it useful for animating a node's location.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getTranslateY()"><code>getTranslateY()</code></a>, 
<a href="Node.html#setTranslateY(double)"><code>setTranslateY(double)</code></a></dd></dl>
</li>
</ul>
<a name="setTranslateZ(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTranslateZ</h4>
<pre>public final&nbsp;void&nbsp;setTranslateZ(double&nbsp;value)</pre>
<div class="block">Sets the value of the property translateZ.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the Z coordinate of the translation that is added to the
 transformed coordinates of this <code>Node</code>.  This value will be added
 to any translation defined by the <code>transforms</code> ObservableList and
 <code>layoutZ</code>.
<p>
 This variable can be used to alter the location of a Node without
 disturbing its layout bounds, which makes it useful for animating a
 node's location.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>0</dd></dl>
</li>
</ul>
<a name="getTranslateZ()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTranslateZ</h4>
<pre>public final&nbsp;double&nbsp;getTranslateZ()</pre>
<div class="block">Gets the value of the property translateZ.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the Z coordinate of the translation that is added to the
 transformed coordinates of this <code>Node</code>.  This value will be added
 to any translation defined by the <code>transforms</code> ObservableList and
 <code>layoutZ</code>.
<p>
 This variable can be used to alter the location of a Node without
 disturbing its layout bounds, which makes it useful for animating a
 node's location.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>0</dd></dl>
</li>
</ul>
<a name="translateZProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>translateZProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a>&nbsp;translateZProperty()</pre>
<div class="block">Defines the Z coordinate of the translation that is added to the
 transformed coordinates of this <code>Node</code>.  This value will be added
 to any translation defined by the <code>transforms</code> ObservableList and
 <code>layoutZ</code>.
<p>
 This variable can be used to alter the location of a Node without
 disturbing its layout bounds, which makes it useful for animating a
 node's location.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>JavaFX 1.3</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getTranslateZ()"><code>getTranslateZ()</code></a>, 
<a href="Node.html#setTranslateZ(double)"><code>setTranslateZ(double)</code></a></dd></dl>
</li>
</ul>
<a name="setScaleX(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setScaleX</h4>
<pre>public final&nbsp;void&nbsp;setScaleX(double&nbsp;value)</pre>
<div class="block">Sets the value of the property scaleX.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the factor by which coordinates are scaled about the center of the
 object along the X axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd></dl>
</li>
</ul>
<a name="getScaleX()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getScaleX</h4>
<pre>public final&nbsp;double&nbsp;getScaleX()</pre>
<div class="block">Gets the value of the property scaleX.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the factor by which coordinates are scaled about the center of the
 object along the X axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd></dl>
</li>
</ul>
<a name="scaleXProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scaleXProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a>&nbsp;scaleXProperty()</pre>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the X axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getScaleX()"><code>getScaleX()</code></a>, 
<a href="Node.html#setScaleX(double)"><code>setScaleX(double)</code></a></dd></dl>
</li>
</ul>
<a name="setScaleY(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setScaleY</h4>
<pre>public final&nbsp;void&nbsp;setScaleY(double&nbsp;value)</pre>
<div class="block">Sets the value of the property scaleY.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the factor by which coordinates are scaled about the center of the
 object along the Y axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd></dl>
</li>
</ul>
<a name="getScaleY()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getScaleY</h4>
<pre>public final&nbsp;double&nbsp;getScaleY()</pre>
<div class="block">Gets the value of the property scaleY.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the factor by which coordinates are scaled about the center of the
 object along the Y axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd></dl>
</li>
</ul>
<a name="scaleYProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scaleYProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a>&nbsp;scaleYProperty()</pre>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the Y axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getScaleY()"><code>getScaleY()</code></a>, 
<a href="Node.html#setScaleY(double)"><code>setScaleY(double)</code></a></dd></dl>
</li>
</ul>
<a name="setScaleZ(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setScaleZ</h4>
<pre>public final&nbsp;void&nbsp;setScaleZ(double&nbsp;value)</pre>
<div class="block">Sets the value of the property scaleZ.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the factor by which coordinates are scaled about the center of the
 object along the Z axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 rectangular bounds formed by taking <a href="Node.html#boundsInLocalProperty()"><code>boundsInLocal</code></a> and applying
 all the transforms in the <a href="Node.html#getTransforms()"><code>transforms</code></a> ObservableList.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd></dl>
</li>
</ul>
<a name="getScaleZ()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getScaleZ</h4>
<pre>public final&nbsp;double&nbsp;getScaleZ()</pre>
<div class="block">Gets the value of the property scaleZ.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the factor by which coordinates are scaled about the center of the
 object along the Z axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 rectangular bounds formed by taking <a href="Node.html#boundsInLocalProperty()"><code>boundsInLocal</code></a> and applying
 all the transforms in the <a href="Node.html#getTransforms()"><code>transforms</code></a> ObservableList.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd></dl>
</li>
</ul>
<a name="scaleZProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scaleZProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a>&nbsp;scaleZProperty()</pre>
<div class="block">Defines the factor by which coordinates are scaled about the center of the
 object along the Z axis of this <code>Node</code>. This is used to stretch or
 animate the node either manually or by using an animation.
 <p>
 This scale factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for scaling the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the scale occurs is the center of the
 rectangular bounds formed by taking <a href="Node.html#boundsInLocalProperty()"><code>boundsInLocal</code></a> and applying
 all the transforms in the <a href="Node.html#getTransforms()"><code>transforms</code></a> ObservableList.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>JavaFX 1.3</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>1.0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getScaleZ()"><code>getScaleZ()</code></a>, 
<a href="Node.html#setScaleZ(double)"><code>setScaleZ(double)</code></a></dd></dl>
</li>
</ul>
<a name="setRotate(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRotate</h4>
<pre>public final&nbsp;void&nbsp;setRotate(double&nbsp;value)</pre>
<div class="block">Sets the value of the property rotate.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the angle of rotation about the <code>Node</code>'s center, measured in
 degrees. This is used to rotate the <code>Node</code>.
 <p>
 This rotation factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for rotating the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the rotation occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.
 <p>
 Note that because the pivot point is computed as the center of this
 <code>Node</code>'s layout bounds, any change to the layout bounds will cause
 the pivot point to change, which can move the object. For a leaf node,
 any change to the geometry will cause the layout bounds to change.
 For a group node, any change to any of its children, including a
 change in a child's geometry, clip, effect, position, orientation, or
 scale, will cause the group's layout bounds to change. If this movement
 of the pivot point is not
 desired, applications should instead use the Node's <a href="Node.html#getTransforms()"><code>transforms</code></a>
 ObservableList, and add a <a href="transform/Rotate.html" title="class in javafx.scene.transform"><code>Rotate</code></a> transform,
 which has a user-specifiable pivot point.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>0.0</dd></dl>
</li>
</ul>
<a name="getRotate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRotate</h4>
<pre>public final&nbsp;double&nbsp;getRotate()</pre>
<div class="block">Gets the value of the property rotate.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the angle of rotation about the <code>Node</code>'s center, measured in
 degrees. This is used to rotate the <code>Node</code>.
 <p>
 This rotation factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for rotating the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the rotation occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.
 <p>
 Note that because the pivot point is computed as the center of this
 <code>Node</code>'s layout bounds, any change to the layout bounds will cause
 the pivot point to change, which can move the object. For a leaf node,
 any change to the geometry will cause the layout bounds to change.
 For a group node, any change to any of its children, including a
 change in a child's geometry, clip, effect, position, orientation, or
 scale, will cause the group's layout bounds to change. If this movement
 of the pivot point is not
 desired, applications should instead use the Node's <a href="Node.html#getTransforms()"><code>transforms</code></a>
 ObservableList, and add a <a href="transform/Rotate.html" title="class in javafx.scene.transform"><code>Rotate</code></a> transform,
 which has a user-specifiable pivot point.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>0.0</dd></dl>
</li>
</ul>
<a name="rotateProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotateProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/DoubleProperty.html" title="class in javafx.beans.property">DoubleProperty</a>&nbsp;rotateProperty()</pre>
<div class="block">Defines the angle of rotation about the <code>Node</code>'s center, measured in
 degrees. This is used to rotate the <code>Node</code>.
 <p>
 This rotation factor is not included in <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a> by
 default, which makes it ideal for rotating the entire node after
 all effects and transforms have been taken into account.
 <p>
 The pivot point about which the rotation occurs is the center of the
 untransformed <a href="Node.html#layoutBoundsProperty()"><code>layoutBounds</code></a>.
 <p>
 Note that because the pivot point is computed as the center of this
 <code>Node</code>'s layout bounds, any change to the layout bounds will cause
 the pivot point to change, which can move the object. For a leaf node,
 any change to the geometry will cause the layout bounds to change.
 For a group node, any change to any of its children, including a
 change in a child's geometry, clip, effect, position, orientation, or
 scale, will cause the group's layout bounds to change. If this movement
 of the pivot point is not
 desired, applications should instead use the Node's <a href="Node.html#getTransforms()"><code>transforms</code></a>
 ObservableList, and add a <a href="transform/Rotate.html" title="class in javafx.scene.transform"><code>Rotate</code></a> transform,
 which has a user-specifiable pivot point.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>0.0</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getRotate()"><code>getRotate()</code></a>, 
<a href="Node.html#setRotate(double)"><code>setRotate(double)</code></a></dd></dl>
</li>
</ul>
<a name="setRotationAxis(javafx.geometry.Point3D)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRotationAxis</h4>
<pre>public final&nbsp;void&nbsp;setRotationAxis(<a href="../geometry/Point3D.html" title="class in javafx.geometry">Point3D</a>&nbsp;value)</pre>
<div class="block">Sets the value of the property rotationAxis.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the axis of rotation of this <code>Node</code>.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>Rotate.Z_AXIS</dd></dl>
</li>
</ul>
<a name="getRotationAxis()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRotationAxis</h4>
<pre>public final&nbsp;<a href="../geometry/Point3D.html" title="class in javafx.geometry">Point3D</a>&nbsp;getRotationAxis()</pre>
<div class="block">Gets the value of the property rotationAxis.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines the axis of rotation of this <code>Node</code>.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>Rotate.Z_AXIS</dd></dl>
</li>
</ul>
<a name="rotationAxisProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotationAxisProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../geometry/Point3D.html" title="class in javafx.geometry">Point3D</a>&gt;&nbsp;rotationAxisProperty()</pre>
<div class="block">Defines the axis of rotation of this <code>Node</code>.
 <p>
 Note that this is a conditional feature. See
 <a href="../application/ConditionalFeature.html#SCENE3D"><code>ConditionalFeature.SCENE3D</code></a>
 for more information.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>JavaFX 1.3</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>Rotate.Z_AXIS</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getRotationAxis()"><code>getRotationAxis()</code></a>, 
<a href="Node.html#setRotationAxis(javafx.geometry.Point3D)"><code>setRotationAxis(Point3D)</code></a></dd></dl>
</li>
</ul>
<a name="localToParentTransformProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localToParentTransformProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&gt;&nbsp;localToParentTransformProperty()</pre>
<div class="block">An affine transform that holds the computed local-to-parent transform.
 This is the concatenation of all transforms in this node, including all
 of the convenience transforms.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getLocalToParentTransform()"><code>getLocalToParentTransform()</code></a></dd></dl>
</li>
</ul>
<a name="getLocalToParentTransform()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLocalToParentTransform</h4>
<pre>public final&nbsp;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&nbsp;getLocalToParentTransform()</pre>
<div class="block">Gets the value of the property localToParentTransform.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>An affine transform that holds the computed local-to-parent transform.
 This is the concatenation of all transforms in this node, including all
 of the convenience transforms.</dd></dl>
</li>
</ul>
<a name="localToSceneTransformProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localToSceneTransformProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyObjectProperty.html" title="class in javafx.beans.property">ReadOnlyObjectProperty</a>&lt;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&gt;&nbsp;localToSceneTransformProperty()</pre>
<div class="block">An affine transform that holds the computed local-to-scene transform.
 This is the concatenation of all transforms in this node's parents and
 in this node, including all of the convenience transforms.

 <p>
 Note that when you register a listener or a binding to this property,
 it needs to listen for invalidation on all its parents to the root node.
 This means that registering a listener on this
 property on many nodes may negatively affect performance of
 transformation changes in their common parents.
 </p></div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getLocalToSceneTransform()"><code>getLocalToSceneTransform()</code></a></dd></dl>
</li>
</ul>
<a name="getLocalToSceneTransform()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLocalToSceneTransform</h4>
<pre>public final&nbsp;<a href="transform/Transform.html" title="class in javafx.scene.transform">Transform</a>&nbsp;getLocalToSceneTransform()</pre>
<div class="block">Gets the value of the property localToSceneTransform.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>An affine transform that holds the computed local-to-scene transform.
 This is the concatenation of all transforms in this node's parents and
 in this node, including all of the convenience transforms.

 <p>
 Note that when you register a listener or a binding to this property,
 it needs to listen for invalidation on all its parents to the root node.
 This means that registering a listener on this
 property on many nodes may negatively affect performance of
 transformation changes in their common parents.
 </p></dd></dl>
</li>
</ul>
<a name="setMouseTransparent(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMouseTransparent</h4>
<pre>public final&nbsp;void&nbsp;setMouseTransparent(boolean&nbsp;value)</pre>
<div class="block">Sets the value of the property mouseTransparent.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>If <code>true</code>, this node (together with all its children) is completely
 transparent to mouse events. When choosing target for mouse event, nodes
 with <code>mouseTransparent</code> set to <code>true</code> and their subtrees
 won't be taken into account.</dd></dl>
</li>
</ul>
<a name="isMouseTransparent()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isMouseTransparent</h4>
<pre>public final&nbsp;boolean&nbsp;isMouseTransparent()</pre>
<div class="block">Gets the value of the property mouseTransparent.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>If <code>true</code>, this node (together with all its children) is completely
 transparent to mouse events. When choosing target for mouse event, nodes
 with <code>mouseTransparent</code> set to <code>true</code> and their subtrees
 won't be taken into account.</dd></dl>
</li>
</ul>
<a name="mouseTransparentProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mouseTransparentProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a>&nbsp;mouseTransparentProperty()</pre>
<div class="block">If <code>true</code>, this node (together with all its children) is completely
 transparent to mouse events. When choosing target for mouse event, nodes
 with <code>mouseTransparent</code> set to <code>true</code> and their subtrees
 won't be taken into account.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isMouseTransparent()"><code>isMouseTransparent()</code></a>, 
<a href="Node.html#setMouseTransparent(boolean)"><code>setMouseTransparent(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setHover(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setHover</h4>
<pre>protected final&nbsp;void&nbsp;setHover(boolean&nbsp;value)</pre>
<div class="block">Sets the value of the property hover.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Whether or not this <code>Node</code> is being hovered over. Typically this is
 due to the mouse being over the node, though it could be due to a pen
 hovering on a graphics tablet or other form of input.

 <p>Note that current implementation of hover relies on mouse enter and
 exit events to determine whether this Node is in the hover state; this
 means that this feature is currently supported only on systems that
 have a mouse. Future implementations may provide alternative means of
 supporting hover.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="isHover()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isHover</h4>
<pre>public final&nbsp;boolean&nbsp;isHover()</pre>
<div class="block">Gets the value of the property hover.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Whether or not this <code>Node</code> is being hovered over. Typically this is
 due to the mouse being over the node, though it could be due to a pen
 hovering on a graphics tablet or other form of input.

 <p>Note that current implementation of hover relies on mouse enter and
 exit events to determine whether this Node is in the hover state; this
 means that this feature is currently supported only on systems that
 have a mouse. Future implementations may provide alternative means of
 supporting hover.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="hoverProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hoverProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a>&nbsp;hoverProperty()</pre>
<div class="block">Whether or not this <code>Node</code> is being hovered over. Typically this is
 due to the mouse being over the node, though it could be due to a pen
 hovering on a graphics tablet or other form of input.

 <p>Note that current implementation of hover relies on mouse enter and
 exit events to determine whether this Node is in the hover state; this
 means that this feature is currently supported only on systems that
 have a mouse. Future implementations may provide alternative means of
 supporting hover.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isHover()"><code>isHover()</code></a>, 
<a href="Node.html#setHover(boolean)"><code>setHover(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setPressed(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPressed</h4>
<pre>protected final&nbsp;void&nbsp;setPressed(boolean&nbsp;value)</pre>
<div class="block">Sets the value of the property pressed.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Whether or not the <code>Node</code> is pressed. Typically this is true when
 the primary mouse button is down, though subclasses may define other
 mouse button state or key state to cause the node to be "pressed".</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="isPressed()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPressed</h4>
<pre>public final&nbsp;boolean&nbsp;isPressed()</pre>
<div class="block">Gets the value of the property pressed.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Whether or not the <code>Node</code> is pressed. Typically this is true when
 the primary mouse button is down, though subclasses may define other
 mouse button state or key state to cause the node to be "pressed".</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="pressedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pressedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a>&nbsp;pressedProperty()</pre>
<div class="block">Whether or not the <code>Node</code> is pressed. Typically this is true when
 the primary mouse button is down, though subclasses may define other
 mouse button state or key state to cause the node to be "pressed".</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isPressed()"><code>isPressed()</code></a>, 
<a href="Node.html#setPressed(boolean)"><code>setPressed(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setOnContextMenuRequested(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnContextMenuRequested</h4>
<pre>public final&nbsp;void&nbsp;setOnContextMenuRequested(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ContextMenuEvent.html" title="class in javafx.scene.input">ContextMenuEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onContextMenuRequested.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a context menu
 has been requested on this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnContextMenuRequested()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnContextMenuRequested</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ContextMenuEvent.html" title="class in javafx.scene.input">ContextMenuEvent</a>&gt;&nbsp;getOnContextMenuRequested()</pre>
<div class="block">Gets the value of the property onContextMenuRequested.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a context menu
 has been requested on this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onContextMenuRequestedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onContextMenuRequestedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ContextMenuEvent.html" title="class in javafx.scene.input">ContextMenuEvent</a>&gt;&gt;&nbsp;onContextMenuRequestedProperty()</pre>
<div class="block">Defines a function to be called when a context menu
 has been requested on this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnContextMenuRequested()"><code>getOnContextMenuRequested()</code></a>, 
<a href="Node.html#setOnContextMenuRequested(javafx.event.EventHandler)"><code>setOnContextMenuRequested(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnMouseClicked(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnMouseClicked</h4>
<pre>public final&nbsp;void&nbsp;setOnMouseClicked(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onMouseClicked.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a mouse button has been clicked
 (pressed and released) on this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnMouseClicked()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnMouseClicked</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;getOnMouseClicked()</pre>
<div class="block">Gets the value of the property onMouseClicked.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a mouse button has been clicked
 (pressed and released) on this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onMouseClickedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseClickedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;&nbsp;onMouseClickedProperty()</pre>
<div class="block">Defines a function to be called when a mouse button has been clicked
 (pressed and released) on this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseClicked()"><code>getOnMouseClicked()</code></a>, 
<a href="Node.html#setOnMouseClicked(javafx.event.EventHandler)"><code>setOnMouseClicked(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnMouseDragged(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnMouseDragged</h4>
<pre>public final&nbsp;void&nbsp;setOnMouseDragged(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onMouseDragged.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a mouse button is pressed
 on this <code>Node</code> and then dragged.</dd></dl>
</li>
</ul>
<a name="getOnMouseDragged()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnMouseDragged</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;getOnMouseDragged()</pre>
<div class="block">Gets the value of the property onMouseDragged.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a mouse button is pressed
 on this <code>Node</code> and then dragged.</dd></dl>
</li>
</ul>
<a name="onMouseDraggedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseDraggedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;&nbsp;onMouseDraggedProperty()</pre>
<div class="block">Defines a function to be called when a mouse button is pressed
 on this <code>Node</code> and then dragged.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseDragged()"><code>getOnMouseDragged()</code></a>, 
<a href="Node.html#setOnMouseDragged(javafx.event.EventHandler)"><code>setOnMouseDragged(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnMouseEntered(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnMouseEntered</h4>
<pre>public final&nbsp;void&nbsp;setOnMouseEntered(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onMouseEntered.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when the mouse enters this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnMouseEntered()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnMouseEntered</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;getOnMouseEntered()</pre>
<div class="block">Gets the value of the property onMouseEntered.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when the mouse enters this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onMouseEnteredProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseEnteredProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;&nbsp;onMouseEnteredProperty()</pre>
<div class="block">Defines a function to be called when the mouse enters this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseEntered()"><code>getOnMouseEntered()</code></a>, 
<a href="Node.html#setOnMouseEntered(javafx.event.EventHandler)"><code>setOnMouseEntered(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnMouseExited(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnMouseExited</h4>
<pre>public final&nbsp;void&nbsp;setOnMouseExited(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onMouseExited.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when the mouse exits this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnMouseExited()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnMouseExited</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;getOnMouseExited()</pre>
<div class="block">Gets the value of the property onMouseExited.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when the mouse exits this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onMouseExitedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseExitedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;&nbsp;onMouseExitedProperty()</pre>
<div class="block">Defines a function to be called when the mouse exits this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseExited()"><code>getOnMouseExited()</code></a>, 
<a href="Node.html#setOnMouseExited(javafx.event.EventHandler)"><code>setOnMouseExited(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnMouseMoved(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnMouseMoved</h4>
<pre>public final&nbsp;void&nbsp;setOnMouseMoved(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onMouseMoved.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when mouse cursor moves within
 this <code>Node</code> but no buttons have been pushed.</dd></dl>
</li>
</ul>
<a name="getOnMouseMoved()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnMouseMoved</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;getOnMouseMoved()</pre>
<div class="block">Gets the value of the property onMouseMoved.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when mouse cursor moves within
 this <code>Node</code> but no buttons have been pushed.</dd></dl>
</li>
</ul>
<a name="onMouseMovedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseMovedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;&nbsp;onMouseMovedProperty()</pre>
<div class="block">Defines a function to be called when mouse cursor moves within
 this <code>Node</code> but no buttons have been pushed.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseMoved()"><code>getOnMouseMoved()</code></a>, 
<a href="Node.html#setOnMouseMoved(javafx.event.EventHandler)"><code>setOnMouseMoved(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnMousePressed(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnMousePressed</h4>
<pre>public final&nbsp;void&nbsp;setOnMousePressed(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onMousePressed.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a mouse button
 has been pressed on this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnMousePressed()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnMousePressed</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;getOnMousePressed()</pre>
<div class="block">Gets the value of the property onMousePressed.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a mouse button
 has been pressed on this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onMousePressedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMousePressedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;&nbsp;onMousePressedProperty()</pre>
<div class="block">Defines a function to be called when a mouse button
 has been pressed on this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMousePressed()"><code>getOnMousePressed()</code></a>, 
<a href="Node.html#setOnMousePressed(javafx.event.EventHandler)"><code>setOnMousePressed(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnMouseReleased(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnMouseReleased</h4>
<pre>public final&nbsp;void&nbsp;setOnMouseReleased(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onMouseReleased.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a mouse button
 has been released on this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnMouseReleased()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnMouseReleased</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;getOnMouseReleased()</pre>
<div class="block">Gets the value of the property onMouseReleased.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a mouse button
 has been released on this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onMouseReleasedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseReleasedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;&nbsp;onMouseReleasedProperty()</pre>
<div class="block">Defines a function to be called when a mouse button
 has been released on this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseReleased()"><code>getOnMouseReleased()</code></a>, 
<a href="Node.html#setOnMouseReleased(javafx.event.EventHandler)"><code>setOnMouseReleased(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnDragDetected(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnDragDetected</h4>
<pre>public final&nbsp;void&nbsp;setOnDragDetected(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onDragDetected.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when drag gesture has been
 detected. This is the right place to start drag and drop operation.</dd></dl>
</li>
</ul>
<a name="getOnDragDetected()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnDragDetected</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&nbsp;getOnDragDetected()</pre>
<div class="block">Gets the value of the property onDragDetected.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when drag gesture has been
 detected. This is the right place to start drag and drop operation.</dd></dl>
</li>
</ul>
<a name="onDragDetectedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDragDetectedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseEvent.html" title="class in javafx.scene.input">MouseEvent</a>&gt;&gt;&nbsp;onDragDetectedProperty()</pre>
<div class="block">Defines a function to be called when drag gesture has been
 detected. This is the right place to start drag and drop operation.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnDragDetected()"><code>getOnDragDetected()</code></a>, 
<a href="Node.html#setOnDragDetected(javafx.event.EventHandler)"><code>setOnDragDetected(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnMouseDragOver(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnMouseDragOver</h4>
<pre>public final&nbsp;void&nbsp;setOnMouseDragOver(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onMouseDragOver.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a full press-drag-release gesture
 progresses within this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnMouseDragOver()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnMouseDragOver</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;getOnMouseDragOver()</pre>
<div class="block">Gets the value of the property onMouseDragOver.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a full press-drag-release gesture
 progresses within this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onMouseDragOverProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseDragOverProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;&nbsp;onMouseDragOverProperty()</pre>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 progresses within this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseDragOver()"><code>getOnMouseDragOver()</code></a>, 
<a href="Node.html#setOnMouseDragOver(javafx.event.EventHandler)"><code>setOnMouseDragOver(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnMouseDragReleased(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnMouseDragReleased</h4>
<pre>public final&nbsp;void&nbsp;setOnMouseDragReleased(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onMouseDragReleased.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a full press-drag-release gesture
 ends (by releasing mouse button) within this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnMouseDragReleased()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnMouseDragReleased</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;getOnMouseDragReleased()</pre>
<div class="block">Gets the value of the property onMouseDragReleased.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a full press-drag-release gesture
 ends (by releasing mouse button) within this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onMouseDragReleasedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseDragReleasedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;&nbsp;onMouseDragReleasedProperty()</pre>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 ends (by releasing mouse button) within this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseDragReleased()"><code>getOnMouseDragReleased()</code></a>, 
<a href="Node.html#setOnMouseDragReleased(javafx.event.EventHandler)"><code>setOnMouseDragReleased(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnMouseDragEntered(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnMouseDragEntered</h4>
<pre>public final&nbsp;void&nbsp;setOnMouseDragEntered(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onMouseDragEntered.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a full press-drag-release gesture
 enters this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnMouseDragEntered()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnMouseDragEntered</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;getOnMouseDragEntered()</pre>
<div class="block">Gets the value of the property onMouseDragEntered.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a full press-drag-release gesture
 enters this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onMouseDragEnteredProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseDragEnteredProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;&nbsp;onMouseDragEnteredProperty()</pre>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 enters this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseDragEntered()"><code>getOnMouseDragEntered()</code></a>, 
<a href="Node.html#setOnMouseDragEntered(javafx.event.EventHandler)"><code>setOnMouseDragEntered(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnMouseDragExited(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnMouseDragExited</h4>
<pre>public final&nbsp;void&nbsp;setOnMouseDragExited(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onMouseDragExited.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a full press-drag-release gesture
 leaves this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="getOnMouseDragExited()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnMouseDragExited</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&nbsp;getOnMouseDragExited()</pre>
<div class="block">Gets the value of the property onMouseDragExited.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a full press-drag-release gesture
 leaves this <code>Node</code>.</dd></dl>
</li>
</ul>
<a name="onMouseDragExitedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onMouseDragExitedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/MouseDragEvent.html" title="class in javafx.scene.input">MouseDragEvent</a>&gt;&gt;&nbsp;onMouseDragExitedProperty()</pre>
<div class="block">Defines a function to be called when a full press-drag-release gesture
 leaves this <code>Node</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnMouseDragExited()"><code>getOnMouseDragExited()</code></a>, 
<a href="Node.html#setOnMouseDragExited(javafx.event.EventHandler)"><code>setOnMouseDragExited(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnScrollStarted(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnScrollStarted</h4>
<pre>public final&nbsp;void&nbsp;setOnScrollStarted(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onScrollStarted.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a scrolling gesture is detected.</dd></dl>
</li>
</ul>
<a name="getOnScrollStarted()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnScrollStarted</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&nbsp;getOnScrollStarted()</pre>
<div class="block">Gets the value of the property onScrollStarted.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a scrolling gesture is detected.</dd></dl>
</li>
</ul>
<a name="onScrollStartedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onScrollStartedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt;&nbsp;onScrollStartedProperty()</pre>
<div class="block">Defines a function to be called when a scrolling gesture is detected.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnScrollStarted()"><code>getOnScrollStarted()</code></a>, 
<a href="Node.html#setOnScrollStarted(javafx.event.EventHandler)"><code>setOnScrollStarted(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnScroll(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnScroll</h4>
<pre>public final&nbsp;void&nbsp;setOnScroll(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onScroll.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when user performs a scrolling action.</dd></dl>
</li>
</ul>
<a name="getOnScroll()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnScroll</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&nbsp;getOnScroll()</pre>
<div class="block">Gets the value of the property onScroll.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when user performs a scrolling action.</dd></dl>
</li>
</ul>
<a name="onScrollProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onScrollProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt;&nbsp;onScrollProperty()</pre>
<div class="block">Defines a function to be called when user performs a scrolling action.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnScroll()"><code>getOnScroll()</code></a>, 
<a href="Node.html#setOnScroll(javafx.event.EventHandler)"><code>setOnScroll(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnScrollFinished(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnScrollFinished</h4>
<pre>public final&nbsp;void&nbsp;setOnScrollFinished(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onScrollFinished.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a scrolling gesture ends.</dd></dl>
</li>
</ul>
<a name="getOnScrollFinished()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnScrollFinished</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&nbsp;getOnScrollFinished()</pre>
<div class="block">Gets the value of the property onScrollFinished.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a scrolling gesture ends.</dd></dl>
</li>
</ul>
<a name="onScrollFinishedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onScrollFinishedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ScrollEvent.html" title="class in javafx.scene.input">ScrollEvent</a>&gt;&gt;&nbsp;onScrollFinishedProperty()</pre>
<div class="block">Defines a function to be called when a scrolling gesture ends.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnScrollFinished()"><code>getOnScrollFinished()</code></a>, 
<a href="Node.html#setOnScrollFinished(javafx.event.EventHandler)"><code>setOnScrollFinished(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnRotationStarted(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnRotationStarted</h4>
<pre>public final&nbsp;void&nbsp;setOnRotationStarted(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onRotationStarted.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a rotation gesture is detected.</dd></dl>
</li>
</ul>
<a name="getOnRotationStarted()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnRotationStarted</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&nbsp;getOnRotationStarted()</pre>
<div class="block">Gets the value of the property onRotationStarted.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a rotation gesture is detected.</dd></dl>
</li>
</ul>
<a name="onRotationStartedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onRotationStartedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt;&nbsp;onRotationStartedProperty()</pre>
<div class="block">Defines a function to be called when a rotation gesture is detected.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnRotationStarted()"><code>getOnRotationStarted()</code></a>, 
<a href="Node.html#setOnRotationStarted(javafx.event.EventHandler)"><code>setOnRotationStarted(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnRotate(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnRotate</h4>
<pre>public final&nbsp;void&nbsp;setOnRotate(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onRotate.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when user performs a rotation action.</dd></dl>
</li>
</ul>
<a name="getOnRotate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnRotate</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&nbsp;getOnRotate()</pre>
<div class="block">Gets the value of the property onRotate.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when user performs a rotation action.</dd></dl>
</li>
</ul>
<a name="onRotateProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onRotateProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt;&nbsp;onRotateProperty()</pre>
<div class="block">Defines a function to be called when user performs a rotation action.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnRotate()"><code>getOnRotate()</code></a>, 
<a href="Node.html#setOnRotate(javafx.event.EventHandler)"><code>setOnRotate(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnRotationFinished(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnRotationFinished</h4>
<pre>public final&nbsp;void&nbsp;setOnRotationFinished(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onRotationFinished.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a rotation gesture ends.</dd></dl>
</li>
</ul>
<a name="getOnRotationFinished()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnRotationFinished</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&nbsp;getOnRotationFinished()</pre>
<div class="block">Gets the value of the property onRotationFinished.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a rotation gesture ends.</dd></dl>
</li>
</ul>
<a name="onRotationFinishedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onRotationFinishedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/RotateEvent.html" title="class in javafx.scene.input">RotateEvent</a>&gt;&gt;&nbsp;onRotationFinishedProperty()</pre>
<div class="block">Defines a function to be called when a rotation gesture ends.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnRotationFinished()"><code>getOnRotationFinished()</code></a>, 
<a href="Node.html#setOnRotationFinished(javafx.event.EventHandler)"><code>setOnRotationFinished(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnZoomStarted(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnZoomStarted</h4>
<pre>public final&nbsp;void&nbsp;setOnZoomStarted(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onZoomStarted.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a zooming gesture is detected.</dd></dl>
</li>
</ul>
<a name="getOnZoomStarted()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnZoomStarted</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&nbsp;getOnZoomStarted()</pre>
<div class="block">Gets the value of the property onZoomStarted.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a zooming gesture is detected.</dd></dl>
</li>
</ul>
<a name="onZoomStartedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onZoomStartedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt;&nbsp;onZoomStartedProperty()</pre>
<div class="block">Defines a function to be called when a zooming gesture is detected.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnZoomStarted()"><code>getOnZoomStarted()</code></a>, 
<a href="Node.html#setOnZoomStarted(javafx.event.EventHandler)"><code>setOnZoomStarted(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnZoom(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnZoom</h4>
<pre>public final&nbsp;void&nbsp;setOnZoom(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onZoom.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when user performs a zooming action.</dd></dl>
</li>
</ul>
<a name="getOnZoom()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnZoom</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&nbsp;getOnZoom()</pre>
<div class="block">Gets the value of the property onZoom.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when user performs a zooming action.</dd></dl>
</li>
</ul>
<a name="onZoomProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onZoomProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt;&nbsp;onZoomProperty()</pre>
<div class="block">Defines a function to be called when user performs a zooming action.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnZoom()"><code>getOnZoom()</code></a>, 
<a href="Node.html#setOnZoom(javafx.event.EventHandler)"><code>setOnZoom(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnZoomFinished(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnZoomFinished</h4>
<pre>public final&nbsp;void&nbsp;setOnZoomFinished(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onZoomFinished.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a zooming gesture ends.</dd></dl>
</li>
</ul>
<a name="getOnZoomFinished()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnZoomFinished</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&nbsp;getOnZoomFinished()</pre>
<div class="block">Gets the value of the property onZoomFinished.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a zooming gesture ends.</dd></dl>
</li>
</ul>
<a name="onZoomFinishedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onZoomFinishedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/ZoomEvent.html" title="class in javafx.scene.input">ZoomEvent</a>&gt;&gt;&nbsp;onZoomFinishedProperty()</pre>
<div class="block">Defines a function to be called when a zooming gesture ends.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnZoomFinished()"><code>getOnZoomFinished()</code></a>, 
<a href="Node.html#setOnZoomFinished(javafx.event.EventHandler)"><code>setOnZoomFinished(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnSwipeUp(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnSwipeUp</h4>
<pre>public final&nbsp;void&nbsp;setOnSwipeUp(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onSwipeUp.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when an upward swipe gesture
 centered over this node happens.</dd></dl>
</li>
</ul>
<a name="getOnSwipeUp()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnSwipeUp</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;getOnSwipeUp()</pre>
<div class="block">Gets the value of the property onSwipeUp.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when an upward swipe gesture
 centered over this node happens.</dd></dl>
</li>
</ul>
<a name="onSwipeUpProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onSwipeUpProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;&nbsp;onSwipeUpProperty()</pre>
<div class="block">Defines a function to be called when an upward swipe gesture
 centered over this node happens.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnSwipeUp()"><code>getOnSwipeUp()</code></a>, 
<a href="Node.html#setOnSwipeUp(javafx.event.EventHandler)"><code>setOnSwipeUp(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnSwipeDown(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnSwipeDown</h4>
<pre>public final&nbsp;void&nbsp;setOnSwipeDown(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onSwipeDown.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a downward swipe gesture
 centered over this node happens.</dd></dl>
</li>
</ul>
<a name="getOnSwipeDown()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnSwipeDown</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;getOnSwipeDown()</pre>
<div class="block">Gets the value of the property onSwipeDown.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a downward swipe gesture
 centered over this node happens.</dd></dl>
</li>
</ul>
<a name="onSwipeDownProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onSwipeDownProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;&nbsp;onSwipeDownProperty()</pre>
<div class="block">Defines a function to be called when a downward swipe gesture
 centered over this node happens.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnSwipeDown()"><code>getOnSwipeDown()</code></a>, 
<a href="Node.html#setOnSwipeDown(javafx.event.EventHandler)"><code>setOnSwipeDown(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnSwipeLeft(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnSwipeLeft</h4>
<pre>public final&nbsp;void&nbsp;setOnSwipeLeft(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onSwipeLeft.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a leftward swipe gesture
 centered over this node happens.</dd></dl>
</li>
</ul>
<a name="getOnSwipeLeft()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnSwipeLeft</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;getOnSwipeLeft()</pre>
<div class="block">Gets the value of the property onSwipeLeft.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a leftward swipe gesture
 centered over this node happens.</dd></dl>
</li>
</ul>
<a name="onSwipeLeftProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onSwipeLeftProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;&nbsp;onSwipeLeftProperty()</pre>
<div class="block">Defines a function to be called when a leftward swipe gesture
 centered over this node happens.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnSwipeLeft()"><code>getOnSwipeLeft()</code></a>, 
<a href="Node.html#setOnSwipeLeft(javafx.event.EventHandler)"><code>setOnSwipeLeft(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnSwipeRight(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnSwipeRight</h4>
<pre>public final&nbsp;void&nbsp;setOnSwipeRight(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onSwipeRight.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when an rightward swipe gesture
 centered over this node happens.</dd></dl>
</li>
</ul>
<a name="getOnSwipeRight()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnSwipeRight</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&nbsp;getOnSwipeRight()</pre>
<div class="block">Gets the value of the property onSwipeRight.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when an rightward swipe gesture
 centered over this node happens.</dd></dl>
</li>
</ul>
<a name="onSwipeRightProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onSwipeRightProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/SwipeEvent.html" title="class in javafx.scene.input">SwipeEvent</a>&gt;&gt;&nbsp;onSwipeRightProperty()</pre>
<div class="block">Defines a function to be called when an rightward swipe gesture
 centered over this node happens.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnSwipeRight()"><code>getOnSwipeRight()</code></a>, 
<a href="Node.html#setOnSwipeRight(javafx.event.EventHandler)"><code>setOnSwipeRight(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnTouchPressed(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnTouchPressed</h4>
<pre>public final&nbsp;void&nbsp;setOnTouchPressed(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onTouchPressed.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a new touch point is pressed.</dd></dl>
</li>
</ul>
<a name="getOnTouchPressed()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnTouchPressed</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;getOnTouchPressed()</pre>
<div class="block">Gets the value of the property onTouchPressed.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a new touch point is pressed.</dd></dl>
</li>
</ul>
<a name="onTouchPressedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onTouchPressedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;&nbsp;onTouchPressedProperty()</pre>
<div class="block">Defines a function to be called when a new touch point is pressed.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnTouchPressed()"><code>getOnTouchPressed()</code></a>, 
<a href="Node.html#setOnTouchPressed(javafx.event.EventHandler)"><code>setOnTouchPressed(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnTouchMoved(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnTouchMoved</h4>
<pre>public final&nbsp;void&nbsp;setOnTouchMoved(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onTouchMoved.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a touch point is moved.</dd></dl>
</li>
</ul>
<a name="getOnTouchMoved()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnTouchMoved</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;getOnTouchMoved()</pre>
<div class="block">Gets the value of the property onTouchMoved.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a touch point is moved.</dd></dl>
</li>
</ul>
<a name="onTouchMovedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onTouchMovedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;&nbsp;onTouchMovedProperty()</pre>
<div class="block">Defines a function to be called when a touch point is moved.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnTouchMoved()"><code>getOnTouchMoved()</code></a>, 
<a href="Node.html#setOnTouchMoved(javafx.event.EventHandler)"><code>setOnTouchMoved(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnTouchReleased(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnTouchReleased</h4>
<pre>public final&nbsp;void&nbsp;setOnTouchReleased(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onTouchReleased.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a touch point is released.</dd></dl>
</li>
</ul>
<a name="getOnTouchReleased()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnTouchReleased</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;getOnTouchReleased()</pre>
<div class="block">Gets the value of the property onTouchReleased.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a touch point is released.</dd></dl>
</li>
</ul>
<a name="onTouchReleasedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onTouchReleasedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;&nbsp;onTouchReleasedProperty()</pre>
<div class="block">Defines a function to be called when a touch point is released.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnTouchReleased()"><code>getOnTouchReleased()</code></a>, 
<a href="Node.html#setOnTouchReleased(javafx.event.EventHandler)"><code>setOnTouchReleased(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnTouchStationary(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnTouchStationary</h4>
<pre>public final&nbsp;void&nbsp;setOnTouchStationary(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onTouchStationary.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a touch point stays pressed and
 still.</dd></dl>
</li>
</ul>
<a name="getOnTouchStationary()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnTouchStationary</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&nbsp;getOnTouchStationary()</pre>
<div class="block">Gets the value of the property onTouchStationary.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when a touch point stays pressed and
 still.</dd></dl>
</li>
</ul>
<a name="onTouchStationaryProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onTouchStationaryProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/TouchEvent.html" title="class in javafx.scene.input">TouchEvent</a>&gt;&gt;&nbsp;onTouchStationaryProperty()</pre>
<div class="block">Defines a function to be called when a touch point stays pressed and
 still.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>2.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnTouchStationary()"><code>getOnTouchStationary()</code></a>, 
<a href="Node.html#setOnTouchStationary(javafx.event.EventHandler)"><code>setOnTouchStationary(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnKeyPressed(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnKeyPressed</h4>
<pre>public final&nbsp;void&nbsp;setOnKeyPressed(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onKeyPressed.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been pressed. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</dd></dl>
</li>
</ul>
<a name="getOnKeyPressed()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnKeyPressed</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&nbsp;getOnKeyPressed()</pre>
<div class="block">Gets the value of the property onKeyPressed.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been pressed. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</dd></dl>
</li>
</ul>
<a name="onKeyPressedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onKeyPressedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt;&nbsp;onKeyPressedProperty()</pre>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been pressed. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnKeyPressed()"><code>getOnKeyPressed()</code></a>, 
<a href="Node.html#setOnKeyPressed(javafx.event.EventHandler)"><code>setOnKeyPressed(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnKeyReleased(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnKeyReleased</h4>
<pre>public final&nbsp;void&nbsp;setOnKeyReleased(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onKeyReleased.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been released. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</dd></dl>
</li>
</ul>
<a name="getOnKeyReleased()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnKeyReleased</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&nbsp;getOnKeyReleased()</pre>
<div class="block">Gets the value of the property onKeyReleased.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been released. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</dd></dl>
</li>
</ul>
<a name="onKeyReleasedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onKeyReleasedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt;&nbsp;onKeyReleasedProperty()</pre>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been released. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnKeyReleased()"><code>getOnKeyReleased()</code></a>, 
<a href="Node.html#setOnKeyReleased(javafx.event.EventHandler)"><code>setOnKeyReleased(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnKeyTyped(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnKeyTyped</h4>
<pre>public final&nbsp;void&nbsp;setOnKeyTyped(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onKeyTyped.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been typed. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</dd></dl>
</li>
</ul>
<a name="getOnKeyTyped()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnKeyTyped</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&nbsp;getOnKeyTyped()</pre>
<div class="block">Gets the value of the property onKeyTyped.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been typed. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</dd></dl>
</li>
</ul>
<a name="onKeyTypedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onKeyTypedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/KeyEvent.html" title="class in javafx.scene.input">KeyEvent</a>&gt;&gt;&nbsp;onKeyTypedProperty()</pre>
<div class="block">Defines a function to be called when this <code>Node</code> or its child
 <code>Node</code> has input focus and a key has been typed. The function
 is called only if the event hasn't been already consumed during its
 capturing or bubbling phase.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnKeyTyped()"><code>getOnKeyTyped()</code></a>, 
<a href="Node.html#setOnKeyTyped(javafx.event.EventHandler)"><code>setOnKeyTyped(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setOnInputMethodTextChanged(javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOnInputMethodTextChanged</h4>
<pre>public final&nbsp;void&nbsp;setOnInputMethodTextChanged(<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/InputMethodEvent.html" title="class in javafx.scene.input">InputMethodEvent</a>&gt;&nbsp;value)</pre>
<div class="block">Sets the value of the property onInputMethodTextChanged.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when this <code>Node</code>
 has input focus and the input method text has changed.  If this
 function is not defined in this <code>Node</code>, then it
 receives the result string of the input method composition as a
 series of <code>onKeyTyped</code> function calls.
 </p>
 When the <code>Node</code> loses the input focus, the JavaFX runtime
 automatically commits the existing composed text if any.</dd></dl>
</li>
</ul>
<a name="getOnInputMethodTextChanged()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnInputMethodTextChanged</h4>
<pre>public final&nbsp;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/InputMethodEvent.html" title="class in javafx.scene.input">InputMethodEvent</a>&gt;&nbsp;getOnInputMethodTextChanged()</pre>
<div class="block">Gets the value of the property onInputMethodTextChanged.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Defines a function to be called when this <code>Node</code>
 has input focus and the input method text has changed.  If this
 function is not defined in this <code>Node</code>, then it
 receives the result string of the input method composition as a
 series of <code>onKeyTyped</code> function calls.
 </p>
 When the <code>Node</code> loses the input focus, the JavaFX runtime
 automatically commits the existing composed text if any.</dd></dl>
</li>
</ul>
<a name="onInputMethodTextChangedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onInputMethodTextChangedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super <a href="input/InputMethodEvent.html" title="class in javafx.scene.input">InputMethodEvent</a>&gt;&gt;&nbsp;onInputMethodTextChangedProperty()</pre>
<div class="block">Defines a function to be called when this <code>Node</code>
 has input focus and the input method text has changed.  If this
 function is not defined in this <code>Node</code>, then it
 receives the result string of the input method composition as a
 series of <code>onKeyTyped</code> function calls.
 </p>
 When the <code>Node</code> loses the input focus, the JavaFX runtime
 automatically commits the existing composed text if any.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getOnInputMethodTextChanged()"><code>getOnInputMethodTextChanged()</code></a>, 
<a href="Node.html#setOnInputMethodTextChanged(javafx.event.EventHandler)"><code>setOnInputMethodTextChanged(EventHandler)</code></a></dd></dl>
</li>
</ul>
<a name="setInputMethodRequests(javafx.scene.input.InputMethodRequests)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setInputMethodRequests</h4>
<pre>public final&nbsp;void&nbsp;setInputMethodRequests(<a href="input/InputMethodRequests.html" title="interface in javafx.scene.input">InputMethodRequests</a>&nbsp;value)</pre>
<div class="block">Sets the value of the property inputMethodRequests.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Property holding InputMethodRequests.</dd></dl>
</li>
</ul>
<a name="getInputMethodRequests()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInputMethodRequests</h4>
<pre>public final&nbsp;<a href="input/InputMethodRequests.html" title="interface in javafx.scene.input">InputMethodRequests</a>&nbsp;getInputMethodRequests()</pre>
<div class="block">Gets the value of the property inputMethodRequests.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Property holding InputMethodRequests.</dd></dl>
</li>
</ul>
<a name="inputMethodRequestsProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inputMethodRequestsProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="input/InputMethodRequests.html" title="interface in javafx.scene.input">InputMethodRequests</a>&gt;&nbsp;inputMethodRequestsProperty()</pre>
<div class="block">Property holding InputMethodRequests.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>InputMethodRequestsProperty</dd><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getInputMethodRequests()"><code>getInputMethodRequests()</code></a>, 
<a href="Node.html#setInputMethodRequests(javafx.scene.input.InputMethodRequests)"><code>setInputMethodRequests(InputMethodRequests)</code></a></dd></dl>
</li>
</ul>
<a name="setFocused(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFocused</h4>
<pre>protected final&nbsp;void&nbsp;setFocused(boolean&nbsp;value)</pre>
<div class="block">Sets the value of the property focused.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Indicates whether this <code>Node</code> currently has the input focus.
 To have the input focus, a node must be the <code>Scene</code>'s focus
 owner, and the scene must be in a <code>Stage</code> that is visible
 and active. See <a href="Node.html#requestFocus()"><code>requestFocus()</code></a> for more information.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="isFocused()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isFocused</h4>
<pre>public final&nbsp;boolean&nbsp;isFocused()</pre>
<div class="block">Gets the value of the property focused.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Indicates whether this <code>Node</code> currently has the input focus.
 To have the input focus, a node must be the <code>Scene</code>'s focus
 owner, and the scene must be in a <code>Stage</code> that is visible
 and active. See <a href="Node.html#requestFocus()"><code>requestFocus()</code></a> for more information.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="focusedProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>focusedProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ReadOnlyBooleanProperty.html" title="class in javafx.beans.property">ReadOnlyBooleanProperty</a>&nbsp;focusedProperty()</pre>
<div class="block">Indicates whether this <code>Node</code> currently has the input focus.
 To have the input focus, a node must be the <code>Scene</code>'s focus
 owner, and the scene must be in a <code>Stage</code> that is visible
 and active. See <a href="Node.html#requestFocus()"><code>requestFocus()</code></a> for more information.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isFocused()"><code>isFocused()</code></a>, 
<a href="Node.html#setFocused(boolean)"><code>setFocused(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setFocusTraversable(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFocusTraversable</h4>
<pre>public final&nbsp;void&nbsp;setFocusTraversable(boolean&nbsp;value)</pre>
<div class="block">Sets the value of the property focusTraversable.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies whether this <code>Node</code> should be a part of focus traversal
 cycle. When this property is <code>true</code> focus can be moved to this
 <code>Node</code> and from this <code>Node</code> using regular focus traversal
 keys. On a desktop such keys are usually <code>TAB</code> for moving focus
 forward and <code>SHIFT+TAB</code> for moving focus backward.

 When a <code>Scene</code> is created, the system gives focus to a
 <code>Node</code> whose <code>focusTraversable</code> variable is true
 and that is eligible to receive the focus,
 unless the focus had been set explicitly via a call
 to <a href="Node.html#requestFocus()"><code>requestFocus()</code></a>.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="isFocusTraversable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isFocusTraversable</h4>
<pre>public final&nbsp;boolean&nbsp;isFocusTraversable()</pre>
<div class="block">Gets the value of the property focusTraversable.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies whether this <code>Node</code> should be a part of focus traversal
 cycle. When this property is <code>true</code> focus can be moved to this
 <code>Node</code> and from this <code>Node</code> using regular focus traversal
 keys. On a desktop such keys are usually <code>TAB</code> for moving focus
 forward and <code>SHIFT+TAB</code> for moving focus backward.

 When a <code>Scene</code> is created, the system gives focus to a
 <code>Node</code> whose <code>focusTraversable</code> variable is true
 and that is eligible to receive the focus,
 unless the focus had been set explicitly via a call
 to <a href="Node.html#requestFocus()"><code>requestFocus()</code></a>.</dd>
<dt><span class="strong">Default value:</span></dt>
  <dd>false</dd></dl>
</li>
</ul>
<a name="focusTraversableProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>focusTraversableProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/BooleanProperty.html" title="class in javafx.beans.property">BooleanProperty</a>&nbsp;focusTraversableProperty()</pre>
<div class="block">Specifies whether this <code>Node</code> should be a part of focus traversal
 cycle. When this property is <code>true</code> focus can be moved to this
 <code>Node</code> and from this <code>Node</code> using regular focus traversal
 keys. On a desktop such keys are usually <code>TAB</code> for moving focus
 forward and <code>SHIFT+TAB</code> for moving focus backward.

 When a <code>Scene</code> is created, the system gives focus to a
 <code>Node</code> whose <code>focusTraversable</code> variable is true
 and that is eligible to receive the focus,
 unless the focus had been set explicitly via a call
 to <a href="Node.html#requestFocus()"><code>requestFocus()</code></a>.</div>
<dl><dt><span class="strong">Default value:</span></dt>
  <dd>false</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#isFocusTraversable()"><code>isFocusTraversable()</code></a>, 
<a href="Node.html#setFocusTraversable(boolean)"><code>setFocusTraversable(boolean)</code></a></dd></dl>
</li>
</ul>
<a name="requestFocus()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>requestFocus</h4>
<pre>public&nbsp;void&nbsp;requestFocus()</pre>
<div class="block">Requests that this <code>Node</code> get the input focus, and that this
 <code>Node</code>'s top-level ancestor become the focused window. To be
 eligible to receive the focus, the node must be part of a scene, it and
 all of its ancestors must be visible, and it must not be disabled.
 If this node is eligible, this function will cause it to become this
 <code>Scene</code>'s "focus owner". Each scene has at most one focus owner
 node. The focus owner will not actually have the input focus, however,
 unless the scene belongs to a <code>Stage</code> that is both visible
 and active.</div>
</li>
</ul>
<a name="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Returns a string representation for the object.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation for the object.</dd></dl>
</li>
</ul>
<a name="setEventDispatcher(javafx.event.EventDispatcher)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setEventDispatcher</h4>
<pre>public final&nbsp;void&nbsp;setEventDispatcher(<a href="../event/EventDispatcher.html" title="interface in javafx.event">EventDispatcher</a>&nbsp;value)</pre>
<div class="block">Sets the value of the property eventDispatcher.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies the event dispatcher for this node. The default event
 dispatcher sends the received events to the registered event handlers and
 filters. When replacing the value with a new <code>EventDispatcher</code>,
 the new dispatcher should forward events to the replaced dispatcher
 to maintain the node's default event handling behavior.</dd></dl>
</li>
</ul>
<a name="getEventDispatcher()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEventDispatcher</h4>
<pre>public final&nbsp;<a href="../event/EventDispatcher.html" title="interface in javafx.event">EventDispatcher</a>&nbsp;getEventDispatcher()</pre>
<div class="block">Gets the value of the property eventDispatcher.</div>
<dl><dt><span class="strong">Property description:</span></dt>
  <dd>Specifies the event dispatcher for this node. The default event
 dispatcher sends the received events to the registered event handlers and
 filters. When replacing the value with a new <code>EventDispatcher</code>,
 the new dispatcher should forward events to the replaced dispatcher
 to maintain the node's default event handling behavior.</dd></dl>
</li>
</ul>
<a name="eventDispatcherProperty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eventDispatcherProperty</h4>
<pre>public final&nbsp;<a href="../beans/property/ObjectProperty.html" title="class in javafx.beans.property">ObjectProperty</a>&lt;<a href="../event/EventDispatcher.html" title="interface in javafx.event">EventDispatcher</a>&gt;&nbsp;eventDispatcherProperty()</pre>
<div class="block">Specifies the event dispatcher for this node. The default event
 dispatcher sends the received events to the registered event handlers and
 filters. When replacing the value with a new <code>EventDispatcher</code>,
 the new dispatcher should forward events to the replaced dispatcher
 to maintain the node's default event handling behavior.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="Node.html#getEventDispatcher()"><code>getEventDispatcher()</code></a>, 
<a href="Node.html#setEventDispatcher(javafx.event.EventDispatcher)"><code>setEventDispatcher(EventDispatcher)</code></a></dd></dl>
</li>
</ul>
<a name="addEventHandler(javafx.event.EventType, javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addEventHandler</h4>
<pre>public final&nbsp;&lt;T extends <a href="../event/Event.html" title="class in javafx.event">Event</a>&gt;&nbsp;void&nbsp;addEventHandler(<a href="../event/EventType.html" title="class in javafx.event">EventType</a>&lt;T&gt;&nbsp;eventType,
                                     <a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super T&gt;&nbsp;eventHandler)</pre>
<div class="block">Registers an event handler to this node. The handler is called when the
 node receives an <code>Event</code> of the specified type during the bubbling
 phase of event delivery.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>T</code> - the specific event class of the handler</dd><dt><span class="strong">Parameters:</span></dt><dd><code>eventType</code> - the type of the events to receive by the handler</dd><dd><code>eventHandler</code> - the handler to register</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.NullPointerException</code> - if the event type or handler is null</dd></dl>
</li>
</ul>
<a name="removeEventHandler(javafx.event.EventType, javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeEventHandler</h4>
<pre>public final&nbsp;&lt;T extends <a href="../event/Event.html" title="class in javafx.event">Event</a>&gt;&nbsp;void&nbsp;removeEventHandler(<a href="../event/EventType.html" title="class in javafx.event">EventType</a>&lt;T&gt;&nbsp;eventType,
                                        <a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super T&gt;&nbsp;eventHandler)</pre>
<div class="block">Unregisters a previously registered event handler from this node. One
 handler might have been registered for different event types, so the
 caller needs to specify the particular event type from which to
 unregister the handler.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>T</code> - the specific event class of the handler</dd><dt><span class="strong">Parameters:</span></dt><dd><code>eventType</code> - the event type from which to unregister</dd><dd><code>eventHandler</code> - the handler to unregister</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.NullPointerException</code> - if the event type or handler is null</dd></dl>
</li>
</ul>
<a name="addEventFilter(javafx.event.EventType, javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addEventFilter</h4>
<pre>public final&nbsp;&lt;T extends <a href="../event/Event.html" title="class in javafx.event">Event</a>&gt;&nbsp;void&nbsp;addEventFilter(<a href="../event/EventType.html" title="class in javafx.event">EventType</a>&lt;T&gt;&nbsp;eventType,
                                    <a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super T&gt;&nbsp;eventFilter)</pre>
<div class="block">Registers an event filter to this node. The filter is called when the
 node receives an <code>Event</code> of the specified type during the capturing
 phase of event delivery.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>T</code> - the specific event class of the filter</dd><dt><span class="strong">Parameters:</span></dt><dd><code>eventType</code> - the type of the events to receive by the filter</dd><dd><code>eventFilter</code> - the filter to register</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.NullPointerException</code> - if the event type or filter is null</dd></dl>
</li>
</ul>
<a name="removeEventFilter(javafx.event.EventType, javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeEventFilter</h4>
<pre>public final&nbsp;&lt;T extends <a href="../event/Event.html" title="class in javafx.event">Event</a>&gt;&nbsp;void&nbsp;removeEventFilter(<a href="../event/EventType.html" title="class in javafx.event">EventType</a>&lt;T&gt;&nbsp;eventType,
                                       <a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super T&gt;&nbsp;eventFilter)</pre>
<div class="block">Unregisters a previously registered event filter from this node. One
 filter might have been registered for different event types, so the
 caller needs to specify the particular event type from which to
 unregister the filter.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>T</code> - the specific event class of the filter</dd><dt><span class="strong">Parameters:</span></dt><dd><code>eventType</code> - the event type from which to unregister</dd><dd><code>eventFilter</code> - the filter to unregister</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.NullPointerException</code> - if the event type or filter is null</dd></dl>
</li>
</ul>
<a name="setEventHandler(javafx.event.EventType, javafx.event.EventHandler)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setEventHandler</h4>
<pre>protected final&nbsp;&lt;T extends <a href="../event/Event.html" title="class in javafx.event">Event</a>&gt;&nbsp;void&nbsp;setEventHandler(<a href="../event/EventType.html" title="class in javafx.event">EventType</a>&lt;T&gt;&nbsp;eventType,
                                     <a href="../event/EventHandler.html" title="interface in javafx.event">EventHandler</a>&lt;? super T&gt;&nbsp;eventHandler)</pre>
<div class="block">Sets the handler to use for this event type. There can only be one such handler
 specified at a time. This handler is guaranteed to be called first. This is
 used for registering the user-defined onFoo event handlers.</div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>T</code> - the specific event class of the handler</dd><dt><span class="strong">Parameters:</span></dt><dd><code>eventType</code> - the event type to associate with the given eventHandler</dd><dd><code>eventHandler</code> - the handler to register, or null to unregister</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.NullPointerException</code> - if the event type is null</dd></dl>
</li>
</ul>
<a name="buildEventDispatchChain(javafx.event.EventDispatchChain)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buildEventDispatchChain</h4>
<pre>public&nbsp;<a href="../event/EventDispatchChain.html" title="interface in javafx.event">EventDispatchChain</a>&nbsp;buildEventDispatchChain(<a href="../event/EventDispatchChain.html" title="interface in javafx.event">EventDispatchChain</a>&nbsp;tail)</pre>
<div class="block">Construct an event dispatch chain for this node. The event dispatch chain
 contains all event dispatchers from the stage to this node.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../event/EventTarget.html#buildEventDispatchChain(javafx.event.EventDispatchChain)">buildEventDispatchChain</a></code>&nbsp;in interface&nbsp;<code><a href="../event/EventTarget.html" title="interface in javafx.event">EventTarget</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tail</code> - the initial chain to build from</dd>
<dt><span class="strong">Returns:</span></dt><dd>the resulting event dispatch chain for this node</dd></dl>
</li>
</ul>
<a name="fireEvent(javafx.event.Event)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>fireEvent</h4>
<pre>public final&nbsp;void&nbsp;fireEvent(<a href="../event/Event.html" title="class in javafx.event">Event</a>&nbsp;event)</pre>
<div class="block">Fires the specified event. By default the event will travel through the
 hierarchy from the stage to this node. Any event filter encountered will
 be notified and can consume the event. If not consumed by the filters,
 the event handlers on this node are notified. If these don't consume the
 event eighter, the event will travel back the same path it arrived to
 this node. All event handlers encountered are called and can consume the
 event.
 <p>
 This method must be called on the FX user thread.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>event</code> - the event to fire</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="Node.html#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Node.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em>JavaFX&nbsp;2.2</em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="ImageCursorBuilder.html" title="class in javafx.scene"><span class="strong">Prev Class</span></a></li>
<li><a href="Node.FocusedProperty.html" title="class in javafx.scene"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?javafx%252Fscene%252FNode.html" target="_top">Frames</a></li>
<li><a href="Node.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="Node.html#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="Node.html#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="Node.html#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="Node.html#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small><small><a href=http://docs.oracle.com/javase/7/docs/legal/cpyr.html>Copyright</a> (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.</small></small></p>
</body>
</html>
