<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--JavaEE</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle"
					data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1">
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->


	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">Java EE</h3>
					</div>
					<div class="list-group">
						<a href="#" class="list-group-item">简介</a>
                        <a href="#javaee-web-xml" class="list-group-item">JavaEE 项目启动流程及 <code>web.xml</code> 文件</a>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#javax-servlet-http" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							<code>javax.servlet.http</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="javax-servlet-http" class="panel-collapse collapse"
							role="tabpanel">
                            <a href="#javax-servlet-ServletContext" class="list-group-item">ServletContext 及相关类</a>
                            <a href="#javax-servlet-http-Listener" class="list-group-item">Listener 相关类</a>
                            <a href="#javax-servlet-http-HttpFilter" class="list-group-item">HttpFilter 及相关类</a>
                            <a href="#javax-servlet-http-HttpServlet" class="list-group-item">HttpServlet 及相关类</a>
                            <a href="#javax-servlet-http-HttpSession" class="list-group-item">HttpSession 及相关类</a>
						</div>
                        <a class="list-group-item active dropup" data-toggle="collapse"
                           data-parent="#accordion" href="#javaee-websocket" aria-expanded="true"   style="border-top: 1px solid #DDDDDD;">
                            <code>javax.websocket</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="javaee-websocket" class="panel-collapse collapse in"
                             role="tabpanel">
                            <a href="#javax-websocket-server" class="list-group-item">WebSocket Server API</a>
                            <a href="#javax-websocket-client" class="list-group-item">WebSocket Client API</a>
                        </div>
                        <a class="list-group-item active dropdown" data-toggle="collapse"
                           data-parent="#accordion" href="#javaee-tag" aria-expanded="true"   style="border-top: 1px solid #DDDDDD;">
                            <code>JSTL, EL, ONGL</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="javaee-tag" class="panel-collapse collapse"
                             role="tabpanel">
                            <a href="#javaee-jstl" class="list-group-item">JSTL -- Java 标准标签库</a>
                            <a href="#javaee-el" class="list-group-item">EL 表达式</a>
                            <a href="#javaee-ongl" class="list-group-item">ONGL -- 对象图导航语言</a>
                        </div>
						<a href="#javaee-" class="list-group-item">...</a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">JavaEE</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
                            <p><b>JavaEE & J2EE</b></p>
                            <p>JavaEE 是一套使用 Java 进行企业级 Web 应用开发的大家一致遵循的工业标准。</p>
                            <p>JavaEE 平台提供了一个基于组件的方法来加快设计、开发、装配及部署企业应用程序。</p>
                            <p>JavaEE 平台规范: <a href=" https://javaee.github.io/javaee-spec" target="_blank"> https://javaee.github.io/javaee-spec</a></p>
                            <p>Sun 公司在 1998 年发表 JDK1.2 版本的时候， 使用了新名称 Java 2 Platform，即“Java2 平台”，修改后的 JDK 称为 Java 2 Platform Software Develping Kit，即 J2SDK。并分为标准版(Standard Edition，J2SE), 企业版(Enterprise Edition，J2EE)，微型版(MicroEdition，J2ME)。</p>
                            <p>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名以取消其中的数字“2”：J2EE 更名为 Java EE, J2SE更名为 Java SE，J2ME 更名为Java ME。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。</p>
                            <p>JavaEE 技术架构，包含许多组件及标准规范，用来简化且规范应用系统的开发与部署，提高其安全、复用性、维护性及可移植性。JavaEE 核心是一组技术规范与指南，其中所包含的各类组件、服务架构及技术层次，均有共同的标准及规格，让各种依循 JavaEE 架构的不同平台之间，存在良好的兼容性，解决过去企业后端使用的信息产品彼此之间无法兼容，企业内部或外部难以互通的窘境。</p>
                        </div>

                        <div class="sub-item">
                            <p><b>JavaEE 包：</b></p>
                            <pre class="brush: java;">compile 'javax:javaee-api:8.0'</pre>
                            <ul>
                                <li><p><a href="docs/docs-javaee-8/javax/servlet/package-summary.html" target="_blank">javax.servlet</a> -- 描述和定义 servlet 类与由符合 servlet 容器为此类实例提供的运行时环境之间的契约。包括接口：<code>Servlet</code>, <code>ServletContext</code>, <code>ServletContextListener</code>, <code>ServletConfig</code>, <code>ServletRequest</code>, <code>ServletResponse</code>, <code>ServletRequestListener</code>, <code>ServletRequestAttributeListener</code>, <code>Filter</code>, <code>FilterConfig</code>, <code>FilterChain</code> ... 包括类： <code>GenericServlet</code>, <code>GenericFilter</code>, <code>ServletRequestEvent</code> ...</p></li>
                                <li><p><a href="docs/docs-javaee-8/javax/servlet/http/package-summary.html" target="_blank">javax.servlet.http</a> -- 描述和定义在 HTTP 协议下运行的 servlet 类与由符合的 servlet 容器为此类实例提供的运行时环境之间的契约。包括接口：<code>HttpSession</code>, <code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>HttpServletMapping</code>, <code>HttpSessionIdListener</code>, <code>HttpSessionListener</code>, <code>HttpSessionAttributeListener</code> ... 包括类： <code>HttpServlet</code>, <code>HttpFilter</code>, <code>Cookie</code>, <code>HttpSessionEvent</code>, <code>HttpServletRequestWrapper</code>, <code>HttpServletResponseWrapper</code>, <code>HttpSessionBindingEvent</code> ...</p></li>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/package-summary.html" target="_blank">javax.websocket / javax.websocket.server</a> -- WebSocket API。WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p></li>
                                <li><p><a href="docs/docs-javaee-8/javax/servlet/jsp/package-summary.html" target="_blank">javax.servlet.jsp</a> -- </p></li>
                                <li><p><a href="docs/docs-javaee-8/javax/.../package-summary.html" target="_blank">javax.</a> -- </p></li>
                            </ul>
                        </div>

                        <div class="sub-item">
                            <p><b>JavaEE 的 13 种核心技术规范：</b></p>
                            <ol type="I">
                                <li><p><code>JDBC(Java DataBase Connectivity)</code> -- 是一组用于执行 SQL 的 Java API，为访问不同的数据库提供了一种统一的途径，几乎所有的关系型数据库厂商（DBMS）都提供了 JDBC 的服务或驱动。</p></li>
                                <li><p><code>JNDI(Java Naming and Directory Interfaces)</code> -- 是命名目录服务的抽象接口集合，为企业级应用提供了统一的标准化连接，使 Java 能够无缝地获取任何可目录化的企业信息。在 JavaEE 体系中，JNDI 用来定位各种对象，包括 EJB、数据库驱动、JDBC 数据源及消息连接等。</p></li>
                                <li><p><code>RMI(Remote Method Invoke)</code> -- 是远程方法调用，RMI 协议能够让在某个 Java 虚拟机上的对象，像调用本地对象一样调用另一个 Java 虚拟机中的对象上的方法。它使用了序列化方式在客户端和服务器端传送数据。RMI 是一种被 EJB 使用的更底层的协议。</p></li>
                                <li><p><code>EJB(Enterprise JavaBean)</code> -- 是企业级 JavaBean，把原来放到客户端实现的代码放到服务器端，并依靠 RMI 进行通信。又可以分为以下部分：</p>
                                    <ul>
                                        <li><p><b>EJB 组件</b> -- JavaBean 是在编程环境（IDE）中能被可视化处理的可重用组件，实现分布式业务逻辑的 Java 组件。</p></li>
                                        <li><p><b>EJB 容器</b> -- 是 EJB 组件的运行环境，为部署 EJB 组件提供服务，包括事务、安全、远程客户端的网络发布等。</p></li>
                                        <li><p><b>EJB 服务器</b> -- 管理 EJB 容器的高端进程或应用程序，并提供对系统服务的访问。</p></li>
                                    </ul>
                                </li>
                                <li><p><code>Java IDL(Interface Description Language) / CORBA(Common Object Broker Architecture)</code> -- 是用来描述软件组件接口的一种计算机语言。IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流。</p></li>
                                <li><p><code>Servlet</code> -- 是一种小型的 Java 程序，它扩展了 Web 服务器的功能。作为一种服务器端的应用，当被请求时开始执行。</p></li>
                                <li><p><code>JSP(Java Server Pages)</code> -- 是服务器页面，由 HTML 代码和嵌入其中的 Java 代码所组成。服务器在页面被客户端所请求以后对这些 Java 代码进行处理，然后将生成的 HTML 页面返回给客户端的浏览器。</p></li>
                                <li><p><code>XML(Extensible Markup Language)</code> -- 是一种用于标记电子文件使其具有结构性的标记语言。它被用来在不同的商务过程中共享数据。</p></li>
                                <li><p><code>JMS(Java Message Service)</code> -- 是 Java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。JMS 用于和面向消息的中间件相互通信的应用程序接口(API)。它既支持点对点的域，有支持发布/订阅类型的域，并且提供对下列类型的支持：经认可的消息传递,事务型消息的传递，一致性消息和具有持久性的订阅者支持。</p></li>
                                <li><p><code>JTA(Java Transaction API)</code> -- 是 Java 事务 API，它保证了用户操作 ACID（即原子、一致、隔离、持久）属性。对于那些跨数据源（例如多个数据库，或者数据库与 JMS）的大型应用，则必须使用全局事务 JTA。应用系统可以由 JTA 定义的标准 API 访问各种事务监控，JTA 为 JavaEE 平台提供了分布式事务服务，它隔离了事务与底层的资源，实现了透明的事务管理方式。</p></li>
                                <li><p><code>JTS(Java Transaction Service)</code> -- 是一个组件事务监视器，规定了事务管理器的实现方式。JTS 事务管理器为应用服务器、资源管理器、独立的应用以及通信资源管理器提供了事务服务。</p></li>
                                <li><p><code>JavaMail</code> -- 是用于存取邮件服务器的 API，它提供了一套邮件服务器的抽象类。不仅支持 SMTP 服务器，也支持 IMAP 服务器和 POP 服务器。</p></li>
                                <li><p><code>JAF(JavaBean Activation Framework)</code> -- JavaMail 利用 JAF 来处理 MIME 编码的邮件附件。MIME 的字节流可以被转换成 Java 对象，或者转换自 Java 对象。大多数应用都可以不需要直接使用 JAF。</p></li>
                            </ol>

                        </div>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="javaee-web-xml"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">JavaEE 项目启动流程及 <code>web.xml</code> 文件</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <p><b>相同的组件，根据其在 <code>web.xml</code> 中的配置顺序依次执行。</b></p>
                            <p><b>WEB 项目启动及初始化流程：</b></p>
                            <ol>
                                <li><p>在启动 WEB 项目时，WEB 容器(如: Tomcat)会读 <code>web.xml</code> 配置文件中的两个节点 <code>&lt;listener></code> 和 <code>&lt;context-param></code>；</p></li>
                                <li><p>接着 WEB 容器会创建一个 ServletContext 对象，应用范围内即整个 WEB 项目都能使用这个上下文对象；</p></li>
                                <li><p>接着容器会将读取到 <code>&lt;context-param> </code> 转化为键值对,并交给 ServletContext对象；</p></li>
                                <li><p>接着 WEB 容器创建 <code>&lt;listener></code> 中的类实例，即创建监听（备注：Listener 为自定义的类但必须需要实现 ServletContextListener 接口）；</p></li>
                                <li><p>接着会执行 <code>&lt;listener></code> 中的 <code>contextInitialized(ServletContextEvent)</code> 方法，此处可以读取到 <code>web.xml</code> 中配置的 <code>context-parm</code> 值，并且可以设置值(<code>setInitParameter(String, String)</code>)；</p>
                                    <p>在此类中还必须有一个 <code>contextDestroyed(ServletContextEvent)</code> 销毁方法，用于关闭应用前释放资源，比如说数据库连接的关闭；</p>
                                </li>
                                <li><p>接着会执行 Filter 的 <code>init(FilterConfig)</code> 方法；</p></li>
                                <li><p>到这一步，应用启动完成。</p></li>
                                <li><p>在客户端有请求时在根据相应配置执行不懂的逻辑，比如 Servlet 请求，先执行 Servlet 的 <code>init</code> 方法。 </p></li>
                            </ol>

                        </div>

                        <div class="sub-item">
                            <p><b>不同 Servlet 版本对应的的 <code>web.xml</code> 配置：</b></p>
                            <div class="split-item">
                                <p><b>Servlet 4.0</b></p>
                                <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="UTF-8"?>

&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
  version="4.0">
  ...
&lt;/web-app>
</pre>
                                </div>
                            <div class="split-item">
                                <p><b>Servlet 3.1</b></p>
                                <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="UTF-8"?>

&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
  version="3.1">
  ...
&lt;/web-app>
</pre>
                            </div>
                            <div class="split-item">
                                <p><b>Servlet 3.0</b></p>
                                <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="UTF-8"?>

&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0">
    ...
&lt;/web-app>
</pre>
                                </div>
                            <div class="split-item">
                                <p><b>Servlet 2.5</b></p>
                                <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="UTF-8"?>

&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
    version="2.5">
    ...
&lt;/web-app>
</pre>
                            </div>
                            <div class="split-item">
                                <p><b>Servlet 2.4</b></p>
                                <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="UTF-8"?>

&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
    version="2.4">
    ...
&lt;/web-app>
</pre>
                            </div>

                        </div>

                        <div class="sub-item">
                            <p><b><code>web.xml</code> 常用配置</b></p>
                            <ul>
                                <li><p><code>welcome-file-list</code> -- 默认文件列表</p></li>
                                <li><p><code>error-page</code> -- 错误页面，一般一个错误码对应一个错误页面</p></li>
                                <li><p><code>context-param</code> -- 初始化的上下文参数，参见： <a href="#javax-servlet-ServletContext">ServletContext</a></p></li>
                                <li><p><code>jsp-config</code> -- jsp 相关配置，参见： <a href="#javax-servlet-ServletContext">ServletContext</a> 的 <code>getJspConfigDescriptor()</code> 方法</p></li>
                                <li><p><code>listener</code> -- Listener 配置，参见： <a href="#javax-servlet-http-Listener">ServletContextListener</a></p></li>
                                <li><p><code>filter, filter-mapping</code> -- Filter 配置，参见： <a href="#javax-servlet-http-HttpFilter">HttpFilter</a></p></li>
                                <li><p><code>servlet, servlet-mapping</code> -- Servlet 器配置，参见： <a href="#javax-servlet-http-HttpServlet">HttpServlet</a></p></li>
                                <li><p><code>...</code> -- </p></li>

                            </ul>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-servlet-ServletContext"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">ServletContext</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface ServletContext {
    public static final String TEMPDIR = "javax.servlet.context.tempdir";
    public static final String ORDERED_LIBS = "javax.servlet.context.orderedLibs";
}
</pre>
                            <p><a href="docs/docs-javaee-8/javax/servlet/ServletContext.html" target="_blank">ServletContext</a> 是整个应用共享的上下问对象。</p>
                            <p>在同一个应用中，不管是哪个 Listener, Filter, Servlet 或者 JSP 页面，获取到的都是同一个上下文对象实例。</p>
                            <pre class="brush: java;">
/** 在 Listener 中获取(此方法来自实现的 ServletContextListener 接口)： */
public void contextInitialized(ServletContextEvent sce) {
  ServletContext C0 = sce.getServletContext();
}

/** 在 Filter 中获取(此方法来自实现的 Filter 接口)： */
public void init(FilterConfig config) throws ServletException {
    ServletContext C1 = config.getServletContext();
}

/** 在 Servlet 中获取(init 方法及以后才能获取到)： */
 @Override
public void init() throws ServletException {
    ServletContext C2 = getServletContext();
}

/** 在 JSP 页面中也可以获取到此对象: */
ServletContext C3 = getServletConfig().getServletContext();

/** 同一个应用中，都是同一个实例对象： */
C0 == C1 == C2 == C3 == Cn...
</pre>
                            <p>ServletContext 由 Servlet 容器在装载的时候实例化，并且可以在 <code>web.xml</code> 文件中以键值对的形式配置。</p>
                            <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="UTF-8"?>

&lt;web-app
  xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
  version="3.1">

  <!-- 下面的参数可以在任何一个 Filter / Servlet 的 init 方法中获取，每个应用共享一个 ServletContext 对象  -->
  &lt;context-param>
    &lt;param-name>phone&lt;/param-name>
    &lt;param-value>1388888888&lt;/param-value>
  &lt;/context-param>
  &lt;context-param>
    &lt;param-name>...&lt;/param-name>
    &lt;param-value>...&lt;/param-value>
  &lt;/context-param>

  ...
&lt;web-app>
</pre>
                            <ol>
                                <li><p><code>Enumeration&lt;String> 	getInitParameterNames()</code> -- 获取所有的初始参数名称列表(<code>web.xml</code> 中配置，Servlet 容器(如: Tomcat)可能有一些初始化参数)</p></li>
                                <li><p><code>String 	getInitParameter(String name)</code> -- 获取指定的初始参数<code>web.xml</code> 中配置</p></li>
                                <li><p><code>boolean 	setInitParameter(String name, String value)</code> -- 设置一个初始化参数，如果已经初始化，那么将抛出异常(此方法不可以在 Servlet 中调用，因为 ServletContext 已经初始化过了)</p></li>

                                <li class="group"><p><code>void 	setRequestCharacterEncoding(String encoding)</code> -- 设置请求的编码</p></li>
                                <li><p><code>String 	getRequestCharacterEncoding()</code> -- 获取请求的编码</p></li>
                                <li><p><code>void 	setResponseCharacterEncoding(String encoding)</code> -- 设置响应的编码</p></li>
                                <li><p><code>String 	getResponseCharacterEncoding()</code> -- 获取响应的编码</p></li>

                                <li class="group"><p><code>Enumeration&lt;String> 	getAttributeNames()</code> -- 获取所有属性名列表(Servlet 容器配置了很多属性)</p></li>
                                <li><p><code>void 	setAttribute(String name, Object object)</code> -- 设置一个指定的属性</p></li>
                                <li><p><code>Object 	getAttribute(String name)</code> -- 获取一个指定的属性</p></li>
                                <li><p><code>void 	removeAttribute(String name)</code> -- 移除一个指定的属性</p>
                                    <pre class="brush: java;">
ServletContext context = getServletContext();
Enumeration&lt;String> params = context.getAttributeNames();
while(params.hasMoreElements()) {
    String name = params.nextElement();
    Log.d(name, context.getAttribute(name));
}

/** Servlet 容器(这里使用的是 Gretty)配置的属性名：
 * javax.servlet.context.tempdir -- 临时存储目录
 * org.eclipse.jetty.tmpdirConfigured --临时目录是否已经配置
 * org.apache.catalina.jsp_classpath -- JSP 的 CLASSPATH
 * ...
 */
</pre>
                                </li>

                                <li class="group"><p><code>void 	setSessionTimeout(int sessionTimeout)</code> -- 设置 Session 超时分钟数(Servlet 4.0)</p></li>
                                <li><p><code>int 	getSessionTimeout()</code> -- 获取 Session 超时分钟数(Servlet 4.0)</p></li>
                                <li><p><code><a href="docs/docs-javaee-8/javax/servlet/SessionCookieConfig.html" target="_blank">SessionCookieConfig</a> 	getSessionCookieConfig()</code> -- 获取 SessionCookieConfig 对象，可用于配置用于会话跟踪目的的 Cookie 的各种属性</p></li>
                                <li><p><code>Set&lt;SessionTrackingMode> 	getDefaultSessionTrackingModes()</code> -- 返回的默认会话跟踪模式</p></li>
                                <li><p><code>Set&lt;SessionTrackingMode> 	getEffectiveSessionTrackingModes()</code> --  获取对该 ServletContext 有效的会话跟踪模式</p></li>
                                <li><p><code>void 	setSessionTrackingModes(Set&lt;SessionTrackingMode> sessionTrackingModes)</code> -- 设置对该 ServletContext 有效的会话跟踪模式</p>
                                    <pre class="brush: java;">
public enum SessionTrackingMode {
    COOKIE,  // Cookie 模式
    URL,     // URL 模式
    SSL      // Https 模式
}
</pre>
                                </li>

                                <li class="group"><p><code>FilterRegistration.Dynamic 	addFilter(String filterName, Class&lt;? extends Filter> filterClass)</code> -- 动态添加 Filter(在 Filter 和 Listener 中的 init 方法中可以调用，在 Servlet 中不能调用)</p></li>
                                <li><p><code>FilterRegistration.Dynamic 	addFilter(String filterName, Filter filter)</code> -- 同上</p></li>
                                <li><p><code>FilterRegistration.Dynamic 	addFilter(String filterName, String className)</code> -- 同上</p></li>
                                <li><p><code>&lt;T extends Filter> T 	createFilter(Class&lt;T> clazz)</code> -- 创建 Filter</p>
                                    <pre class="brush: java;">
/** 在 Filter(以下实例继承自 HttpFilter) 的 init 方法中动态添加 Filter: *.jsp */
public void init(FilterConfig config) throws ServletException {
    super.init(config);
    ServletContext context = getServletContext();

    FilterRegistration.Dynamic filterDynamic = context.addFilter("jsp", JspFilter.class);
    filterDynamic.addMappingForUrlPatterns(null, true, "*.jsp");
}
</pre>
                                </li>

                                <li class="group"><p><code>ServletRegistration.Dynamic 	addServlet(String servletName, Class&lt;? extends Servlet> servletClass)</code> -- 动态添加 Servlet(在 Filter 和 Listener 中的 init 方法中可以调用，在 Servlet 中不能调用)</p></li>
                                <li><p><code>ServletRegistration.Dynamic 	addServlet(String servletName, Servlet servlet)</code> -- 同上</p></li>
                                <li><p><code>ServletRegistration.Dynamic 	addServlet(String servletName, String className)</code> -- 同上</p></li>
                                <li><p><code>&lt;T extends Servlet> T 	createServlet(Class&lt;T> clazz)</code> -- 创建一个 Servlet</p>
                                    <pre class="brush: java;">
/** 在 Filter(以下实例继承自 HttpFilter) 的 init 方法中动态添加 Servlet: /s */
public void init(FilterConfig config) throws ServletException {
    super.init(config);
    ServletContext context = getServletContext();

    ServletRegistration.Dynamic Dynamic = context.addServlet("s", ServerServlet.class);
    Dynamic.addMapping("/s");
}
</pre>
                                </li>

                                <li class="group"><p><code>ServletRegistration.Dynamic 	addJspFile(String servletName, String jspFile)</code> -- 动态添加一个 JSP 文件，同 <code>addServlet(String, String)</code> 方法(一般用来添加在 webapp 目录外的文件)</p></li>

                                <li class="group"><p><code>void 	addListener(Class&lt;? extends EventListener> listenerClass)</code> -- 动态添加 Listener,<b>注意：动态添加的监听器不能监听到 ServletContextListener 的 contextInitialized 方法</b>(在 Filter 和 Listener 中的 init 方法中可以调用，在 Servlet 中不能调用)</p></li>
                                <li><p><code>void 	addListener(String className)</code> -- 同上</p></li>
                                <li><p><code>&lt;T extends EventListener> void 	addListener(T t)</code> -- 同上</p></li>
                                <li><p><code>&lt;T extends EventListener> T 	createListener(Class&lt;T> clazz)</code> -- 创建一个 Listener</p></li>



                                <li class="group"><p><code>Set&lt;String> 	getResourcePaths(String path)</code> -- 获取指定路径下的文件和目录集合(根目录为: "/")</p></li>
                                <li><p><code>URL 	getResource(String path)</code> -- 转换为 URL 形式的却对路径</p></li>
                                <li><p><code>String 	getContextPath()</code> -- 返回上下文路径(如： /site)</p></li>
                                <li><p><code>String 	getRealPath(String path)</code> -- 获取指定目录的物理路径，不管指定的路径是否存在</p>
                                    <pre class="brush: java;">
ServletContext cx = config.getServletContext();

cx.getResourcePaths("/").forEach(path -> {
    Log.d(path); // 列出项目根目录下的内容，比如: /WEB-INF/, /index.jsp ...
});
Log.d(cx.getContextPath()); // 上下文目录，比如: /site

Log.d(cx.getRealPath("/")); // 运行时的物理路径，如： $CATALINA_HOME/webapps/site
String webXmlPathName = cx.getRealPath("/WEB-INF/web.xl");
Log.d(new File(webXmlPathName).exists()); // 这里返回 true

Log.d(cx.getResource("/WEB-INF")); // 转换为 URL 形式的却对路径： file:/home/nate/...
 </pre>
                                </li>

                                <li class="group"><p><code>Map&lt;String,? extends ServletRegistration> 	getServletRegistrations()</code> -- 获取所有的已经注册的 Servlet 的信息</p></li>
                                <li><p><code>ServletRegistration 	getServletRegistration(String servletName)</code> -- 获取指定的 Servlet 信息(参数为 Servlet 的别名)</p></li>
                                <li><p><code>Map&lt;String,? extends FilterRegistration> 	getFilterRegistrations()</code> --  获取所有的已经注册的 Filter 的信息</p></li>
                                <li><p><code>FilterRegistration 	getFilterRegistration(String filterName)</code> -- 获取指定的 Filter 注册信息(参数为 Filter 的别名)</p></li>

                                <li class="group"><p><code>RequestDispatcher 	getRequestDispatcher(String path)</code> -- 获取 RequestDispatcher 对象，路径以 "/" 开头，可用于向资源转发请求或在响应中包含资源</p></li>
                                <li><p><code>RequestDispatcher 	getNamedDispatcher(String name)</code> -- 同上，只是参数不同，如果是 Servlet, 那么参数为 Servlet 的别名</p></li>

                                <li class="group"><p><code><a href="docs/docs-javaee-8/javax/servlet/descriptor/JspConfigDescriptor.html" target="_blank">JspConfigDescriptor</a> 	getJspConfigDescriptor()</code> -- 获取 jsp 相关配置(在 <code>web.xml</code> 中由 <code>&lt;jsp-config></code> 配置)</p></li>

                                <li class="group"><p><code>String 	getServletContextName()</code> -- 此应用的名称(如: /site)</p></li>
                                <li><p><code>String 	getVirtualServerName()</code> -- 返回部署此应用的的逻辑主机的配置名称</p></li>
                                <li><p><code>ServletContext 	getContext(String uripath)</code> -- 允许访问此服务上的其他应用的上下文对象(/site, /javaee), 但是在安全的环境中(如: Tomcat 中)一般返回 NULL</p></li>
                                <li><p><code>ClassLoader 	getClassLoader()</code> -- 获取类加载器</p></li>

                                <li class="group"><p><code>int 	getMajorVersion()</code> -- 返回 Servlet 容器支持的 Servlet API 的主要版本</p></li>
                                <li><p><code>int 	getMinorVersion()</code> -- 返回 Servlet 容器支持的 Servlet API 的最低版本</p></li>
                                <li><p><code>int 	getEffectiveMajorVersion()</code> -- 获取由该 ServletContext 表示的应用程序的 Servlet 规范的主要版本</p></li>
                                <li><p><code>int 	getEffectiveMinorVersion()</code> -- 获取由该 ServletContext 表示的应用程序的 Servlet 规范的最低版本</p></li>

                                <li class="group"><p><code>String 	getServerInfo()</code> -- 获取 Servlet 容器的信息</p></li>
                                <li><p><code>String 	getMimeType(String file)</code> -- 获取指定文件的 Mime 类型(路径以 "/" 开头，如: "/index.jsp)</p></li>
                                <li><p><code>InputStream 	getResourceAsStream(String path)</code> -- 流的形式读取资源</p></li>

                                <li class="group"><p><code>void 	declareRoles(String... roleNames)</code> -- 声明使用 isUserInRole 角色测试的角色名称</p></li>

                                <li class="group"><p><code>void 	log(String msg)</code> -- 将指定的消息写入 servlet 日志文件</p></li>
                                <li><p><code>void 	log(String message, Throwable throwable)</code> -- 将指定的消息和异常写入 servlet 日志文件</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-servlet-http-Listener"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Listener 及相关类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <p>JavaEE 监听器用来监听容器(如: Tomcat)中某一执行动作，并根据其要求做出相应的响应。</p>
                            <p>JavaEE 监听器主要分为以下几类：</p>
                            <ul>
                                <li><p><b>上下文监听器，与 ServletContext 相关</b> -- 包括接口： <a href="docs/docs-javaee-8/javax/servlet/ServletContextListener.html" target="_blank">ServletContextListener</a> 和 <a href="docs/docs-javaee-8/javax/servlet/ServletContextAttributeListener.html" target="_blank">ServletContextAttributeListener</a>；</p>
                                    <pre class="brush: java;">
/** 监听上下文的初始化和销毁 */
public interface ServletContextListener extends EventListener {
    public void contextInitialized(ServletContextEvent sce);
    public void contextDestroyed(ServletContextEvent sce);
}

/** 监听上下文的属性变化 */
public interface HttpSessionAttributeListener extends EventListener {
    /** 在任何一个地方修改上下文属性都会触发监听器的相应的方法回调：
     * ServletContext cx = request.getServletContext();
     * cx.setAttribute("aa", "aaaaaa");
     * cx.setAttribute("aa", "bbbbbb");
     * cx.removeAttribute("aa");
     */
    public void attributeAdded(HttpSessionBindingEvent event);
    public void attributeRemoved(HttpSessionBindingEvent event);
    public void attributeReplaced(HttpSessionBindingEvent event);
}
</pre>
                                </li>
                                <li><p><b>会话监听器，与 HttpSession 相关</b> -- 包括接口： <a href="docs/docs-javaee-8/javax/servlet/http/HttpSessionListener.html" target="_blank">HttpSessionListener</a>、<a href="docs/docs-javaee-8/javax/servlet/http/HttpSessionAttributeListener.html" target="_blank">HttpSessionAttributeListener</a>、<a href="docs/docs-javaee-8/javax/servlet/http/HttpSessionIdListener.html" target="_blank">HttpSessionIdListener</a>、<a href="docs/docs-javaee-8/javax/servlet/http/HttpSessionBindingListener.html" target="_blank">HttpSessionBindingListener</a> 和 <a href="docs/docs-javaee-8/javax/servlet/http/HttpSessionActivationListener.html" target="_blank">HttpSessionActivationListener</a>；</p>
                                    <pre class="brush: java;">

/** 监听会话创建和销毁，客户端第一次访问创建，会话超时或者退出销毁（比如监听在线用户数） */
public interface HttpSessionListener extends EventListener {
    public void sessionCreated(HttpSessionEvent se);
    public void sessionDestroyed(HttpSessionEvent se);
}

/** 监听会话的属性变化 */
public interface HttpSessionAttributeListener extends EventListener {
    /** 一般根据 SessionId 来做监听，在任何一个地方修改 Session 属性都会触发监听器的相应的方法回调：
     * HttpSession session = request.getSession(true);
     * if(null != session) {
     *   session.setAttribute(session.getId(), user);
     *   session.removeAttribute(session.getId());
     * }
     */
    public void attributeAdded(HttpSessionBindingEvent event);
    public void attributeRemoved(HttpSessionBindingEvent event);
    public void attributeReplaced(HttpSessionBindingEvent event);
}

/** 监听 SessionId 的改变，比如 HttpServletRequest 的 changeSessionId() 方法 */
public interface HttpSessionIdListener extends EventListener {
    public void sessionIdChanged(HttpSessionEvent event, String oldSessionId);
}

/** 监听对象在绑定到会话或解绑会话 */
public interface HttpSessionBindingListener extends EventListener {
    /** 以下方法同样可以实现计数器功能：
     * HttpSession session = request.getSession();
     * if(null != session) {
     *     if(session.getAttribute(session.getId()) == null) {
     *         // 只有将 HttpSessionBindingListener 设置到 Session 中才会触发 valueBound 事件
     *         session.setAttribute(session.getId(), new CounterListener(1001));
     *     }
     * }
     *
     * class CounterListener implements HttpSessionBindingListener {
     *   int uid;
     *
     *   CounterListener(int uid) {
     *      this.uid = uid;
     *   }
     *
     *   @Override
     *   public void valueBound(HttpSessionBindingEvent event) {
     *      Log.d("valueBound", event.getSession().getId(), event.getName(), uid);
     *   }
     *
     *   @Override
     *   public void valueUnbound(HttpSessionBindingEvent event) {
     *      Log.d("valueUnbound", event.getSession().getId(), event.getName(), );
     *   }
     * }
     */
    public void valueBound(HttpSessionBindingEvent event);
    public void valueUnbound(HttpSessionBindingEvent event);
}

/** 监听对象被活化(从硬盘到内存)和钝化(从内存到硬盘)的过程,比如会话太多时可以将部分 Session 写入硬盘 */
public interface HttpSessionActivationListener extends EventListener {
    /** 监听和 HttpSessionBindingListener 一样的操作，但是要在应用的 /META-INF/context.xml 中做如下配置：
     * &lt;?xml version="1.0" encoding="UTF-8"?>
     * &lt;Context>
     *   &lt;Manager className="org.apache.catalina.session.PersistentManager" maxIdleSwap="1">
           &lt;!-- 指定保存路径 -->
     *     &lt;Store className="org.apache.catalina.session.FileStore" directory="/tmp/site.session"/>
     *   &lt;/Manager>
     * &lt;/Context>
     */
    public void sessionWillPassivate(HttpSessionEvent se); // Session 被序列化到（钝化）到硬盘中
    public void sessionDidActivate(HttpSessionEvent se);   // Session被反序列化到（活化）到内存中
}
</pre>
                                </li>
                                <li><p><b>请求监听器，与 ServletRequest 相关</b> -- 包括接口： <a href="docs/docs-javaee-8/javax/servlet/ServletRequestListener.html" target="_blank">ServletRequestListener</a> 和 <a href="docs/docs-javaee-8/javax/servlet/ServletRequestAttributeListener.html" target="_blank">ServletRequestAttributeListener</a>。</p>
                                    <pre class="brush: java;">

/** 监听 Http 请求，每个请求的页面或者资源都会触发以下事件(一个 jsp 或者 html 页面会触发多次，因为有多个资源) */
public interface ServletRequestListener extends EventListener {
    public void requestDestroyed(ServletRequestEvent sre);
    public void requestInitialized(ServletRequestEvent sre);
}

/** 请求的属性变化监听 */
public interface ServletRequestAttributeListener extends EventListener {
    public void attributeAdded(ServletRequestAttributeEvent srae);
    public void attributeRemoved(ServletRequestAttributeEvent srae);
    public void attributeReplaced(ServletRequestAttributeEvent srae);
}
</pre>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-servlet-http-HttpFilter"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">HttpFilter 及相关类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public abstract class HttpFilter extends GenericFilter {}
</pre>
                            <p><a href="docs/docs-javaee-8/javax/servlet/http/HttpFilter.html" target="_blank">HttpFilter</a> 是过滤器，在 WEB 应用初始化时候调用其 <code>init()</code> 方法，以后根据请求的 <code>url-pattern</code> 决定时候调用其 <code>doFilter</code> 方法。</p>
                            <p>Filter 在开发中的常见应用：</p>
                            <ul>
                                <li><p>在目标资源执行之前，进行权限检查，检查用户有无权限，如有权限则放行，如没有，则拒绝访问；</p></li>
                                <li><p>在放行之前，对 request 和 response 进行预处理，从而实现一些全局性的设置，比如设置其编码；</p></li>
                                <li><p>在放行之后，可以捕获到目标资源的输出，从而对输出作出类似于压缩这样的设置。</p></li>
                            </ul>
                            <p>Filter 在 <code>web.xml</code> 中的配置：</p>
                            <pre class="brush: xml;">
&lt;filter>
    &lt;filter-name>EncodeFilter&lt;/filter-name>
    &lt;filter-class>io.jiwanger.site.filter.EncodeFilter&lt;/filter-class>
    &lt;init-param>
        &lt;param-name>...&lt;/param-name>
        &lt;param-value>...&lt;/param-value>
    &lt;/init-param>
&lt;/filter>
&lt;filter-mapping>
    &lt;filter-name>EncodeFilter&lt;/filter-name>
    <!-- 根据请求的 url 决定是否调用其 doFilter 方法
        /* -- 拦截项目下的所有资源
        *.jsp -- 拦截所有的jsp页面
        /jsps/* --  拦截 jsps 目录下的所有资源
        /LoginServlet -- 只拦截该 Servlet
        login -- 只拦截名为“login”的 Servlet
    -->
    &lt;url-pattern>*&lt;/url-pattern>
    <!-- 分发器类型，先要满足 url-pattern
        REQUEST -- 默认，直接访问触发
        FORWARD -- forward 方法来访问触发
        INCLUDE -- include 方法来访问触发
        ERROR -- 发生错误触发
        ASYNC -- 异步访问触发
     -->
    &lt;dispatcher>REQUEST|FORWARD|INCLUDE|ASYNC|ERROR&lt;/dispatcher>
&lt;/filter-mapping>
</pre>
                            <ol>
                                <li><p><code>void 	doFilter(ServletRequest req, ServletResponse res, FilterChain chain)</code> -- 转换参数为 HttpServletRequest 和 HttpServletResponse，并调用以下方法</p></li>
                                <li><p><code>protected void 	doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain)</code> -- </p>
                                    <pre class="brush: java;">
public void doFilter(HttpServletRequest req, HttpServletResponse resp, FilterChain chain)
                                        throws ServletException, IOException {
    Log.d("doFilter before");   // 前置过滤
    chain.doFilter(req, resp);
    Log.d("doFilter after");    // 后置过滤
}
</pre>
                                </li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public abstract class GenericFilter implements Filter, FilterConfig, Serializable {}

public interface Filter {
    void doFilter(ServletRequest request, ServletResponse response, FilterChain chain);
    default void init(FilterConfig filterConfig);
    default void destroy();
}

public interface FilterConfig {
    String getFilterName();
    String getInitParameter(String name);
    Enumeration&lt;String> getInitParameterNames();
    ServletContext getServletContext();
}
</pre>
                            <p><a href="docs/docs-javaee-8/javax/servlet/GenericFilter.html" target="_blank">GenericFilter</a> 定义了一个通用的、与协议无关的过滤器。</p>
                            <ol>
                                <li><p><code>FilterConfig 	getFilterConfig()</code> -- 获取过滤器的配置参数</p></li>
                                <li><p><code>String 	getFilterName()</code> -- 获取过滤器的别名</p></li>

                                <li class="group"><p><code>String 	getInitParameter(String name)</code> -- 获取指定的初始化参数</p></li>
                                <li><p><code>Enumeration&lt;String> 	getInitParameterNames()</code> -- 获取所有的初始化参数名列表</p></li>

                                <li class="group"><p><code>ServletContext 	getServletContext()</code> -- 获取 ServletContext 对象</p></li>

                                <li class="group"><p><code>void 	init()</code> -- 初始化回调</p></li>
                                <li><p><code>void 	init(FilterConfig config)</code> -- 初始化回调<p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="javax-servlet-http-HttpServlet"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">HttpServlet</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public abstract class HttpServlet extends GenericServlet {}
</pre>
							<p><a href="docs/docs-javaee-8/javax/servlet/http/HttpServlet.html" target="_blank">HttpServlet</a> 是一个抽象类，通常继承此类类创建一个 HttpServlet。</p>
                            <p>Servlet 通常在多线程服务器上运行，因此请注意 Servlet 必须处理并发请求，并注意同步对共享资源的访问。共享资源包括内存中的数据，比如实例或类变量，以及外部对象，比如文件、数据库连接和网络连接。</p>
                            <p>Servlet 的生命周期：</p>
                            <pre class="brush: java;">
/* 只关注 GET / POST 方法
 * 1. Construct -- 启动调用，只调用一次
 * 2. init -- 构造方法调用完后就调用此方法，只调用一次(此方法中可以获取 ServletConfig 和 ServletContext 的参数)

 * 3. service(ServletRequest, ServletResponse) -- 每次访问都会调用，不管是 Get / Post 方法
 * 4. service(HttpServletRequest, HttpServletResponse) -- 每次访问都会调用，不管是 Get / Post 方法
 * 5. getLastModified -- 每次在 doGet 方法前会调用， doPost 不调用此方法
 * 6. doGet -- 每次 Get 请求调用
 * 7. doPost -- 每次 Post 请求调用

 * 8. destroy -- 关闭服务调用，只调用一次
 */
</pre>

                            <p><b>Servlet 在 <code>web.xml</code> 中的配置:</b></p>
                            <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="UTF-8"?>

&lt;web-app
  xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
  version="3.1">

  <!-- 下面的参数可以在任何一个 Servlet 的 init 方法中获取，每个应用共享一个 ServletContext 对象  -->
  &lt;context-param>
    &lt;param-name>phone&lt;/param-name>
    &lt;param-value>1388888888&lt;/param-value>
  &lt;/context-param>

  &lt;servlet>
    &lt;servlet-name>TestServlet&lt;/servlet-name>  <!-- Servlet 别名 -->
    &lt;servlet-class>io.jiwanger.site.servlet.TestServlet&lt;/servlet-class> <!-- Servlet 完全限定名 -->
    <!-- 下面的参数可以在 Servlet 的 init 方法中获取()，每个 Servlet 有唯一对应 ServletConfig 对象 -->
    &lt;init-param>
      &lt;param-name>user&lt;/param-name>
      &lt;param-value>root&lt;/param-value>
    &lt;/init-param>
    &lt;init-param>
      &lt;param-name>password&lt;/param-name>
      &lt;param-value>123456&lt;/param-value>
    &lt;/init-param>
  &lt;/servlet>
  &lt;servlet-mapping>
    &lt;servlet-name>TestServlet&lt;/servlet-name>  <!-- Servlet 别名 -->
    &lt;url-pattern>/T&lt;/url-pattern>             <!-- Servlet 访问路径 -->
  &lt;/servlet-mapping>

&lt;/web-app>
</pre>
                            <ol>
                                <li><p><code>void 	service(ServletRequest req, ServletResponse res)</code> -- 每次访问调用此方法，将两个参数强制转换再调用以下方法</p></li>
                                <li><p><code>protected void 	service(HttpServletRequest req, HttpServletResponse resp)</code> -- 每次访问调用此方法，在此方法中根据请求调用 doGet / doPost / 	doHead / ... 的哪一个方法</p>
                                    <pre class="brush: java;">
protected void service(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
    String method = req.getMethod();
    if (method.equals(METHOD_GET)) {
        ...
    } else if (method.equals(METHOD_HEAD)) {
        ...
    } else if (method.equals(METHOD_POST)) {
       ...
    } else if ...
}
</pre>
                                </li>

                                <li class="group"><p><code>protected void 	doGet(HttpServletRequest req, HttpServletResponse resp)</code> -- GET 请求调用此方法</p></li>
                                <li><p><code>protected void 	doPost(HttpServletRequest req, HttpServletResponse resp)</code> -- POST 请求调用此方法</p></li>
                                <li><p><code>protected void 	doHead(HttpServletRequest req, HttpServletResponse resp)</code> -- HEAD 请求调用此方法</p></li>
                                <li><p><code>protected void 	doPut(HttpServletRequest req, HttpServletResponse resp)</code> -- PUT 请求调用此方法</p></li>
                                <li><p><code>protected void 	doDelete(HttpServletRequest req, HttpServletResponse resp)</code> -- DELETE 请求调用此方法</p></li>
                                <li><p><code>protected void 	doTrace(HttpServletRequest req, HttpServletResponse resp)</code> -- TRACE 请求调用此方法</p></li>
                                <li><p><code>protected void 	doOptions(HttpServletRequest req, HttpServletResponse resp)</code> -- OPTIONS 请求调用此方法</p></li>

                                <li class="group"><p><code>protected long 	getLastModified(HttpServletRequest req)</code> -- GET 和 HEAD 请求都会先调用此方法，在 Http 协议中，浏览器对访问过的页面缓存后，它将会在以后访问该页面时，将会根据 LastModified 头字段指定的时间值生成 If-Modified-Since 头字段，作为缓存页面的最新更新时间。如果网页的最后修改时间比 If-Modified-Since 头字段指定的时间早的话，web 服务器就会请求的页面，如果自 If-modified-Since 指定的时间以来，网页内容没有被修改的话，服务器就会返回一个 304 响应头，一次告诉浏览器继续使用已缓存的页面。</p>
                                    <p>由于在动态网页程序中，网页内容随时在变化，因此我们要保证在每次的访问请求中都要返回最新的内容。<b>注意：HttpServlet 类中的 getLastModified() 方法的返回值是一个负数。</b></p>
                                    <p>继承 HttpServlet 的 servlet 程序在接收到客户端的 GET 请求后，HttpServlet 的重载 service 方法会先调用 getLastModified() 方法，根据这个方法的返回值来决定是否要调用 doGet 方法和生成 Last-Modified 头字段。主要有以下三种决定方式：</p>
                                    <ol>
                                        <li><p>如果 getLastModified() 方法的返回值是一个负数的话，不管客户端的请求信息如何，service 方法都会调用 doGet 方法生成响应信息返回给客户端。</p></li>
                                        <li><p>如果 getLastModified() 方法的返回值是一个正数，并且客户端的请求消息中没有包含 If-Modified-Since 头字段的(这种情况是第一次访问该页面时)或者是请求消息中包含 If-Modified-Since 头字段，但是返回值比 If-Modified-Since 头字段指定的时间新的话，则 service 方法调用 doGet 方法生成响应信息和 Last-Modified 消息头返回给客户端。</p></li>
                                        <li><p>如果 getLastModified() 方法的返回值是一个正数，并且返回值比客户端发出的请求消息中 If-Modified-Since 头字段指定的时间值旧的话，那么 service 方法将不会调用 doGet 方法和生成 Last-Modified 头字段，而是返回一个 304 状态给客户端，表示让客户端继续使用以前缓存的页面。</p></li>
                                    </ol>
                                </li>


                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public abstract class GenericServlet implements Servlet, ServletConfig, Serializable {}

public interface Servlet {
    void init(ServletConfig config);
    void service(ServletRequest req, ServletResponse res);
    ServletConfig getServletConfig();
    String getServletInfo();
    void destroy();
}

public interface ServletConfig {
    String getInitParameter(String name);
    Enumeration&lt;String> getInitParameterNames();
    ServletContext getServletContext();
    String getServletName();
}
</pre>
                            <p><a href="docs/docs-javaee-8/javax/servlet/GenericServlet.html" target="_blank">GenericServlet</a> 定义了一个通用的、与协议无关的 servlet。若要在 Web 上使用 Servlet，请代之以扩展 HttpServlet。</p>
                            <ol>
                                <li><p><code>void 	init()</code> -- 在此方法中可以获取 ServletConfig 和 ServletContext 的数据，Servlet 初始化时回调(第一次有客户端访问此 Servlet 时)</p>
                                    <pre class="brush: java;">
@Override
public void init() throws ServletException {
    /** 配置在 web.xml 中(参见前面的 Servlet 在 web.xml 中的配置)，对应此 Servlet 的 ServletConfig 对象 */
    ServletConfig config = getServletConfig();
    String user = config.getInitParameter("user");

    /** 配置在 web.xml 中(参见前面的 Servlet 在 web.xml 中的配置)， 整个应用的的 ServletContext 对象 */
    ServletContext context = getServletContext();
    String phone = context.getInitParameter("phone");
    Log.d("=== init ===", user, phone);
}
</pre>
                                </li>
                                <li><p><code>void 	init(ServletConfig config)</code> -- 将此 config 存储到当前实例</p></li>
                                <li><p><code>abstract void 	service(ServletRequest req, ServletResponse res)</code> -- 参见 HttpServlet 的同名方法</p></li>

                                <li class="group"><p><code>ServletConfig 	getServletConfig()</code> -- 获取 init(ServletConfig) 传过来的 config 实例</p></li>
                                <li><p><code>String 	getInitParameter(String name)</code> -- 调用 config 实例的同名方法</p></li>
                                <li><p><code>Enumeration&lt;String> 	getInitParameterNames()</code> -- 调用 config 实例的同名方法</p></li>

                                <li class="group"><p><code>ServletContext 	getServletContext()</code> -- 获取应用共享的 ServletContext 实例</p></li>

                                <li class="group"><p><code>String 	getServletInfo()</code> -- 返回有关 Servlet 的信息，如作者、版本和版权。默认情况下，此方法返回空字符串</p></li>
                                <li><p><code>String 	getServletName()</code> -- 返回 Servlet 在 <code>web.xml</code> 中配置的别名</p></li>

                                <li class="group"><p><code>void 	log(String msg)</code> -- 将指定的消息写入 servlet 日志文件，调用 getServletContext() 的 log 方法</p></li>
                                <li><p><code>void 	log(String message, Throwable t)</code> -- 将指定的消息写入 servlet 日志文件，调用 getServletContext() 的 log 方法</p></li>

                                <li class="group"><p><code>void 	destroy()</code> -- 应用移除或者关闭回调</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <div class="split-item">
                                <pre class="brush: java;">
public interface HttpServletRequest extends ServletRequest {
    /** 用于保护 servlet 的身份验证方案的名称 */
    public static final String BASIC_AUTH = "BASIC";             // 基本验证
    public static final String FORM_AUTH = "FORM";               // 表单验证
    public static final String CLIENT_CERT_AUTH = "CLIENT_CERT"; // 客户端证书认证
    public static final String DIGEST_AUTH = "DIGEST";           // 摘要认证
}
</pre>
                                <p><a href="docs/docs-javaee-8/javax/servlet/http/HttpServletRequest.html" target="_blank">HttpServletRequest</a> 是客户端发送给服务器的请求报文。</p>
                                <p>该对象由服务器(如:Tomcat)创建，最终作为参数传递到 doGet 或 doPost 方法中，我们可以在这两个方法中直接使用。</p>
                                <p>可以将客户端请求转发，对客户端来说是透明的(比如浏览器地址不会改变)。</p>
                                <p>有一个实现类：<a href="docs/docs-javaee-8/javax/servlet/http/HttpServletRequestWrapper.html" target="_blank">HttpServletRequestWrapper</a></p>
                                <ol>
                                    <li><p><code>String 	getMethod()</code> -- 获取请求的方法(主要是在 service 方法中区分请求的方法)</p></li>

                                    <li class="group"><p><code>String 	getContextPath()</code> -- 获取应用路径(如: /site)</p></li>
                                    <li><p><code>String 	getServletPath()</code> -- 获取在 <code>web.xml</code> 配置的 Servlet 路径(如： /T)</p></li>
                                    <li><p><code>String 	getPathInfo()</code> -- 获取额外路径信息，一般返回 NULL</p></li>
                                    <li><p><code>String 	getPathTranslated()</code> -- 额外路径信息转化为实际路径，一般返回 NULL</p></li>
                                    <li><p><code>default HttpServletMapping 	getHttpServletMapping()</code> -- 获取 HttpServletMapping 对象，在 <code>web.xml</code> 中，有 <code>servlet-mapping</code> 标签配置</p></li>


                                    <li class="group"><p><code>Enumeration&lt;String> 	getHeaderNames()</code> -- 获取所有请求头的名字枚举列表</p></li>
                                    <li><p><code>String 	getHeader(String name)</code> -- 获取指定的请求头</p>
                                        <pre class="brush: java;">
Enumeration&lt;String> names = request.getHeaderNames();
while(names.hasMoreElements()) {
    String name = names.nextElement();
    System.out.println(name + ":" + request.getHeader(name));
}

/* 常见的 Http 头（可以自定义 Http 头）：
 * // 浏览器端可以接受的媒体类型
 * Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
 * // 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩
 * Accept-Encoding:gzip, deflate
 * // 浏览器申明自己接收的语言
 * Accept-Language:zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
 * // 是否使用已经建立的连接
 * Connection:keep-alive
 * // 必须，请求资源的 Internet 主机和端口号
 * Host:localhost:8080
 * // 客户端使用的操作系统和浏览器的名称和版本
 * User-Agent:Mozilla/5.0 (X11; Linux i686; rv:62.0) Gecko/20100101 Firefox/62.0
 * // 本地数据 Cookie
 * Cookie:JSESSIONID=31uuwk5cgyvanvrcxystclu; android_developer_api_level=24; ...
 */
</pre>
                                    </li>
                                    <li><p><code>Enumeration&lt;String> 	getHeaders(String name)</code> -- 客户端作为多个报头发送同一个名字，每个报头具有不同的值，而不是将报头作为逗号分隔列表发送</p></li>
                                    <li><p><code>int 	getIntHeader(String name)</code> -- 将获取的指定头转换为 int 类型</p></li>
                                    <li><p><code>long 	getDateHeader(String name)</code> -- 将获取的指定头转换为日期类型的 long 表示</p></li>

                                    <li class="group"><p><code>HttpSession 	getSession()</code> -- 获取 Session</p></li>
                                    <li><p><code>HttpSession 	getSession(boolean create)</code> -- 获取 Session, 如果为空则创建一个</p></li>
                                    <li><p><code>String 	getRequestedSessionId()</code> -- 返回客户端指定的会话 ID。这可能与此请求的当前有效会话的 ID 不相同</p></li>
                                    <li><p><code>String 	changeSessionId()</code> -- 更改 SessionId</p></li>
                                    <li><p><code>boolean 	isRequestedSessionIdFromCookie()</code> -- 检查所请求的会话 ID 是否作为 HTTP Cookie 传送到服务器(浏览器返回为 true, OkHttp 返回 false, 因为 OkHttp 默认并未存储 Cookie)</p></li>
                                    <li><p><code>boolean 	isRequestedSessionIdFromURL()</code> -- 检查请求的会话 ID 是否作为请求 URL 的一部分传送到服务器</p></li>
                                    <li><p><code>boolean 	isRequestedSessionIdValid()</code> -- 如果客户端没有指定任何会话 ID，则此方法返回 false</p></li>

                                    <li class="group"><p><code><a href="docs/docs-javaee-8/javax/servlet/http/Cookie.html" target="_blank">Cookie</a>[] 	getCookies()</code> -- 获取所有的 Cookie</p>
                                        <pre class="brush: java;">
Cookie[] cookies = request.getCookies();
if(null != cookies) {
    for (Cookie cookie : cookies) {
        Log.d(cookie.getDomain(), cookie.getName(), cookie.getValue());
    }
}
</pre>
                                    </li>

                                    <li class="group"><p><code>StringBuffer 	getRequestURL()</code> -- 获取 URL,括括完整的 URL，但不包括查询参数(如：http://localhost:8080/site/T)</p></li>
                                    <li><p><code>String 	getRequestURI()</code> -- 获取 URI，只包括应用到查询参数前的一部分(如：/site/T)</p></li>
                                    <li><p><code>String 	getQueryString()</code> -- 获取查询参数，问好后面的部分(如：x=value)</p></li>

                                    <li class="group"><p><code>Collection&lt;<a href="docs/docs-javaee-8/javax/servlet/http/Part.html" target="_blank">Part</a>> 	getParts()</code> -- 获取 POST 提交的表单数据(用于表单提交数据，比如上传二进制文件)</p></li>
                                    <li><p><code><a href="docs/docs-javaee-8/javax/servlet/http/Part.html" target="_blank">Part</a> 	getPart(String name)</code> -- 获取指定项</p></li>

                                    <li class="group"><p><code>boolean 	isUserInRole(String role)</code> -- </p></li>
                                    <li><p><code>String 	getRemoteUser()</code> -- </p></li>
                                    <li><p><code>Principal 	getUserPrincipal()</code> -- </p></li>

                                    <li class="group"><p><code>void 	login(String username, String password)</code> -- </p></li>
                                    <li><p><code>void 	logout()</code> -- </p></li>
                                    <li><p><code>boolean 	authenticate(HttpServletResponse response)</code> -- </p></li>

                                    <li class="group"><p><code>String 	getAuthType()</code> -- 返回用于保护 servlet 的身份验证方案的名称</p></li>
                                    <li><p><code>&lt;T extends HttpUpgradeHandler> upgrade(Class&lt;T> handlerClass)</code> -- </p></li>
                                </ol>
                            </div>

                            <div class="split-item">
                                <pre class="brush: java;">
public interface ServletRequest {}
</pre>
                                <p><a href="docs/docs-javaee-8/javax/servlet/ServletRequest.html" target="_blank">ServletRequest</a> 定义 servlet 提供客户端请求信息对象。</p>
                                <ol>
                                    <li><p><code>void 	setCharacterEncoding(String env)</code> -- 设置请求的字符编码</p></li>
                                    <li><p><code>String 	getCharacterEncoding()</code> -- 获取字符编码，如果未设置则返回 NULL</p></li>

                                    <li class="group"><p><code>String 	getLocalAddr()</code> -- 获取本机 IP 地址</p></li>
                                    <li><p><code>String 	getLocalName()</code> -- 获取本机主机名</p></li>
                                    <li><p><code>int 	getLocalPort()</code> -- 获取本机服务端口</p></li>

                                    <li class="group"><p><code>String 	getScheme()</code> -- 获取 Scheme(如：http 或者 https)</p></li>
                                    <li><p><code>String 	getProtocol()</code> -- 获取协议(如：HTTP/1.1)</p></li>

                                    <li class="group"><p><code>String 	getServerName()</code> -- 获取本机名(localhost， 域名或者 IP)</p></li>
                                    <li><p><code>int 	getServerPort()</code> -- 获取端口</p></li>

                                    <li class="group"><p><code>Locale 	getLocale()</code> -- 获取当前语言环境</p></li>
                                    <li><p><code>Enumeration&lt;Locale> 	getLocales()</code> -- 获取所有支持的语言环境</p></li>

                                    <li class="group"><p><code>String 	getRemoteAddr()</code> -- 获取请求的客户端地址</p></li>
                                    <li><p><code>String 	getRemoteHost()</code> -- 获取请求的客户端主机</p></li>
                                    <li><p><code>int 	getRemotePort()</code> -- 获取请求的客户端端口(此端口为客户端的随机端口)</p></li>

                                    <li class="group"><p><code>Enumeration&lt;String> 	getAttributeNames()</code> -- 获取所有的属性名列表</p></li>
                                    <li><p><code>void 	setAttribute(String name, Object o)</code> -- 设置一个属性(在转发的时候可以从之请求中获取)</p></li>
                                    <li><p><code>Object 	getAttribute(String name)</code> -- 获取一个属性</p></li>
                                    <li><p><code>void 	removeAttribute(String name)</code> -- 移除一个属性</p></li>

                                    <li class="group"><p><code>Enumeration&lt;String> 	getParameterNames()</code> -- 获取所有的参数名字列表</p></li>
                                    <li><p><code>String[] 	getParameterValues(String name)</code> -- 获取指定的参数值列表(Http 允许同一个参数名字有多个值)</p></li>
                                    <li><p><code>String 	getParameter(String name)</code> -- 获取一个指定的参数</p></li>
                                    <li><p><code>Map&lt;String,String[]> 	getParameterMap()</code> -- 将参数转换为 Map 的形式</p></li>

                                    <li class="group"><p><code>int 	getContentLength()</code> -- 获取请求内容长度(Post 上传文件)</p></li>
                                    <li><p><code>long 	getContentLengthLong()</code> -- 获取 long 值的请求内容长度(Post 上传文件)</p></li>
                                    <li><p><code>String 	getContentType()</code> -- 获取请求内容类型(Post 请求才有)</p></li>

                                    <li class="group"><p><code>ServletInputStream 	getInputStream()</code> -- 获取请求体的二进制流(Post 上传文件)</p></li>
                                    <li><p><code>BufferedReader 	getReader()</code> -- 获取请求体的字符流(Post 上传文件)</p></li>

                                    <li class="group"><p><code>DispatcherType 	getDispatcherType()</code> -- 获取此请求的调度器类型</p>
                                        <pre class="brush: java;">
public enum DispatcherType {
    FORWARD,
    INCLUDE,
    REQUEST,
    ASYNC,
    ERROR
}
</pre>
                                    </li>
                                    <li><p><code>RequestDispatcher 	getRequestDispatcher(String path)</code> -- 返回一个 RequestDispatcher 对象，该对象作为位于给定路径的资源的包装器，可用于向资源转发请求或在响应中包含资源</p></li>

                                    <li class="group"><p><code>ServletContext 	getServletContext()</code> -- 获取应用共享的 ServletContext 实例</p></li>

                                    <li class="group"><p><code>boolean 	isSecure()</code> -- 是否是 Https 链接</p></li>

                                    <li class="group"><p><code>boolean 	isAsyncSupported()</code> -- 检查此请求是否支持异步操作</p></li>
                                    <li><p><code><a href="docs/docs-javaee-8/javax/servlet/AsyncContext.html" target="_blank">AsyncContext</a> 	getAsyncContext()</code> -- 获取异步上下文对象</p></li>
                                    <li><p><code>boolean 	isAsyncStarted()</code> -- 检查此请求是否已进入异步模式</p></li>
                                    <li><p><code><a href="docs/docs-javaee-8/javax/servlet/AsyncContext.html" target="_blank">AsyncContext</a> 	startAsync()</code> -- 进入异步模式</p></li>
                                    <li><p><code>AsyncContext 	startAsync(ServletRequest servletRequest, ServletResponse servletResponse)</code> -- 进入异步模式</p></li>
                                </ol>
                            </div>
                        </div>

                        <div class="sub-item">
                            <div class="split-item">
                                <pre class="brush: java;">
public interface HttpServletResponse extends ServletResponse {
    public static final int SC_CONTINUE = 100;
    public static final int SC_SWITCHING_PROTOCOLS = 101;
    public static final int SC_OK = 200;
    public static final int SC_CREATED = 201;
    public static final int SC_ACCEPTED = 202;
    public static final int SC_NON_AUTHORITATIVE_INFORMATION = 203;
    public static final int SC_NO_CONTENT = 204;
    public static final int SC_RESET_CONTENT = 205;
    public static final int SC_PARTIAL_CONTENT = 206;
    public static final int SC_MULTIPLE_CHOICES = 300;
    public static final int SC_MOVED_PERMANENTLY = 301;
    public static final int SC_MOVED_TEMPORARILY = 302;
    public static final int SC_FOUND = 302;
    public static final int SC_SEE_OTHER = 303;
    public static final int SC_NOT_MODIFIED = 304;
    public static final int SC_USE_PROXY = 305;
    public static final int SC_TEMPORARY_REDIRECT = 307;
    public static final int SC_BAD_REQUEST = 400;
    public static final int SC_UNAUTHORIZED = 401;
    public static final int SC_PAYMENT_REQUIRED = 402;
    public static final int SC_FORBIDDEN = 403;
    public static final int SC_NOT_FOUND = 404;
    public static final int SC_METHOD_NOT_ALLOWED = 405;
    public static final int SC_NOT_ACCEPTABLE = 406;
    public static final int SC_PROXY_AUTHENTICATION_REQUIRED = 407;
    public static final int SC_REQUEST_TIMEOUT = 408;
    public static final int SC_CONFLICT = 409;
    public static final int SC_GONE = 410;
    public static final int SC_LENGTH_REQUIRED = 411;
    public static final int SC_PRECONDITION_FAILED = 412;
    public static final int SC_REQUEST_ENTITY_TOO_LARGE = 413;
    public static final int SC_REQUEST_URI_TOO_LONG = 414;
    public static final int SC_UNSUPPORTED_MEDIA_TYPE = 415;
    public static final int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
    public static final int SC_EXPECTATION_FAILED = 417;
    public static final int SC_INTERNAL_SERVER_ERROR = 500;
    public static final int SC_NOT_IMPLEMENTED = 501;
    public static final int SC_BAD_GATEWAY = 502;
    public static final int SC_SERVICE_UNAVAILABLE = 503;
    public static final int SC_GATEWAY_TIMEOUT = 504;
    public static final int SC_HTTP_VERSION_NOT_SUPPORTED = 505;
}
</pre>
                                <p><a href="docs/docs-javaee-8/javax/servlet/http/HttpServletResponse.html" target="_blank">HttpServletResponse</a> 服务器发送给客户端的响应报文。</p>
                                <ol>
                                    <li><p><code>int 	getStatus()</code> -- 获取状态码</p></li>
                                    <li><p><code>void 	setStatus(int sc)</code> -- 设置状态码</p></li>

                                    <li class="group"><p><code>void 	sendError(int sc)</code> -- 重定向到指定的错误码页面</p></li>
                                    <li><p><code>void 	sendError(int sc, String msg)</code> -- 重定向到指定的错误码页面</p></li>

                                    <li class="group"><p><code>void 	sendRedirect(String location)</code> -- 重定向</p></li>

                                    <li class="group"><p><code>Collection&lt;String> 	getHeaderNames()</code> -- 获取响应头名字列表</p></li>
                                    <li><p><code>Collection&lt;String> 	getHeaders(String name)</code> -- 获取指定响应头的值，可能有多个值</p></li>
                                    <li><p><code>boolean 	containsHeader(String name)</code> -- 是否包含指定的响应头</p></li>

                                    <li class="group"><p><code>void 	addHeader(String name, String value)</code> -- 添加响应头，允许重复</p></li>
                                    <li><p><code>void 	setHeader(String name, String value)</code> -- 修改响应头，不存在则添加</p></li>
                                    <li><p><code>String 	getHeader(String name)</code> -- 获取指定响应头的值</p></li>

                                    <li class="group"><p><code>void 	addDateHeader(String name, long date)</code> -- 添加日期类型的响应头</p></li>
                                    <li><p><code>void 	setDateHeader(String name, long date)</code> -- 修改日期类型的响应头</p></li>

                                    <li class="group"><p><code>void 	addIntHeader(String name, int value)</code> -- 添加 int 类型的响应头</p></li>
                                    <li><p><code>void 	setIntHeader(String name, int value)</code> -- 修改 int 类型的响应</p></li>

                                    <li class="group"><p><code>String 	encodeURL(String url)</code> -- 编码 URL</p></li>
                                    <li><p><code>String 	encodeRedirectURL(String url)</code> -- 编码重定向的 URL</p></li>

                                    <li class="group"><p><code>void 	addCookie(<a href="docs/docs-javaee-8/javax/servlet/http/Cookie.html" target="_blank">Cookie</a> cookie)</code> -- 添加 Cookie</p></li>

                                    <li class="group"><p><code>default Supplier&lt;Map&lt;String,String>> 	getTrailerFields()</code> -- 获取供应商头</p></li>
                                    <li><p><code>default void 	setTrailerFields(Supplier&lt;Map&lt;String,String>> supplier)</code> -- 设置供应商头</p></li>
                                </ol>
                                <p>该对象由服务器(如:Tomcat)创建，最终作为参数传递到 doGet 或 doPost 方法中，我们可以在这两个方法中直接使用。</p>
                                <p>可以将客户端请求重定向，客户端会知道被重定向了(比如浏览器地址会跳转)。</p>
                                <p>有一个实现类：<a href="docs/docs-javaee-8/javax/servlet/http/HttpServletResponseWrapper.html" target="_blank">HttpServletResponseWrapper</a></p>
                            </div>

                            <div class="split-item">
                                <pre class="brush: java;">
public interface ServletResponse {}
</pre>
                                <p><a href="docs/docs-javaee-8/javax/servlet/ServletResponse.html" target="_blank">ServletResponse</a> 定义一个对象，以帮助 Servlet 向客户端发送响应。</p>
                                <ol>
                                    <li><p><code>void 	setContentType(String type)</code> -- 设置响应的数据类型</p></li>
                                    <li><p><code>String 	getContentType()</code> -- 获取响应的数据类型</p>
                                        <pre class="brush: java;">
/** 常见的类型：
 * text/html -- HTML 类型
 * text/plain -- 纯文本类型
 * text/xml -- XML 类型
 * image/gif -- GIF 图片
 * image/jpeg -- JPG 图片
 * image/png -- PNG 图片

 * application/json -- JSON 串
 * application/xhtml+xml -- XHTML 文件
 * application/xml -- XML 类型
 * application/pdf -- PDF 类型
 * application/msword -- WORD 文件
 * application/octet-stream -- 二进制文件
 */
</pre>
                                    </li>

                                    <li class="group"><p><code>void 	setCharacterEncoding(String charset)</code> -- 设置响应编码</p></li>
                                    <li><p><code>String 	getCharacterEncoding()</code> -- 获取响应编码，默认为: ISO-8859-1</p></li>

                                    <li class="group"><p><code>void 	setContentLength(int len)</code> -- 设置响应体长度(如果长度不够，客户端一直等到读取到此长度；如果长度超出，超过的长度不会获取到)</p></li>
                                    <li><p><code>void 	setContentLengthLong(long len)</code> -- 设置响应体长度</p></li>

                                    <li class="group"><p><code>PrintWriter 	getWriter()</code> -- 获取字符流</p></li>
                                    <li><p><code>ServletOutputStream 	getOutputStream()</code> -- 获取字节流</p></li>

                                    <li class="group"><p><code>int 	getBufferSize()</code> -- 获取缓存大小</p></li>
                                    <li><p><code>void 	setBufferSize(int size)</code> -- 设置缓存大小</p></li>
                                    <li><p><code>void 	flushBuffer()</code> -- 强制将缓冲区中的任何内容写入客户端。对该方法的调用自动提交响应，将写入状态代码和标头</p></li>
                                    <li><p><code>void 	resetBuffer()</code> -- 重置缓存区</p></li>

                                    <li class="group"><p><code>void 	setLocale(Locale loc)</code> -- 设置语言环境</p></li>
                                    <li><p><code>Locale 	getLocale()</code> -- 获取语言环境</p></li>

                                    <li class="group"><p><code>boolean 	isCommitted()</code> -- 是否已提交，比如关闭流或者调用了: <code>flushBuer</code> 后就为 true</p></li>
                                    <li><p><code>void 	reset()</code> -- 重置响应</p></li>
                                </ol>
                            </div>
                        </div>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-servlet-http-HttpSession"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">HttpSession 及相关类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface HttpSession {}
</pre>
                            <p><a href="docs/docs-javaee-8/javax/servlet/http/HttpSession.html" target="_blank">HttpSession</a> 是在服务器端保持 HTTP 状态信息的方案 。</p>
                            <p><b>SessonId 默认以 Cookie 的形式保存在客户端，如果客户端禁用了 Cookie, 那么 Session 也会失效。</b></p>
                            <p>当程序需要为某个客户端的请求创建一个 session 时，服务器首先检查这个客户端的请求里是否包含了一个 session 标识(即 sessionId),如果已经包含一个 sessionId 则说明以前已经为此客户创建过 session，服务器就按照 sessionId 把这个 session 检索出来使用(如果检索不到，可能会新建一个，这种情况可能出现在服务端已经删除了该用户对应的 session 对象，但用户人为地在请求的 URL 后面附加上一个 JSESSION 的参数)。如果客户请求不包含 sessionId，则为此客户创建一个 session 并且生成一个与此 session 相关联的 sessionId，这个 sessionId 将在本次响应中返回给客户端保存。</p>
                            <ol>
                                <li><p><code>String 	getId()</code> -- 获取 sessionId</p></li>

                                <li class="group"><p><code>Enumeration&lt;String> 	getAttributeNames()</code> -- 获取所有属性名称列表</p></li>
                                <li><p><code>void 	setAttribute(String name, Object value)</code> -- 保存或修改一个属性值</p></li>
                                <li><p><code>Object 	getAttribute(String name)</code> -- 获取指定属性值</p></li>
                                <li><p><code>void 	removeAttribute(String name)</code> -- 移除指定属性值</p></li>

                                <li class="group"><p><code>boolean 	isNew()</code> -- 是否新创建的</p></li>
                                <li><p><code>long 	getCreationTime()</code> -- 获取其创建的时间</p></li>
                                <li><p><code>long 	getLastAccessedTime()</code> -- 获取最后一次访问的时间</p></li>

                                <li class="group"><p><code>void 	setMaxInactiveInterval(int interval)</code> -- 设置 Session 的有效时间(单位为秒，可在 <code>web.xml</code> 中通过 <code>&lt;session-config></code> 的 <code>&lt;session-timeout></code>全局配置，单位为分钟)</p></li>
                                <li><p><code>int 	getMaxInactiveInterval()</code> -- 获取 Session 的有效时间(最后一次访问为准，单位为秒)</p></li>

                                <li class="group"><p><code>void 	invalidate()</code> -- 使会话失效，释放其资源</p></li>

                                <li class="group"><p><code>ServletContext 	getServletContext()</code> -- 获取 ServletContext 对象</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-websocket-server"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">WebSocket Server API</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <p><b>WebSocket 要求: HTML5 + Tomcat7.0.47 以上</b></p>
                            <p>随着互联网的发展，传统的 HTTP 协议已经很难满足 Web 应用日益复杂的需求了。近年来，随着 HTML5 的诞生，WebSocket 协议被提出，它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据。</p>
                            <p>传统的 HTTP 协议是无状态的，每次请求（request）都要由客户端（如 浏览器）主动发起，服务端进行处理后返回 response 结果，而服务端很难主动向客户端发送数据；这种客户端是主动方，服务端是被动方的传统 Web 模式 对于信息变化不频繁的 Web 应用来说造成的麻烦较小，而对于涉及实时信息的 Web 应用却带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应 用。在 WebSocket 规范提出之前，开发人员若要实现这些实时性较强的功能，经常会使用折衷的解决方法：轮询（polling）和 Comet 技术。其实后者本质上也是一种轮询，只不过有所改进。</p>
                            <p><b>轮询</b>是最原始的实现实时 Web 应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。明显地，这种方法会导致过多不必要的请求，浪费流量和服务器资源。</p>
                            <p><b>Comet</b> 技术又可以分为长轮询和流技术。长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个 HTTP 长连接，服务端会不断更新连接状态以保持 HTTP 长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。</p>
                            <p>伴随着 HTML5 推出的 WebSocket，真正实现了 Web 的实时通信，使 B/S 模式具备了 C/S 模式的实时通信能力。WebSocket 的工作流程是这 样的：浏览器通过 JavaScript 向服务端发出建立 WebSocket 连接的请求，在 WebSocket 连接建立成功后，客户端和服务端就可以通过 TCP 连接传输数据。因为 WebSocket 连接本质上是 TCP 连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和 Comet 技术少了很多。</p>
                            <p>JavaEE 7 中出了 JSR-356:Java API for WebSocket 规范。不少 Web 容器，如 Tomcat, Nginx, Jetty 等都支持 WebSocket。Tomcat 从 7.0.27 开始支持 WebSocket，从 7.0.47 开始支持 JSR-356。</p>
                        </div>

                        <div class="sub-item">
                            <p>JavaEE 的 WebSocket 服务端 API 主要有以下注解类型：</p>
                            <ul>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/server/ServerEndpoint.html" target="_blank">ServerEndpoint</a> -- 将目前的类定义成一个 WebSocket 服务器端, 注解的值将被用于监听用户连接的终端访问 URL 地址,客户端可以通过这个 URL 来连接到 WebSocket 服务器端。</p>
                                    <pre class="brush: java;">
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface ServerEndpoint {
    public String value();
    public String[] subprotocols() default {};
    public Class&lt;? extends Decoder>[] decoders() default {};
    public Class&lt;? extends Encoder>[] encoders() default {};
    public Class&lt;? extends ServerEndpointConfig.Configurator> configurator() default
                     ServerEndpointConfig.Configurator.class;
}
</pre>
                                </li>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/OnOpen.html" target="_blank">OnOpen</a> -- WebSocket 连接建立成功调用的方法，参数是可选的</p>
                                    <pre class="brush: java;">
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface OnOpen {}

/** 实例，参数都是可选的，其中最后一个参数 PathParam 可以有多个
 * Session -- 与某个客户端的连接会话，需要通过它来给客户端发送数据
 * EndpointConfig -- 端点配置包含在该端点的握手过程中需要的所有信息
 * @PathParam -- 是 ServerEndpoint 的 value 中的变量，可以有多个，如: @ServerEndpoint("/websocket/{item}")
 */
@OnOpen
public void onOpen(Session session, EndpointConfig config, @PathParam("item") String item) {
    ...
}
</pre>
                                </li>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/OnClose.html" target="_blank">OnClose</a> -- WebSocket 连接关闭调用的方法，参数是可选的</p>
                                    <pre class="brush: java;">
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface OnClose {}

/** 实例，参数都是可选的，其中最后一个参数 PathParam 可以有多个
 * Session -- 与某个客户端的连接会话，可以知道哪个会话被关掉了
 * CloseReason -- 关闭原因
 * @PathParam -- 是 ServerEndpoint 的 value 中的变量，可以有多个，如: @ServerEndpoint("/websocket/{item}")
 */
@OnClose
public void onClose(Session session, CloseReason reason, @PathParam("item") String item) {
    ...
}
</pre>
                                </li>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/OnMessage.html" target="_blank">OnMessage</a> -- 收到客户端消息后调用的方法，允许的参数类型如下表:</p>
                                    <ul>
                                        <li><p><b>Session</b> -- 与客户端的会话</p></li>
                                        <li><p><b>@PathParam</b> -- 是 ServerEndpoint 的 value 中的变量，可以有多个</p></li>
                                        <li><p><b>以下的任何一个选择：</b></p>
                                            <ul>
                                                <li><p>如果该方法处理文本消息:</p>
                                                    <ul><li><p>String</p></li></ul>
                                                    <ul><li><p>Java 基本类型及实体类</p></li></ul>
                                                    <ul><li><p>String 和 boolean 组成的对(接受分段的消息)</p></li></ul>
                                                    <ul><li><p>Reader</p></li></ul>
                                                </li>
                                                <li><p>如果该方法处理二进制消息:</p>
                                                    <ul><li><p>byte[] 或者 ByteBuffer</p></li></ul>
                                                    <ul><li><p>byte[] 和 boolean 组成的对 或者 ByteBuffer和 boolean 组成的对(接受分段的消息)</p></li></ul>
                                                    <ul><li><p>InputStream</p></li></ul>
                                                </li>
                                                <li><p>如果该方法处理 PONG 消息:</p>
                                                    <ul><li><p>PongMessage</p></li></ul>
                                                </li>
                                            </ul>
                                        </li>

                                    </ul>
                                    <pre class="brush: java;">
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface OnMessage {
    public long maxMessageSize() default -1;
}
</pre>
                                </li>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/OnError.html" target="_blank">OnError</a> -- 发生错误时调用的方法，参数也是可选的</p>
                                    <pre class="brush: java;">
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface OnError {}

/** 实例，参数都是可选的，其中最后一个参数 PathParam 可以有多个
 * Session -- 与某个客户端的连接会话，可以知道哪个会话发生错误
 * Throwable -- 错误类型
 * @PathParam -- 是 ServerEndpoint 的 value 中的变量，可以有多个，如: @ServerEndpoint("/websocket/{item}")
 */
@OnError
public void OnError(Session session, Throwable throwable, @PathParam("item") String item) {
    ...
}
</pre>
                                </li>
                            </ul>

                        </div>

                        <div class="sub-item">
                            <p><b>WebSocket Server 的相关类：</b></p>
                            <ul>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/server/PathParam.html" target="_blank">@PathParam</a> -- 用于方法的参数，表示 @ServerEndpoint 的参数</p>
                                    <pre class="brush: java;">
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.PARAMETER)
public @interface PathParam {
    public String value();
}

/** 实例，可以根据参数创建不同的 WebSocket 连接 */
@ServerEndpoint("/websocket/{item}")
public class CustomWebsocket {
    @OnOpen
    public void onOpen(Session session, EndpointConfig config, @PathParam("item") String item) {
        ...
    }
}
</pre>
                                </li>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/EndpointConfig.html" target="_blank">EndpointConfig</a> -- </p>
                                    <pre class="brush: java;">

</pre>
                                </li>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/CloseReason.html" target="_blank">CloseReason</a> -- </p>
                                    <pre class="brush: java;">

</pre>
                                </li>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/Session.html" target="_blank">Session</a> -- 是 WebSocket 连接的会话，需要通过它来给客户端发送数据</p>
                                    <pre class="brush: java;">
public interface Session extends Closeable {}

public interface Closeable extends java.io.AutoCloseable {
    public void close() throws IOException;
}

public interface java.lang.AutoCloseable {
    void close() throws Exception;
}
</pre>
                                    <ol>
                                        <li><p><code>String 	getId()</code> -- 获取会话 ID</p></li>

                                        <li class="group"><p><code>long 	getMaxIdleTimeout()</code> -- 获取超时时间(测试默认为 5 分钟)</p></li>
                                        <li><p><code>void 	setMaxIdleTimeout(long milliseconds)</code> -- 设置超时时间（单位为毫秒）</p></li>

                                        <li class="group"><p><code>RemoteEndpoint.Basic 	getBasicRemote()</code> -- </p></li>
                                        <li><p><code>RemoteEndpoint.Async 	getAsyncRemote()</code> -- </p></li>

                                        <li class="group"><p><code>Set&lt;MessageHandler> 	getMessageHandlers()</code> -- </p></li>
                                        <li><p><code>&lt;T> void 	addMessageHandler(Class&lt;T> clazz, MessageHandler.Partial&lt;T> handler)</code> -- </p></li>
                                        <li><p><code>&lt;T> void 	addMessageHandler(Class&lt;T> clazz, MessageHandler.Whole&lt;T> handler)</code> -- </p></li>
                                        <li><p><code>void 	addMessageHandler(MessageHandler handler)</code> -- </p></li>
                                        <li><p><code>void 	removeMessageHandler(MessageHandler handler)</code> -- </p></li>

                                        <li class="group"><p><code>void 	close()</code> -- </p></li>
                                        <li><p><code>void 	close(CloseReason closeReason)</code> -- </p></li>

                                        <li class="group"><p><code>void 	setMaxBinaryMessageBufferSize(int length)</code> -- </p></li>
                                        <li><p><code>int 	getMaxBinaryMessageBufferSize()</code> -- </p></li>

                                        <li class="group"><p><code>void 	setMaxTextMessageBufferSize(int length)</code> -- </p></li>
                                        <li><p><code>int 	getMaxTextMessageBufferSize()</code> -- </p></li>



                                        <li class="group"><p><code>Set&lt;Session> 	getOpenSessions()</code> -- </p></li>
                                        <li><p><code>boolean 	isOpen()</code> -- </p></li>

                                        <li class="group"><p><code>Map&lt;String,String> 	getPathParameters()</code> -- </p></li>
                                        <li><p><code>Map&lt;String,List&lt;String>> 	getRequestParameterMap()</code> -- </p></li>
                                        <li><p><code>URI 	getRequestURI()</code> -- </p></li>

                                        <li class="group"><p><code>List&lt;Extension> 	getNegotiatedExtensions()</code> -- </p></li>
                                        <li><p><code>Map&lt;String,Object> 	getUserProperties()</code> -- </p></li>

                                        <li class="group"><p><code>boolean 	isSecure()</code> -- </p></li>
                                        <li><p><code>String 	getNegotiatedSubprotocol()</code> -- </p></li>
                                        <li><p><code>String 	getProtocolVersion()</code> -- </p></li>
                                        <li><p><code>String 	getQueryString()</code> -- </p></li>
                                        <li><p><code>Principal 	getUserPrincipal()</code> -- </p></li>
                                        <li><p><code>WebSocketContainer 	getContainer()</code> -- </p></li>


                                    </ol>
                                </li>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/RemoteEndpoint.html" target="_blank">RemoteEndpoint</a> -- 是远程端点(客户端)</p>
                                    <pre class="brush: java;">
public interface RemoteEndpoint {
    void setBatchingAllowed(boolean allowed) throws IOException;
    boolean getBatchingAllowed();
    void flushBatch() throws IOException;
    void sendPing(ByteBuffer applicationData) throws IOException, IllegalArgumentException;
    void sendPong(ByteBuffer applicationData) throws IOException, IllegalArgumentException;

    interface Async extends RemoteEndpoint {
        long getSendTimeout();
        void setSendTimeout(long timeoutmillis);

        void sendText(String text, SendHandler handler);
        Future&lt;Void> sendText(String text);
        Future&lt;Void> sendBinary(ByteBuffer data);
        void sendBinary(ByteBuffer data, SendHandler handler);
        Future&lt;Void> sendObject(Object data);
        void sendObject(Object data, SendHandler handler);
    }

    interface Basic extends RemoteEndpoint {
        void sendText(String text) throws IOException;
        void sendText(String partialMessage, boolean isLast) throws IOException;
        void sendBinary(ByteBuffer data) throws IOException;
        void sendBinary(ByteBuffer partialByte, boolean isLast) throws IOException;
        void sendObject(Object data) throws IOException, EncodeException;

        OutputStream getSendStream() throws IOException;
        Writer getSendWriter() throws IOException;
    }
}
</pre>
                                </li>
                                <li><p><a href="docs/docs-javaee-8/javax/websocket/" target="_blank"></a> -- </p>
                                    <pre class="brush: java;">

</pre>
                                </li>
                            </ul>
                        </div>

                        <div class="sub-item">
                            <p><b>WebSocket 实例：</b></p>
                            <div class="split-item">
                                <p>Server 端:</p>
                                <ol>
                                    <li><p>构建 WebSocket 服务端</p>
                                        <pre class="brush: java;">
/**
 * @ServerEndpoint 注解将目前的类定义成一个 websocket 服务器端,
 * 注解的值将被用于监听用户连接的终端访问 URL 地址,客户端可以通过这个 URL 来连接到 WebSocket 服务器端
 */
@ServerEndpoint(value = "/websocket/{item}", configurator = GetHttpSessionConfigurator.class)
public class CustomWebsocket {

    // 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。
    private static int onlineCount = 0;

    // 线程安全 Set，用来存放每个客户端对应的 CustomWebsocket 对象
    private static CopyOnWriteArraySet&lt;CustomWebsocket> webSocketSet = new CopyOnWriteArraySet<>();

    // 与某个客户端的连接会话，需要通过它来给客户端发送数据
    private Session session;
    //
    private HttpSession httpSession;

    /** 连接建立成功调用的方法, session 为与某个客户端的连接会话，需要通过它来给客户端发送数据 */
    @OnOpen
    public void onOpen(Session session, EndpointConfig config) {
        this.session = session;
        httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class.getName());

        webSocketSet.add(this);     // 加入 set 中
        onlineCount++;              // 在线数加 1
        System.out.println("有新连接加入:" + httpSession.getId() + ", 当前在线人数为" + onlineCount);
    }

    /**
     * 连接关闭调用的方法
     */
    @OnClose
    public void onClose(Session session, CloseReason reason, @PathParam("item") String item) {
        webSocketSet.remove(this);  //从 set 中删除
        onlineCount--;           // 在线数减 1
        System.out.println("有一连接关闭！当前在线人数为" + onlineCount);
    }

    /** 收到客户端消息后调用的方法，此处的参数参见 @OnMessage 注解 */
    @OnMessage
    public void onMessage(String message) {
        System.out.println("来自客户端的消息:" + message);
        // 群发消息
        for (CustomWebsocket item : webSocketSet) {
            try {
                item.sendMessage(message);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /** 发生错误时调用 */
    @OnError
    public void onError(Session session, Throwable error) {
        System.out.println("发生错误");
        error.printStackTrace();
    }

    /** 发送消息 */
    public void sendMessage(String message) throws IOException {
        this.session.getBasicRemote().sendText(message);
    }

}
</pre>
                                    </li>
                                    <li><p>获取 HttpSession, 并添加到 ServerEndpointConfig 中(要在 Listener 中获取，否则这一步还为空)</p>
                                        <pre class="brush: java;">
public class GetHttpSessionConfigurator extends ServerEndpointConfig.Configurator {
    @Override
    public void modifyHandshake(ServerEndpointConfig config, HandshakeRequest request,
                                            HandshakeResponse response) {
        HttpSession httpSession = (HttpSession) request.getHttpSession();
        config.getUserProperties().put(HttpSession.class.getName(), httpSession);
    }
}
</pre>
                                    </li>
                                    <li><p>请求监听器，并获取到 HttpSession</p>
                                        <pre class="brush: java;">
/** 在 web.xml 配置 Listener
 * &lt;listener>
 *   &lt;listener-class>io.jiwanger.site.listener.RequestListener&lt;/listener-class>
 * &lt;/listener>
 */

@WebListener()
public class RequestListener implements ServletRequestListener {
    public RequestListener() {}

    @Override
    public void requestDestroyed(ServletRequestEvent sre) {}

    @Override
    public void requestInitialized(ServletRequestEvent sre) {
        // 经过此步骤，才能在 WebSocket 中获取到 HttpSession
        ((HttpServletRequest) sre.getServletRequest()).getSession();
    }
}
</pre>
                                    </li>
                                </ol>
                            </div>
                            <div class="split-item">
                                <p>WebSocket Client 端(HTML 5 支持)</p>
                                <pre class="brush: js;">
var url = "ws://192.168.0.104:8080/site/websocket/shop";

var websocket = null;
// 判断当前浏览器是否支持 WebSocket
if ('WebSocket' in window) {
    websocket = new WebSocket(url);
} else {
    alert('当前浏览器不支持 WebSocket!')
}

// 连接发生错误的回调方法
websocket.onerror = function () {
    // 将连接发生错误显示在页面上，此方法在页面中定义
    setMessageInnerHTML("WebSocket 连接发生错误!");
};

// 连接成功建立的回调方法
websocket.onopen = function () {
    // 将连接成功显示在页面上，此方法在页面中定义
    setMessageInnerHTML("WebSocket 连接成功!");
};

// 接收到消息的回调方法
websocket.onmessage = function (event) {
    // 将接收的消息显示在页面上，此方法在页面中定义
    setMessageInnerHTML(event.data);
};

// 连接关闭的回调方法
websocket.onclose = function () {
    setMessageInnerHTML("WebSocket 连接关闭!");
};

// 监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
window.onbeforeunload = function () {
    closeWebSocket();
};

// 关闭WebSocket连接
function closeWebSocket() {
    websocket.close();
}

// 发送消息
function send(message) {
    websocket.send(message);
}
</pre>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javax-websocket-client"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">WebSocket Client API</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-javaee-8/javax/ejb/" target="_blank"></a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="javax-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">...</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
                            <pre class="brush: java;">

</pre>
							<p><a href="docs/docs-javaee-8/javax/" target="_blank"></a></p>
						</div>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="javaee-jstl"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">JSTL -- Java 标准标签库</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-javaee-8/javax/" target="_blank"></a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javaee-el"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">EL 表达式</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-javaee-8/javax/" target="_blank"></a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="javaee-ongl"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">ONGL -- 对象图导航语言</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">

</pre>
                            <p><a href="docs/docs-javaee-8/javax/" target="_blank"></a></p>
                        </div>
                    </div>
                </div>
                <!-- item over -->


			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button" class="btn btn-default dropdown-toggle dropup"
			data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button" class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup">
			TOP
		</a>
		<a target="_blank" href="./docs/docs-java/api-zh/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-6 </a>
		<a target="_blank" href="./docs/docs-java/api/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-8 </a>
        <a target="_blank" href="./docs/docs-javaee-8/index.html"
           type="button" class="btn btn-default dropdown-toggle btn-primary"
           data-toggle="dropup"> JavaEE-8 </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
    <script src="../support/syntaxhighlighter/scripts/shBrushXml.js"></script>
    <script src="../support/syntaxhighlighter/scripts/shBrushJScript.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
