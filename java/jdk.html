<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--JDK</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1" >
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->

	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">JDK</h3>
					</div>
					<div class="list-group">
						<a href="#jdk-intro" class="list-group-item">简介</a>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#java-lang" aria-expanded="true">
							<code>java.lang</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-lang" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#java-lang-Object" class="list-group-item">Object</a>
							<a href="#java-lang-Class" class="list-group-item">Class 及相关类</a>
                            <a href="#java-lang-ClassLoader" class="list-group-item">ClassLoader</a>
                            <a href="#java-lang-Enum" class="list-group-item">Enum</a>
							<a href="#java-lang-Package" class="list-group-item">Package</a>
							<a href="#java-lang-System" class="list-group-item">System</a>
							<a href="#java-lang-Runtime" class="list-group-item">Runtime / Process</a>
                            <a href="#java-lang-Thread" class="list-group-item">Thread 与 ThreadGroup</a>
                            <a href="#java-lang-String" class="list-group-item">String 及相关类</a>
                            <a href="#java-lang-Math" class="list-group-item">Math 及 RoundingMode</a>
                            <a href="#java-lang-Number" class="list-group-item">Number 及子类</a>
                            <a href="#java-lang-Exception" class="list-group-item">Exception 和 Error</a>
                            <a href="#java-lang-ref-Reference" class="list-group-item">ref.Reference 及子类</a>
						</div>

                        <a class="list-group-item active drop" data-toggle="collapse"
                           data-parent="#accordion" href="#java-lang-annotation" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
                            <code>java.lang.annotation</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="java-lang-annotation" class="panel-collapse collapse"
                             role="tabpanel">
                            <a href="#java-lang-annotation-Annotation" class="list-group-item">Annotation 及元注解</a>
                            <a href="#java-lang-annotation-MyAnnotation" class="list-group-item">自定义运行时注解使用实例</a>
                            <a href="#java-lang-annotation-Compile-Annotation" class="list-group-item">编译时注解和源码注解</a>
                        </div>

                        <a class="list-group-item active drop" data-toggle="collapse"
                           data-parent="#accordion" href="#java-lang-reflect" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
                            <code>java.lang.reflect</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="java-lang-reflect" class="panel-collapse collapse"
                             role="tabpanel">
                            <a href="#java-lang-reflect-base" class="list-group-item">反射类的基础接口</a>
                            <a href="#java-lang-reflect-AccessibleObject" class="list-group-item">AccessibleObject</a>
                            <a href="#java-lang-reflect-Executable" class="list-group-item">Executable</a>
                            <a href="#java-lang-reflect-Constructor" class="list-group-item">Constructor</a>
                            <a href="#java-lang-reflect-Field" class="list-group-item">Field</a>
                            <a href="#java-lang-reflect-Method" class="list-group-item">Method</a>
                            <a href="#java-lang-reflect-Modifier" class="list-group-item">Modifier</a>
                            <a href="#java-lang-reflect-Parameter" class="list-group-item">Parameter</a>
                            <a href="#java-lang-reflect-Array" class="list-group-item">Array</a>
                            <a href="#java-lang-reflect-Proxy" class="list-group-item">InvocationHandler 和 Proxy</a>
                            <a href="#java-lang-reflect-ReflectPermission" class="list-group-item">ReflectPermission</a>
                        </div>

						<a class="list-group-item active drop" data-toggle="collapse"
						   data-parent="#accordion" href="#java-util" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							<code>java.util</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-util" class="panel-collapse collapse"
							 role="tabpanel">
							<a href="#java-util-Base64" class="list-group-item">Base64</a>
							<a href="#java-util-Date" class="list-group-item">Date, TimeZone, Calendar</a>
                            <a href="#java-util-Timer" class="list-group-item">Timer 和 TimerTask</a>
                            <a href="#java-util-List" class="list-group-item">List, Map, Set, Queue...</a>
                            <a href="#java-util-function" class="list-group-item"><code>.function</code> 包</a>
                            <a href="#java-util-stream" class="list-group-item"><code>.stream</code> 包</a>
                            <a href="#java-util-Random" class="list-group-item">Random 子类及 SplittableRandom</a>
                            <a href="#java-util-Optional" class="list-group-item">Optional 和 Objects</a>
							<a href="#java-util-concurrent-atomic" class="list-group-item"><code>.concurrent.atomic</code> 包</a>
							<a href="#java-util-concurrent-locks" class="list-group-item"><code>.concurrent.locks</code> 包</a>
                            <a href="#java-util-Formatter" class="list-group-item">Formatter, Formattable</a>
                            <a href="#java-util-Observable" class="list-group-item">Observer, Observable</a>
                            <a href="#java-util-UUID" class="list-group-item">UUID</a>
							<a href="#java-util-Scanner" class="list-group-item">Scanner</a>
							<a href="#java-util-concurrent-Executor" class="list-group-item">Executor 及实现类</a>
							<a href="#java-util-concurrent-Future" class="list-group-item">Future 及实现类</a>
						</div>

						<a class="list-group-item active drop" data-toggle="collapse"
						   data-parent="#accordion" href="#java-io" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							<code>java.io</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-io" class="panel-collapse collapse"
							 role="tabpanel">
							<a href="#java-io-InputStream" class="list-group-item">InputStream & OutputStream</a>
							<a href="#java-io-Reader" class="list-group-item">Reader & Writer</a>
							<a href="#java-io-File" class="list-group-item">File & RandomAccessFile</a>
							<a href="#java-io-Console" class="list-group-item">Console</a>
						</div>
						<a class="list-group-item active drop" data-toggle="collapse"
						   data-parent="#accordion" href="#java-nio" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							<code>java.nio</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-nio" class="panel-collapse collapse" role="tabpanel">
							<a href="#java-nio-intro" class="list-group-item">NIO 简介</a>
							<a href="#java-nio-Buffer" class="list-group-item">Buffer 及子类</a>
							<a href="#java-nio-channels-Channel" class="list-group-item">Channel 及实现类</a>
							<a href="#java-nio-channels-Selector" class="list-group-item">Selector 及相关类</a>
							<a href="#java-nio-charset-Charset" class="list-group-item">Charset 及相关类</a>
							<a href="#java-nio-file-Files" class="list-group-item">Path / Files 及相关类</a>
						</div>

						<a class="list-group-item active drop" data-toggle="collapse"
						   data-parent="#accordion" href="#java-net" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							<code>java.net</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-net" class="panel-collapse collapse"
							 role="tabpanel">
							<a href="#java-net-URI" class="list-group-item">URI 和 URL</a>
							<a href="#java-net-URLConnection" class="list-group-item">URLConnection 及子类</a>
							<a href="#java-net-URLEncoder" class="list-group-item">URLEncoder 和 URLDecoder</a>
						</div>

                        <a class="list-group-item active drop" data-toggle="collapse"
                           data-parent="#accordion" href="#java-sql" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
                            <code>java.sql</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="java-sql" class="panel-collapse collapse"
                             role="tabpanel">
                            <a href="#java-sql-DriverManager" class="list-group-item">DriverManager</a>
							<a href="#java-sql-Connection" class="list-group-item">Connection</a>
                            <a href="#java-sql-DatabaseMetaData" class="list-group-item">DatabaseMetaData</a>
                            <a href="#java-sql-Types" class="list-group-item">Types 及内置类型</a>
                            <a href="#java-sql-Statement" class="list-group-item">Statement 及子接口</a>
							<a href="#java-sql-ResultSet" class="list-group-item">ResultSet 及子接口</a>
                            <a href="#java-sql-" class="list-group-item">...</a>
                        </div>

                        <a class="list-group-item active drop" data-toggle="collapse"
                           data-parent="#accordion" href="#java-beans" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
                            <code>java.beans</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="java-beans" class="panel-collapse collapse"
                             role="tabpanel">
                            <a href="#java-beans-Beans" class="list-group-item">Beans</a>
                            <a href="#java-beans-Encoder" class="list-group-item">Encoder 及相关类</a>
                            <a href="#java-beans-FeatureDescriptor" class="list-group-item">FeatureDescriptor 及子类</a>

                            <a href="#java-beans-" class="list-group-item"></a>
                        </div>

                        <a class="list-group-item active drop" data-toggle="collapse"
                           data-parent="#accordion" href="#java-text" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
                            <code>java.text</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="java-text" class="panel-collapse collapse"
                             role="tabpanel">
                            <a href="#java-text-Format" class="list-group-item">Format 及子类</a>
                            <a href="#java-text-CharacterIterator" class="list-group-item">CharacterIterator 及实现类</a>
							<a href="#java-text-" class="list-group-item">...</a>
                        </div>

                        <a class="list-group-item active drop" data-toggle="collapse"
                           data-parent="#accordion" href="#java-xxx" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
                            <code>java...</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="java-xxx" class="panel-collapse collapse"
                             role="tabpanel">
                            <a href="#java-" class="list-group-item"></a>
                        </div>

						<a href="#java-" class="list-group-item">...</a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<a class="offset" id="jdk-intro"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<p>JDK 是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的 java 应用程序。JDK 是整个
							java 开发的核心，它包含了 JAVA 的运行环境（JVM + Java 系统类库）和 JAVA 工具。</p>
						<p>
							<b>以下是各版本的名称及发布日期：</b>
						</p>
						<table class="table table-bordered table-responsive">
							<tbody>
								<tr>
									<td><div>版本</div></td>
									<td><div>名称</div></td>
									<td><div>发行日期</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.4</div></td>
									<td><div>Sparkler（宝石）</div></td>
									<td><div>1997-09-12</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.5</div></td>
									<td><div>Pumpkin（南瓜）</div></td>
									<td><div>1997-12-13</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.6</div></td>
									<td><div>Abigail（阿比盖尔–女子名）</div></td>
									<td><div>1998-04-24</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.7</div></td>
									<td><div>Brutus（布鲁图–古罗马政治家和将军）</div></td>
									<td><div>1998-09-28</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.8</div></td>
									<td><div>Chelsea（切尔西–城市名）</div></td>
									<td><div>1999-04-08</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.2</div></td>
									<td><div>Playground（运动场）</div></td>
									<td><div>1998-12-04</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.2.1</div></td>
									<td><div>none（无）</div></td>
									<td><div>1999-03-30</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.2.2</div></td>
									<td><div>Cricket（蟋蟀）</div></td>
									<td><div>1999-07-08</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.3</div></td>
									<td><div>Kestrel（美洲红隼）</div></td>
									<td><div>2000-05-08</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.3.1</div></td>
									<td><div>Ladybird（瓢虫）</div></td>
									<td><div>2001-05-17</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.4.0</div></td>
									<td><div>Merlin（灰背隼）</div></td>
									<td><div>2002-02-13</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.4.1</div></td>
									<td><div>grasshopper（蚱蜢）</div></td>
									<td><div>2002-09-16</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.4.2</div></td>
									<td><div>Mantis（螳螂）</div></td>
									<td><div>2003-06-26</div></td>
								</tr>
								<tr>
									<td><div>Java SE 5.0 (1.5.0)</div></td>
									<td><div>Tiger（老虎）</div></td>
									<td><div>2004-09-30</div></td>
								</tr>
								<tr>
									<td><div>Java SE 6.0 (1.6.0)</div></td>
									<td><div>Mustang（野马）</div></td>
									<td><div>2006-04</div></td>
								</tr>
								<tr>
									<td><div>Java SE 7.0 (1.7.0)</div></td>
									<td><div>Dolphin（海豚）</div></td>
									<td><div>2011-07-28</div></td>
								</tr>
								<tr>
									<td><div>Java SE 8.0 (1.8.0)</div></td>
									<td>Spider（蜘蛛）</td>
									<td><div>2014-03-18</div></td>
								</tr>
								<tr>
									<td colspan="1" rowspan="1">Java SE 9</td>
									<td colspan="1" rowspan="1"></td>
									<td colspan="1" rowspan="1">2017-09-21</td>
								</tr>
							</tbody>
						</table>
						<p>
							<b>JDK 各版本新增的主要特性</b>
						</p>
						<p>
							<b>JDK 5 新特性：</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. 自动装箱与拆箱：</p>
							<p>2. 枚举</p>
							<p>
								3. 静态导入，如：
								<code>import staticjava.lang.System.out</code>
							</p>
							<p>4. 可变参数（Varargs）</p>
							<p>5. 内省（Introspector），主要用于操作 JavaBean 中的属性，通过
								getXxx/setXxx。一般的做法是通过类 Introspector 来获取某个对象的 BeanInfo 信息，然后通过
								BeanInfo 来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的
								getter/setter 方法，然后我们就可以通过反射机制来调用这些方法。</p>
							<p>6. 泛型(Generic)（包括通配类型/边界类型等）</p>
							<p>7. For-Each 循环</p>
							<p>8. 注解</p>
							<p>9. 协变返回类型：实际返回类型可以是要求的返回类型的一个子类型</p>
						</div>
						<p>
							<b>JDK 6 新特性：</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. AWT 新增加了两个类: Desktop 和
								SystemTray，其中前者用来通过系统默认程序来执行一个操作，如使用默认浏览器浏览指定的URL,用默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以
								txt 为后缀名的文件),用系统默认的打印机打印文档等。后者可以用来在系统托盘区创建一个托盘程序</p>
							<p>2. 使用 JAXB2 来实现对象与 XML 之间的映射，可以将一个 Java 对象转变成为 XML 格式，反之亦然</p>
							<p>3. StAX，一种利用拉模式解析(pull-parsing)XML 文档的API。类似于
								SAX，也基于事件驱动模型。之所以将 StAX 加入到 JAXP 家族，是因为 JDK6 中的 JAXB2 和 JAX-WS
								2.0 中都会用 StAX。</p>
							<p>4.使用 Compiler API，动态编译 Java 源文件，如 JSP
								编译引擎就是动态的，所以修改后无需重启服务器。</p>
							<p>5. 轻量级 Http Server API，据此可以构建自己的嵌入式 HttpServer,它支持 Http 和
								Https 协议。</p>
							<p>6. 插入式注解处理 API(PluggableAnnotation Processing API)</p>
							<p>7. 提供了 Console 类用以开发控制台程序，位于 java.io 包中。据此可方便与 Windows 下的
								cmd 或 Linux 下的 Terminal 等交互。</p>
							<p>8. 对脚本语言的支持如: ruby, groovy, javascript</p>
							<p>9. Common Annotations，原是 J2EE 5.0 规范的一部分，现在把它的一部分放到了 J2SE
								6.0 中</p>
							<p>10. 嵌入式数据库 Derby</p>
						</div>
						<p>
							<b>JDK 7 新特性</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. 对 Java 集合（Collections）的增强支持，可直接采用 []、{} 的形式存入对象，采用 []
								的形式按照索引、键值来获取集合中的对象。如：
							<pre class="brush: java;">
List&lt;String&gt; list = [“item1”, ”item2”]; // 存
String item = list[0]; // 直接取
Set&lt;String&gt; set = {“item1”, ”item2”, ”item3”}; // 存
Map&lt;String, Integer&gt; map = {“key1”:1, ”key2”:2}; // 存
Int value = map[“key1”]; // 取
</pre>
							<p>2. 在 Switch 中可用 String</p>
							<p>3. 数值可加下划线用作分隔符（编译时自动被忽略）</p>
							<p>
								4. 支持二进制数字，如：
								<code>int binary = 0b1001_1001;</code>
							</p>
							<p>5. 简化了可变参数方法的调用</p>
							<p>6. 调用泛型类的构造方法时，可以省去泛型参数，编译器会自动判断。</p>
							<p>7. Boolean 类型反转，空指针安全,参与位运算</p>
							<p>
								8. char 类型的 equals 方法:
								<code>booleanCharacter.equalsIgnoreCase(char ch1, char
									ch2)</code>
							</p>
							<p>9. 安全的加减乘除:
							<pre class="brush: java;">
Math.safeToInt(longv); 
Math.safeNegate(int v);
Math.safeSubtract(long v1, int v2);
Math.safeMultiply(int v1, int v2);
......
</pre>
							<p>
								10. Map 集合支持并发请求，注 HashTable 是线程安全的，Map
								是非线程安全的。但此处更新使得其也支持并发。另外，Map 对象可这样定义：
								<code>Map map = {name:"xxx",age:18};</code>
							</p>
						</div>
						<p>
							<b>JDK 8 新特性</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1.
								接口的默认方法：即接口中可以声明一个非抽象的方法做为默认的实现，但只能声明一个，且在方法的返回类型前要加上“default”关键字。
							</p>
							<p>2. Lambda 表达式：是对匿名比较器的简化，如：</p>
							<pre class="brush: java;">
Collections.sort(names,(String a, String b) -&gt; {
	returnb.compareTo(a);
});
</pre>
							<p>对于函数体只有一行代码的，你可以去掉大括号 {} 以及 return 关键字。如：</p>
							<pre class="brush: java;">
Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));
// 或
Collections.sort(names, (a, b) -&gt; b.compareTo(a));
</pre>
							<p>3. 函数式接口：是指仅仅只包含一个抽象方法的接口，要加 @FunctionalInterface 注解</p>
							<p>4. 使用 :: 关键字来传递方法或者构造函数引用</p>
							<p>5. 多重注解</p>
							<p>6. 还增加了很多与函数式接口类似的接口以及与Map相关的API等……</p>
						</div>
						<p>
							<b>JDK 9 新特性 </b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. Jigsaw 项目：模块化 JDK 源码。</p>
							<p>2. 简化了的进程 API。</p>
							<p>3. 轻量级的 JSON API。</p>
							<p>4. 钱和货币的相关 API。</p>
							<p>5. 改善锁争用机制。</p>
							<p>6. 代码分段缓存。</p>
							<p>7. 智能 Java 编译工具。</p>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Object"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">java.lang.Object</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p>
								<code>java.lang</code>
								包在使用的时候无需显示导入，编译时由编译器自动导入。
							</p>
						</div>

						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object

public class Object {}
</pre>

							<p><a href="docs/docs-java/api/java/lang/Object.html" target="_blank">Object</a> 类是类层次结构的根，Java中所有的类从根本上都继承自这个类。</p>
							<p>Object 类是 Java 中唯一没有父类的类。Java 中的每个类都具有定义在 Object 类中的这些方法。</p>
							<ol>
								<li><p><code>protected native Object clone()</code> -- 对象复制(浅层复制)。1.要实现 Cloneable; 2.覆写此方法要修改为 public
										修饰,才能让类外部的代码调用。</p>
									<p>
										<strong>浅层复制：&nbsp;</strong>被复制的对象的所有成员属性都有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅层复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
									<p>
										<strong>深层复制：</strong>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不是原有的那些被引用的对象。换言之，深层复制要复制的对象引用的对象都复制一遍。</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-clone" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-clone" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
/**
 * 要实现 Cloneable
 */
public class Person implements Cloneable {
	private String name;
	private Student student;
	
	public Person() {
	}

	public Person(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	/**
	 * 覆写此方法修改为 public, 才能让类外部的代码调用
	 */
	@Override
	public Object clone() throws CloneNotSupportedException {
		// TODO Auto-generated method stub
		return super.clone();
	}
	
	private void testClone() throws CloneNotSupportedException {
		Person p1 = new Person();
		p1.setName("aaa");
		Person p2 = (Person) p1.clone();	// p2 也有 name=aaa属性
		p1.setName("bbb");
		System.out.println(p1.getName() + "==" + p2.getName());
		
		Student s1 = new Student();
		p1.setStudent(s1);
		
		Person p3 = (Person) p1.clone();
		Student s2 = p3.getStudent();
		System.out.println(s1 == s2);		// s1==s2, 说明p1和p3引用了同一个Student对象
	}
}
</pre>
										</div>
									</div>

									<p>
										<b>使用序列化实现深层复制:</b></p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-deepClone" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-deepClone" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
public class DeepClone {
	public static void main(String[] args) throws Exception {
		Teacher t = new Teacher();
		t.setName("Teacher Wang");
		t.setAge(50);

		Student s1 = new Student();
		s1.setAge(20);
		s1.setName("ZhangSan");
		s1.setTeacher(t);

		Student s2 = (Student) s1.deepClone();

		System.out.println("拷贝得到的信息:");
		System.out.println(s2.getName());
		System.out.println(s2.getAge());
		System.out.println(s2.getTeacher().getName());
		System.out.println(s2.getTeacher().getAge());
		System.out.println("---------------------------");

		// 将复制后的对象的老师信息修改一下：
		s2.getTeacher().setName("New Teacher Wang");
		s2.getTeacher().setAge(28);

		System.out.println("修改了拷贝对象的教师后：");
		System.out.println("拷贝对象的教师：");
		System.out.println(s2.getTeacher().getName());
		System.out.println(s2.getTeacher().getAge());
		System.out.println("原来对象的教师：");
		System.out.println(s1.getTeacher().getName());
		System.out.println(s1.getTeacher().getAge());

		// 由此证明序列化的方式实现了对象的深拷贝
	}

}

class Teacher implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;
	private int age;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}

class Student implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;
	private int age;
	private Teacher teacher;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public Teacher getTeacher() {
		return teacher;
	}

	public void setTeacher(Teacher teacher) {
		this.teacher = teacher;
	}

	/**
	 * 使用序列化实现深层复制
	 */ 
	public Object deepClone() throws Exception {
		// 序列化
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		ObjectOutputStream oos = new ObjectOutputStream(bos);

		oos.writeObject(this);

		// 反序列化
		ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
		ObjectInputStream ois = new ObjectInputStream(bis);

		return ois.readObject();
	}

}
</pre>
										</div>
									</div>
								</li>
								<li><p><code>public boolean equals(Object obj)</code> -- 两个对象是否相等。如果不覆写此方法，使用
										<code>return (this == obj);</code>
										,就是说同一个对象才返回 true。并且覆写equals()方法时，应该同时覆写hashCode()方法，反之亦然。</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-equals" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-equals" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
/**
 * 两个对象的 name 属性相等，返回　true
 */
@Override
public boolean equals(Object obj) {
	return this.name.equals(((Person) obj).getName());
}

public void testEquals() {
	Person p1 = new Person("aa");
	Person p2 = new Person("aa");
	System.out.println(p1.equals(p2));
}
</pre>
										</div>
									</div>
								</li>
								<li><p><code>public native int hashCode()</code>
										--
										Object 类的 hashCode() 方法为不同的对象返回不同的值，Object 类的 hashCode 值表示的是对象的地址。两个不相等的对象产生两个不同的 hashCode 可以改善哈希表的性能。</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-hashCode" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-hashCode" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
/**
 * 直接使用 name 的 hashCode 返回
 */
@Override
public int hashCode() {
	return this.name.hashCode();
}

public void testHashCode(){
	Person p1 = new Person("aa");
	Person p2 = new Person("aa");
	System.out.println(p1.hashCode() + "==" + p2.hashCode());
}
</pre>
										</div>
									</div>
								</li>
								<li><p><code>public String toString()</code> -- Object 的 toString 方法返回 className 和 hashCode 的十六进制值</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-toString" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-toString" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
// Object 的 toString 方法
return getClass().getName() + "@" + Integer.toHexString(hashCode());

@Override
public String toString() {
	return "Person [name=" + name + "]";
}
</pre>
										</div>
									</div>
								</li>
								<li><p><code>public final native Class&lt;?> getClass()</code> -- 返回该对象的运行时类的 Java.lang.Class 对象</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-getClass" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-getClass" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
public class ObjectDemo {
	class Person {
		Person() {
			// 注意如果是实例化了子类的调用，这里打印的是运行时类的类名, 是 Student
			System.out.println("Person:" + getClass().getName());
		}
	}
	
	class Student extends Person {
		Student(){
			System.out.println("Student:" + getClass().getName());
		}
	}
	
	public static void main(String[] args) {
		/** 输出:
		 * Person:cm.nate.lang.ObjectDemo$Student
		 * Student:cm.nate.lang.ObjectDemo$Student
		 */
		new ObjectDemo().new Student();
	}
}
</pre>
										</div>
									</div>
								</li>
								<li><p><code>protected void finalize()</code> -- 用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p></li>
								<li><p><code>notity</code>,<code>wait</code>,<code>notityAll</code>方法参见:<a href="index.html#java-thread">Java 多线程</a></p></li>
							</ol>
						</div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Class"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">java.lang.Class</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">Class 类</h5>
							<pre class="brush: java;">
java.lang.Object
	java.lang.Class&lt;T>

public final class Class&lt;T> implements Serializable, GenericDeclaration, Type, AnnotatedElement {}

/** 序列化标识 */
public interface Serializable {}

/** 表示目前正在此 VM 中运行的程序的一个已注释元素 */
public interface AnnotatedElement {
	// 如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。
	&lt;T extends Annotation> T	getAnnotation(Class&lt;T> annotationClass)
	// 返回此元素上存在的所有注释。
	Annotation[] getAnnotations();
	// 返回直接存在于此元素上的所有注释。
	Annotation[] getDeclaredAnnotations();
	// 返回直接存在于此元素上的指定类型的注释
	default &lt;T extends Annotation> T getDeclaredAnnotation(Class&lt;T> annotationClass);
	// 返回直接存在于此元素上的指定类型所有注释
	default &lt;T extends Annotation> T[] getDeclaredAnnotationsByType(Class&lt;T> annotationClass);
	// 如果指定类型的注释存在于此元素上，则返回 true，否则返回 false。
	boolean isAnnotationPresent(Class&lt;? extends Annotation> annotationClass);
}

public interface GenericDeclaration extends AnnotatedElement {
	TypeVariable&lt;?>[] getTypeParameters();
}

/** 类型 */
public interface Type {
    default String getTypeName() {
        return toString();
    }
}
</pre>
							<p><a href="docs/docs-java/api/java/lang/Class.html" target="_blank">Class</a> 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。</p>
							<p><a href="docs/docs-java/api/java/lang/Class.html" target="_blank">Class</a> 类没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。</p>
							<pre class="brush: java;">
/** 1.反射方式第一次会触发静态代码块
 *  2.类名直接访问不会触发静态代码块
 *  3.通过 getClass 方法，因为要小得到实例，所以第一次触发静态代码块，每个实例触发普通代码块
 */
Class clas = Class.forName("cm.nate.lang.ClassDemo"); // 反射得到类
Class&lt;MyClass> clazz = MyClass.class; // 类名直接访问
Class cls = obj.getClass(); // Object 的 getClass() 方法
</pre>
							<p><b>类的加载:</b></p>
							<ol>
								<li>
									<code>Class.forName</code>
									方式加载 -- 静态代码块 -> 如果调用 newInstance 方法 -> 非静态代码块 -> 构造方法
								</li>
								<li>
									<code>直接 new</code>
									-- 静态代码块 -> [如果加载过了 class -> 非静态代码块 -> 构造方法 | 没加载过 class ->
									静态代码块 -> 非静态代码块 -> 构造方法]
								</li>
							</ol>
							<div class="panel panel-default">
								<div class="panel-heading">
									<a data-toggle="collapse" data-parent="#accordion"
										href="#jdk-Class-load" aria-expanded="true"
										class="code-header">
										<span class="glyphicon glyphicon-plus"></span> View Code
									</a>
								</div>
								<div id="jdk-Class-load" class="panel-collapse collapse"
									style="" aria-expanded="true">
									<pre class="brush: java;">
public class ClassDemo {
	static {
		System.out.println("===静态代码块===");
	}
	
	{
		System.out.println("===非静态代码块===");
	}
	
	public ClassDemo() {
		System.out.println("===构造方法===");
	}
	
	// Class.forName 方式加载
	public static void testForName(){
		try {
			Class testTypeForName = Class.forName("cm.nate.lang.ClassDemo");
			testTypeForName.newInstance();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) {
		testForName();
		
		// 前面加载过class了,这里不会调用静态代码块 
		new ClassDemo();
	}
}
</pre>
								</div>
							</div>
                            <p><b>Class 类的常用方法:</b></p>
							<ol>
								<li><p><code>static Class&lt;?> forName(String className)</code> -- 动态加载类。调用了 native 方法加载类</p></li>
                                <li>
                                    <p><code>static Class&lt;?> 	forName(String name, boolean initialize, ClassLoader loader)</code> -- 使用给定的类加载器</p></li>
                                <li class="group">
                                    <p><code>native boolean isInterface()</code> -- 是否是接口</p>
                                </li>
                                <li>
                                    <p><code>native boolean isPrimitive()</code> -- 是否是基础类</p>
                                </li>
                                <li>
                                    <p><code>boolean isEnum()</code> -- 是否是枚举</p>
                                </li>
                                <li>
                                    <p><code>boolean isAnnotation()</code> -- 是否为注解类</p>
                                </li>
                                <li>
                                    <p><code>native boolean isArray()</code> -- 是否是数组</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isAnonymousClass()</code> -- 是否为匿名类</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isMemberClass()</code> -- 是否为成员类</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isSynthetic()</code> -- 是否为复合类(编译器生成的特殊类)</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isAssignableFrom(Class&lt;?> cls)</code> -- 此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isInstance(Object obj)</code> -- 对象是否为 class 的实例</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isLocalClass()</code> -- 是否为局部类(在方法体中的类)</p>
                                </li>

                                <li class="group">
                                    <p><code>ClassLoader getClassLoader()</code> -- 获得类的类加载器</p>
                                </li>
                                <li>
                                    <p><code>Package getPackage()</code> -- 获得 package，参见相关类</p>
                                </li>
                                <li class="group">
                                    <p><code>Class&lt;?>[] getInterfaces()</code> -- 获得直接实现的接口列表</p>
                                </li>
                                <li>
                                    <p><code>Type[] getGenericInterfaces()</code> -- 直接实现接口的类型，参见相关类</p>
                                </li>
                                <li>
                                    <p><code>native Class&lt;? super T> getSuperclass()</code> -- 获取类的直接父类，继承了父类则返回父类，否则返回 Object</p>
                                </li>
                                <li>
                                    <p><code>Type 	getGenericSuperclass()</code> -- 直接继承类的类型，只有 Object 返回空，参见相关类</p>
                                </li>
                                <li class="group">
                                    <p><code>native int getModifiers()</code> -- 获得整数表示的修饰符，由 <a href="#java-lang-reflect-Modifier" target="_blank">Modifier</a> 定义</p>
                                </li>
                                <li>
                                    <p><code>String getName()</code> -- 获取类或接口的名字，包括包名</p>
                                </li>
                                <li>
                                    <p><code>String getSimpleName()</code> -- 获得类名</p>
                                </li>
                                <li>
                                    <p><code>String 	getCanonicalName()</code> -- 同 getName(), 内部类的 <code>$</code> 变成 <code>.</code></p>
                                </li>
                                <li>
                                    <p><code>String getTypeName()</code> -- 如果是数组，获得数组数据类型名，否则返回类名</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?> 	getComponentType()</code> -- 返回表示数组组件类型的 Class</p>
                                </li>
                                <li>
                                    <p><code>TypeVariable&lt;Class&lt;T>>[] 	getTypeParameters()</code> -- 声明顺序返回类型变量对象的数组，就是下面的 <code>T, M</code></p>
                                    <pre class="brush: java;">
public class Test&lt;T, M> {}
                                    </pre>
                                </li>

                                <li class="group">
                                    <p><code><a href="#java-lang-reflect-Constructor">Constructor&lt;?></a>[] getConstructors()</code> -- 获得所有的构造函数</p>
                                </li>
                                <li>
                                    <p><code><a href="#java-lang-reflect-Constructor">Constructor&lt;?></a> getConstructor(Class&lt;?>... parameterTypes)</code> -- 获得指定参数类型的构造函数</p>
                                </li>
                                <li>
                                    <p><code><a href="#java-lang-reflect-Constructor">Constructor&lt;?></a>[] 	getDeclaredConstructors()</code> -- 自己的构造方法</p>
                                </li>
                                <li>
                                    <p><code><a href="#java-lang-reflect-Constructor">Constructor&lt;?></a> 	getDeclaredConstructor(Class&lt;?>... parameterTypes)</code> -- 指定参数类型的自己的构造方法</p>
                                </li>

                                <li class="group">
                                    <p><code><a href="#java-lang-reflect-Field">Field</a>[] getFields()</code> -- 获得字段数组(public 修饰的，包括继承的)</p>
                                </li>
                                <li>
                                    <p><code><a href="#java-lang-reflect-Field">Field</a> 	getField(String name)</code> -- 获取指定名字字段(public 修饰的，包括继承的)</p>
                                </li>
                                <li>
                                    <p><code><a href="#java-lang-reflect-Field">Field</a>[] 	getDeclaredFields()</code> -- 自己的所有字段列表，不包括父类</p>
                                </li>
                                <li>
                                    <p><code><a href="#java-lang-reflect-Field">Field</a> 	getDeclaredField(String name)</code> -- 指定名字的自己的字段</p>
                                </li>
                                <li>
                                    <p><code>T[] getEnumConstants()</code> -- 获取枚举常量数组</p>
                                </li>

                                <li class="group">
                                    <p><code><a href="#java-lang-reflect-Method">Method</a>[] 	getDeclaredMethods()</code> -- 自己的所有方法列表，不包括父类</p>
                                </li>
                                <li>
                                    <p><code><a href="#java-lang-reflect-Method">Method</a> 	getDeclaredMethod(String name, Class&lt;?>... parameterTypes)</code> -- 指定名字和参数类型的自己的方法</p>
                                </li>
                                <li>
                                    <p><code><a href="#java-lang-reflect-Method">Method</a>[] getMethods()</code> -- 获得 public 方法(包括继承的)</p>
                                </li>
                                <li>
                                    <p><code><a href="#java-lang-reflect-Method">Method</a> 	getMethod(String name, Class&lt;?>... parameterTypes)</code> -- 指定名字和参数类型的 public 方法(包括继承的)</p>
                                </li>

                                <li class="group">
                                    <p><code>Class&lt;?>[] 	getClasses()</code> -- public 的成员类</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?>[] 	getDeclaredClasses()</code> -- 所有成员类/接口/枚举</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?> 	getDeclaringClass()</code> -- 如果是成员类，则返回其包裹类</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?> 	getEnclosingClass()</code> -- 返回其包裹类(上一级的类)</p>
                                </li>
                                <li>
                                    <p><code><a href="#java-lang-reflect-Constructor">Constructor&lt;?></a> 	getEnclosingConstructor()</code> -- 如果局部类定义在构造方法中，返回局部类所在的构造方法</p>
                                </li>
                                <li>
                                    <p><code><a href="#java-lang-reflect-Method">Method</a> 	getEnclosingMethod()</code> -- 如果局部类定义在普通方法中，返回局部类所在的方法</p>
                                </li>

                                <li class="group">
									<p><code>T newInstance()</code> -- 根据对象的 class 新建一个对象，用于反射。</p></li>

								<li><p><code>java.net.URL getResource(String name)</code> -- 返回文件的却对路径(file:/home/nate/....)</p></li>
                                <li>
                                    <p><code>InputStream 	getResourceAsStream(String name)</code> -- 指定文件读取为流</p>
                                </li>
                                <li class="group">
                                    <p><code>&lt;A extends Annotation> A getAnnotation(Class&lt;A> annotationClass)</code> -- 如果存在指定类型的注释，则返回这些注释</p>
                                </li>
                                <li>
                                    <p><code>Annotation[] getAnnotations</code> -- 返回此元素上存在的所有注释</p>
                                </li>
                                <li>
                                    <p><code>&lt;A extends Annotation> A[] 	getAnnotationsByType(Class&lt;A> annotationClass)</code> -- 获取指定类型注解列表</p>
                                </li>
                                <li>
                                    <p><code>&lt;A extends Annotation> A[] getDeclaredAnnotationsByType(Class&lt;A> annotationClass)</code> -- 获取指定类型注解列表</p>
                                </li>
                                <li>
                                    <p><code>&lt;A extends Annotation> A getDeclaredAnnotation(Class&lt;A> annotationClass)</code> -- 获取指定类型注解</p>
                                </li>
                                <li>
                                    <p><code>Annotation[] getDeclaredAnnotations()</code> -- 直接存在于此元素上的所有注释</p>
                                </li>
                                <li>
                                    <p><code>boolean isAnnotationPresent(Class&lt;? extends Annotation> annotationClass)</code> -- 是否有指定注解存在此元素上</p>
                                </li>


                                <li class="group">
                                    <p><code>&lt;U> Class&lt;? extends U> 	asSubclass(Class&lt;U> clazz)</code> -- 强制转换为 <code>clazz</code> 的子类</p>
                                </li>
                                <li>
                                    <p><code>T 	cast(Object obj)</code> -- 强制类型转换</p>
                                </li>
                                <li>
                                    <p><code>boolean 	desiredAssertionStatus()</code> -- 如果要在调用此方法时将要初始化该类，则返回将分配给该类的断言状态</p>
                                </li>

                                <li class="group">
                                    <p><code>AnnotatedType[] 	getAnnotatedInterfaces()</code> -- 获取直接继承/实现带注解的接口列表</p>
                                </li>
                                <li>
                                    <p><code>AnnotatedType 	getAnnotatedSuperclass()</code> -- 获取直接继承带注解的类</p>
                                </li>



                                <li class="group">
                                    <p><code>ProtectionDomain 	getProtectionDomain()</code> -- 返回该类的 ProtectionDomain，参见相关类</p>
                                </li>
                                <li>
                                    <p><code>Object[] 	getSigners()</code> -- 获取类的签名，一般为 NULL</p>
                                </li>

                                <li>
                                    <p><code>String 	toGenericString()</code> -- 返回形式：<code>修饰符 + class/interface/enum + getName()</code></p>
                                </li>
                                <li>
                                    <p><code>String 	toString()</code> -- 返回形式：<code>interface / class + getName()</code></p>
                                </li>

							</ol>
							<div class="panel panel-default">
								<div class="panel-heading">
									<a data-toggle="collapse" data-parent="#accordion"
										href="#jdk-Class-clazz" aria-expanded="true"
										class="code-header">
										<span class="glyphicon glyphicon-plus"></span> View Code
									</a>
								</div>
								<div id="jdk-Class-clazz" class="panel-collapse collapse"
									style="" aria-expanded="true">
									<pre class="brush: java;">
public class MyReflect {
	public static void main(String[] args) {
		/** 类型 */
		System.out.println(Serializable.class.isInterface());
		System.out.println(ElementType.class.isEnum());
		System.out.println(Target.class.isAnnotation());
		String[] array = {};
		System.out.println(array.getClass().isArray());
	
		MyReflect testReflect = new MyReflect();
		Class&lt;?> clazz = testReflect.getClass();
		
		System.out.println("完整类名: " + clazz.getName());
		System.out.println("类名: " + clazz.getSimpleName());
		System.out.println("类型名: " + clazz.getTypeName());
		System.out.println("ClassLoader名: "
				+ clazz.getClassLoader().getClass().getName());
		System.out.println("父类: " + clazz.getSuperclass().getName());
		
		/** 实例化一个对象，并操作这个对象 */
		try {
			// 第一种方法，实例化默认构造方法，调用set赋值
			Class&lt;?> myClass = Class.forName("cm.nate.reflect.MyReflect");
			MyReflect mr = (MyReflect) myClass.newInstance();
			mr.setName("hello");
			System.out.println(mr.getName());
			
			// 取得指定的构造函数 使用构造函数赋值
			@SuppressWarnings("unchecked")
			Constructor&lt;MyReflect> constructor = 
				(Constructor&lt;MyReflect>) myClass.getConstructor(String.class);
			MyReflect mr2 = constructor.newInstance("jiwanger");
			System.out.println(mr2.getName());
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		/** 取得本类的全部属性 */
		Field[] field = clazz.getDeclaredFields();
        for (int i = 0; i &lt; field.length; i++) {
            // 权限修饰符
            int mo = field[i].getModifiers();
            String priv = Modifier.toString(mo);
            // 属性类型
            Class&lt;?> type = field[i].getType();
            System.out.println(priv + " " + type.getName() + " " + field[i].getName() + ";");
        }
        
        /** 获取某个类的全部方法 */
        Method method[] = clazz.getMethods();
        for (int i = 0; i &lt; method.length; ++i) {
            Class&lt;?> returnType = method[i].getReturnType();
            Class&lt;?> para[] = method[i].getParameterTypes();
            int temp = method[i].getModifiers();
            System.out.print(Modifier.toString(temp) + " ");
            System.out.print(returnType.getName() + "  ");
            System.out.print(method[i].getName() + " ");
            System.out.print("(");
            for (int j = 0; j &lt; para.length; ++j) {
                System.out.print(para[j].getName() + " " + "arg" + j);
                if (j &lt; para.length - 1) {
                    System.out.print(",");
                }
            }
            Class&lt;?> exce[] = method[i].getExceptionTypes();
            if (exce.length > 0) {
                System.out.print(") throws ");
                for (int k = 0; k &lt; exce.length; ++k) {
                    System.out.print(exce[k].getName() + " ");
                    if (k &lt; exce.length - 1) {
                        System.out.print(",");
                    }
                }
            } else {
                System.out.print(")");
            }
            System.out.println();
        }
        
        /** 反射机制调用某个类的方法 */
        try {
			Class&lt;?> myClass = Class.forName("cm.nate.reflect.MyReflect");
			// 调用TestReflect类中的reflect1方法
			
			// Java 反射机制 - 调用某个类的方法1.
			// 调用TestReflect的reflect2方法
			MyReflect mr3 = (MyReflect) myClass.newInstance();
			Method method2 = myClass.getMethod("setName", String.class);
			method2.invoke(mr3, "张三");
			
			Method method3 = myClass.getMethod("getName");
			String name = (String) method3.invoke(mr3);
			System.out.println(name);
			
		}  catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public MyReflect(){}
	
	public MyReflect(String name){
		this.name = name;
	}

	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

}
</pre>
								</div>
							</div>
						</div>

						<div class="sub-item">
                            <p><b><code>Class</code> 相关类：</b></p>
                            <p><a href="docs/docs-java/api/java/lang/annotation/Annotation.html" target="_blank">Annotation</a> -- 所有 annotation 类型都要扩展的公共接口。注意，手动扩展该公共接口的接口不 定义 annotation 类型。还要注意此接口本身不定义 annotation 类型。</p>
                            <pre class="brush: java;">
Class&lt;? extends Annotation> annotationType() -- 返回此 annotation 的注释类型。
boolean equals(Object obj); // 如果指定的对象表示在逻辑上等效于此接口的注释，则返回 true。
int hashCode(); // 返回此 annotation 的哈希码，
String toString(); // 返回此 annotation 的字符串表示形式
                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Constructor.html" target="_blank">Constructor</a> -- 提供关于类的单个构造方法的信息以及对它的访问权限。</p>
							<p><code>Constructor</code> 允许在将实参与带有底层构造方法的形参的 <code>newInstance()</code> 匹配时进行扩展转换，但是如果发生收缩转换，则抛出 <code>IllegalArgumentException</code>。 </p>
                            <pre class="brush: java;">
public final class Constructor&lt;T> extends Executable {
	// 主要是这个方法，用于使用指定的参数构造对象实例
	T newInstance(Object... initargs);
}

public abstract class Executable extends AccessibleObject implements Member, GenericDeclaration {}

/** 可访问性控制 */
public class AccessibleObject implements AnnotatedElement {
	// 值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查
	void setAccessible(boolean flag);
	// 获取此对象的 accessible 标志的值
	boolean isAccessible();
    ...
}

public interface Member {
    public static final int PUBLIC = 0; // 标识类或接口的所有已声明成员的集合
    public static final int DECLARED = 1; // 标识类或接口的所有公共成员（包括继承成员）的集合

    public Class&lt;?> getDeclaringClass(); // 返回表示声明由此 Member 表示的成员或构造方法的类或接口的 Class 对象
    public String getName(); // 作为整数返回由此 Member 所表示的成员或构造方法的 Java 语言修饰符
    int getModifiers(); // 返回此 Member 表示的底层成员或构造方法的简单名称
    boolean isSynthetic(); //  如果此成员是编译器引入的，则返回 true；否则，返回 false。
}
                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Field.html" target="_blank">Field</a> -- 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p>
							<p>Array 允许在执行 <code>get</code> 或 <code>set</code> 访问操作期间进行扩展转换，但如果将发生收缩转换，则抛出一个 <code>IllegalArgumentException。</code> </p>
                            <pre class="brush: java;">
public final class Field extends AccessibleObject implements Member {
	String getName(); // 返回此 Field 对象表示的字段的名称
	Class&lt;?> getType(); // 返回标识了此 Field 对象所表示字段的声明类型
	Object get(Object obj); // 获取指定对象实例上该字段的值
	void set(Object obj, Object value); // 设置指定对象实例上该字段的值
	int getInt(Object obj); // 获取指定对象实例上 int 字段的值
	void setInt(Object obj, int i); // 设置指定对象实例上 int 字段的值
	boolean getBoolean(Object obj); // 获取指定对象实例上 boolean 字段的值
	void setBoolean(Object obj, boolean z); // 设置指定对象实例上 boolean 字段的值
	...
}
                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Method.html" target="_blank">Method</a> -- 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法）。 </p>
							<p><code>Method</code> 允许在匹配要调用的实参与底层方法的形参时进行扩展转换；但如果要进行收缩转换，则会抛出 <code>IllegalArgumentException</code>。</p>
                            <pre class="brush: java;">
public final class Method extends Executable {
	String getName(); // 方法名
	Class&lt;?> getReturnType(); // 返回返回值类型
	Class&lt;?>[] getParameterTypes(); // 按照声明顺序返回参数类型的 Class 对象的数组
	Object invoke(Object obj, Object... args); // 调用指定对象的方法
	boolean isVarArgs(); // 是否有可变数量的参数类型
}
                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Type.html" target="_blank">Type</a> -- 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。有以下子类：</p>
							<ul>
								<li><p><a href="docs/docs-java/api/java/lang/reflect/TypeVariable.html" target="_blank">TypeVariable</a> -- 是各种类型变量的公共高级接口。类型变量在反射方法首次需要时创建。如果类型变量 t 由类型（即类、接口或注释类型）T 引用，而且 T 由 T 的第 n 个封闭类声明（请参见 JLS 8.1.2），那么创建 t 需要解析（请参见 JVMS 5）T 的第 i 个封闭类，其中 i = 0 到 n（包含）。创建某个类型变量决不能导致创建其边界。重复创建类型变量没有效果。 </p>
									<p>可以在运行时将多个对象实例化，以表示一个给定的类型变量。尽管类型变量仅创建一次，这并不意味着任何缓存实例的要求都表示类型变量。不过，表示类型变量的所有实例彼此必须相等 (equal())。因此，使用类型变量的用户决不能依靠实现此接口的类实例的身份。 </p>
								<pre class="brush: java;">
public interface TypeVariable&lt;D extends GenericDeclaration> extends Type, AnnotatedElement {
	Type[] getBounds(); // 返回表示此类型变量上边界的 Type 对象的数组。
	D getGenericDeclaration(); // 返回 GenericDeclaration 对象，该对象表示声明此类型变量的一般声明。
	String getName(); // 返回此类型变量的名称，它出现在源代码中。
}

public interface GenericDeclaration extends AnnotatedElement {
	// 返回声明顺序的 TypeVariable 对象的数组，由此 GenericDeclaration 对象表示的一般声明声明的类型变量
	TypeVariable&lt;?>[] getTypeParameters();
}
								</pre>
								</li>
								<li><p><a href="docs/docs-java/api/java/lang/reflect/ParameterizedType.html" target="_blank">ParameterizedType</a> -- 表示参数化类型，如 <code>Collection&lt;String></code>。</p>
									<p>参数化类型在反射方法首次需要时创建（在此包中指定）。当创建参数化类型 p 时，p 实例化的一般类型声明会被解析，并且按递归方式创建 p 的所有类型参数。有关类型变量创建过程的详细信息，请参阅 TypeVariable。重复创建的参数化类型无效。</p>
										<p>实现此接口的类的实例必须实现 <code>equals()</code> 方法，该方法用于比较两个共享相同一般类型声明和具有相同类型参数的任何实例。 </p>
									<pre class="brush: java;">
public interface ParameterizedType extends Type {
	Type[] getActualTypeArguments(); // 返回表示此类型实际类型参数的 Type 对象的数组。
	Type getOwnerType(); // 返回 Type 对象，表示此类型是其成员之一的类型。
	Type getRawType(); // 返回 Type 对象，表示声明此类型的类或接口
}
									</pre>
								</li>
								<li><p><a href="docs/docs-java/api/java/lang/reflect/WildcardType.html" target="_blank">WildcardType</a> -- 表示一个通配符类型表达式，如 <code>?</code>、<code>? extends Number</code> 或 <code>? super Integer</code>。</p>
									<pre class="brush: java;">
public interface WildcardType extends Type {
	Type[] getLowerBounds(); // 返回表示此类型变量下边界的 Type 对象的数组。
	Type[] getUpperBounds(); // 返回表示此类型变量上边界的 Type 对象的数组。
}
									</pre>
								</li>
								<li><p><a href="docs/docs-java/api/java/lang/reflect/GenericArrayType.html" target="_blank">GenericArrayType</a> -- 表示一种数组类型，其组件类型为参数化类型或类型变量。</p>
									<pre class="brush: java;">
public interface GenericArrayType extends Type {
	Type getGenericComponentType(); // 返回表示此数组的组件类型的 Type 对象
}
									</pre>
								</li>
							</ul>
                            <p><a href="docs/docs-java/api/java/security/ProtectionDomain.html" target="_blank">ProtectionDomain</a> -- 封装域的特征，域中包装一个类集合，在代表给定的主体集合执行这些类的实例时会授予它们一个权限集合。</p>
							<p>在构造 ProtectionDomain 时可以对它绑定一个静态的权限集合；不管 Policy 是否有效，都会将这些权限授予域。但是，为了支持动态安全策略，也可以构造 ProtectionDomain，使得只要检查权限时就能通过当前 Policy 将其动态地映射到一个权限集合。 </p>
                            <pre class="brush: java;">
public class ProtectionDomain {
	public ProtectionDomain(CodeSource codesource, PermissionCollection permissions) {}
	public ProtectionDomain(CodeSource codesource, PermissionCollection permissions,
								ClassLoader classloader, Principal[] principals) {}

	ClassLoader getClassLoader(); // 返回此域的 ClassLoader。
	CodeSource getCodeSource(); // 返回此域的 CodeSource。
	PermissionCollection getPermissions(); // 返回授予此域的静态权限。
	Principal[] getPrincipals(); // 返回此域的 principals 数组。
	boolean implies(Permission permission); //  查看此 ProtectionDomain 是否暗含了 Permission 对象中表示的权限。
}
                            </pre>

						</div>
				    </div>
			    </div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-ClassLoader"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">ClassLoader</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
public abstract class ClassLoader {
    protected 	ClassLoader() {}
    protected 	ClassLoader(ClassLoader parent) {}
}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/ClassLoader.html" target="_blank">ClassLoader</a> -- 是一个抽象类，负责加载类的对象。如果给定类的二进制名称，那么类加载器会试图查找或生成构成类定义的数据。一般策略是将名称转换为某个文件名，然后从文件系统读取该名称的“类文件”。 </p>
                        <p>每个 Class 对象都包含一个对定义它的 ClassLoader 的引用。 </p>
                        <p>数组类的 Class 对象不是由类加载器创建的，而是由 Java 运行时根据需要自动创建。数组类的类加载器由 <code>Class.getClassLoader()</code> 返回，该加载器与其元素类型的类加载器是相同的；如果该元素类型是基本类型，则该数组类没有类加载器。 </p>
                        <p>类加载器通常由安全管理器使用，用于指示安全域。</p>
                        <p>ClassLoader 类使用委托模型来搜索类和资源。每个 ClassLoader 实例都有一个相关的父类加载器。需要查找类或资源时，ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。虚拟机的内置类加载器（称为 "bootstrap class loader"）本身没有父类加载器，但是可以将它用作 ClassLoader 实例的父类加载器。</p>
                        <p>通常情况下，Java 虚拟机以与平台有关的方式，从本地文件系统中加载类。例如，在 UNIX 系统中，虚拟机从 CLASSPATH 环境变量定义的目录中加载类。</p>
                        <p><b>类加载过程：</b></p>
                        <ul>
                            <li><p><b>加载</b>：类加载过程的一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个 Class 对象;</p></li>
                            <li><p><b>验证</b>：目的在于确保 Class 文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证;                           </p></li>
                            <li><p><b>准备</b>：为类变量(即 static 修饰的字段变量)分配内存并且设置该类变量的初始值即0(如 static int i = 5;这里只将 i 初始化为 0，至于 5 的值将在初始化时赋值)，这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中;                           </p></li>
                            <li><p><b>解析</b>：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析(这里涉及到字节码变量的引用，如需更详细了解，可参考《深入 Java 虚拟机》);                           </p></li>
                            <li><p><b>初始化</b>：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的 static 变量将会在这个阶段赋值，成员变量也将被初始化)。                           </p></li>
                        </ul>

                        <p><a href="docs/docs-java/api/java/lang/ClassLoader.html" target="_blank">ClassLoader</a> 的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，<b>引导（Bootstrap）类加载器</b>、<b>扩展（Extension）类加载器</b>、<b>系统（System）类加载器（也称应用类加载器）</b></p>
                        <p><b>启动类加载器</b> -- 启动类加载器主要加载的是 JVM 自身需要的类，这个类加载使用 C++ 语言实现的，是虚拟机自身的一部分，它负责将 <code>$JAVA_HOME/lib</code> 路径下的核心类库或 <code>-Xbootclasspath</code> 参数指定的路径下的 jar 包加载到内存中，注意必由于虚拟机是按照文件名识别加载 jar 包的，如 rt.jar，如果文件名不被虚拟机识别，即使把 jar 包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启 动类加载器只加载包名为 java、javax、sun 等开头的类)。</p>
                        <p><b>扩展类加载器</b> -- 扩展类加载器是指 Sun 公司(已被 Oracle 收购)实现的 sun.misc.Launcher$ExtClassLoader 类，由 Java 语言实现的，是Launcher的静态内部类，它负责加载 <code>$JAVA_HOME/lib/ext</code> 目录下或者由系统变量 <code>-Djava.ext.dir</code> 指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</p>
                        <p><b>系统类加载器</b> -- 也称应用程序加载器是指 Sun 公司实现的 sun.misc.Launcher$AppClassLoader。它负责加载系统类路径 <code>java -classpath</code> 或 <code>-D java.class.path</code> 指定路径下的类库，也就是我们经常用到的 classpath 路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过 <code>ClassLoader.getSystemClassLoader()</code> 方法可以获取到该类加载器。 </p>

                        <p><b>双亲委派模式</b> -- 要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
                        <p>采用双亲委派模式的是好处是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次。其次是考虑到安全因素，java 核心 api 中定义类型不会被随意替换。</p>
                        <ol>
                            <li><p><code>static ClassLoader 	getSystemClassLoader()</code> -- 返回委托的系统类加载器</p></li>
                            <li><p><code>static URL 	getSystemResource(String name)</code> -- 从用来加载类的搜索路径中查找具有指定名称的资源</p></li>
                            <li><p><code>static InputStream 	getSystemResourceAsStream(String name)</code> -- 以流的形式读取该资源</p></li>
                            <li><p><code>static Enumeration&lt;URL> 	getSystemResources(String name)</code> -- 从用来加载类的搜索路径中查找所有具有指定名称的资源</p></li>

                            <li class="group"><p><code>Class&lt;?> 	loadClass(String name)</code> -- 使用指定的二进制名称来加载类</p></li>
                            <li><p><code>protected Class&lt;?> 	loadClass(String name, boolean resolve)</code> -- 使用指定的二进制名称来加载类</p></li>

                            <li class="group"><p><code>protected Class&lt;?> 	findClass(String name)</code> -- 使用指定的二进制名称查找类</p></li>
                            <li><p><code>protected String 	findLibrary(String libname)</code> -- 返回本机库的绝对路径名</p></li>
                            <li><p><code>protected Class&lt;?> 	findLoadedClass(String name)</code> -- 如果 JVM 已将此加载器记录为具有给定二进制名称的某个类的启动加载器，则返回该二进制名称的类</p></li>
                            <li><p><code>protected URL 	findResource(String name)</code> -- 查找具有给定名称的资源</p></li>
                            <li><p><code>protected Enumeration&lt;URL> 	findResources(String name)</code> -- 返回表示所有具有给定名称的资源的 URL 对象的枚举</p></li>
                            <li><p><code>protected Class&lt;?> 	findSystemClass(String name)</code> --  查找具有指定的二进制名称的类，必要时加载它</p></li>


                            <li class="group"><p><code>protected Class&lt;?> 	defineClass(String name, byte[] b, int off, int len)</code> -- 将一个 byte 数组转换为 Class 类的实例</p></li>
                            <li><p><code>protected Class&lt?> 	defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)</code> -- 使用可选的 ProtectionDomain 将一个 byte 数组转换为 Class 类的实例</p></li>
                            <li><p><code>protected Class&lt;?> 	defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)</code> -- 使用可选的 ProtectionDomain 将 ByteBuffer 转换为 Class 类的实例</p></li>
                            <li><p><code>protected Package 	definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)</code> -- 根据 name 在此 ClassLoader 中定义包</p></li>

                            <li class="group"><p><code>protected Object 	getClassLoadingLock(String className)</code> -- 返回类加载操作的锁定对象</p></li>
                            <li><p><code>protected Package 	getPackage(String name)</code> --  返回由此类加载器或其任何祖先所定义的 Package</p></li>
                            <li><p><code>protected Package[] 	getPackages()</code> -- 返回此类加载器及其祖先所定义的所有 Package</p></li>
                            <li><p><code>ClassLoader 	getParent()</code> -- 返回委托的父类加载器</p></li>
                            <li><p><code>URL 	getResource(String name)</code> -- 查找具有给定名称的资源</p></li>
                            <li><p><code>InputStream 	getResourceAsStream(String name)</code> -- 返回读取指定资源的输入流</p></li>
                            <li><p><code>Enumeration&lt;URL> 	getResources(String name)</code> -- 查找所有给定名称的资源</p></li>

                            <li class="group"><p><code>protected static boolean 	registerAsParallelCapable()</code> -- 注册为并行</p></li>
                            <li><p><code>protected void 	resolveClass(Class&lt;?> c)</code> -- 链接指定的类</p></li>
                            <li><p><code>protected void 	setSigners(Class&lt;?> c, Object[] signers)</code> -- 设置类的签署者</p></li>
                            <li><p><code>void 	setPackageAssertionStatus(String packageName, boolean enabled)</code> -- 为指定包设置默认断言状态</p></li>
                            <li><p><code>void 	setDefaultAssertionStatus(boolean enabled)</code> -- 设置此类加载器的默认断言状态</p></li>
                            <li><p><code>void 	setClassAssertionStatus(String className, boolean enabled)</code> -- 设置在此类加载器及其包含的嵌套类中指定的最高层类所需的断言状态</p></li>
                            <li><p><code>void 	clearAssertionStatus()</code> -- 将此类加载器的默认断言状态设置为 false，并放弃与此类加载器关联的所有默认包或类断言状态设置</p></li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-Enum"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">java.lang.Enum</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.Enum&lt;E>

public abstract class Enum&lt;E extends Enum&lt;E>> implements Comparable&lt;E>, Serializable {
    protected Enum(String name, int ordinal) {}
}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/Enum.html" target="_blank">Enum</a> -- 特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。</p>
                        <p><a href="docs/docs-java/api/java/lang/Enum.html" target="_blank">Enum</a> 还有专属的 <code>Map(<a href="docs/docs-java/api/java/util/EnumMap.html" target="_blank">EnumMap</a>)</code> 和 <code>Set(<a href="docs/docs-java/api/java/util/EnumSet.html" target="_blank">EnumSet</a>)</code></p>

                        <ul>
                            <li><p><a href="docs/docs-java/api/java/util/EnumMap.html" target="_blank">EnumMap</a> -- 与枚举类型键一起使用的专用 Map 实现。枚举映射中所有键都必须来自单个枚举类型，该枚举类型在创建映射时显式或隐式地指定。枚举映射在内部表示为数组。此表示形式非常紧凑且高效。 </p></li>
                            <li><p><a href="docs/docs-java/api/java/util/EnumSet.html" target="_blank">EnumSet</a> -- 与枚举类型一起使用的专用 Set 实现。枚举 set 中所有键都必须来自单个枚举类型，该枚举类型在创建 set 时显式或隐式地指定。枚举 set 在内部表示为位向量。此表示形式非常紧凑且高效。此类的空间和时间性能应该很好，足以用作传统上基于 int 的“位标志”的替换形式，具有高品质、类型安全的优势。如果其参数也是一个枚举 set，则批量操作（如 containsAll 和 retainAll）也应运行得非常快。 </p></li>
                        </ul>


                        <pre class="brush: java;">
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

/** 编译器编译后的 class 文件: */
public final class Day extends Enum {
	// 前面定义的 7 种枚举实例
    public static final Day MONDAY;
    public static final Day TUESDAY;
    public static final Day WEDNESDAY;
    public static final Day THURSDAY;
    public static final Day FRIDAY;
    public static final Day SATURDAY;
    public static final Day SUNDAY;
    private static final Day $VALUES[];

    static {
        // 实例化枚举实例
        MONDAY = new Day("MONDAY", 0);
        TUESDAY = new Day("TUESDAY", 1);
        WEDNESDAY = new Day("WEDNESDAY", 2);
        THURSDAY = new Day("THURSDAY", 3);
        FRIDAY = new Day("FRIDAY", 4);
        SATURDAY = new Day("SATURDAY", 5);
        SUNDAY = new Day("SUNDAY", 6);
        $VALUES = (new Day[] {
            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
        });
    }

	// 私有构造函数
    private Day(String s, int i) {
        super(s, i);
    }

    // 编译器为我们添加的静态的values()方法
    public static Day[] values() {
        return (Day[])$VALUES.clone();
    }

    // 编译器为我们添加的静态的 valueOf() 方法，注意间接调用了 Enum 也类的 valueOf 方法
    public static Day valueOf(String s) {
        return (Day)Enum.valueOf(com/zejian/enumdemo/Day, s);
    }
}
</pre>
						<p><b>Enum API:</b></p>
						<ol>
							<li><p><code>static &lt;T extends Enum&lt;T>> T 	valueOf(Class&lt;T> enumType, String name)</code> -- 返回带指定名称的指定枚举类型的枚举常量</p></li>
							<li class="group"><p><code>String 	name()</code> -- 返回此枚举常量的名称</p></li>
							<li><p><code>int 	ordinal()</code> -- 返回枚举常量的序数</p></li>
							<li><p><code>int 	compareTo(E o)</code> -- 比较此枚举与指定对象的顺序</p></li>
							<li><p><code>Class&lt;E> 	getDeclaringClass()</code> -- 返回与此枚举常量的枚举类型相对应的 Class 对象</p></li>
							<li class="group"><p><code>boolean 	equals(Object other)</code> -- 当指定对象等于此枚举常量时，返回 true</p></li>
							<li><p><code>int 	hashCode()</code> -- 返回枚举常量的哈希码</p></li>
							<li><p><code>protected void 	finalize()</code> -- 枚举类不能有 finalize 方法</p></li>
							<li><p><code>String 	toString()</code> -- 返回枚举常量的名称</p></li>
							<li><p><code>protected Object 	clone()</code> -- 枚举类不能 clone，抛出异常</p></li>
							<li class="group"><p><code>static &lt;T extends Enum&lt;T>> T valueOf(String name)</code> -- 编译器自动生成的方法</p></li>
							<li><p><code>static &lt;T extends Enum&lt;T>>[] T values()</code> -- 编译器自动生成的方法</p></li>
						</ol>

                        <p><b>添加方法与自定义构造函数</b></p>
                        <pre class="brush: java;">
public enum Day {
    MONDAY("星期一"), TUESDAY("星期二"), WEDNESDAY("星期三"), THURSDAY("星期四"),
    FRIDAY("星期五"), SATURDAY("星期六"), SUNDAY("星期日"); // 最后一个分号不能少

    private String desc; // 中文描述

    private Day(String desc) { // 私有构造,防止被外部调用
        this.desc = desc;
    }

    public String getDesc(){ // 常规类的定义没区别
        return desc;
    }
}
</pre>

                        <p><b>定义抽象方法，每个枚举实例都实现该方法，以便产生不同的行为方式</b></p>
                        <pre class="brush: java;">
public enum Day {
    MONDAY {
        @Override
        public String getInfo() {
            return null;
        }
    }, FRIDAY {
        @Override
        public String getInfo() {
            return null;
        }
    };

    public abstract String getInfo();
}
                        </pre>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Package"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Class</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">Package 类</h5>
							<pre class="brush: java;">
public class Package implements AnnotatedElement {}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/Package.html" target="_blank">Package</a> 对象包含有关 Java 包的实现和规范的版本信息。通过用于加载类的 ClassLoader
								实例，可以获取并获得此版本信息。通常，此信息存储在与类一起分发的清单中。</p>
							<p>组成包的类集可以实现一个特定规范，如此一来，就可以通过规范标题、版本号和供应商字符串来标识该规范。应用程序可以询问包是否与特定版本兼容，有关详细信息，请参阅
								isCompatibleWith 方法。</p>
                            <p>在每一个 ClassLoader 实例中，<b>相同 java 包中的所有类都有相同的 Package 对象</b>。静态方法允许通过名称或当前类加载器已知的所有包的集合来找到包。 </p>
                            <ol>
                                <li><p><code>static Package 	getPackage(String name)</code> -- 如果 ClassLoader 加载了此包，则返回 Package；否则返回空</p>
                                <pre class="brush: java;">
/** 已知一个 App 源码结构如下：
 *  io.github.java.App.java
 *  io.github.java.helper.Log.java
 *  io.github.java.io.MyFile.java
 *  io.github.java.lang.MyPackage.java
 */
/** 代码总只使用了 MyPackage, App, Log, 那么以下输出为： */
Package.getPackage("io.github"); // null
Package.getPackage("io.github.jiwanger"); // 不为空
Package.getPackage("io.github.java.helper"); // null
Package.getPackage("io.github.java.lang"); // 不为空
                                </pre>
                                </li>
                                <li><p><code>static Package[] 	getPackages()</code> -- ClassLoader 实例当前已知的所有包</p></li>

                                <li class="group"><p><code>String 	getImplementationTitle()</code> -- 实现标题</p></li>
                                <li><p><code>String 	getSpecificationTitle()</code> -- 规范标题</p></li>
                                <li><p><code>String 	getImplementationVendor()</code> -- 实现供应商</p></li>
                                <li><p><code>String 	getSpecificationVendor()</code> -- 规范供应商</p></li>
                                <li><p><code>String 	getImplementationVersion()</code> -- 实现版本</p></li>
                                <li><p><code>String 	getSpecificationVersion()</code> -- 规范版本</p></li>

                                <li class="group"><p><code>&lt;A extends Annotation> A 	getAnnotation(Class&lt;A> annotationClass)</code> -- 存在该元素的指定类型的注释</p></li>
                                <li><p><code>Annotation[] 	getAnnotations()</code> -- 返回此元素上存在的所有注释</p></li>
                                <li><p><code>&lt;A extends Annotation> A 	getDeclaredAnnotation(Class&lt;A> annotationClass)</code> -- 返回直接存在于此元素上的指定注释</p></li>
                                <li><p><code>Annotation[] 	getDeclaredAnnotations()</code> -- 返回直接存在于此元素上的所有注释</p></li>
                                <li><p><code>&lt;A extends Annotation> A[] 	getAnnotationsByType(Class&lt;A> annotationClass)</code> -- 此元素上的指定类型注释</p></li>
                                <li><p><code>&lt;A extends Annotation> A[] 	getDeclaredAnnotationsByType(Class&lt;A> annotationClass)</code> -- 直接存在于此元素上的指定类型注释</p></li>
                                <li><p><code>boolean 	isAnnotationPresent(Class&lt;? extends Annotation> annotationClass)</code> -- 如果指定类型的注释存在于此元素上，则返回 true，否则返回 false</p></li>

                                <li class="group"><p><code>String 	getName()</code> -- 包的名称</p></li>
                                <li><p><code>boolean 	isSealed()</code> -- 是否密封</p></li>
                                <li><p><code>boolean 	isSealed(URL url)</code> -- 对于指定的代码源 url 是密封的</p></li>
                                <li><p><code>boolean 	isCompatibleWith(String desired)</code> -- 比较此包的规范版本和所需版本</p></li>
                            </ol>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-System"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">System</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.lang.System

public final class System {
    public final static InputStream in = null; // “标准”输入流
    public final static PrintStream out = null; // “标准”输出流
    public final static PrintStream err = null; // “标准”错误输出流
}
                            </pre>
							<p><a href="docs/docs-java/api/java/lang/System.html" target="_blank">System</a> 类代表系统，系统级的很多属性和控制方法都放置在该类的内部。</p>
							<p>System类内部包含 <code>in</code>、<code>out</code> 和 <code>err</code> 三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</p>
							<ol>
								<li><p><code>static void setIn(InputStream in)</code> -- 改变标准输入流</p></li>
                                <li><p><code>static void setOut(PrintStream out)</code> -- 改变标准输出流</p></li>
                                <li><p><code>static void setError(PrintStream out)</code> -- 改变标准错误流</p></li>

                                <li class="group"><p><code>static void setProperty(String key, String value)</code> -- 设置系统属性</p></li>
                                <li><p><code>static String getProperty(String key)</code> -- 获得系统属性</p></li>
                                <li><p><code>static StringgetProperty(String key, String def)</code> -- 获得系统属性，如果为空则返回默认值</p></li>
                                <li><p><code>static String clearProperty(String key)</code> -- 清除属性</p></li>
                                <li><p><code>static void 	setProperties(Properties props)</code> -- 将系统属性设置为 Properties 参数</p></li>
                                <li><p><code>static Properties getProperties()</code> -- 获得所有系统属性，参见: <a href="#Properties">java.util.Properties</a></p>
									<pre class="brush: java;">
//  所有的 property
Properties prop = System.getProperties();
prop.stringPropertyNames().forEach(s -> System.out.println(s + ":" + prop.getProperty(s)));

// 指定的 property
System.out.println(System.getProperty("os.name"));
// 如果没有指定的 property, 返回指定的 default
System.out.println(System.getProperty("os.name2", "default"));

// 自己定义属性
System.setProperty("property.define", "myProperty");

/** 系统属性: System.getProperties()
file.separator=/ 								目录分隔符
path.separator=: 								类路径分隔符
java.io.tmpdir=/tmp 							临时目录
line.separator= 								行分隔符(这里直接打印了换行)
user.dir=/home/nate/Desktop/git/MyApplication   当前运行的路径=
user.home=/home/nate 							用户主目录
file.encoding=UTF-8								文件编码

java.class.version=52.0       					class 文件版本
// 本地库路径
java.library.path=/home/nate/installed/android-studio/bin::/usr/java/packages/lib/i386:/lib:/usr/lib
java.class.path=/home/nate/installed/jdk1.8.0_65/jre/lib/charsets.jar:...   Java 库路径
java.home=/home/nate/installed/jdk1.8.0_65/jre 								Java 主目录
java.version=1.8.0_65 							Java 版本
java.specification.version=1.8     				简单版本
java.ext.dirs=/home/nate/installed/jdk1.8.0_65/jre/lib/ext:/usr/java/packages/lib/ext     	扩展类路径
sun.boot.class.path=/home/nate/installed/jdk1.8.0_65/jre/lib/resources.jar:...      		启动类路径

java.runtime.version=1.8.0_65-b17  			 			运行时 Java 版本
java.runtime.name=Java(TM) SE Runtime Environment  		运行时 Java 名称

sun.boot.library.path=/home/nate/installed/jdk1.8.0_65/jre/lib/i386  				Java 启动本地库路径

java.vm.version=25.65-b01
java.vm.specification.version=1.8
java.vm.vendor=Oracle Corporation
java.vm.name=Java HotSpot(TM) Server VM
java.vm.specification.name=Java Virtual Machine Specification
java.vm.specification.vendor=Oracle Corporation
java.vm.info=mixed mode

java.vendor=Oracle Corporation
java.vendor.url=http://java.oracle.com/
java.vendor.url.bug=http://bugreport.sun.com/bugreport/

file.encoding.pkg=sun.io

sun.java.launcher=SUN_STANDARD
sun.os.patch.level=unknown

java.specification.vendor=Oracle Corporation
java.specification.name=Java Platform API Specification
java.awt.graphicsenv=sun.awt.X11GraphicsEnvironment
java.awt.printerjob=sun.print.PSPrinterJob
java.endorsed.dirs=/home/nate/installed/jdk1.8.0_65/jre/lib/endorsed
awt.toolkit=sun.awt.X11.XToolkit

os.arch=i386
os.name=Linux
os.version=3.13.0-24-generic

user.name=nate
user.language=en
user.country=GB
user.timezone=

sun.jnu.encoding=UTF-8
sun.arch.data.model=32
sun.management.compiler=HotSpot Tiered Compilers
sun.desktop=gnome
sun.java.command=io.github.java.App
sun.cpu.endian=little
sun.io.unicode.encoding=UnicodeLittle
sun.cpu.isalist=
*/
</pre>
								</li>

                                <li class="group"><p><code>static String getenv(String name)</code> -- 获得环境变量</p></li>
                                <li><p><code>static String getenv()</code> -- 获得所有环境变量</p>
									<pre class="brush: java;">
//  所有的 env
Map&lt;String, String> env = System.getenv();
Iterator&lt;String> it = env.keySet().iterator();
while(it.hasNext()) {
	String key = it.next();
	System.out.println(key + ":" + env.get(key));
}

// 指定 env
System.out.println(System.getenv("PATH"));
</pre>
								</li>

                                <li class="group"><p><code>static native long currentTimeMillis()</code> -- 自 1970 年 1 月 1 日 0 时起的毫秒数</p></li>
                                <li><p><code>static long 	nanoTime()</code> -- 返回最准确的可用系统计时器的当前值，以纳秒秒为单位</p>
                                <pre class="brush: java;">
/** currentTimeMillis() -- 自 1970 年 1 月 1 日 0 时起的毫秒数
 * nanoTime() -- 返回的时间点是随机的，不是 1970 年..., 但是对于同一个JVM里，不同地方使用到的基点时间是一样的
 */
long start = System.nanoTime();
...
long time = System.nanoTime() - start;

Date date = new Data(System.currentTimeMillis());
                                </pre>
                                </li>

                                <li class="group"><p><code>static void exit(int status)</code> -- 退出程序(调用 Runtime 的 exit) </p>
                                <li><p><code>static void gc()</code> -- 请求系统进行垃圾回收</p></li>
                                <li><p><code>static Console 	console()</code> -- 返回与当前 Java 虚拟机关联的唯一 Console 对象(JVM 在命令行中被调用，并且输入/输出未被重定向)</p></li>
                                <li><p><code>static void 	runFinalization()</code> -- 运行处于挂起终止状态的所有对象的终止方法</p></li>
                                <li><p><code>static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code> -- 该方法的作用是数组拷贝。比使用循环更高效。</p>
                                    <pre class="brush: java;">
int[] a = { 1, 2, 3, 4 };
int[] b = new int[5];

// 将数组a中，从下标为1开始，复制到数组b从下标3开始的位置，总共复制2个。b -> 0 0 0 2 3
System.arraycopy(a, 1, b, 3, 2);
</pre>
                                </li>

                                <li class="group"><p><code>static void load(String filename)</code> -- 主要用来加载动态链接库</p></li>
                                <li><p><code>static String 	mapLibraryName(String libname)</code> -- 将一个库名称映射到特定于平台的、表示本机库的字符串中</p></li>
                                <li><p><code>static void loadLibrary(String libname)</code> -- 主要用来加载动态链接库, JNI 中使用, 实例参见:
                                    <a href="index.html#java-jni">Java 本地编程 - JNI</a></p></li>

                                <li class="group"><p><code>static void setSecurityManager(final SecurityManager s)</code> -- 设置安全管理器</p></li>
                                <li><p><code>static getSecurityManager()</code> -- 获得安全管理器</p></li>
                                <li><p><code>static int 	identityHashCode(Object x)</code> -- 返回给定对象的哈希码，该代码与默认的方法 hashCode() 返回的代码一样，无论给定对象的类是否重写 hashCode()。</p></li>
                                <li><p><code>static Channel 	inheritedChannel()</code> -- 返回从创建此 Java 虚拟机的实体中继承的信道。</p></li>

							</ol>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Runtime"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Runtime / Process</h3>
					</div>
					<div class="panel-body">

						<div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.lang.Runtime

public class Runtime {
     private Runtime() {}
}
</pre>

                            <p>每个 Java 应用程序都有一个 <a href="docs/docs-java/api/java/lang/Runtime.html" target="_blank">Runtime</a> 类实例，使应用程序能够与其运行的环境相连接。可以通过
								getRuntime 方法获取当前运行时。 应用程序不能创建自己的 Runtime 类实例。</p>

                            <ol>
                                <li><p><code>static Runtime 	getRuntime()</code> -- 返回与当前 Java 应用程序相关的运行时对象。</p></li>

                                <li class="group"><p><code>int 	availableProcessors()</code> -- 向 Java 虚拟机返回可用处理器的数目。</p></li>
                                <li><p><code>long 	maxMemory()</code> --  JVM 能从系统分配到的最大内存总量，字节为单位</p></li>
                                <li><p><code>long 	totalMemory()</code> -- JVM 已经分配到的内存总量，字节为单位，<code>-Xms</code> 参数会影响此值</p></li>
                                <li><p><code>long 	freeMemory()</code> -- 已经分配到但是空闲的内存量，字节为单位</p></li>

                                <li class="group"><p><code>Process 	exec(String command)</code> -- 在单独的进程中执行指定的字符串命令。</p></li>
                                <li><p><code>Process 	exec(String command, String[] envp)</code> -- 在指定环境的单独进程中执行指定的字符串命令。</p></li>
                                <li><p><code>Process 	exec(String command, String[] envp, File dir)</code> -- 在有指定环境和工作目录的独立进程中执行指定的字符串命令。</p></li>
                                <li><p><code>Process 	exec(String[] cmdarray)</code> -- 在单独的进程中执行指定命令和变量。</p></li>
                                <li><p><code>Process 	exec(String[] cmdarray, String[] envp)</code> -- 在指定环境的独立进程中执行指定命令和变量。</p></li>
                                <li><p><code>Process 	exec(String[] cmdarray, String[] envp, File dir)</code> -- 在指定环境和工作目录的独立进程中执行指定的命令和变量。</p>
                                <pre class="brush: java;">
Runtime r = Runtime.getRuntime();
Process process = r.exec("ls");
InputStream in = process.getInputStream();
...

/** 当 exec 使用管道符和重定向时候，最好使用以下方法： */
Process process = r.exec(new String[]{"/bin/bash", "-c", "ls >> log.log"});
...
</pre>
                                </li>

                                <li class="group"><p><code>void 	addShutdownHook(Thread hook)</code> -- 注册新的虚拟机来关闭钩子。</p></li>
                                <li><p><code>boolean 	removeShutdownHook(Thread hook)</code> -- 取消注册某个先前已注册的虚拟机关闭钩子。</p></li>

                                <li class="group"><p><code>void 	exit(int status)</code> -- 通过启动虚拟机的关闭序列，终止当前正在运行的 Java 虚拟机。</p></li>
                                <li><p><code>void 	halt(int status)</code> -- 强行终止目前正在运行的 Java 虚拟机(不会运行关闭回调)。</p></li>
                                <li><p><code>void 	gc()</code> -- 运行垃圾回收器。</p></li>
                                <li><p><code>void 	load(String filename)</code> -- 加载作为动态库的指定文件名。</p></li>
                                <li><p><code>void 	loadLibrary(String libname)</code> -- 加载具有指定库名的动态库。</p></li>
                                <li><p><code>void 	runFinalization()</code> -- 运行挂起 finalization 的所有对象的终止方法。</p></li>

                                <li class="group"><p><code>void 	traceInstructions(boolean on)</code> -- 启用／禁用指令跟踪。</p></li>
                                <li><p><code>void 	traceMethodCalls(boolean on)</code> -- 启用／禁用方法调用跟踪。</p></li>


                            </ol>

						</div>

                        <div class="sub-item">
                            <p><b>Process</b></p>
                            <p>ProcessBuilder.start() 和 Runtime.exec 方法创建一个本机进程，并返回
                                Process 子类的一个实例，该实例可用来控制进程并获得相关信息。Process
                                类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程的方法。</p>
                            <p>创建进程的方法可能无法针对某些本机平台上的特定进程很好地工作，比如，本机窗口进程，守护进程，Microsoft
                                Windows 上的 Win16/DOS 进程，或者 shell 脚本。创建的子进程没有自己的终端或控制台。它的所有标准
                                io（即 stdin、stdout 和 stderr）操作都将通过三个流
                                (getOutputStream()、getInputStream() 和 getErrorStream())
                                重定向到父进程。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。因为有些本机平台仅针对标准输入和输出流提供有限的缓冲区大小，如果读写子进程的输出流或输入流迅速出现失败，则可能导致子进程阻塞，甚至产生死锁。
                            </p>
                            <p>当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。</p>
                            <p>对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</p>

							<ol>

								<li><p><code>abstract  void 	destroy()</code> -- 杀掉子进程。</p></li>
								<li><p><code>abstract  int 	exitValue()</code> -- 返回子进程的出口值。</p></li>
								<li><p><code>abstract  InputStream 	getErrorStream()</code> -- 获取子进程的错误流。</p></li>
								<li><p><code>abstract  InputStream 	getInputStream()</code> -- 获取子进程的输入流。</p></li>
								<li><p><code>abstract  OutputStream 	getOutputStream()</code> -- 获取子进程的输出流。</p></li>
								<li><p><code>abstract  int 	waitFor()</code> -- 导致当前线程等待，如有必要，一直要等到由该 Process 对象表示的进程已经终止。</p></li>
							</ol>
                        </div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Thread"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Thread 与 ThreadGroup</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.lang.Thread

public class Thread implements Runnable {
    /** 线程状态 */
    public enum State {
        NEW, // 至今尚未启动的线程处于这种状态。
        RUNNABLE, // 正在 Java 虚拟机中执行的线程处于这种状态。
        BLOCKED, // 受阻塞并等待某个监视器锁的线程处于这种状态。
        WAITING, // 无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。
        TIMED_WAITING, // 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。
        TERMINATED, // 已退出的线程处于这种状态。
    }

    /** 未捕获的异常回调接口 */
    public interface UncaughtExceptionHandler {
        void uncaughtException(Thread t, Throwable e);
    }

    public static int MAX_PRIORITY; // 线程可以具有的最高优先级。
    public static int 	MIN_PRIORITY; // 线程可以具有的最低优先级。
    public static int 	NORM_PRIORITY; // 分配给线程的默认优先级。

    public Thread() {}
    public Thread(String name) {}
    public Thread(Runnable target) {}
    public Thread(Runnable target, String name) {}
    public Thread(ThreadGroup group, String name) {}
    public Thread(ThreadGroup group, Runnable target) {}
    public Thread(ThreadGroup group, Runnable target, String name) {}
    public Thread(ThreadGroup group, Runnable target, String name, long stackSize) {}
}

/** 为非 Thread 子类的类提供了一种激活方式 */
public interface Runnable {
    void run();
}
                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/Thread.html" target="_blank">Thread</a> 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。 </p>
                            <p>每个线程都有一个标识名，多个线程可以同名。如果线程创建时没有指定标识名，就会为其生成一个新名称。</p>
                            <p>每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。每个线程都可以或不可以标记为一个守护程序。当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护程序。
                            </p>
                            <p>当 Java 虚拟机启动时，通常都会有单个非守护线程（它通常会调用某个指定类的 main 方法）。Java 虚拟机会继续执行线程，直到下列任一情况出现时为止：
                            </p>
                            <ul>
                                <li><p>调用了 Runtime 类的 exit 方法，并且安全管理器允许退出操作发生。</p></li>
                                <li><p>非守护线程的所有线程都已停止运行，无论是通过从对 run 方法的调用中返回，还是通过抛出一个传播到 run 方法之外的异常。</p></li>
                            </ul>

                            <ol>
                                <li><p><code>static void 	setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code> -- 设置未捕获到异常而突然终止时调用的默认处理程序</p></li>
                                <li><p><code>static Thread.UncaughtExceptionHandler 	getDefaultUncaughtExceptionHandler()</code> -- 获取未捕获到异常而突然终止时调用的默认处理程序</p></li>

                                <li class="group"><p><code>static boolean 	interrupted()</code> -- 测试当前线程是否已经中断</p></li>
                                <li><p><code>static void 	sleep(long millis)</code> -- 当前线程休眠指定毫秒数</p></li>
                                <li><p><code>static void 	sleep(long millis, int nanos)</code> -- 当前线程休眠指定毫秒数+纳秒数目</p></li>
                                <li><p><code>static void 	yield()</code> -- 暂停当前正在执行的线程对象，并执行其他线程</p></li>

                                <li class="group"><p><code>static int 	activeCount()</code> -- 当前线程的线程组中活动线程的数目</p></li>
                                <li><p><code>static int 	enumerate(Thread[] tarray)</code> -- 将当前线程的线程组及其子组中的每一个活动线程复制到指定的数组中</p></li>
                                <li><p><code>static void 	dumpStack()</code> -- 将当前线程的堆栈跟踪打印至标准错误流</p></li>
                                <li><p><code>static Map&lt;Thread, StackTraceElement[]> 	getAllStackTraces()</code> -- 返回所有活动线程的堆栈跟踪的一个映射</p></li>
                                <li><p><code>static Thread 	currentThread()</code> -- 当前线程</p></li>
                                <li><p><code>static boolean 	holdsLock(Object obj)</code> -- 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true</p></li>

                                <li class="group"><p><code>void 	setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code> -- 设置该线程由于未捕获到异常而突然终止时调用的处理程序</p></li>
                                <li><p><code>Thread.UncaughtExceptionHandler 	getUncaughtExceptionHandler()</code> -- 获取该线程由于未捕获到异常而突然终止时调用的处理程序</p></li>

                                <li class="group"><p><code>void 	setPriority(int newPriority)</code> -- 更改线程的优先级</p></li>
                                <li><p><code>int 	getPriority()</code> -- 获取线程优先级</p></li>
                                <li><p><code>void 	setName(String name)</code> -- 更改线程的名字</p></li>
                                <li><p><code>String 	getName()</code> -- 获取线程名字</p></li>
                                <li><p><code>long 	getId()</code> -- 获取线程 ID</p></li>
                                <li><p><code>void 	setDaemon(boolean on)</code> --  将该线程标记为守护线程或用户线程，<code>在命令行程序中，不会等待守护线程运行完成程序可能就退出了</code></p></li>
                                <li><p><code>boolean 	isDaemon()</code> -- 是否为守护线程</p></li>

                                <li class="group"><p><code>void 	start()</code> --  使该线程开始执行；Java 虚拟机调用该线程的 run 方法</p></li>
                                <li><p><code>void 	run()</code> -- 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回</p></li>
                                <li><p><code>void 	interrupt()</code> -- 中断线程</p></li>
                                <li><p><code>boolean 	isInterrupted()</code> -- 是否已经中断</p></li>
                                <li><p><code>boolean 	isAlive()</code> -- 测试线程是否处于活动状态</p></li>
                                <li><p><code>Thread.State 	getState()</code> -- 返回该线程的状态</p></li>
                                <li><p><code>void 	checkAccess()</code> -- 判定当前运行的线程是否有权修改该线程</p></li>
                                <li><p><code>void 	join()</code> -- 等待该线程终止</p></li>
                                <li><p><code>void 	join(long millis)</code> -- 等待该线程终止的时间最长为 millis 毫秒</p></li>
                                <li><p><code>void 	join(long millis, int nanos)</code> -- 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</p></li>

                                <li class="group"><p><code>ThreadGroup 	getThreadGroup()</code> -- 返回该线程所属的线程组</p></li>
                                <li><p><code>StackTraceElement[] 	getStackTrace()</code> -- 返回一个表示该线程堆栈转储的堆栈跟踪元素数组</p></li>
                                <li><p><code>ClassLoader 	getContextClassLoader()</code> -- 返回该线程的上下文 ClassLoader</p></li>
                                <li><p><code>void 	setContextClassLoader(ClassLoader cl)</code> -- 设置该线程的上下文 ClassLoader</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class ThreadGroup implements Thread.UncaughtExceptionHandler {
    public ThreadGroup(String name) {}
    public ThreadGroup(ThreadGroup parent, String name) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/ThreadGroup.html" target="_blank">ThreadGroup</a> 表示一个线程的集合。此外，线程组也可以包含其他线程组。线程组构成一棵树，在树中，除了初始线程组外，每个线程组都有一个父线程组。 </p>
                            <p>允许线程访问有关自己的线程组的信息，但是不允许它访问有关其线程组的父线程组或其他任何线程组的信息。 </p>
                            <ol>

                                <li><p><code>int 	activeCount()</code> -- 返回此线程组中活动线程的估计数。</p></li>
                                <li><p><code>int 	activeGroupCount()</code> -- 返回此线程组中活动线程组的估计数。</p></li>

                                <li class="group"><p><code>int 	enumerate(Thread[] list)</code> -- 把此线程组及其子组中的所有活动线程复制到指定数组中。</p></li>
                                <li><p><code>int 	enumerate(Thread[] list, boolean recurse)</code> -- 把此线程组中的所有活动线程复制到指定数组中。</p></li>
                                <li><p><code>int 	enumerate(ThreadGroup[] list)</code> -- 把对此线程组中的所有活动子组的引用复制到指定数组中。</p></li>
                                <li><p><code>int 	enumerate(ThreadGroup[] list, boolean recurse)</code> -- 把对此线程组中的所有活动子组的引用复制到指定数组中。</p></li>

                                <li class="group"><p><code>int 	getMaxPriority()</code> -- 返回此线程组的最高优先级。</p></li>
                                <li><p><code>void 	setMaxPriority(int pri)</code> -- 设置线程组的最高优先级。</p></li>
                                <li><p><code>String 	getName()</code> -- 返回此线程组的名称。</p></li>
                                <li><p><code>ThreadGroup 	getParent()</code> -- 返回此线程组的父线程组。</p></li>
                                <li><p><code>void 	setDaemon(boolean daemon)</code> -- 更改此线程组的后台程序状态。</p></li>
                                <li><p><code>boolean 	isDaemon()</code> -- 测试此线程组是否为一个后台程序线程组。</p></li>
                                <li><p><code>void 	interrupt()</code> -- 中断此线程组中的所有线程。</p></li>
                                <li><p><code>void 	destroy()</code> -- 销毁此线程组及其所有子组。</p></li>
                                <li><p><code>boolean 	isDestroyed()</code> -- 测试此线程组是否已经被销毁。</p></li>
                                <li><p><code>void 	checkAccess()</code> -- 确定当前运行的线程是否有权修改此线程组。</p></li>

                                <li class="group"><p><code>void 	list()</code> -- 将有关此线程组的信息打印到标准输出。</p></li>
                                <li><p><code>boolean 	parentOf(ThreadGroup g)</code> -- 测试此线程组是否为线程组参数或其祖先线程组之一。</p></li>
                                <li><p><code>String 	toString()</code> -- 返回此线程组的字符串表示形式。</p></li>
                                <li><p><code>void 	uncaughtException(Thread t, Throwable e)</code> -- 当此线程组中的线程因为一个未捕获的异常而停止，并且线程没有安装特定 Thread.UncaughtExceptionHandler 时，由 Java Virtual Machine 调用此方法。</p></li>
                            </ol>
                        </div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-String"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">String 相关类</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.lang.String

public final class String implements Serializable, Comparable&lt;String>, CharSequence {
    public String() {}
    public String(String original) {}
    public String(StringBuffer buffer) {}
    public String(StringBuilder builder)

    public String(byte[] bytes) {}
    public String(byte[] bytes, Charset charset) {}
    public String(byte[] bytes, int offset, int length) {}
    public String(byte[] bytes, int offset, int length, Charset charset) {}
    public String(byte[] bytes, int offset, int length, String charsetName) {}
    public String(byte[] bytes, String charsetName) {}

    public String(char[] value) {}
    public String(char[] value, int offset, int count) {}

    public String(int[] codePoints, int offset, int count) {}
}

/** CharSequence 是 char 值的一个可读序列。此接口对许多不同种类的 char 序列提供统一的只读访问。
 *      char 值表示 Unicode 的 Basic Multilingual Plane (BMP字符平面) 或代理项中的一个字符。
 * 此接口不修改 equals 和 hashCode 方法的常规协定。因此，通常未定义比较实现 CharSequence 的两个对象的结果。
 *      每个对象都可以通过一个不同的类实现，而且不能保证每个类能够测试其实例与其他类的实例的相等性。
 *      因此，使用任意 CharSequence 实例作为集合中的元素或映射中的键是不合适的。
 */
public interface CharSequence {
    char charAt(int index); // 返回指定索引的 char 值。
    int length(); // 返回此字符序列的长度。
    CharSequence subSequence(int start, int end); // 返回一个新的 CharSequence，它是此序列的子序列。
    String toString(); // 返回一个包含此序列中字符的字符串，该字符串与此序列的顺序相同。
}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/String.html" target="_blank">String</a> 类代表字符串。Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。</p>
                            <p><a href="docs/docs-java/api/java/lang/String.html" target="_blank">String</a> 在创建之后不能更改。字符串缓冲区支持可变的字符串。</p>
                            <p><a href="docs/docs-java/api/java/lang/String.html" target="_blank">String</a> 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。大小写映射基于 Character 类指定的 Unicode 标准版。 </p>
                            <p>Java 语言提供对字符串串联符号（"+"）以及将其他对象转换为字符串的特殊支持。字符串串联是通过 StringBuilder（或 StringBuffer）类及其 append 方法实现的。字符串转换是通过 toString 方法实现的，该方法由 Object 类定义，并可被 Java 中的所有类继承。</p>
                            <ol>

                                <li class="group"><p><code>static String 	copyValueOf(char[] data)</code> -- 返回指定数组中表示该字符序列的 String。</p></li>
                                <li><p><code>static String 	copyValueOf(char[] data, int offset, int count)</code> -- 返回指定数组中表示该字符序列的 String。</p></li>

                                <li class="group"><p><code>static String 	format(String format, Object... args)</code> -- 格式化字符串，参见: <a href="#java-util-Formatter">Formatter</a></p></li>
                                <li><p><code>static String 	format(Locale l, String format, Object... args)</code> -- 用指定的语言环境格式化字符串，参见: <a href="#java-util-Formatter">Formatter</a></p>
                                    <pre class="brush: java;">
/** 两个格式化方法都是使用 java.util.Formatter 来进行操作的: */
public static String format(String format, Object... args) {
    return new Formatter().format(format, args).toString();
}
</pre>
                                </li>

                                <li class="group"><p><code>static String 	valueOf(boolean b)</code> -- 返回 boolean 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(char c)</code> -- 返回 char 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(char[] data)</code> -- 返回 char 数组参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(char[] data, int offset, int count)</code> -- 返回 char 数组参数的特定子数组的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(double d)</code> -- 返回 double 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(float f)</code> -- 返回 float 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(int i)</code> -- 返回 int 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(long l)</code> -- 返回 long 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(Object obj)</code> -- 返回 Object 参数的字符串表示形式。</p></li>

                                <li class="group"><p><code>static String join(CharSequence delimiter, CharSequence... elements)</code> -- 在 elements 间插入 delimiter，连接成一个 String, JAVA8 添加</p></li>
                                <li><p><code>static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence> elements)</code> -- 同上，JAVA8 添加</p>
                                    <pre class="brush: java;">
String jo = String.join("-", "abc", "def", "hi");
// jo == "abc-def-hi";
</pre>
                                </li>

                                <li class="group"><p><code>int 	length()</code> -- 返回此字符串的长度</p></li>
                                <li><p><code>boolean 	isEmpty()</code> -- 当且仅当 length() 为 0 时返回 true</p></li>
                                <li><p><code>int 	indexOf(int ch)</code> -- 返回指定字符在此字符串中第一次出现处的索引</p></li>
                                <li><p><code>int 	indexOf(int ch, int fromIndex)</code> -- 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索</p></li>
                                <li><p><code>int 	indexOf(String str)</code> -- 返回指定子字符串在此字符串中第一次出现处的索引</p></li>
                                <li><p><code>int 	indexOf(String str, int fromIndex)</code> -- 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</p></li>
                                <li><p><code>int 	lastIndexOf(int ch)</code> -- 返回指定字符在此字符串中最后一次出现处的索引</p></li>
                                <li><p><code>int 	lastIndexOf(int ch, int fromIndex)</code> -- 指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始</p></li>
                                <li><p><code>int 	lastIndexOf(String str)</code> -- 返回指定子字符串在此字符串中最右边出现处的索引</p></li>
                                <li><p><code>int 	lastIndexOf(String str, int fromIndex)</code> -- 指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始</p></li>

                                <li class="group"><p><code>char 	charAt(int index)</code> -- 指定索引处的 char 值</p></li>
                                <li><p><code>int 	codePointAt(int index)</code> -- 返回指定索引处的字符 Unicode 编码, <a href="https://zh.wikibooks.org/wiki/Unicode" target="_blank">Unicode 编码查询</a></p>
                                <pre class="brush: java;">
/** 可从 Unicode 编码查询到以下结果：
 * "陈".codePointAt(0) -- 结果为 38472, 十六进制为 9648
 * "茂".codePointAt(0) -- 结果为 33538, 十六进制为 8302
 */
</pre>
                                </li>
                                <li><p><code>int 	codePointBefore(int index)</code> -- 基本等同于 <code>codePointAt(index - 1)</code></p></li>
                                <li><p><code>int 	offsetByCodePoints(int index, int codePointOffset)</code> -- 返回此 String 中从给定的 index 处偏移 codePointOffset 个代码点的索引</p></li>
                                <li><p><code>int 	codePointCount(int beginIndex, int endIndex)</code> -- 在求 Unicode 非 BMP(<a href="../tips/charset.html">Unicode</a>) 平面字符数目时候使用</p>
                                <pre class="brush: java;">
/** 常用的 UniCode 字符使用一个代码单元就可以表示，但有些辅助字符需要一对代码单元表示
 * 比如整数集合的数学符号 '𝕫', 不是字母 'z', Unicode 代码点是 U+1D56B, 但它的代理单元是 U+D835 和 U+DD6B
 * 如果令字符串 str = "\u1D56B", 而是一个代码点 '\u1D56' 和字符 'B', 它的代码点数是 2，代码单元数也是 2;
 * 但如果令字符 str = "\uD835\uDD6B", str.lenght == 2, str.codePointCount(0, 2) == 1.
 */

// 字面为：“陈茂𝕫”, 是整数集合的数学符号 '𝕫', 不是字母 'z'
String s1 = "\u9648\u8302\uD835\uDD6B";
String s2 = "陈茂𝕫";
log(s1.equals(s2)); // true
log(s1, s2); // 陈茂𝕫
log(s1.codePointCount(0, 4), s2.codePointCount(0, 4)); // 长度为 3
log(s1.length(), s2.length()); // 长度为 4
                                </pre>
                                </li>

                                <li class="group"><p><code>int 	compareTo(String anotherString)</code> --   按字典顺序比较两个字符串</p></li>
                                <li><p><code>int 	compareToIgnoreCase(String str)</code> -- 按字典顺序比较两个字符串，不考虑大小写</p></li>
                                <li><p><code>boolean 	contains(CharSequence s)</code> -- 当且仅当此字符串包含指定的 char 值序列时</p></li>
                                <li><p><code>boolean 	endsWith(String suffix)</code> -- 测试此字符串是否以指定的后缀结束</p></li>
                                <li><p><code>boolean 	startsWith(String prefix)</code> -- 测试此字符串是否以指定的前缀开始</p></li>
                                <li><p><code>boolean 	startsWith(String prefix, int toffset)</code> -- 测试此字符串从指定索引开始的子字符串是否以指定前缀开始</p></li>
                                <li><p><code>boolean 	equals(Object anObject)</code> -- 将此字符串与指定的对象比较</p></li>
                                <li><p><code>boolean 	equalsIgnoreCase(String anotherString)</code> -- 将此 String 与另一个 String 比较，不考虑大小写</p></li>
                                <li><p><code>boolean 	matches(String regex)</code> -- 告知此字符串是否匹配给定的正则表达式,参见： <a href="../regex/regexp-java.html">Regex In Java</a></p></li>
                                <li><p><code>boolean 	regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</code> -- 测试两个字符串区域是否相等</p></li>
                                <li><p><code>boolean 	regionMatches(int toffset, String other, int ooffset, int len)</code> -- 测试两个字符串区域是否相等</p></li>
                                <li><p><code>boolean 	contentEquals(CharSequence cs)</code> -- 将此字符串与指定的 CharSequence 比较</p></li>
                                <li><p><code>boolean 	contentEquals(StringBuffer sb)</code> -- 将此字符串与指定的 StringBuffer 比较</p></li>

                                <li class="group"><p><code>byte[] 	getBytes()</code> --  使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中</p></li>
                                <li><p><code>byte[] 	getBytes(Charset charset)</code> -- 使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组</p></li>
                                <li><p><code>byte[] 	getBytes(String charsetName)</code> -- 使用指定的字符集将此 String 编码为 byte 序列，并存储到一个新的 byte 数组中</p>
                                    <pre class="brush: java;">
/** 可用于将字符串转码，将 iso8895-1 转换为 utf-8 */
String keyword = request.getParameter("key");
keyword = new String(keyword.getBytes("iso8859-1"), "utf-8");
</pre>
                                </li>


                                <li class="group"><p><code>String 	replace(char oldChar, char newChar)</code> -- 用 newChar 替换所有 oldChar，并返回一个新的字符串</p></li>
                                <li><p><code>String 	replace(CharSequence target, CharSequence replacement)</code> -- 用 replacement 替换所有 target，返回新的字符串</p></li>
                                <li><p><code>String 	replaceAll(String regex, String replacement)</code> -- 用 replacement 替换所有匹配给定的正则表达式的子字符串</p></li>
                                <li><p><code>String 	replaceFirst(String regex, String replacement)</code> --  用 replacement 替换匹配给定的正则表达式的第一个子串</p></li>

                                <li class="group"><p><code>String 	toLowerCase()</code> -- 使用默认语言环境的规则将此 String 中的所有字符都转换为小写</p></li>
                                <li><p><code>String 	toLowerCase(Locale locale)</code> -- 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写</p></li>
                                <li><p><code>String 	toUpperCase()</code> -- 使用默认语言环境的规则将此 String 中的所有字符都转换为大写</p></li>
                                <li><p><code>String 	toUpperCase(Locale locale)</code> -- 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写</p></li>

                                <li class="group"><p><code>String[] 	split(String regex)</code> -- 根据给定正则表达式的匹配拆分此字符串</p></li>
                                <li><p><code>String[] 	split(String regex, int limit)</code> -- 同上，但是最多分为 limit 组</p>
                                    <pre class="brush: java;">
String s = "Hello Everyone! Today is Monday!";
for (String s1 : s.split(" ")) {
    log(s1); // {"Hello", "Everyone!", "Today", "is", "Monday!"}
}
for (String s1 : s.split(" ", 2)) {
    log(s1); // {"Hello", "Everyone! Today is Monday!"}
}

// 如果使用正则表达式的特殊字符 .$|()[{^?*+\ 分割，则必须做如下处理，如：
for (String s1 : "One|Two|Three".split("\\|")) {
    log(s1);
}
</pre>
                                </li>

                                <li class="group"><p><code>String 	substring(int beginIndex)</code> -- 返回从 beginIndex 到结尾的新的子串</p></li>
                                <li><p><code>String 	substring(int beginIndex, int endIndex)</code> -- 返回从 beginIndex 到 endIndex 的新的子串</p></li>
                                <li><p><code>CharSequence 	subSequence(int beginIndex, int endIndex)</code> -- 返回从 beginIndex 到 endIndex 的新的子串</p></li>

                                <li class="group"><p><code>String 	intern()</code> -- 类 String 私有地维护一个初始为空的字符串池， 当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。</p>
                                    <pre class="brush: java;">
/** str1.intern() 发现常量池中不存在 “SEUCalvin”，因此指向了 str1。
 *  "SEUCalvin" 在常量池中创建时，也就直接指向了 str1 了。两个都返回 true 就理所当然啦。
 */
String str1 = new String("SEU") + new String("Calvin");
log(str1.intern() == str1, str1 == "SEUCalvin"); // false, false

/** s2 先在常量池中创建了 “MyCalvin”，那么 s3.intern() 当然就直接指向了 s2，你可以去验证它们两个是返回的 true。
 * 后面的 "MyCalvin" 也一样指向 s2。所以谁都不搭理在堆空间中的 s3 了，所以都返回了 false。
 */
String s2 = "MyCalvin"; // 新加的一行代码，其余不变
String s3 = new String("My") + new String("Calvin");
log(s3.intern() == s3, s3 == "SEUCalvin"); // true, true
</pre>
                                </li>
                                <li><p><code>String 	concat(String str)</code> -- 将指定字符串连接到此字符串的结尾，并返回一个新的字符串</p></li>
                                <li><p><code>String 	trim()</code> -- 截去字符串开头和末尾的空白</p></li>
                                <li><p><code>void 	getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code> -- 将字符从此字符串复制到目标字符数组</p></li>
                                <li><p><code>char[] 	toCharArray()</code> -- 将此字符串转换为一个新的字符数组</p></li>
                                <li><p><code>int 	hashCode()</code> -- 返回此字符串的哈希码</p></li>
                                <li><p><code>String 	toString()</code> -- 返回此对象本身</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.lang.AbstractStringBuilder
        java.lang.StringBuffer
        java.lang.StringBuilder

public final class StringBuffer  extends AbstractStringBuilder implements Serializable, CharSequence {
    public StringBuffer() {} // 构造一个其中不带字符的字符串生成器，初始容量为 16 个字符。
    public StringBuffer(CharSequence seq) {} // 构造一个字符串生成器，包含与指定的 CharSequence 相同的字符。
    public StringBuffer(int capacity) {} //  构造一个其中不带字符的字符串生成器，初始容量由 capacity 参数指定。
    public StringBuffer(String str) {} // 构造一个字符串生成器，并初始化为指定的字符串内容
}

public final class StringBuffer extends AbstractStringBuilder
                                implements java.io.Serializable, CharSequence {
    public StringBuilder() {} // 构造一个其中不带字符的字符串生成器，初始容量为 16 个字符。
    public StringBuilder(CharSequence seq) {} // 构造一个字符串生成器，包含与指定的 CharSequence 相同的字符。
    public StringBuilder(int capacity) {} //  构造一个其中不带字符的字符串生成器，初始容量由 capacity 参数指定。
    public StringBuilder(String str) {} // 构造一个字符串生成器，并初始化为指定的字符串内容
}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/StringBuffer.html" target="_blank">StringBuffer</a> 是线程安全的可变字符序列。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 </p>
                            <p>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。 </p>
                            <p>每个字符串缓冲区都有一定的容量。只要字符串缓冲区所包含的字符序列的长度没有超出此容量，就无需分配新的内部缓冲区数组。如果内部缓冲区溢出，则此容量自动增大。从 JDK 5 开始，为该类补充了一个单个线程使用的等价类，即 StringBuilder。与该类相比，通常应该优先使用 StringBuilder 类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。</p>

                            <p><a href="docs/docs-java/api/java/lang/StringBuilder.html" target="_blank">StringBuilder</a> 提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。 </p>

                            <p>在 StringBuilder 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。append 方法始终将这些字符添加到生成器的末端；而 insert 方法则在指定的点添加字符。 </p>
                            <p>将 StringBuilder 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用 StringBuffer。 </p>

                            <p><a href="docs/docs-java/api/java/lang/StringBuilder.html" target="_blank">StringBuilder</a> 和 <a href="docs/docs-java/api/java/lang/StringBuffer.html" target="_blank">StringBuffer</a> 除了构造方法，其他方法都是来自 AbstractStringBuilder 类，但是二者都简单覆写了: 调用父类处理，并返回自身，如下：</p>
                            <pre class="brush: java;">
/** StringBuffer 都有 synchronized 修饰符，线程安全的 */
@Override
public synchronized StringBuffer append(boolean b) {
    toStringCache = null;
    super.append(b);
    return this;
}

/** StringBuidler 无 synchronized 修饰符，单线程操作，速度较快 */
@Override
public StringBuffer append(boolean b) {
    toStringCache = null;
    super.append(b);
    return this;
}

...
</pre>
                            <ol>

                                <li><p><code>StringBuffer / StringBuilder 	append(boolean/char/char[]/CharSequence/double/float/int/long/Object/String/StringBuffer b)</code> -- 添加各种类型到该序列</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	append(char[] str, int offset, int len)</code> -- 偏移 offset 长度为 len 添加到该序列</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	append(CharSequence s, int start, int end)</code> -- 指定 start 和 end 到该序列</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	appendCodePoint(int codePoint)</code> -- 添加 Unicode 代码点表示的字符到该序列</p></li>

                                <li class="group"><p><code>StringBuffer / StringBuilder 	insert(int offset, boolean/char/char[]/CharSequence/double/float/int/long/Object/String b)</code> -- 从指定位置插入到此序列</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	insert(int index, char[] str, int offset, int len)</code> -- 从指定位置插入到此序列</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	insert(int dstOffset, CharSequence s, int start, int end)</code> -- 从指定位置插入到此序列</p></li>

                                <li class="group"><p><code>StringBuffer / StringBuilder 	delete(int start, int end)</code> -- 删除指定索引 start 到 end 的串</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	deleteCharAt(int index)</code> -- 删除指定索引字符</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	replace(int start, int end, String str)</code> -- 替换指定索引 start 到 end 的为 str</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	reverse()</code> -- 反转字符串</p></li>


                                <li class="group"><p><code>String 	substring(int start)</code> -- 指定 start 到结尾的子串</p></li>
                                <li><p><code>String 	substring(int start, int end)</code> -- 指定 start 到 end 的子串</p></li>
                                <li><p><code>CharSequence 	subSequence(int start, int end)</code> -- 指定索引 start 到 end 子序列</p></li>
                                <li><p><code>String 	toString()</code> -- 转为 String</p></li>

                                <li class="group"><p><code>int 	indexOf(String str)</code> -- 子串位置</p></li>
                                <li><p><code>int 	indexOf(String str, int fromIndex)</code> -- 从指定的索引开始，子串位置</p></li>
                                <li><p><code>int 	lastIndexOf(String str)</code> -- 返回指定字符在此字符串中最后一次出现处的索引</p></li>
                                <li><p><code>int 	lastIndexOf(String str, int fromIndex)</code> -- 从指定的索引开始，最后一次出现处的索引</p></li>
                                <li><p><code>int 	length()</code> -- 返回此字符串的长度</p></li>

                                <li class="group"><p><code>int 	capacity()</code> -- 返回容量大小，容量大小会根据使用的量动态添加</p></li>
                                <li><p><code>void 	ensureCapacity(int minimumCapacity)</code> -- 设置容量至少等于指定的最小值</p></li>
                                <li><p><code>char 	charAt(int index)</code> -- 指定索引出字符</p></li>
                                <li><p><code>void 	setCharAt(int index, char ch)</code> -- 更改指定索引出字符</p></li>
                                <li><p><code>void 	setLength(int newLength)</code> -- 使用 '\0' 填充其空的容量</p></li>
                                <li><p><code>void 	trimToSize()</code> -- 将未使用的容量去除(不是去除空白，调用此方法后，<code>capacity() == length()</code>)</p></li>
                                <li><p><code>void 	getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code> -- 复制到 dst 中</p></li>

                                <li class="group"><p><code>int 	codePointAt(int index)</code> -- 同 String 同名方法</p></li>
                                <li><p><code>int 	codePointBefore(int index)</code> -- 同 String 同名方法</p></li>
                                <li><p><code>int 	codePointCount(int beginIndex, int endIndex)</code> -- 同 String 同名方法</p></li>
                                <li><p><code>int 	offsetByCodePoints(int index, int codePointOffset)</code> -- 同 String 同名方法</p></li>
                            </ol>


                        </div>


					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-Math"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Math 及 RoundingMode</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
public final class Math {
    // 比任何其他值都更接近 e（即自然对数的底数）的 double 值, e 的值为 n 接近无穷大时： e = Math.pow(1 + 1 / n, n)
    public static final double E = 2.7182818284590452354;
    // 比任何其他值都更接近 pi（即圆的周长与直径之比）的 double 值
    public static final double PI = 3.14159265358979323846;
}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/Math.html" target="_blank">Math</a> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p>
                            <p>默认情况下，很多 Math 方法仅调用 StrictMath 中的等价方法来完成它们的实现，而这些函数方法在 StrictMath 里面的形式是调用本地的非 Java 代码的接口。建议代码生成器使用特定于平台的本机库或者微处理器指令（可用时）来提供 Math 方法更高性能的实现。这种更高性能的实现仍然必须遵守 Math 的规范。 </p>
                            <ol>
                                <li><p><code>static double 	max(double a, double b)</code> -- 返回两个 double 值中较大的一个。</p></li>
                                <li><p><code>static float 	max(float a, float b)</code> -- 返回两个 float 值中较大的一个。</p></li>
                                <li><p><code>static int 	max(int a, int b)</code> -- 返回两个 int 值中较大的一个。</p></li>
                                <li><p><code>static long 	max(long a, long b)</code> -- 返回两个 long 值中较大的一个。</p></li>
                                <li><p><code>static double 	min(double a, double b)</code> -- 返回两个 double 值中较小的一个。</p></li>
                                <li><p><code>static float 	min(float a, float b)</code> -- 返回两个 float 值中较小的一个。</p></li>
                                <li><p><code>static int 	min(int a, int b)</code> -- 返回两个 int 值中较小的一个。</p></li>
                                <li><p><code>static long 	min(long a, long b)</code> -- 返回两个 long 值中较小的一个。</p></li>

                                <li class="group"><p><code>static double 	abs(double a)</code> -- 返回 double 值的绝对值。</p></li>
                                <li><p><code>static float 	abs(float a)</code> -- 返回 float 值的绝对值。</p></li>
                                <li><p><code>static int 	abs(int a)</code> -- 返回 int 值的绝对值。</p></li>
                                <li><p><code>static long 	abs(long a)</code> -- 返回 long 值的绝对值。</p></li>

                                <li class="group"><p><code>static double 	signum(double d)</code> -- 返回参数的符号函数；如果参数为 0，则返回 0；如果参数大于 0，则返回 1.0；如果参数小于 0，则返回 -1.0。</p></li>
                                <li><p><code>static float 	signum(float f)</code> -- 返回参数的符号函数；如果参数为 0，则返回 0；如果参数大于 0，则返回 1.0；如果参数小于 0，则返回 -1.0。</p></li>

                                <li class="group"><p><code>static double 	floor(double a)</code> -- 返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。</p></li>
                                <li><p><code>static double 	ceil(double a)</code> -- 返回最小的（最接近负无穷大）double 值，该值大于等于参数，并等于某个整数。</p></li>
                                <li><p><code>static double 	rint(double a)</code> -- 返回最接近参数并等于某一整数的 double 值。</p></li>
                                <li><p><code>static long 	round(double a)</code> -- 返回最接近参数的 long。</p></li>
                                <li><p><code>static int 	round(float a)</code> -- 返回最接近参数的 int。</p>
                                    <pre class="brush: java;">
/** floor -- 总是往负无穷大方向舍取，如: floor(3.9) = 3.0, floor(-3.1) = -4.0
 * ceil -- 和 floor 相反，总是往正无穷大方向舍取，如: ceil(3.9) = 4.0, ceil(-3.1) = -3.0
 * rint -- 四舍五入，如：rint(3.1) = 3.0, rint(3.5) = 4.0, rint(-3.1) = 3.0, rint(-3.5) = -4.0
 * round -- 舍入同 rint 函数，返回 int 或 long，如： round(3.1) = 3, round(-3.1) = 3
 */
</pre>
                                </li>

                                <li class="group"><p><code>static double 	pow(double a, double b)</code> -- 返回第一个参数的第二个参数次幂的值。</p></li>
                                <li><p><code>static double 	sqrt(double a)</code> -- 返回正确舍入的 double 值的正平方根。</p></li>
                                <li><p><code>static double 	cbrt(double a)</code> -- 返回 double 值的立方根。</p></li>
                                <li><p><code>static double 	hypot(double x, double y)</code> -- 返回 sqrt(x2 +y2)，没有中间溢出或下溢。</p></li>

                                <li class="group"><p><code>static double 	toDegrees(double angrad)</code> -- 将用弧度表示的角转换为近似相等的用角度表示的角。</p></li>
                                <li><p><code>static double 	toRadians(double angdeg)</code> -- 将用角度表示的角转换为近似相等的用弧度表示的角。</p>
                                    <pre class="brush: java;">
Math.toDegrees(Math.PI * 30 / 180) ~= 30;
Math.toDegrees(Math.PI * 45 / 180) ~= 45;

Math.toRadians(30) ~= Math.PI * 30 / 180;
Math.toRadians(45) ~= Math.PI * 45 / 180;
</pre>
                                </li>

                                <li><p><code>static double 	sin(double a)</code> -- 返回角的三角正弦。</p></li>
                                <li><p><code>static double 	cos(double a)</code> -- 返回角的三角余弦。</p></li>
                                <li><p><code>static double 	tan(double a)</code> -- 返回角的三角正切。</p>
                                    <pre class="brush: java;">
sin(30°) == Math.sin(Math.PI * 30 / 180) ~= 1 / 2
sin(45°) == Math.sin(Math.PI * 45 / 180) ~= 1 / sqrt(2)
cos(60°) == Math.cos(Math.PI * 60 / 180) ~= 1 / 2
cos(45°) == Math.cos(Math.PI * 45 / 180) ~= 1 / sqrt(2)
tan(30°) == Math.tan(Math.PI * 30 / 180) ~= 1 / sqrt(3)
tan(45°) == Math.tan(Math.PI * 45 / 180) ~= 1
</pre>
                                </li>

                                <li><p><code>static double 	asin(double a)</code> -- 返回一个值的反正弦；返回的角度范围在 -pi/2 到 pi/2 之间。</p></li>
                                <li><p><code>static double 	acos(double a)</code> -- 返回一个值的反余弦；返回的角度范围在 0.0 到 pi 之间。</p></li>
                                <li><p><code>static double 	atan2(double y, double x)</code> -- 同 atan(double), 参数为 y 边长 和 x 边长</p></li>
                                <li><p><code>static double 	atan(double a)</code> -- 返回一个值的反正切；返回的角度范围在 -pi/2 到 pi/2 之间。</p>
                                    <pre class="brush: java;">
asin(30°) ~= Math.PI * 30 / 180, sin(30°) == Math.sin(Math.PI * 30 / 180)
acos(60°) ~= Math.PI * 60 / 180, cos(60°) == Math.cos(Math.PI * 60 / 180)
atan(30°) ~= atan2(1, Math.sqrt(3)) ~= Math.PI * 30 / 180, tan(30°) == Math.tan(Math.PI * 30 / 180)
</pre>
                                </li>

                                <li><p><code>static double 	sinh(double x)</code> -- 返回 x 值的双曲线正弦，x 的双曲正弦被定义为 <code>(e<sup>x</sup> - e<sup>-x</sup>) / 2</code>, e 为自然对数</p></li>
                                <li><p><code>static double 	cosh(double x)</code> -- 返回 x 值的双曲线余弦，x 的双曲余弦被定义为 <code>(e<sup>x</sup> + e<sup>-x</sup>) / 2</code>, e 为自然对数</p></li>
                                <li><p><code>static double 	tanh(double x)</code> -- 返回 x 值的双曲线正切，x 的双曲正切被定义为 <code>(e<sup>x</sup> - e<sup>-x</sup>) / (e<sup>x</sup> + e<sup>-x</sup>)</code>, e 为自然对数</p>
                                    <pre class="brush: java;">
sinh(x) == (Math.pow(Math.E, x) - Math.pow(Math.E, -x)) / 2
cosh(x) == (Math.pow(Math.E, x) + Math.pow(Math.E, -x)) / 2
tanh(x) == (Math.pow(Math.E, x) - Math.pow(Math.E, -x)) / (Math.pow(Math.E, x) + Math.pow(Math.E, -x))
</pre>
                                </li>


                                <li class="group"><p><code>static double 	exp(double x)</code> -- 返回 e^x</p></li>
                                <li><p><code>static double 	expm1(double x)</code> -- 返回 e^x - 1</p></li>
                                <li><p><code>static double 	log(double a)</code> -- 返回 a 值的自然对数（底数是 e）。</p></li>
                                <li><p><code>static double 	log10(double a)</code> -- 返回 a 值的底数为 10 的对数。</p></li>
                                <li><p><code>static double 	log1p(double x)</code> -- 返回参数与 1 之和的自然对数。</p></li>
                                <li><p><code>static int 	getExponent(double d)</code> -- 返回 d 表示形式中使用的无偏差指数(d 是 2 的 x 次方，不管符号，余数和小数)</p></li>
                                <li><p><code>static int 	getExponent(float f)</code> -- 返回 f 表示形式中使用的无偏差指数(d 是 2 的 x 次方，不管符号，余数和小数)</p>
                                <pre class="brush: java;">
Math.getExponent(8) == 3
Math.getExponent(-8) == 3
Math.getExponent(9) == 3

double m = Math.pow(Math.E, 3);
Math.log(m) == Math.log1p(m - 1) == 3.0
</pre>
                                </li>

                                <li class="group"><p><code>static double 	nextUp(double d)</code> -- 返回 d 和正无穷大之间与 d 相邻的浮点值。</p></li>
                                <li><p><code>static float 	nextUp(float f)</code> -- 返回 f 和正无穷大之间与 f 相邻的浮点值。</p></li>
                                <li><p><code>static double 	nextDown(double d)</code> -- 返回 d 和负无穷大之间与 d 相邻的浮点值。</p></li>
                                <li><p><code>static float 	nextDown(float f)</code> -- 返回 f 和负无穷大之间与 f 相邻的浮点值。</p></li>
                                <li><p><code>static double 	nextAfter(double start, double direction)</code> -- 返回 start 和 direction 间与第一个参数相邻的浮点数。</p></li>
                                <li><p><code>static float 	nextAfter(float start, double direction)</code> -- 返回 start 和 direction 间与第一个参数相邻的浮点数。</p>
                                <pre class="brush: java;">
float f = 3.14f;
double d = 3.14;
Math.nextUp(f) == 3.1400003; // 比 f 稍大但是接近 f 的浮点值
Math.nextUp(d) == 3.1400000000000006; // 比 d 稍大但是接近 d 的 double 值
Math.nextDown(f) == 3.1399999; // 比 f 稍小但是接近 f 的浮点值
Math.nextDown(d) == 3.1399999999999997; // 比 d 稍小但是接近 d 的 double 值

/* 如果 direction > start, 则相当于 nextUp;
 * 如果 direction < start, 则相当于 nextDown;
 */
nextAfter(double start, double direction);
</pre>
                                </li>

                                <li class="group"><p><code>static double 	random()</code> -- 返回随机正的 double 值，该值大于等于 0.0 且小于 1.0。</p></li>
                                <li><p><code>static double 	IEEEremainder(double f1, double f2)</code> -- 按照 IEEE 754 标准的规定，对两个参数进行余数运算，返回为 <code>f1 - f2 * Math.rint(f1 / f2)</code></p></li>
                                <li><p><code>static double 	copySign(double magnitude, double sign)</code> -- 返回带有第二个浮点参数符号的第一个浮点参数。</p></li>
                                <li><p><code>static float 	copySign(float magnitude, float sign)</code> -- 返回带有第二个浮点参数符号的第一个浮点参数。</p></li>

                                <li><p><code>static double 	scalb(double d, int scaleFactor)</code> -- 返回 <code>d × 2^scaleFactor</code>，其舍入方式如同将一个正确舍入的浮点值乘以 double 值集合中的一个值。</p></li>
                                <li><p><code>static float 	scalb(float f, int scaleFactor)</code> -- 返回 <code>f × 2^scaleFactor</code>，其舍入方式如同将一个正确舍入的浮点值乘以 float 值集合中的一个值。</p></li>

                                <li><p><code>static double 	ulp(double d)</code> -- 返回一个数字和距其最近的数字之间的距离</p></li>
                                <li><p><code>static float 	ulp(float f)</code> -- 返回一个数字和距其最近的数字之间的距离</p>
                                    <pre class="brush: java;">
在计算机中，float(32 位) 和 double(64 位) 都是固定长度的，一个数字和另外一个数字间，所有的数字是有限的。
比如： 1.0001f 和 1.00012f 间，假设计算机能表示的数字为 10232332(乱写的)，那么，ulp = 1.0 / 10232332.
                                    </pre>
                                </li>
                            </ol>
                        </div>

                        <a id="java-math-RoundingMode" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.lang.Enum&lt;RoundingMode>
        java.math.RoundingMode

public enum RoundingMode {
    /** 参见 Number 的子类 BigDecimal 的常量 */
    UP(BigDecimal.ROUND_UP),
    DOWN(BigDecimal.ROUND_DOWN),
    CEILING(BigDecimal.ROUND_CEILING),
    FLOOR(BigDecimal.ROUND_FLOOR),
    HALF_UP(BigDecimal.ROUND_HALF_UP),
    HALF_DOWN(BigDecimal.ROUND_HALF_DOWN),
    HALF_EVEN(BigDecimal.ROUND_HALF_EVEN),
    UNNECESSARY(BigDecimal.ROUND_UNNECESSARY);
}
</pre>
                            <p><a href="docs/docs-java/api/java/math/RoundingMode.html" target="_blank">RoundingMode</a> 为可能丢弃精度的数值操作指定一种舍入行为。</p>
                            <p>每种舍入模式都指示如何计算返回舍入结果位数的最低有效位。如果返回的位数比表示精确数值结果所需的位数少，则舍弃的位数称为舍弃部分，而不管这些位数对数值的作用如何。换句话说，假设是一个数值，舍弃部分的绝对值可能大于 1。 </p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Number"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Number 及子类</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.Number

public abstract class Number implements java.io.Serializable {
    byte byteValue() {
        return (byte)intValue();
    }

    short shortValue() {
        return (short)intValue();
    }
    abstract int intValue();
    abstract long longValue();
    abstract float floatValue();
    abstract double doubleValue();
}
						</pre>
                        <p>抽象类 <a href="docs/docs-java/api/java/lang/Number.html" target="_blank">Number</a> 是 BigDecimal、BigInteger、Byte、Double、Float、Integer、Long 和 Short 类的超类。 </p>
                        <p><a href="docs/docs-java/api/java/lang/Number.html" target="_blank">Number</a> 的子类必须提供将表示的数值转换为 byte、double、float、int、long 和 short 的方法。 </p>

                        <ul>
                            <li><p><a href="docs/docs-java/api/java/lang/Byte.html" target="_blank">Byte</a> 类将基本类型 byte 的值包装在一个对象中。一个 Byte 类型的对象只包含一个类型为 byte 的字段。</p>
                                <p>此外，该类还为 byte 和 String 的相互转换提供了几种方法，并提供了处理 byte 时非常有用的其他一些常量和方法。 </p>
                                <pre class="brush: java;">
public final class Byte extends Number implements Comparable&lt;Byte> {
    public static byte MAX_VALUE = 127; // 保存 byte 类型可取的最大值，即 2^7 - 1
    public static byte MIN_VALUE = -128; // 保存 byte 类型可取的最小值，即 -2^7
    public static int 	SIZE = 8; // byte 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

    static byte parseByte(String s) {} // 默认 10 进制转换
    /** radix 为指定进制:
     * log(Byte.parseByte("100"), Byte.parseByte("100", 2), Byte.parseByte("1A", 16));
     * 输出为: 100, 4, 26
     */
    static byte parseByte(String s, int radix) {}

	/** decode 接受 10 进制 16 进制， 8 进制数据
	 * log(Byte.decode("100"), Byte.decode("0x1A"), Byte.decode("#1A"), Byte.decode("010"));
	 * 输出为: 100, 26, 26, 8
	 */
    static Byte decode(String nm) {}

	/** 调用 parseByte 方法 */
    static Byte valueOf(byte b) {}
    static Byte valueOf(String s) {}
    static Byte valueOf(String s, int radix) {}

	static int compare(byte x, byte y) {} // reurn x - y;
	static int toUnsignedInt(byte x) {} // 转为无符号整型
	static long toUnsignedLong(byte x) {} // 转为无符号长整型
}
</pre>
                            </li>
                            <li><p><a href="docs/docs-java/api/java/lang/Short.html" target="_blank">Short</a> 类在对象中包装基本类型 short 的值。一个 Short 类型的对象只包含一个 short 类型的字段。 </p>
								<pre class="brush: java;">
public final class Short extends Number implements Comparable&lt;Short> {
    public static final short MAX_VALUE = 32767; // 最大值的常量，最大值为 2^15 - 1
	public static final short MIN_VALUE = -32768; // 最小值的常量，最小值为 -2^15
	public static final int SIZE = 16; // short 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

	// 低字节和高字节二进制互换位置
	static byte reverseBytes(byte i) {}

	// 以下方法同 Byte 类似
	static int compare(short x, short y) {}
	static int toUnsignedInt(short x)
	static long toUnsignedLong(short x)
	static Short decode(String nm) {}
	static short parseShort(String s) {}
	static short parseShort(String s, int radix) {}
	static Short valueOf(short s) {}
	static Short valueOf(String s) {}
	static Short valueOf(String s, int radix) {}
}
</pre>
							</li>
                            <li><p><a href="docs/docs-java/api/java/lang/Integer.html" target="_blank">Integer</a> 类在对象中包装了一个基本类型 int 的值。Integer 类型的对象包含一个 int 类型的字段。 </p>
								<pre class="brush: java;">
public final class Short extends Number implements Comparable&lt;Short> {
    public static final int MAX_VALUE = 0x7fffffff; // 最大值的常量，最大值为 2^31 - 1, 即： 2147483647
	public static final int MIN_VALUE = 0x80000000; // 最小值的常量，最小值为 -2^31，即： -2147483648
	public static final int SIZE = 32; // int 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

	static int 	compareUnsigned(int x, int y) {} // 无符号 x - y
	static int 	divideUnsigned(int x, int y) {} // 无符号 x / y
	static int remainderUnsigned(int x, int y) {} // 无符号 x % y
	static int 	max(int a, int b) {} // 返回较大值
	static int 	min(int a, int b) {} // 返回较小值
	static int 	sum(int a, int b) {} // 返回 a + b

	static Integer getInteger(String nm) {} // 获取系统属性的 int 值
	static Integer getInteger(String nm, int val) {} // 获取系统属性的 int 值, 为空则返回 val
	static Integer getInteger(String nm, Integer val) {} // 获取系统属性的 int 值, 为空则返回 val

	static int bitCount(int i) {} // 二进制形式表示后 '1' 的数量，和数大小无关
	static int highestOneBit(int i) {} // 二进制形式最高为为 '1' 表示的整数，highestOneBit(0x60) == 64
	static int lowestOneBit(int i) {} // 二进制形式最低为为 '1' 表示的整数，lowestOneBit(0x60) == 32
	static int numberOfLeadingZeros(int i) {} // 二进制形式从左往右有多少个连续的 '0'
	static int numberOfTrailingZeros(int i) {} // 二进制形式从右往左有多少个连续的 '0'

	static int reverse(int i) {} // 同 reverseBytes 区别为此方法二进制从右往左的值，按位不是按字节
	static int rotateLeft(int i, int b) {} // 二进制左移 b 位，左边会移动到右边，若 b 为 32 倍数，值将不变
	static int rotateRight(int i, int b) {} // 二进制右移 b 位，右边会移动到左边，若 b 为 32 倍数，值将不变
	static int signum(int i) {} // 返回 1 为正， -1 为负

	static String toBinaryString(int i) {} // 二进制形式
	static String toHexString(int i) {} // 八进制形式
	static String toOctalString(int i) {} // 十六进制形式

	static int parseUnsignedInt(String s) {} // 同 paseInt(String), 无符号整型
	static int parseUnsignedInt(String s, int radix) {} // 同 paseInt(String, int), 无符号整型


	// 其它方法同 Short 类似
	...
}
</pre>
							</li>
                            <li><p><a href="docs/docs-java/api/java/lang/Long.html" target="_blank">Long</a> 类在对象中包装了基本类型 long 的值。每个 Long 类型的对象都包含一个 long 类型的字段。 </p>
								<pre class="brush: java;">
/** long 类型在数字后加 'L' 表示， 如： 100L */
public final class Long extends Number implements Comparable&lt;Long> {
	public static final int MAX_VALUE = 0x7fffffffffffffffL; // 最大值的常量，最大值为 2^63 - 1
	public static final int MIN_VALUE = 0x8000000000000000L; // 最小值的常量，最小值为 -2^63
	public static final int SIZE = 64; // int 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

	/** Long 的方法和 Integer 都是类似的 */
}
</pre>
							</li>
                            <li><p><a href="docs/docs-java/api/java/lang/Float.html" target="_blank">Float</a> 类在对象中包装一个基本类型 float 的值，在不超出范围情况下，<b>其精度只有小数点后面 6 位，第 7 位可能为舍入的</b>。Float 类型的对象包含一个 float 类型的字段。 </p>
								<p><b>一个浮点数有 2 部分组成：底数 和 指数</b></p>
								<ul>
									<li><p>底数 -- 使用二进制数来表示此浮点数的实际值，但是最高位始终为 1，所以，最高位省去不存储，在存储中占 23 bit</p></li>
									<li><p>指数 -- 占用 8 bit 的二进制数，可表示数值范围为 0-255。</p></li>
								</ul>
								<p><b>float 类型在内存中的表示：</b></p>
								<pre class="brush: java;">
SEEEEEEE EMMMMMMM MMMMMMMM MMMMMMMM
S: 符号位
E: 指数位，实际指数加上 127(2^7-1) 后的值后得二进制数据
M: 底数位，IEEE 794 规定最高位始终为 1，所以，最高位省去不存储

实例： 17.625 在内存中的表示形式
1.整数部分直接换算程二进制： 10001
2.小数部分使用乘 2 取整法：
	2.1 首先给小数部分乘 2，得到的数，如果小数点前为 1，则计 1；为 0，则计 0；
	2.2 再对剩下的小数部分乘 2，再计出 1 或 0；
	2.3 重复以上步骤，直至达到需要的精度。
		0.625 x 2 = 1.25   	--- 计为 1
		0.25 x 2 = 0.5      --- 计为 0
        0.5 x 2 = 1.0       --- 计为 1
		... 如果还有尾数，算到需要的精度为止(最多只有23 bit)
3.得到的形式为: 10001.101
4.再将 10001.101 右移，直到小数点前只剩 1 位(IEEE 794 规定)，最终移动了 4 位： 1.0001101 * 2^4
5.此时，得到了底数和指数：
	5.1 指数部分要加上 127，即 4 + 127 = 131，二进制表示为： 1000 0011
	5.2 底数部分为： 1.0001101
6.符号为正，底数最高位不存储(IEEE 794 规定)，因此表示如下：
	SEEEEEEE EMMMMMMM MMMMMMMM MMMMMMMM
	01000001 10001101 00000000 00000000
</pre>
								<pre class="brush: java;">
/** float 类型在数字后加 'f' 表示， 如： 1.0f */
public final class Float extends Number implements Comparable&lt;Float> {
	public static final int SIZE = 32; // int 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

	public static final float NaN = 0.0f / 0.0f; // 保存 float 类型的非数字 (NaN) 值的常量
	public static final float POSITIVE_INFINITY = 1.0f / 0.0f; // 保存 float 类型的正无穷大值的常量
	public static final float NEGATIVE_INFINITY = -1.0f / 0.0f; // 保存 float 类型的负无穷大值的常量

	public static final int MAX_EXPONENT = 127; // 有限 float 变量可能具有的最大指数
	public static final int MIN_EXPONENT = -126; // 标准化 float 变量可能具有的最小指数

	public static final float MAX_VALUE = 0x1.fffffeP+127f; // 最大正有限值，即 (2-2^23) · 2^127
	public static final float MIN_NORMAL = 0x1.0p-126f; // float 类型最小正标准值，即 2^-126
	public static final float MIN_VALUE = 0x0.000002P-126f; // float 类型最小正非零值，即 2^-149

	static boolean isNaN(float v) {} // 如果指定的数是一个非数字 (NaN) 值，则返回 true
	static boolean isInfinite(float v) {} // 如果指定数的数值是无穷大，则返回 true

	/** Float 只支持 10 进制 / 16 的转换，浮点数的 16 进制为 toHexString(String) 的结果 */
	static float Float.parseFloat(String s) {}

	/** 返回 float 参数的十六进制字符串表示形式，可以通过 parseFloat 转换为浮点数
	 *  1.如果参数为NaN，那么结果是字符串 "NaN";
	 *  2.如果符号为负，那么结果的第一个字符是 "-",为正则不显示；
	 *  3.如果 f 为无穷大，则用字符串 "Infinity" 表示，负无穷大生成结果 "-Infinity";
	 *  4.如果 f 为 0，则用字符串 "0x0.0p0" 表示，因此，负 0 生成结果 "-0x0.0p0";
	 *  5.如果是有效浮点数，形式为：0x1.MpE(M 用于表示有效底数，E 用于表示偏移指数) 则需要计算：
	 *     5.1 前缀不变，为: 0x1.
	 * 	   5.2 先将浮点书转为二进制表示形式，如： 10.5 二进制为: 0100 0001 0010 1000 0000 0000 0000 0000
	 * 	   5.3 先计算指数 E:
	 *         5.3.1 取出二进制指数位(第 2 位开始取 8 位):  100 0001 0 = 130
     * 		   5.3.2 减去 127, 130 - 127 = 3，即 E = 3(如果浮点数 < 1.0，此值就为负)
     *     5.4 计算底数 M
     *         5.4.1 取出二进制底数位(第 10 位开始): 010 1000 0000 0000 0000 0000
     * 	       5.4.2 去除左右的 '0', 10 1 = 5
     *     5.5 最终结果为： 0x1.5p3
	 */
	static String toHexString(float f) {}

	/** 要明白下面的方法，首先明白一点，float 和 int 的二进制都是 32 位，在二进制范围无区别
	 * 因此，一个 32 位的二进制，可以用 int 表示，也可以用 float 表示，下面的方法就是相互转化
	 */
	static float intBitsToFloat(int bits) {} // 将 int 表示的二进制转化为 float 类型
	static int floatToIntBits(float value) {} // 将浮点数的二进制转化为 int 值
	static int floatToRawIntBits(float value) {} // 将浮点数的二进制转化为 int 值，不压缩 NaN 值
}
</pre>
							</li>
                            <li><p><a href="docs/docs-java/api/java/lang/Double.html" target="_blank">Double</a> 类在对象中包装一个基本类型 double 的值，在不超出范围情况下，<b>其精度只有小数点后面 15 位，第 16 位可能为舍入的</b>。每个 Double 类型的对象都包含一个 double 类型的字段。 </p>
								<p><b>一个 Double 有 2 部分组成：底数 和 指数</b></p>
								<ul>
									<li><p>底数 -- 使用二进制数来表示此 Double 的实际值，但是最高位始终为 1，所以，最高位省去不存储，在存储中占 52 bit</p></li>
									<li><p>指数 -- 占用 11 bit 的二进制数，可表示数值范围为 0-1023。</p></li>
								</ul>
								<p><b>float 类型在内存中的表示：</b></p>
								<pre class="brush: java;">
SEEEEEEE EEEEMMMM MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
S: 符号位
E: 指数位，实际指数加上 1023(2^10-1) 后的值后得二进制数据
M: 底数位，IEEE 794 规定最高位始终为 1，所以，最高位省去不存储
</pre>
								<pre class="brush: java;">
/** Double 的方法和 Float 都是类似的
 * Double 类型使用 64 位存储，因此对应 Long 类型
 */
public final class Double extends Number implements Comparable&lt;Double> {
	public static final int SIZE = 64; // int 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

	public static final double NaN = 0.0d / 0.0; // 保存 double 类型的非数字 (NaN) 值的常量
	public static final double POSITIVE_INFINITY = 1.0 / 0.0; // 保存 double 类型的正无穷大值的常量
	public static final double NEGATIVE_INFINITY = -1.0 / 0.; // 保存 double 类型的负无穷大值的常量

	public static final int MAX_EXPONENT = 1023; // 有限 double 变量可能具有的最大指数
	public static final int MIN_EXPONENT = -1022; // 标准化 double 变量可能具有的最小指数

	public static final double MAX_VALUE = 0x1.fffffffffffffP+1023;; // 最大正有限值
	public static final double MIN_NORMAL = 0x1.0p-1022; // double 类型最小正标准值
	public static final double MIN_VALUE = 0x0.0000000000001P-1022;; // double 类型最小正非零值

	static double longBitsToDouble(long bits) {} // 将 long 表示的二进制转化为 double 类型
	static long doubleToLongBits(double value) {} // 将 double 的二进制转化为 long 值
	static long doubleToRawLongBits(double value) {} // 将 double 的二进制转化为 long 值，不压缩 NaN 值
}
</pre>
							</li>
							<li><p><a href="docs/docs-java/api/java/math/BigInteger.html" target="_blank">java.math.BigInteger</a> 不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 BigInteger（如 Java 的基本整数类型）。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 </p>
								<pre class="brush: java;">
public class BigInteger extends Number implements Comparable&lt;BigInteger> {
	public static final BigInteger ONE = valueOf(1); // BigInteger 的常量 1
	public static final BigInteger TEN = valueOf(10); // BigInteger 的常量 10
	public static final BigInteger ZERO = new BigInteger(new int[0], 0); // BigInteger 的常量 0

	/** 将 BigInteger 的十进制字符串表示形式转换为 BigInteger */
	public BigInteger(String val) {}
	/** 将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger */
	public BigInteger(String val, int radix) {}
	/** 将包含 BigInteger 的二进制补码表示形式的 byte 数组转换为 BigInteger */
	public BigInteger(byte[] val) {}
	/** 将 BigInteger 的符号-数量表示形式转换为 BigInteger */
	public BigInteger(int signum, byte[] magnitude) {}
	/** 构造一个随机生成的正 BigInteger，它可能是一个具有指定 bitLength 的素数 */
	public BigInteger(int bitLength, int certainty, Random rnd) {}
	/** 构造一个随机生成的 BigInteger，它是在 0 到 (2numBits - 1)（包括）范围内均匀分布的值 */
	public BigInteger(int numBits, Random rnd) {}
}
</pre>
								<ol>
									<li><p><code>static BigInteger 	valueOf(long val)</code> -- 返回其值等于指定 long 的值的 BigInteger</p></li>
									<li><p><code>static BigInteger 	probablePrime(int bitLength, Random rnd)</code> -- 返回有可能是素数的、具有指定长度的正 BigInteger</p></li>

                                    <li class="group"><p><code>BigInteger 	add(BigInteger val)</code> -- 返回其值为 (this + val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	subtract(BigInteger val)</code> -- 返回其值为 (this - val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	multiply(BigInteger val)</code> -- 返回其值为 (this * val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	divide(BigInteger val)</code> -- 返回其值为 (this / val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	remainder(BigInteger val)</code> -- 返回其值为 (this % val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	negate()</code> -- 返回其值是 (-this) 的 BigInteger。</p></li>

                                    <li class="group"><p><code>BigInteger 	and(BigInteger val)</code> -- 返回其值为 (this & val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	or(BigInteger val)</code> -- 返回其值为 (this | val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	not()</code> -- 返回其值为 (~this) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	xor(BigInteger val)</code> -- 返回其值为 (this ^ val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	andNot(BigInteger val)</code> -- 返回其值为 (this & ~val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	shiftLeft(int n)</code> -- 返回其值为 (this << n) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	shiftRight(int n)</code> -- 返回其值为 (this >> n) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger[] 	divideAndRemainder(BigInteger val)</code> -- 返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。</p></li>

                                    <li class="group"><p><code>int 	bitLength()</code> -- 返回此 BigInteger 的最小的二进制补码表示形式的位数，不包括符号位。</p></li>
                                    <li><p><code>int 	bitCount()</code> -- 返回此 BigInteger 的二进制补码表示形式中与符号不同的位的数量。</p></li>
                                    <li><p><code>BigInteger 	clearBit(int n)</code> -- 返回其值与清除了指定位的此 BigInteger 等效的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	setBit(int n)</code> -- 返回其值与设置了指定位的此 BigInteger 等效的 BigInteger。</p></li>
                                    <li><p><code>boolean 	testBit(int n)</code> -- 当且仅当设置了指定的位时，返回 true。</p></li>
                                    <li><p><code>int 	getLowestSetBit()</code> -- 返回此 BigInteger 最右端（最低位）1 比特的索引（即从此字节的右端开始到本字节中最右端 1 比特之间的 0 比特的位数）。</p></li>
                                    <li><p><code>BigInteger 	flipBit(int n)</code> -- 返回其值与对此 BigInteger 进行指定位翻转后的值等效的 BigInteger。</p></li>

                                    <li class="group"><p><code>BigInteger 	abs()</code> -- 返回其值是此 BigInteger 的绝对值的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	max(BigInteger val)</code> -- 返回此 BigInteger 和 val 的最大值。</p></li>
                                    <li><p><code>BigInteger 	min(BigInteger val)</code> -- 返回此 BigInteger 和 val 的最小值。</p></li>
                                    <li><p><code>BigInteger 	mod(BigInteger m)</code> -- 返回其值为 (this mod m) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	modInverse(BigInteger m)</code> -- 返回其值为 (this^-1 mod m) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	modPow(BigInteger exponent, BigInteger m)</code> -- 返回其值为 (thisexponent mod m) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	pow(int exponent)</code> -- 返回其值为 (thisexponent) 的 BigInteger。</p></li>

                                    <li class="group"><p><code>int 	intValue()</code> -- 将此 BigInteger 转换为 int。</p></li>
                                    <li><p><code>long 	longValue()</code> -- 将此 BigInteger 转换为 long。</p></li>
                                    <li><p><code>float 	floatValue()</code> -- 将此 BigInteger 转换为 float。</p></li>
                                    <li><p><code>double 	doubleValue()</code> -- 将此 BigInteger 转换为 double。</p></li>
                                    <li><p><code>int 	signum()</code> -- 返回此 BigInteger 的正负号函数。</p></li>

                                    <li class="group"><p><code>BigInteger 	gcd(BigInteger val)</code> -- 返回一个 BigInteger，其值是 abs(this) 和 abs(val) 的最大公约数。</p></li>
                                    <li><p><code>boolean 	isProbablePrime(int certainty)</code> -- 如果此 BigInteger 可能为素数，则返回 true，如果它一定为合数，则返回 false。</p></li>
                                    <li><p><code>BigInteger 	nextProbablePrime()</code> -- 返回大于此 BigInteger 的可能为素数的第一个整数。</p></li>

                                    <li class="group"><p><code>int 	hashCode()</code> -- 返回此 BigInteger 的哈希码。</p></li>
                                    <li><p><code>boolean 	equals(Object x)</code> -- 比较此 BigInteger 与指定的 Object 的相等性。</p></li>
                                    <li><p><code>int 	compareTo(BigInteger val)</code> -- 将此 BigInteger 与指定的 BigInteger 进行比较。</p></li>
                                    <li><p><code>String 	toString()</code> -- 返回此 BigInteger 的十进制字符串表示形式。</p></li>
                                    <li><p><code>byte[] 	toByteArray()</code> -- 返回一个 byte 数组，该数组包含此 BigInteger 的二进制补码表示形式。</p></li>
                                    <li><p><code>String 	toString(int radix)</code> -- 返回此 BigInteger 的给定基数的字符串表示形式。</p></li>
								</ol>
							</li>
                            <li><p><a href="docs/docs-java/api/java/math/BigDecimal.html" target="_blank">java.math.BigDecimal</a> 不可变的、任意精度的有符号十进制数。由任意精度的整数非标度值 和 32 位的整数标度 (scale) 组成。如果为零或正数，则标度是小数点后的位数。如果为负数，则将该数的非标度值乘以 10 的负 scale 次幂。</p>
								<p>BigDecimal 类提供以下操作：算术、标度操作、舍入、比较、哈希算法和格式转换。toString() 方法提供 BigDecimal 的规范表示形式。 </p>
                                <p>BigDecimal 类使用户能完全控制舍入行为。如果未指定舍入模式，并且无法表示准确结果，则抛出一个异常；否则，通过向该操作提供适当的 MathContext 对象，可以对已选择的精度和舍入模式执行计算。在任何情况下，可以为舍入控制提供八种舍入模式。</p>
								<pre class="brush: java;">
public class BigDecimal extends Number implements Comparable&lt;BigDecimal> {
    /** 舍入远离零的舍入模式 */
    public final static int ROUND_UP =           0;
    /** 接近零的舍入模式 */
    public final static int ROUND_DOWN =         1;
    /** 接近正无穷大的舍入模式 */
    public final static int ROUND_CEILING =      2;
    /** 接近负无穷大的舍入模式 */
    public final static int ROUND_FLOOR =        3;
    /** 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式 */
    public final static int ROUND_HALF_UP =      4;
    /** 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式 */
    public final static int ROUND_HALF_DOWN =    5;
    /** 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入 */
    public final static int ROUND_HALF_EVEN =    6;
    /** 断言请求的操作具有精确的结果，因此不需要舍入 */
    public final static int ROUND_UNNECESSARY =  7;

    /** 将 BigInteger 转换为 BigDecimal */
    public BigDecimal(BigInteger val) {}
    /** 将 BigInteger 非标度值和 int 标度转换为 BigDecimal */
    public BigDecimal(BigInteger unscaledVal, int scale) {}
    /** 将 BigInteger 非标度值和 int 标度转换为 BigDecimal（根据上下文设置进行舍入） */
    public BigDecimal(BigInteger unscaledVal, int scale, MathContext mc) {}
    /** 将 BigInteger 转换为 BigDecimal（根据上下文设置进行舍入） */
    public BigDecimal(BigInteger val, MathContext mc) {}
    /** 将 BigDecimal 的字符数组表示形式转换为 BigDecimal，接受与 BigDecimal(String) 构造方法相同的字符序列 */
    public BigDecimal(char[] in) {}
    /** 将 BigDecimal 的字符数组表示形式转换为 BigDecimal，接受与 BigDecimal(String) 构造方法相同的字符序列，
     * 同时允许指定子数组 */
    public BigDecimal(char[] in, int offset, int len) {}
    /** 将 BigDecimal 的字符数组表示形式转换为 BigDecimal，接受与 BigDecimal(String) 构造方法相同的字符序列，
     * 同时允许指定子数组，并根据上下文设置进行舍入 */
    public BigDecimal(char[] in, int offset, int len, MathContext mc) {}
    /** 将 BigDecimal 的字符数组表示形式转换为 BigDecimal，接受与 BigDecimal(String) 构造方法相同的字符序列
     *（根据上下文设置进行舍入） */
    public BigDecimal(char[] in, MathContext mc) {}
    /** 将 double 转换为 BigDecimal，后者是 double 的二进制浮点值准确的十进制表示形式 */
    public BigDecimal(double val) {}
    /** 将 double 转换为 BigDecimal（根据上下文设置进行舍入） */
    public BigDecimal(double val, MathContext mc) {}
    /** 将 int 转换为 BigDecimal */
    public BigDecimal(int val) {}
    /**  将 int 转换为 BigDecimal（根据上下文设置进行舍入） */
    public BigDecimal(int val, MathContext mc) {}
    /** 将 long 转换为 BigDecimal */
    public BigDecimal(long val) {}
    /** 将 long 转换为 BigDecimal（根据上下文设置进行舍入） */
    public BigDecimal(long val, MathContext mc) {}
    /** 将 BigDecimal 的字符串表示形式转换为 BigDecimal */
    public BigDecimal(String val) {}
    /** 将 BigDecimal 的字符串表示形式转换为 BigDecimal，接受与 BigDecimal(String) 构造方法相同的字符串
     * （按照上下文设置进行舍入） */
    public BigDecimal(String val, MathContext mc) {}
}
</pre>
								<ol>
                                    <li><p><code>static BigDecimal 	valueOf(double val)</code> -- 使用 Double.toString(double) 方法提供的 double 规范的字符串表示形式将 double 转换为 BigDecimal。</p></li>
                                    <li><p><code>static BigDecimal 	valueOf(long val)</code> -- 将 long 值转换为具有零标度的 BigDecimal。</p></li>
                                    <li><p><code>static BigDecimal 	valueOf(long unscaledVal, int scale)</code> -- 将 long 非标度值和 int 标度转换为 BigDecimal。</p></li>


                                    <li class="group"><p><code>BigDecimal 	add(BigDecimal augend)</code> -- 返回一个 BigDecimal，其值为 (this + augend)，其标度为 max(this.scale(), augend.scale())。</p></li>
                                    <li><p><code>BigDecimal 	add(BigDecimal augend, MathContext mc)</code> -- 返回其值为 (this + augend) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	subtract(BigDecimal subtrahend)</code> -- 返回一个 BigDecimal，其值为 (this - subtrahend)，其标度为 max(this.scale(), subtrahend.scale())。</p></li>
                                    <li><p><code>BigDecimal 	subtract(BigDecimal subtrahend, MathContext mc)</code> -- 返回其值为 (this - subtrahend) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	multiply(BigDecimal multiplicand)</code> -- 返回一个 BigDecimal，其值为 (this × multiplicand)，其标度为 (this.scale() + multiplicand.scale())。</p></li>
                                    <li><p><code>BigDecimal 	multiply(BigDecimal multiplicand, MathContext mc)</code> -- 返回其值为 (this × multiplicand) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	plus()</code> -- 返回 BigDecimal，其值为 (+this)，其标度为 this.scale()。</p></li>
                                    <li><p><code>BigDecimal 	plus(MathContext mc)</code> -- 返回其值为 (+this) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	negate()</code> -- 返回 BigDecimal，其值为 (-this)，其标度为 this.scale()。</p></li>
                                    <li><p><code>BigDecimal 	negate(MathContext mc)</code> -- 返回其值为 (-this) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	remainder(BigDecimal divisor)</code> -- 返回其值为 (this % divisor) 的 BigDecimal。</p></li>
                                    <li><p><code>BigDecimal 	remainder(BigDecimal divisor, MathContext mc)</code> -- 返回其值为 (this % divisor) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>

                                    <li class="group"><p><code>BigDecimal 	divide(BigDecimal divisor)</code> -- 返回一个 BigDecimal，其值为 (this / divisor)，其首选标度为 (this.scale() - divisor.scale())；如果无法表示准确的商值（因为它有无穷的十进制扩展），则抛出 ArithmeticException。</p></li>
                                    <li><p><code>BigDecimal 	divide(BigDecimal divisor, int roundingMode)</code> -- 返回一个 BigDecimal，其值为 (this / divisor)，其标度为 this.scale()。</p></li>
                                    <li><p><code>BigDecimal 	divide(BigDecimal divisor, int scale, int roundingMode)</code> -- 返回一个 BigDecimal，其值为 (this / divisor)，其标度为指定标度。</p></li>
                                    <li><p><code>BigDecimal 	divide(BigDecimal divisor, int scale, RoundingMode roundingMode)</code> -- 返回一个 BigDecimal，其值为 (this / divisor)，其标度为指定标度。</p></li>
                                    <li><p><code>BigDecimal 	divide(BigDecimal divisor, MathContext mc)</code> -- 返回其值为 (this / divisor) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	divide(BigDecimal divisor, RoundingMode roundingMode)</code> -- 返回一个 BigDecimal，其值为 (this / divisor)，其标度为 this.scale()。</p></li>
                                    <li><p><code>BigDecimal[] 	divideAndRemainder(BigDecimal divisor)</code> -- 返回由两个元素组成的 BigDecimal 数组，该数组包含 divideToIntegralValue 的结果，后跟对两个操作数计算所得到的 remainder。</p></li>
                                    <li><p><code>BigDecimal[] 	divideAndRemainder(BigDecimal divisor, MathContext mc)</code> -- 返回由两个元素组成的 BigDecimal 数组，该数组包含 divideToIntegralValue 的结果，后跟根据上下文设置对两个操作数进行舍入计算所得到的 remainder 的结果。</p></li>
                                    <li><p><code>BigDecimal 	divideToIntegralValue(BigDecimal divisor)</code> -- 返回 BigDecimal，其值为向下舍入所得商值 (this / divisor) 的整数部分。</p></li>
                                    <li><p><code>BigDecimal 	divideToIntegralValue(BigDecimal divisor, MathContext mc)</code> -- 返回 BigDecimal，其值为 (this / divisor) 的整数部分。</p>
										<pre class="brush:java;">
BigDecimal b1 = BigDecimal.valueOf(Math.PI); // 3.141592653589793
BigDecimal b2 = BigDecimal.valueOf(1.0);
b1.divide(b2) == 3.141592653589793;
b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP) == 3.14; // 指定精度和舍入模式
</pre>
									</li>

                                    <li class="group"><p><code>int 	intValue()</code> -- 将此 BigDecimal 转换为 int。</p></li>
                                    <li><p><code>int 	intValueExact()</code> -- 将此 BigDecimal 转换为 int，以检查丢失的信息。</p></li>
                                    <li><p><code>byte 	byteValueExact()</code> -- 将此 BigDecimal 转换为 byte，以检查丢失的信息。</p></li>
                                    <li><p><code>long 	longValue()</code> -- 将此 BigDecimal 转换为 long。</p></li>
                                    <li><p><code>long 	longValueExact()</code> -- 将此 BigDecimal 转换为 long，以检查丢失的信息。</p></li>
                                    <li><p><code>float 	floatValue()</code> -- 将此 BigDecimal 转换为 float。</p></li>
                                    <li><p><code>double 	doubleValue()</code> -- 将此 BigDecimal 转换为 double。</p></li>

                                    <li class="group"><p><code>BigDecimal 	abs()</code> -- 返回 BigDecimal，其值为此 BigDecimal 的绝对值，其标度为 this.scale()。</p></li>
                                    <li><p><code>BigDecimal 	abs(MathContext mc)</code> -- 返回其值为此 BigDecimal 绝对值的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	max(BigDecimal val)</code> -- 返回此 BigDecimal 和 val 的最大值。</p></li>
                                    <li><p><code>BigDecimal 	min(BigDecimal val)</code> -- 返回此 BigDecimal 和 val 的最小值。</p></li>
                                    <li><p><code>BigDecimal 	pow(int n)</code> -- 返回其值为 (thisn) 的 BigDecimal，准确计算该幂，使其具有无限精度。</p></li>
                                    <li><p><code>BigDecimal 	pow(int n, MathContext mc)</code> -- 返回其值为 (thisn) 的 BigDecimal。</p></li>
                                    <li><p><code>BigDecimal 	round(MathContext mc)</code> -- 返回根据 MathContext 设置进行舍入后的 BigDecimal。</p></li>

                                    <li class="group"><p><code>BigDecimal 	movePointLeft(int n)</code> -- 返回一个 BigDecimal，它等效于将该值的小数点向左移动 n 位。</p></li>
                                    <li><p><code>BigDecimal 	movePointRight(int n)</code> -- 返回一个 BigDecimal，它等效于将该值的小数点向右移动 n 位。</p></li>
                                    <li><p><code>BigDecimal 	scaleByPowerOfTen(int n)</code> -- 返回其数值等于 (this * 10n) 的 BigDecimal。</p></li>
                                    <li><p><code>BigDecimal 	setScale(int newScale)</code> -- 返回一个 BigDecimal，其标度为指定值，其值在数值上等于此 BigDecimal 的值。</p></li>
                                    <li><p><code>BigDecimal 	setScale(int newScale, int roundingMode)</code> -- 返回一个 BigDecimal，其标度为指定值，其非标度值通过此 BigDecimal 的非标度值乘以或除以十的适当次幂来确定，以维护其总值。</p></li>
                                    <li><p><code>BigDecimal 	setScale(int newScale, RoundingMode roundingMode)</code> -- 返回 BigDecimal，其标度为指定值，其非标度值通过此 BigDecimal 的非标度值乘以或除以十的适当次幂来确定，以维护其总值。</p></li>
                                    <li><p><code>short 	shortValueExact()</code> -- 将此 BigDecimal 转换为 short，以检查丢失的信息。</p></li>
                                    <li><p><code>BigDecimal 	stripTrailingZeros()</code> -- 返回数值上等于此小数，但从该表示形式移除所有尾部零的 BigDecimal。</p></li>

                                    <li class="group"><p><code>BigInteger 	toBigInteger()</code> -- 将此 BigDecimal 转换为 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	toBigIntegerExact()</code> -- 将此 BigDecimal 转换为 BigInteger，以检查丢失的信息。</p></li>

                                    <li class="group"><p><code>int 	signum()</code> -- 返回此 BigDecimal 的正负号函数。</p></li>
                                    <li><p><code>int 	precision()</code> -- 返回此 BigDecimal 的精度。</p></li>
                                    <li><p><code>int 	scale()</code> -- 返回此 BigDecimal 的标度。</p></li>
                                    <li><p><code>BigDecimal 	ulp()</code> -- 返回此 BigDecimal 的 ulp（最后一位的单位）的大小。</p></li>
                                    <li><p><code>BigInteger 	unscaledValue()</code> -- 返回其值为此 BigDecimal 的非标度值 的 BigInteger。</p></li>

                                    <li class="group"><p><code>String 	toString()</code> -- 返回此 BigDecimal 的字符串表示形式，如果需要指数，则使用科学记数法。</p></li>
                                    <li><p><code>String 	toPlainString()</code> -- 返回不带指数字段的此 BigDecimal 的字符串表示形式。</p></li>
                                    <li><p><code>String 	toEngineeringString()</code> -- 返回此 BigDecimal 的字符串表示形式，需要指数时，则使用工程计数法。</p></li>
                                    <li><p><code>int 	compareTo(BigDecimal val)</code> -- 将此 BigDecimal 与指定的 BigDecimal 比较。</p></li>
                                    <li><p><code>boolean 	equals(Object x)</code> -- 比较此 BigDecimal 与指定的 Object 的相等性。</p></li>
                                    <li><p><code>int 	hashCode()</code> -- 返回此 BigDecimal 的哈希码。</p></li>
								</ol>
							</li>
                            <li><p><a href="docs/docs-java/api/java/util/concurrent/atomic/AtomicInteger.html" target="_blank">java.util.concurrent.atomic.AtomicInteger</a> 可以用原子方式更新的 int 值，可用在应用程序中（如以原子方式增加的计数器），并且不能用于替换 Integer。但是，此类确实扩展了 Number，允许那些处理基于数字类的工具和实用工具进行统一访问。</p>
								<p><a href="docs/docs-java/api/java/util/concurrent/atomic/AtomicLong.html" target="_blank">java.util.concurrent.atomic.AtomicLong</a> 可以用原子方式更新的 long 值，可用在应用程序中（如以原子方式增加的序列号），并且不能用于替换 Long。但是，此类确实扩展了 Number，允许那些处理基于数字类的工具和实用工具进行统一访问。 </p>
								<pre class="brush: java;">
public class AtomicInteger extends Number implements Serializable {
    public AtomicInteger() {}
    public AtomicInteger(int initialValue) {}
}

public class AtomicLong extends Number implements Serializable {
    public AtomicLong() {}
    public AtomicLong(long initialValue) {}
}
</pre>
                                <ol>
                                    <li><p><code>int/long 	incrementAndGet()</code> -- 以原子方式将当前值加 1。</p></li>
                                    <li><p><code>int/long 	decrementAndGet()</code> -- 以原子方式将当前值减 1。</p></li>
                                    <li><p><code>int/long 	getAndDecrement()</code> -- 以原子方式将当前值减 1。</p></li>
                                    <li><p><code>int/long 	getAndIncrement()</code> -- 以原子方式将当前值加 1。</p></li>

                                    <li class="group"><p><code>int/long 	addAndGet(int/long delta)</code> -- 以原子方式将给定值与当前值相加。</p></li>
                                    <li><p><code>int/long 	getAndAdd(int/long delta)</code> -- 以原子方式将给定值与当前值相加。</p></li>
                                    <li><p><code>int/long 	getAndSet(int/long newValue)</code> -- 以原子方式设置为给定值，并返回旧值。</p></li>
                                    <li><p><code>int/long 	get()</code> -- 获取当前值。</p></li>
                                    <li><p><code>void 	set(int/long newValue)</code> -- 设置为给定值。</p></li>
                                    <li><p><code>void 	lazySet(int/long newValue)</code> -- 最后设置为给定值。</p></li>
                                    <li><p><code>String 	toString()</code> -- 返回当前值的字符串表示形式。</p></li>
                                    <li><p><code>boolean 	compareAndSet(int/long expect, int/long update)</code> -- 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。</p></li>
                                    <li><p><code>boolean 	weakCompareAndSet(int/long expect, int/long update)</code> -- 如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。</p></li>

                                    <li class="group"><p><code>int 	intValue()</code> -- 以 int 形式返回指定的数值。</p></li>
                                    <li><p><code>long 	longValue()</code> -- 以 long 形式返回指定的数值。</p></li>
                                    <li><p><code>float 	floatValue()</code> -- 以 float 形式返回指定的数值。</p></li>
                                    <li><p><code>double 	doubleValue()</code> -- 以 double 形式返回指定的数值。</p></li>

                                </ol>
							</li>
                        </ul>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Exception"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Exception 和 Error</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">
public class Throwable implements Serializable {
    public Throwable() {}
    public Throwable(String message) {}
    public Throwable(String message, Throwable cause) {}
    public Throwable(Throwable cause) {}
    protected Throwable(String message, Throwable cause, boolean enableSuppression,
                            boolean writableStackTrace) {}
}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/Throwable.html" target="_blank">Throwable</a> 是 Java 语言中所有错误或异常的超类。只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。类似地，只有此类或其子类之一才可以是 catch 子句中的参数类型。 </p>
                        <p>两个子类的实例，<a href="docs/docs-java/api/java/lang/Error.html" target="_blank">Error</a> 和 <a href="docs/docs-java/api/java/lang/Exception.html" target="_blank">Exception</a>，通常用于指示发生了异常情况。通常，这些实例是在异常情况的上下文中新近创建的，因此包含了相关的信息（比如堆栈跟踪数据）。 </p>
                        <ul>
                            <li><p><a href="docs/docs-java/api/java/lang/Exception.html" target="_blank">Exception</a> -- 类及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。</p></li>
                            <li><p><a href="docs/docs-java/api/java/lang/Error.html" target="_blank">Error</a> -- 是 Throwable 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。虽然 ThreadDeath 错误是一个“正规”的条件，但它也是 Error 的子类，因为大多数应用程序都不应该试图捕获它。 </p></li>
                        </ul>
                        <p><b>Throwable</b> API:</p>
                        <ol>
                            <li><p><code>Throwable 	getCause()</code> -- 返回此 throwable 的 cause；如果 cause 不存在或未知，则返回 null。</p></li>
                            <li><p><code>String 	getLocalizedMessage()</code> -- 创建此 throwable 的本地化描述。</p></li>
                            <li><p><code>String 	getMessage()</code> -- 返回此 throwable 的详细消息字符串。</p></li>
                            <li><p><code>StackTraceElement[] 	getStackTrace()</code> -- 提供编程访问由 printStackTrace() 输出的堆栈跟踪信息。</p></li>
                            <li><p><code>void 	setStackTrace(StackTraceElement[] stackTrace)</code> -- 设置将由 getStackTrace() 返回，并由 printStackTrace() 和相关方法输出的堆栈跟踪元素。</p></li>
                            <li><p><code>String 	toString()</code> -- 返回此 throwable 的简短描述。</p></li>

                            <li class="group"><p><code>void 	printStackTrace()</code> -- 将此 throwable 及其追踪输出至标准错误流。</p></li>
                            <li><p><code>void 	printStackTrace(PrintStream s)</code> -- 将此 throwable 及其追踪输出到指定的输出流。</p></li>
                            <li><p><code>void 	printStackTrace(PrintWriter s)</code> -- 将此 throwable 及其追踪输出到指定的 PrintWriter。</p></li>

                            <li class="group"><p><code>void 	addSuppressed(Throwable exception)</code> -- 将指定的异常追加到为传递此异常而被抑制的异常中。</p></li>
                            <li><p><code>Throwable 	fillInStackTrace()</code> -- 在异常堆栈跟踪中填充。</p></li>
                            <li><p><code>Throwable 	initCause(Throwable cause)</code> -- 将此 throwable 的 cause 初始化为指定值。</p></li>
                        </ol>

                        <p><p><a href="docs/docs-java/api/java/lang/Exception.html" target="_blank">Exception</a> 类的常见直接子类和间接子类:</p>
                            <pre class="brush: java;">
java.lang.Object
    java.lang.Throwable
        java.lang.Exception
         ├─ CloneNotSupportedException -- 对象未实现 Cloneable 接口
         ├─ ClassNotFoundException -- 未找到加载的类(使用反射时候发生)
         ├─ NoSuchMethodException -- 无法找到某一特定方法时，抛出该异常(使用反射时候发生)
         ├─ NoSuchFieldException -- 不包含指定名称的字段时产生的信号(使用反射时候发生)
         ├─ InterruptedException -- 当线程在活动之前或活动期间处于正在等待、休眠或占用状态且该线程被中断时，抛出该异常
         ├─ java.net.URISyntaxException -- 经过检查的指示字符串不能解析为 URI
         ├─ java.util.concurrent.TimeoutException -- 阻塞操作超时时
         ├─ java.sql.SQLException -- 数据库访问错误或其他错误信息
         ├─ java.util.zip.DataFormatException -- 当数据格式发生错误时
         └─ RuntimeException -- 可能在 Java 虚拟机正常运行期间抛出的异常的超类
             ├─ IllegalArgumentException -- 异常表明向方法传递了一个不合法或不正确的参数
             │   ├─ NumberFormatException -- 试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时
             │   ├─ PatternSyntaxException -- 表明正则表达式模式中的语法错误
             │   ├─ IllegalCharsetNameException -- 不是合法 charset 名称的字符串用作 charset 名称时
             │   ├─ IllegalFormatException -- 格式字符串包含非法语法，或者包含与给定参数不兼容的格式说明符时
             │   ├─ IllegalThreadStateException -- 指示线程没有处于请求操作所要求的适当状态时抛出的异常
             │   ├─ UnresolvedAddressException -- 试图对未解析的套接字地址调用网络操作时
             │   ├─ UnsupportedAddressTypeException -- 试图绑定或连接到一个其类型不受支持的套接字地址时
             │   └─ UnsupportedCharsetException -- 当不支持请求的 charset 时
             ├─ ArithmeticException -- 当出现异常的运算条件时(比如除以 0)
             ├─ ClassCastException -- 当试图将对象强制转换为不是实例的子类时
             ├─ org.w3c.dom.DOMException -- DOM 操作只在 "exceptional" 情况下引发异常，即不能执行操作时
             ├─ ArrayStoreException -- 将错误类型的对象存储到一个对象数组时
             ├─ IllegalStateException -- 在非法或不适当的时间调用方法时产生的信号
             ├─ IndexOutOfBoundsException -- 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出
             │   ├─ StringIndexOutOfBoundsException -- 常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小
             │   └─ ArrayIndexOutOfBoundsException -- 用非法索引访问数组时
             ├─ NoSuchElementException -- 由 Enumeration 的 nextElement 方法抛出，表明枚举中没有更多的元素
             ├─ NullPointerException -- 在需要对象的地方使用 null 时
             └─ ......
</pre>
                        <p><p><a href="docs/docs-java/api/java/lang/Error.html" target="_blank">Error</a> 类的常见直接子类和间接子类:</p>
                        <pre class="brush: java;">
java.lang.Error
 ├─ AnnotationFormatError -- 当注释解析器试图从类文件读取注释并确定注释出现异常时
 ├─ AssertionError -- 抛出该异常指示某个断言失败
 ├─ ThreadDeath -- 调用 Thread 类中带有零参数的 stop 方法时，受害线程将抛出一个 ThreadDeath 实例
 ├─ java.io.IOError -- 当发生严重的 I/O 错误时，抛出此错误
 ├─ VirtualMachineError -- 当 Java 虚拟机崩溃或用尽了它继续操作所需的资源时
 │   ├─ OutOfMemoryError -- 因为内存溢出或没有可用的内存提供给垃圾回收器时，Java 虚拟机无法分配一个对象
 │   ├─ StackOverflowError -- 当应用程序递归太深而发生堆栈溢出时
 │   ├─ UnknownError -- 当 Java 虚拟机中出现一个未知但严重的异常时
 │   └─ InternalError -- 该异常指示 Java 虚拟机中出现一些意外的内部错误
 └─ LinkageError -- 指示一个类在一定程度上依赖于另一个类；但是，在编译前一个类之后，后一个类发生了不相容的改变
     ├─ ClassFormatError -- 当 Java 虚拟机试图读取类文件并确定该文件存在格式错误或无法解释为类文件时
     │   ├─ GenericSignatureFormatError -- 解释类型、方法或构造方法的一般签名信息的反射方法遇到语法错误的签名属性时
     │   └─ UnsupportedClassVersionError -- 当 Java 虚拟机试图读取一个类文件，并确定文件的主辅版本号不受支持时
     ├─ ClassCircularityError -- 当初始化类时检测到类的循环调用的时候
     ├─ NoClassDefFoundError -- 当 Java 虚拟机或 ClassLoader 实例试图在类的定义中加载，但无法找到该类的定义时
     ├─ VerifyError -- 当“校验器”检测到一个类文件虽然格式正确，但包含着一些内部不一致性或安全性问题时
     ├─ UnsatisfiedLinkError -- 当 Java 虚拟机无法找到声明为 native 的方法的适当本地语言定义时
     ├─ ExceptionInInitializerError -- 静态初始化程序中发生意外异常的信号
     └─ IncompatibleClassChangeError -- 通常由编译器捕获此类错误
         ├─ NoSuchMethodError -- 当应用程序试图调用类（静态或实例）的指定方法，而该类已不再具有该方法的定义时
         ├─ NoSuchFieldError -- 如果应用程序试图访问或修改一个指定的对象字段，而该对象不再包含该字段时
         ├─ AbstractMethodError -- 当应用程序试图使用 Java 的 new 结构来实例化一个抽象类或一个接口时
         ├─ IllegalAccessError -- 当应用程序试图访问或修改它不能访问的字段，或调用它不能访问的方法时
         └─ InstantiationError -- 当应用程序试图调用一个抽象方法时


</pre>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-ref-Reference"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title"><code>java.lang.ref.</code>Reference 及子类</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
public abstract class Reference&lt;T> {
    private T referent; // 引用的对象

    /** 两个构造方法只有包可访问性，只能使用 JDK 提供的几个子类 */
    Reference(T referent) {}
    Reference(T referent, ReferenceQueue&lt;? super T> queue) {}

    public T get() {} // 返回此引用对象的指示对象
    public void clear() {} // 清除此引用对象
    public boolean enqueue() {} // 将此引用对象添加到引用对象已向其注册的队列
    public boolean isEnqueued() {} // 由程序或垃圾回收器通知是否已将此引用对象加入队列
}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/ref/Reference.html" target="_blank">Reference</a> 引用对象的抽象基类。此类定义了常用于所有引用对象的操作。因为引用对象是通过与垃圾回收器的密切合作来实现的，所以不能直接为此类创建子类。</p>
                        <p><b>四种类型的引用:</b></p>
                        <ul>
                            <li><p><b>强引用</b> -- 直接使用 <code>new</code> 构建的对象，只要某个对象有强引用与之关联，JVM 必定不会回收这个对象，即使在内存不足的情况下，JVM 宁愿抛出 OutOfMemory 错误也不会回收这种对象。</p>
                                <p>如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为 null，这样一来的话，JVM 在合适的时间就会回收该对象。</p>
                            </li>
                            <li><p><b>软引用</b> -- 软引用是用来描述一些有用但并不是必需的对象，在 Java 中用 <a href="docs/docs-java/api/java/lang/ref/SoftReference.html" target="_blank">SoftReference</a> 类来表示。</p>
                                <p>对于软引用关联着的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决 OOM 的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>
                                <p>软引用可以和一个引用队列（<a href="docs/docs-java/api/java/lang/ref/ReferenceQueue.html" target="_blank">ReferenceQueue</a>）联合使用，如果软引用所引用的对象被 JVM 回收，这个软引用就会被加入到与之关联的引用队列中。</p>
                            </li>
                            <li><p><b>弱引用</b> -- 弱引用也是用来描述非必需对象的，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在 Java 中用 <a href="docs/docs-java/api/java/lang/ref/WeakReference.html" target="_blank">WeakReference</a> 类来表示。</p>
                                <p>弱引用可以和一个引用队列（<a href="docs/docs-java/api/java/lang/ref/ReferenceQueue.html" target="_blank">ReferenceQueue</a>）联合使用，如果弱引用所引用的对象被 JVM 回收，这个弱引用就会被加入到与之关联的引用队列中。</p>
                            </li>
                            <li><p><b>虚引用</b> -- 虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在 Java 中用 <a href="docs/docs-java/api/java/lang/ref/PhantomReference.html" target="_blank">PhantomReference</a> 类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</p>
                                <p>要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
                            </li>
                        </ul>

                        <p><a href="docs/docs-java/api/java/lang/ref/ReferenceQueue.html" target="_blank">ReferenceQueue</a> 引用队列，在检测到适当的可到达性更改后，垃圾回收器将已注册的引用对象添加到该队列中。 </p>
                        <pre class="brush: java;">
public class ReferenceQueue&lt;T> {
    public ReferenceQueue() {}

    public Reference&lt;? extends T> poll() {} // 轮询此队列，查看是否存在可用的引用对象
    public Reference&lt;? extends T> remove() {} // 移除此队列中的下一个引用对象，阻塞到某个对象变得可用为止
    public Reference&lt;? extends T> remove(long timeout) {} // 阻塞到有一个对象变得可用或者给定的超时期满了为止
}
</pre>

                        <p><a href="docs/docs-java/api/java/lang/ref/SoftReference.html" target="_blank">SoftReference</a> 软引用对象，在响应内存需要时，由垃圾回收器决定是否清除此对象。软引用对象最常用于实现内存敏感的缓存，比如加载图片。</p>
                        <p>软可到达对象的所有软引用都要保证在虚拟机抛出 OutOfMemoryError 之前已经被清除。否则，清除软引用的时间或者清除不同对象的一组此类引用的顺序将不受任何约束。然而，虚拟机实现不鼓励清除最近访问或使用过的软引用。 </p>
                        <pre class="brush: java;">
public class SoftReference&lt;T> extends Reference&lt;T> {
    public SoftReference(T referent) {}
    public SoftReference(T referent, ReferenceQueue&lt;? super T> q) {}
}
</pre>

                        <p><a href="docs/docs-java/api/java/lang/ref/WeakReference.html" target="_blank">WeakReference</a> 弱引用对象，它们并不禁止其指示对象变得可终结，并被终结，然后被回收。弱引用最常用于实现规范化的映射。 </p>
                        <pre class="brush: java;">
public class WeakReference&lt;T> extends Reference&lt;T> {
    public WeakReference(T referent) {}
    public WeakReference(T referent, ReferenceQueue&lt;? super T> q) {}
}

WeakReference&lt;String> lSoftReference = new WeakReference<>(new String("hello"));
log(lSoftReference.get()); // hello
System.gc();
log(lSoftReference.get()); // null
</pre>

                        <p><a href="docs/docs-java/api/java/lang/ref/PhantomReference.html" target="_blank">PhantomReference</a> 与软引用和弱引用不同，虚引用在加入队列时并没有通过垃圾回收器自动清除。通过虚引用可到达的对象将仍然保持原状，直到所有这类引用都被清除，或者它们都变得不可到达。</p>
                        <pre class="brush: java;">
public class PhantomReference&lt;T> extends Reference&lt;T> {
    public PhantomReference(T referent, ReferenceQueue&lt;? super T> q) {}
}
</pre>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-annotation-Annotation"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Annotation 及元注解</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
public interface Annotation {}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/annotation/Annotation.html" target="_blank">Annotation</a> 为 Java 编程语言注释设施提供库支持。 </p>
                            <p>注解的定义类似于接口的定义，使用 <code>@interface</code> 来定义，自动继承自 <code>Annotation</code> 接口。</p>
                            <p><b>注意</b>，手动扩展该公共接口的接口不定义 annotation 类型。还要注意此接口本身不定义 annotation 类型。 </p>
                            <ol>
                                <li><p><code>Class&lt;? extends Annotation> 	annotationType()</code> -- 返回此 annotation 的注释类型</p></li>
                                <li><p><code>boolean 	equals(Object obj)</code> -- 如果指定的对象表示在逻辑上等效于此接口的注释，则返回 true。换句话说，如果指定对象是一个与此实例相同的 annotation 类型的实例，即其所有成员都与此实例中所对应的成员相等，则返回 true</p></li>
                                <li><p><code>int 	hashCode()</code> -- 返回此 annotation 的哈希码</p></li>
                                <li><p><code>String 	toString()</code> -- 返回此 annotation 的字符串表示形式</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <div class="split-item">
                                <p><b>Java 元注解</b> -- 是指用于定义注解类型的注解。包括 @Retention @Target @Document @Inherited @Repeatable(1.8 添加) 几种。</p>
                                <table class="table table-responsive table-striped table-bordered">
                                    <thead>
                                    <tr>
                                        <th>注解</th>
                                        <th>说明</th>
                                    </tr>
                                    </thead>
                                    <tbody>
                                    <tr>
                                        <td>@Target</td>
                                        <td>定义注解的作用目标，其值为 ElementType 类型数组</td>
                                    </tr>
                                    <tr>
                                        <td>@Retention</td>
                                        <td>定义注解的保留策略，其值为 RetentionPolicy 类型</td>
                                    </tr>
                                    <tr>
                                        <td>@Document</td>
                                        <td>说明该注解将被包含在 Javadoc 中</td>
                                    </tr>
                                    <tr>
                                        <td>@Inherited</td>
                                        <td>说明子类可以继承父类中的该注解</td>
                                    </tr>
                                    <tr>
                                        <td>@RepeatAble</td>
                                        <td>表明标记的注解可以多次应用于相同的声明或类型使用</td>
                                    </tr>
                                    </tbody>
                                </table>
                                <p>当注解未指定 Target 值时，则此注解可以用于任何元素之上，多个值使用 {} 包含并用逗号隔开，如下：</p>
                                <pre class="brush: java;">@Target(value={CONSTRUCTOR, FIELD, METHOD})</pre>
                                <table class="table table-responsive table-striped table-bordered">
                                <thead>
                                <tr>
                                    <th>Target 类型</th>
                                    <th>说明</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>ElementType.TYPE</td>
                                    <td>接口、类、枚举、注解</td>
                                </tr>
                                <tr>
                                    <td>ElementType.FIELD</td>
                                    <td>字段、枚举的常量</td>
                                </tr>
                                <tr>
                                    <td>ElementType.METHOD</td>
                                    <td>方法</td>
                                </tr>
                                <tr>
                                    <td>ElementType.CONSTRUCTOR</td>
                                    <td>构造函数</td>
                                </tr>
                                <tr>
                                    <td>ElementType.LOCAL_VARIABLE</td>
                                    <td>局部变量</td>
                                </tr>
                                <tr>
                                    <td>ElementType.ANNOTATION_TYPE</td>
                                    <td>注解</td>
                                </tr>
                                <tr>
                                    <td>ElementType.PACKAGE</td>
                                    <td>包</td>
                                </tr>
                                <tr>
                                    <td>ElementType.PARAMETER</td>
                                    <td>方法参数</td>
                                </tr>
                                <tr>
                                    <td>ElementType.TYPE_USE</td>
                                    <td>类型使用声明</td>
                                </tr>
                                </tbody>
                            </table>
                            </div>

                            <div class="split-item">
								<pre class="brush: java;">
@Documented // 说明该注解将被包含在 javadoc 中
@Retention(RetentionPolicy.RUNTIME) // 定义注解的保留策略为运行时
@Target(ElementType.ANNOTATION_TYPE) // 表明为元注解
public @interface Target {
	ElementType[] value(); // 值为 ElementType
}

public enum ElementType {
    TYPE, /** 定义接口、类、枚举、注解的时候使用 */
    FIELD, /** 字段、枚举的常量上使用 */
    METHOD, /** 方法上使用 */
    CONSTRUCTOR, /** 构造方法上使用 */
    LOCAL_VARIABLE, /** 局部变量上使用 */
    ANNOTATION_TYPE, /** 注解类型类型上使用,表明为元注解 */
    PACKAGE, /** 包声明时使用 */
    PARAMETER, /** 形式参数声明 */
    TYPE_PARAMETER, /** 类型参数声明 */
    TYPE_USE /** 类型的使用 */
}
</pre>
                                <p><a href="docs/docs-java/api/java/lang/annotation/Target.html" target="_blank">@Target</a> 用于定义注解的作用目标。</p>
								<p><a href="docs/docs-java/api/java/lang/annotation/ElementType.html" target="_blank">ElementType</a> 是 Target 的参数值，为枚举常量。</p>
								<p><a href="docs/docs-java/api/java/lang/annotation/Documented.html" target="_blank">@Documented</a> 表明无论何时使用指定的注释，都应该使用Javadoc工具对这些元素进行文档化。</p>
								<p><a href="docs/docs-java/api/java/lang/annotation/Inherited.html" target="_blank">@Inherited</a> 说明子类可以继承父类中的该注解。</p>
								<p><a href="docs/docs-java/api/java/lang/annotation/Retention.html" target="_blank">@Retention</a> 定义注解的保留策略。</p>
                                <p><a href="docs/docs-java/api/java/lang/annotation/RetentionPolicy.html" target="_blank">RetentionPolicy</a> 是 Retention 的参数值，，为枚举常量。</p>
                                <p><a href="docs/docs-java/api/java/lang/annotation/Repeatable.html" target="_blank">@Repeatable</a> 是 Java 1.8 添加的，表明标记的注解可以多次应用于相同的声明或类型使用。</p>
                                <pre class="brush: java;">
public enum RetentionPolicy {
	RUNTIME // 注解会在 class 字节码文件中存在，在运行时可以通过反射获取到(应用较多)
	CLASS, // 默认的保留策略，注解会在 class 字节码文件中存在，但运行时无法获得
	SOURCE, // 注解仅存在于源码中，在 class 字节码文件中不包含
}
</pre>
                            </div>
                        </div>

                        <div class="split-item">
                            <p><b>Java 常用的内置注解类型(都是 java.lang 包下)：</b></p>
                            <ul>
                                <li><p><a href="docs/docs-java/api/java/lang/Override.html" target="_blank">@Override</a> -- 指示一个方法声明要覆盖一个父类型中的方法声明。</p>
                                    <pre class="brush: java;">
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {}

/** 实例 */
interface IParent { void a(); }
class Parent { void b() {} }

class Child extends Parent implements IParent {
    @Override
    public void a() {}

    @Override
    void b() {}
}
</pre>
                                </li>
                                <li><p><a href="docs/docs-java/api/java/lang/Deprecated.html" target="_blank">@Deprecated</a> -- 指示元素(方法或字段)是程序员使用的不鼓励使用，通常是因为危险，或者因为存在更好的选择。</p>
                                    <pre class="brush: java;">
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {}

/** 实例 */
public class NumberUtil {
    @Deprecated // 不应该再使用此方法，应该使用 toInt(String val, int def) 更好
    public static int toInt(String val) {
        try { return Integer.parseInt(val); }
        catch (NumberFormatException e) { return -1; }
    }

    public static int toInt(String val, int def) {
        try { return Integer.parseInt(val); }
        catch (NumberFormatException e) { return def; }
    }
}
</pre>
                                </li>

                                <li><p><a href="docs/docs-java/api/java/lang/SafeVarargs.html" target="_blank">@SafeVarargs</a> -- 该注释应用于方法或构造函数时，断言代码不会对其可变参数执行潜在的不安全操作。</p>
                                    <pre class="brush: java;">
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD})
public @interface SafeVarargs {}

/** 实例 */
public class VarargsWaring {
    @SafeVarargs // 用于 final / static 的方法，参数为可变参数，并且一般都是泛型
    public static&lt;T> T useVarargs(T... args){
        return args.length > 0 ? args[0] : null;
    }
}
</pre>
                                </li>
                                <li><p><a href="docs/docs-java/api/java/lang/FunctionalInterface.html" target="_blank">@FunctionalInterface</a> -- 表明接口只有一个未实现的方法（对于 Lambda 表达式很重要，参见 <a href="#java-util-function">java.util.function</a> 包）。</p>
                                    <pre class="brush: java;">
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FunctionalInterface {}

/** 实例 */
@FunctionalInterface // 接口只能有一个未实现的方法
public interface ITest {
    void a();

    default void b() {}
}
</pre>
                                </li>
                                <li><p><a href="docs/docs-java/api/java/lang/SuppressWarnings.html" target="_blank">@SuppressWarnings</a> -- 用于抑制编译器的警告。</p>
                                    <p>注意，在给定元素中取消显示的警告集是所有包含元素中取消显示的警告的超集。</p>
                                    <p>根据风格不同，程序员应该始终在最里层的嵌套元素上使用此注释，在那里使用才有效。如果要在特定的方法中取消显示某个警告，则应该注释该方法而不是注释它的类。 </p>
                                    <pre class="brush: java;">
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
</pre>
                                    <p>常见的抑制的选项参见下表，多种类型的警告如下：</p>
                                    <pre class="brush: java;">@SuppressWarnings({"unchecked", "rawtypes"})</pre>
                                    <table class="table table-responsive table-striped table-bordered">
                                        <thead>
                                        <tr>
                                            <th>选项</th>
                                            <th>说明</th>
                                        </tr>
                                        </thead>
                                        <tbody><tr>
                                            <td align="left">all</td>
                                            <td align="left">禁止所有警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">deprecation</td>
                                            <td align="left">使用了不推荐的 API</td>
                                        </tr>
                                        <tr>
                                            <td align="left">unchecked</td>
                                            <td align="left">未经检查的转换，比如泛型未指定类型</td>
                                        </tr>
                                        <tr>
                                            <td align="left">unused</td>
                                            <td align="left">未使用代码，比如某个方法从未调用，或者使用反射调用的</td>
                                        </tr>
                                        <tr>
                                            <td align="left">serial</td>
                                            <td align="left">当在可序列化的类中没有发现 serialVersionUID 字段的警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">boxing</td>
                                            <td align="left">禁止与装箱/拆箱操作相关的警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">cast</td>
                                            <td align="left">强制转换以抑制与强制转换操作相关的警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">dep-ann</td>
                                            <td align="left">用于抑制相对于已弃用注释的警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">fallthrough</td>
                                            <td align="left">在 switch 语句块中，除了最后一个 case 之外的其它 case 中没有包含 break 语句</td>
                                        </tr>
                                        <tr>
                                            <td align="left">finally</td>
                                            <td align="left">当发现 finally 子句无法正常结束的情况时给出警告，比如 finally 块中为死循环</td>
                                        </tr>
                                        <tr>
                                            <td align="left">hiding</td>
                                            <td align="left">隐藏以抑制相对于隐藏变量的本地警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">incomplete-switch</td>
                                            <td align="left">忽略没有完整的 switch 语句</td>
                                        </tr>
                                        <tr>
                                            <td align="left">javadoc</td>
                                            <td align="left">禁止与 javadoc 警告相关的警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">nls</td>
                                            <td align="left">使用nls来抑制相对于非nls字符串的警告。</td>
                                        </tr>
                                        <tr>
                                            <td align="left">null</td>
                                            <td align="left">空值来抑制相对于空值分析的警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">rawtypes</td>
                                            <td align="left">拒绝与使用原始类型相关的警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">resource</td>
                                            <td align="left">用于抑制与使用类型为Closeable的资源相关的警告的资源</td>
                                        </tr>
                                        <tr>
                                            <td align="left">restriction</td>
                                            <td align="left">限制禁止与使用不鼓励或禁止引用相关的警告</td>
                                        </tr>

                                        <tr>
                                            <td align="left">static-access</td>
                                            <td align="left">静态访问，抑制相对于不正确的静态访问的警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">static-method</td>
                                            <td align="left">静态方法，用于抑制相对于可以声明为静态的方法的警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">super</td>
                                            <td align="left">超级-来抑制相对于在没有超级调用的情况下重写方法的警告</td>
                                        </tr>
                                        <tr>
                                            <td align="left">synthetic-access</td>
                                            <td align="left">用于抑制相对于内部类的未优化访问的警告的合成访问</td>
                                        </tr>
                                        <tr>
                                            <td align="left">sync-override</td>
                                            <td align="left">在覆盖同步方法时，由于缺少同步而取消警告</td>
                                        </tr>

                                        <tr>
                                            <td align="left">unqualified-field-access</td>
                                            <td align="left">不限定字段访问来抑制与字段访问不限定相关的警告</td>
                                        </tr>

                                        </tbody>
                                    </table>
                                </li>
                            </ul>


                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-annotation-Compile-Annotation"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">编译时注解和源码注解</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <p>编译时注解(RetentionPolicy.CLASS)都要和注解处理器(Annotation Processor) 扯上关系，因为这里是真正体现编译时注解价值的地方。</p>
                            <p>需要注意的一点是，运行时注解(RetentionPolicy.RUNTIME)和源码注解(RetentionPolicy.SOURCE)也可以在注解处理器进行处理，不同的注解有各自的生命周期，根据你实际使用来确定。</p>
                            <p>注解处理器是 javac 的一个工具，它用来在编译时扫描和处理注解（Annotation）。你可以自定义注解，并注册到相应的注解处理器，由注解处理器来处理你的注解。</p>
                            <p>一个注解的注解处理器，以 Java 代码（或者编译过的字节码）作为输入，生成文件（通常是 <code>.java</code> 文件）作为输出。这些生成的 Java 代码是在生成的 .java 文件中，所以你不能修改已经存在的 Java 类，例如向已有的类中添加方法。这些生成的 Java 文件，会同其他普通的手动编写的Java源代码一样被 javac 编译。</p>
                            <pre class="brush: java;">

</pre>
                        </div>

                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-annotation-MyAnnotation"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">自定义注解使用实例</h3>
                    </div>
                    <div class="panel-body">
                        <p><b>自定义注解使用实例：</b></p>
                        <ol type="I">
                            <li><p>定义实体类和三个注解类(都是运行时注解):</p>
                                <pre class="brush: java;">
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface FruitName { // 表示水果名字
    String value();
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface FruitColor { // 表示水果颜色
    Color color() default Color.RED;

    enum Color { // 内部枚举
        RED("Red"), BLUE("Blue"), GREEN("Green"), YELLOW("Yellow");

        private String colorName;
        private Color(String colorName) { this.colorName = colorName; }
        public String getColorName() { return colorName; }
    }
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface FruitAttributes { // // 表示只是为了演示多个属性时如何使用，相当于前面两个类
    FruitColor.Color color();
    String name();
}

public class Fruit { // 实体类
    private String name;
    private FruitColor.Color color;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public FruitColor.Color getColor() { return color; }
    public void setColor(FruitColor.Color color) { this.color = color; }
}
</pre>
                            </li>
                            <li><p>自定义注解处理器处理注解(这里处理的都是运行时注解):</p>
                                <pre class="brush: java;">
public class FruitAnnotationHandler {
    /** 因为要设置注解所在类的字段值，此处要拿到注解所在类的 class 和实例对象，所以使用了一个 Object 类型的参数 */
    public static void handler(Object instance) {
        Field[] fields = instance.getClass().getDeclaredFields();
        for (Field field : fields) {
            Class clazz = field.getType();
            if (clazz.getName().equals(Fruit.class.getName())) {
                field.setAccessible(true); // 允许访问 private 字段
                Fruit fruit = null;
                try {
                    try {
                        fruit = (Fruit) clazz.newInstance();
                    } catch (InstantiationException e) {
                        e.printStackTrace();
                    }
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
                if (field.isAnnotationPresent(FruitName.class)) {
                    FruitName fruitName = field.getAnnotation(FruitName.class);
                    fruit.setName(fruitName.value());
                }
                if (field.isAnnotationPresent(FruitColor.class)) {
                    FruitColor fruitColor = field.getAnnotation(FruitColor.class);
                    fruit.setColor(fruitColor.color());
                }
                if (field.isAnnotationPresent(FruitAttributes.class)) {
                    FruitAttributes fruitAttributes = field.getAnnotation(FruitAttributes.class);
                    fruit.setName(fruitAttributes.name());
                    fruit.setColor(fruitAttributes.color());
                }
                try {
                    field.set(instance, fruit); // 将指定对象的字段赋为指定值
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</pre>
                            </li>
                            <li><p>使用自定义的注解类(要先调用注解处理器处理注解):</p>
                                <pre class="brush: java;">
public class MyAnnotation {
    @FruitName("Apple") // 如果注解方法为 value(), 那么不用指定方法名
    // 如果注解方法名不是 value()， 那么要如下赋值；可以只写: @FruitColor, 因为定义注解时有默认值为： Color.RED
    @FruitColor(color = FruitColor.Color.RED)
    public Fruit redApple; // 此处为 public

    @FruitName("Banana")
    @FruitColor(color = FruitColor.Color.YELLOW)
    private Fruit yellowBanana; // 如果为 private, 那么在注解处理器要有 field.setAccessible(true);

    @FruitAttributes(name = "Apple", color = FruitColor.Color.GREEN) // 多个注解值一起使用，需要指定方法名
    private Fruit greenApple

    public static void main(String[] args) {
        FruitAnnotationHandler.handler(this); // 调用注解处理器处理注解，实例化注解字段
        log(redApple.getName(), redApple.getColor());
        log(greenApple.getName(), greenApple.getColor(), greenApple.getColor().getColorName());
        log(yellowBanana.getName(), yellowBanana.getColor());
    }
}
</pre>
                            </li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-reflect-base"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">反射类的基础接口和类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
Member
 ├─ Executable
 ├─ Constructor
 ├─ Field
 └─ Method

public interface Member {
    int PUBLIC = 0; // 标识类或接口的所有公共成员（包括继承成员）的集合
    int DECLARED = 1; // 标识类或接口的所有已声明成员的集合
}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Member.html" target="_blank">Member</a> 是一种接口，反映有关单个成员（字段或方法）或构造方法的标识信息。</p>
                            <p>实现类：<a href="#java-lang-reflect-Executable">Executable</a>, <a href="#java-lang-reflect-Constructor">Constructor</a>, <a href="#java-lang-reflect-Field">Field</a>, <a href="#java-lang-reflect-Method">Method</a></p>
                            <ol>
                                <li><p><code>Class&lt;?> 	getDeclaringClass()</code> -- 返回表示声明由此 Member 表示的成员或构造方法的类或接口的 Class 对象</p></li>
                                <li><p><code>int 	getModifiers()</code> -- 作为整数返回由此 Member 所表示的成员或构造方法的 Java 语言修饰符</p></li>
                                <li><p><code>String 	getName()</code> -- 返回此 Member 表示的底层成员或构造方法的简单名称</p></li>
                                <li><p><code>boolean 	isSynthetic()</code> -- 如果此成员是编译器引入的，则返回 true；否则，返回 false</p></li>
                            </ol>
                            <pre class="brush: java;">
public final void member() {
    try {
        Member member = MyReflect.class.getMethod("member"); // MyReflect 的 member 方法
        int mofifiers = member.getModifiers();
        log(Modifier.toString(mofifiers)); // 修饰符，转换为 String 查看: public final
        log(member.getName());  // 成员名，这里是方法: member
        log(member.getDeclaringClass().getName()); // Class: io.github.java.lang.reflect.MyReflect
        log(member.isSynthetic()); // 成员是否是编译器引入: false
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    }
}
</pre>
                        </div>

                        <a class="offset" id="AnnotedElement"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface AnnotatedElement {}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/AnnotatedElement.html" target="_blank">AnnotatedElement</a> 是注解元素(类，字段，方法等等)，表示目前正在此 VM 中运行的程序的一个已注释元素。该接口允许反射性地读取注释。由此接口中的方法返回的所有注释都是不可变并且可序列化的。调用者可以修改已赋值数组枚举成员的访问器返回的数组；这不会对其他调用者返回的数组产生任何影响。 </p>
                            <p>如果此接口中的方法返回的注释（直接或间接地）包含一个已赋值的 Class 成员，该成员引用了一个在此 VM 中不可访问的类，则试图通过在返回的注释上调用相关的类返回的方法来读取该类，将导致一个 TypeNotPresentException。 </p>
                            <p>类似地，如果注释中的枚举常量不再以枚举类型存在，那么试图读取一个已赋值的枚举成员将导致一个 EnumConstantNotPresentException。 </p>
                            <ol>
                                <li><p><code>Annotation[] 	getAnnotations()</code> -- 返回此元素上存在的所有注解</p>
                                    <pre class="brush: java;">
@FruitName("Apple")
@FruitColor(color = FruitColor.Color.RED)
public Fruit redApple;

AnnotatedElement element = MyAnnotation.class.getField("redApple"); // 获取指定字段
// 注解数组：[io.github.java.annotation.FruitName, io.github.java.annotation.FruitColor]
for (Annotation annotation : element.getAnnotations()) {
    log(annotation.annotationType().getName());
}
</pre>
                                </li>
                                <li><p><code>Annotation[] 	getDeclaredAnnotations()</code> -- 返回直接存在于此元素上的所有注解（忽略继承的注释）</p></li>

                                <li class="group"><p><code>default boolean 	isAnnotationPresent(Class&lt;? extends Annotation> annotationClass)</code> -- 如果指定类型的注释存在于此元素上，则返回 true，否则返回 false</p></li>
                                <li><p><code>&lt;T extends Annotation> T 	getAnnotation(Class&lt;T> annotationClass)</code> -- 如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null</p>
                                    <pre class="brush: java;">
@FruitName("Apple")
@FruitColor(color = FruitColor.Color.RED)
public Fruit redApple;

AnnotatedElement filed = MyAnnotation.class.getField("redApple"); // 获取指定字段
if(filed.isAnnotationPresent(FruitName.class)) { // 字段上是否存在指定类型注解
    FruitName fruitName = filed.getAnnotation(FruitName.class);  // 获取此注解
    log(fruitName.value()); // 可以调用注解的方法，拿到注解值: Apple
}
</pre>
                                </li>

                                <li class="group"><p><code>default &lt;T extends Annotation> T[] 	getAnnotationsByType(Class&lt;T> annotationClass)</code> -- 因为 Java 1.8 添加了 <code>@Repeatable</code> 注解，所以同种类型的注解可能多次存在于同一个元素，此方法返回的是数组。同 <code>getAnnotation(Class&lt;T>)</code></p></li>
                                <li><p><code>default &lt;T extends Annotation> T[] 	getDeclaredAnnotationsByType(Class&lt;T> annotationClass)</code> -- 返回直接存在于此元素上的指定类型的注解，检测是否是可重复注释类型，参照： <code>getDeclaredAnnotations()</code> 和 <code>getAnnotation(Class&lt;T>)</code></p></li>
                                <li><p><code>default &lt;T extends Annotation> T 	getDeclaredAnnotation(Class&lt;T> annotationClass)</code> -- 返回直接存在于此元素上的指定类型的注解，不检测是否是可重复注释类型</p></li>
                            </ol>
                            <p>实现类：<a href="#java-lang-reflect-AccessibleObject">AccessibleObject</a>, <a href="#java-lang-reflect-Executable">Executable</a>, <a href="#java-lang-reflect-Constructor">Constructor</a>, <a href="#java-lang-reflect-Field">Field</a>, <a href="#java-lang-reflect-Method">Method</a>, <a href="#java-lang-reflect-Parameter">Parameter</a>, <a href="#java-lang-Package">Package</a>, <a href="#java-lang-Class">Class&lt;T></a></p>
                            <p>子接口：<a href="docs/docs-java/api/java/lang/reflect/GenericDeclaration.html">GenericDeclaration</a>, <a href="docs/docs-java/api/java/lang/reflect/TypeVariable.html">TypeVariable&lt;D></a>, <a href="docs/docs-java/api/java/lang/reflect/AnnotatedType.html">AnnotatedType</a>, <a href="docs/docs-java/api/java/lang/reflect/AnnotatedArrayType.html">AnnotatedArrayType</a>, <a href="docs/docs-java/api/java/lang/reflect/AnnotatedParameterizedType.html">AnnotatedParameterizedType</a>, <a href="docs/docs-java/api/java/lang/reflect/AnnotatedTypeVariable.html">AnnotatedTypeVariable</a>, <a href="docs/docs-java/api/java/lang/reflect/AnnotatedWildcardType.html">AnnotatedWildcardType</a></p>
                            <pre class="brush: java;">
AnnotatedElement
 ├─ AccessibleObject
 │   ├─ Executable implements Member, GenericDeclaration
 │   │    ├─ Constructor&lt;T>
 │   │    └─ Method
 │   └─ Field implements Member
 ├─ Parameter implements AnnotatedElement
 ├─ GenericDeclaration
 ├─ TypeVariable&lt;D>
 └─ AnnotatedType
     ├─ AnnotatedArrayType
     ├─ AnnotatedTypeVariable
     ├─ AnnotatedParameterizedType
     └─ AnnotatedWildcardType

/** 所有可以声明/定义类型变量实体的公共父接口 */
public interface GenericDeclaration extends AnnotatedElement {
    TypeVariable&lt;?>[] getTypeParameters(); // 参见实现类 Executable
}

/** 声明/定义类型变量的实体 */
public interface TypeVariable&lt;D extends GenericDeclaration> extends Type, AnnotatedElement {
    /** 先定义两个方法：
     * 1.public &lt;T extends Integer> void x() {}
     * 2.public &lt;T extends Integer,U extends String> void x() {}
     */

    /** getBounds() -- 返回表示此类型变量上边界的 Type 对象的数组
     * 方法 1 返回: [java.lang.Integer]
     * 方法 2 返回: [java.lang.Integer, java.lang.String]
     */
    Type[] getBounds();
    AnnotatedType[] getAnnotatedBounds(); // 类似 getBounds()
    D getGenericDeclaration(); // 返回 GenericDeclaration 对象
    String getName(); // 返回此类型变量的名称， 方法 1 返回: T, 方法 2 返回: T, U

/**********************************************************************************/
    /** 泛型的上下边界:
     * aList -- 泛型上边界，只能存 B 及 B 的子类
     * bList -- 泛型下边界，只能存 B 及 B 的父类(包括接口)
     */
    void show(List&lt;? extends B> aList, List&lt;? super B> bList) {
        for (B b : aList) { b.b(); }
        for (Object o : bList) { log(o.getClass().getName()); }
    }

    class A { void a() { log("a"); } }
    class B extends A { void b() { log("b"); } }
    class C extends B { void c() { log("c"); } }
/**********************************************************************************/
}



/** 表示在当前 VM 中运行的程序中可能存在的注释类型 */
public interface AnnotatedType extends AnnotatedElement {
    Type getType(); // 返回注解类型的类型
}

public interface AnnotatedArrayType extends AnnotatedType {
    AnnotatedType getAnnotatedGenericComponentType();
}

public interface AnnotatedTypeVariable extends AnnotatedType {
    AnnotatedType[] getAnnotatedBounds();
}

public interface AnnotatedParameterizedType extends AnnotatedType {
    AnnotatedType[] getAnnotatedActualTypeArguments();
}

public interface AnnotatedWildcardType extends AnnotatedType {
    AnnotatedType[] getAnnotatedLowerBounds();
    AnnotatedType[] getAnnotatedUpperBounds();
}
</pre>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
public interface Type {
    default String getTypeName(); // 返回类型名
}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Type.html" target="_blank">Type</a> 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。</p>
                            <p>子接口: <a href="docs/docs-java/api/java/lang/reflect/GenericArrayType.html">GenericArrayType</a>, <a href="docs/docs-java/api/java/lang/reflect/ParameterizedType.html">ParameterizedType</a>, <a href="docs/docs-java/api/java/lang/reflect/WildcardType.html">WildcardType</a>, 还有前面的 <code>TypeVariable&lt;D></code></p>
                            <p>实现类: <a href="#java-lang-Class">Class&lt;T></a></p>
                            <pre class="brush: java;">
/** 数组类型，其组件类型为参数化类型或类型变量 */
public interface GenericArrayType extends Type {
    Type getGenericComponentType();
}

/** 参数化类型，如 Collection&lt;String> */
public interface ParameterizedType extends Type {
    Type[] getActualTypeArguments(); // 返回表示此类型实际类型参数的 Type 对象的数组
    Type getOwnerType(); // 返回 Type 对象，表示此类型是其成员之一的类型
    Type getRawType(); // 返回 Type 对象，表示声明此类型的类或接口
}

/** 通配符类型表达式，如 ?、? extends Number 或 ? super Integer */
public interface WildcardType extends Type {
    Type[] getLowerBounds(); // 返回表示此类型变量下边界的 Type 对象的数组
    Type[] getUpperBounds(); // 返回表示此类型变量上边界的 Type 对象的数组
}
                            </pre>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-reflect-AccessibleObject"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">AccessibleObject</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.reflect.AccessibleObject

public class AccessibleObject implements AnnotatedElement {
    protected AccessibleObject() {}
}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/reflect/AccessibleObject.html" target="_blank">AccessibleObject</a> 是 Executable, Constructor, Field 和 Method 对象的基类。</p>
                        <p>提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。对于公共成员、默认（打包）访问成员、受保护成员和私有成员，在分别使用 Field、Method 或 Constructor 对象来设置或获取字段、调用方法，或者创建和初始化类的新实例的时候，会执行访问检查。 </p>
                        <p>在反射对象中设置 accessible 标志允许具有足够特权的复杂应用程序（比如 Java Object Serialization 或其他持久性机制）以某种通常禁止使用的方式来操作对象。 </p>
                        <ol>
                            <li><p><code>static void 	setAccessible(AccessibleObject[] array, boolean flag)</code> -- 使用单一安全性检查（为了提高效率）为一组对象设置 accessible 标志的便捷方法</p></li>
                            <li class="group"><p><code>boolean 	isAccessible()</code> -- 获取此对象(字段，方法，类)的可访问性</p></li>
                            <li><p><code>void 	setAccessible(boolean flag)</code> -- 强行修改此对象可访问性</p></li>

                            <li class="group"><p><code>&lt;T extends Annotation> T 	getAnnotation(Class&lt;T> annotationClass)</code> -- 返回此元素上的指定类型的注解</p></li>
                            <li><p><code>&lt;T extends Annotation> T 	getDeclaredAnnotation(Class&lt;T> annotationClass)</code> -- 直接存在于此元素上的指定类型的注解</p></li>
                            <li><p><code>Annotation[] 	getAnnotations()</code> -- 返回此元素上存在的所有注解</p></li>
                            <li><p><code>Annotation[] 	getDeclaredAnnotations()</code> -- 返回直接存在于此元素上的所有注解（忽略继承的注释）</p></li>

                            <li class="group"><p><code>&lt;T extends Annotation> T[] 	getAnnotationsByType(Class&lt;T> annotationClass)</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>&lt;T extends Annotation> T[] 	getDeclaredAnnotationsByType(Class&lt;T> annotationClass)</code> --  参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>boolean 	isAnnotationPresent(Class&lt;? extends Annotation> annotationClass)</code> --  参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>


                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-reflect-Executable"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Executable</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.reflect.AccessibleObject
        java.lang.reflect.Executable

public abstract class Executable extends AccessibleObject implements Member, GenericDeclaration {}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/reflect/Executable.html" target="_blank">Executable</a> 是 Constructor 和 Method 的父类。</p>
                        <ol>
                            <li><p><code>abstract Class&lt;?> 	getDeclaringClass()</code> -- 如果是成员类，则返回其包裹类</p></li>
                            <li><p><code>abstract int 	getModifiers()</code> -- 以整数形式返回此方法对象所表示构造方法的 Java 语言修饰符</p></li>
                            <li><p><code>abstract String 	getName()</code> -- 字符串形式返回此方法的名称</p></li>
                            <li><p><code>boolean 	isSynthetic()</code> -- 此方法是否是合成方法（编译器引入）</p></li>

                            <li class="group"><p><code>int 	getParameterCount()</code> -- 参数数量</p></li>
                            <li><p><code>Parameter[] 	getParameters()</code> -- 获取参数列表</p></li>
                            <li><p><code>boolean 	isVarArgs()</code> -- 此方法是否有可变参数</p></li>
                            <li><p><code>abstract String 	toGenericString()</code> -- 返回描述此方法的字符串，其中包括类型参数</p></li>

                            <li class="group"><p><code>abstract Class&lt;?>[] 	getExceptionTypes()</code> -- 抛出的异常类型类列表</p></li>
                            <li><p><code>Type[] 	getGenericExceptionTypes()</code> -- 返回值不同，其它同 <code>getExceptionTypes()</code></p></li>
                            <li><p><code>Type[] 	getGenericParameterTypes()</code> -- 返回值不同，其它同 <code>getParameterTypes()</code></p></li>
                            <li><p><code>abstract Class&lt;?>[] 	getParameterTypes()</code> -- 参数类的类型类列表</p>
                                <pre class="brush: java;">
public void reflect(String s) throws NoSuchMethodException {
    Executable executable = MyAnnotation.class.getMethod("reflect", String.class);
    for (Class&lt;?> aClass : executable.getExceptionTypes()) {
        log(aClass.getName()); // java.lang.NoSuchMethodException
    }
    for (Class&lt;?> aClass : executable.getParameterTypes()) {
        log(aClass.getName()); // java.lang.String
    }
}
</pre>
                            </li>

                            <li class="group"><p><code>AnnotatedType[] 	getAnnotatedExceptionTypes()</code> -- 方法或构造方法抛出的异常类型</p></li>
                            <li><p><code>AnnotatedType[] 	getAnnotatedParameterTypes()</code> -- 方法或构造方法的参数类型</p></li>
                            <li><p><code>abstract AnnotatedType 	getAnnotatedReturnType()</code> -- 方法或构造方法返回值类型</p></li>
                            <li><p><code>AnnotatedType 	getAnnotatedReceiverType()</code> -- 方法/构造函数的接收器类型(static 方法返回 NULL) </p></li>

                            <li class="group"><p><code>abstract TypeVariable&lt;?>[] 	getTypeParameters()</code> -- 获取泛型类型限定符的类型列表</p>
                                <pre class="brush: java;">
/** 此处的类型限定符： &lt;M extends Integer> 只是为了展示 getTypeParameters 的方法 */
public &lt;M extends Integer> void reflect(String s, M... e) throws NoSuchMethodException {
    for (TypeVariable&lt;Class&lt;ArrayList>> classTypeVariable : ArrayList.class.getTypeParameters()) {
        log(classTypeVariable.getName()); // E
    }
    for (TypeVariable&lt;Class&lt;HashMap>> classTypeVariable : HashMap.class.getTypeParameters()) {
        log(classTypeVariable.getName()); // K, V
    }
    Executable executable = MyAnnotation.class.getMethod("reflect", String.class, Integer[].class);
    for (TypeVariable&lt;?> variable : executable.getTypeParameters()) {
        log(variable.getName()); // M
    }
}
</pre>
                            </li>

                            <li class="group"><p><code>&lt;T extends Annotation> T 	getAnnotation(Class&lt;T> annotationClass)</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>&lt;T extends Annotation> T[] 	getAnnotationsByType(Class&lt;T> annotationClass)</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>abstract Annotation[][] 	getParameterAnnotations()</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>Annotation[] 	getDeclaredAnnotations()</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-reflect-Constructor"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Constructor</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.reflect.AccessibleObject
        java.lang.reflect.Executable
            java.lang.reflect.Constructor&lt;T>

public final class Constructor&lt;T> extends Executable {}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/reflect/Constructor.html" target="_blank">Constructor</a> 提供关于类的单个构造方法的信息以及对它的访问权限。 </p>
                        <p>Constructor 允许在将实参与带有底层构造方法的形参的 newInstance() 匹配时进行扩展转换，但是如果发生收缩转换，则抛出 IllegalArgumentException。 </p>
                        <ol>
                            <li><p><code>T 	newInstance(Object... initargs)</code> -- 使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例</p></li>
                            <li><p><code>int 	getModifiers()</code> -- 以整数形式返回此 Constructor 对象所表示构造方法的 Java 语言修饰符</p></li>
                            <li><p><code>int 	getParameterCount()</code> -- 此构造方法的参数数目</p></li>
                            <li><p><code>boolean 	isVarArgs()</code> -- 如果声明此构造方法可以带可变数量的参数，则返回 true；否则返回 false</p></li>
                            <li><p><code>boolean 	isSynthetic()</code> -- 如果此构造方法是一个复合构造方法，则返回 true；否则返回 false</p></li>
                            <li><p><code>String 	getName()</code> -- 以字符串形式返回此构造方法的名称</p></li>

                            <li class="group"><p><code>AnnotatedType 	getAnnotatedReceiverType()</code> -- 返回一个注释类型对象，该对象表示使用类型来指定由该可执行对象表示的方法/构造函数的接收器类型</p></li>
                            <li><p><code>AnnotatedType 	getAnnotatedReturnType()</code> -- 返回一个注释类型对象，该对象表示使用类型来指定由该可执行文件表示的方法/构造函数的返回类型</p></li>

                            <li class="group"><p><code>Type[] 	getGenericExceptionTypes()</code> -- 返回一组 Type 对象，这些对象表示声明要由此 Constructor 对象抛出的异常</p></li>
                            <li><p><code>Type[] 	getGenericParameterTypes()</code> -- 按照声明顺序返回一组 Type 对象，这些对象表示此 Constructor 对象所表示的方法的形参类型</p></li>
                            <li><p><code>TypeVariable&lt;Constructor&lt;T>>[] 	getTypeParameters()</code> -- 按照声明顺序返回一组 TypeVariable 对象，这些对象表示通过此 GenericDeclaration 对象所表示的一般声明来声明的类型变量</p></li>

                            <li class="group"><p><code>&lt;T extends Annotation> T 	getAnnotation(Class&lt;T> annotationClass)</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>Annotation[] 	getDeclaredAnnotations()</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>Annotation[][] 	getParameterAnnotations()</code> -- 按照声明顺序返回一组数组，这些数组表示通过此 Constructor 对象表示的方法的形参上的注释</p></li>

                            <li class="group"><p><code>Class&lt;T> 	getDeclaringClass()</code> -- 返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类</p></li>
                            <li><p><code>Class&lt;?>[] 	getExceptionTypes()</code> -- 返回一组表示声明要抛出的异常类型的 Class 对象，这些异常是由此 Constructor 对象表示的底层构造方法抛出的</p></li>
                            <li><p><code>Class&lt;?>[] 	getParameterTypes()</code> -- 按照声明顺序返回一组 Class 对象，这些对象表示此 Constructor 对象所表示构造方法的形参类型</p></li>

                            <li class="group"><p><code>int 	hashCode()</code> -- 返回此 Constructor 的哈希码</p></li>
                            <li><p><code>boolean 	equals(Object obj)</code> -- 将此 Constructor 对象与指定的对象进行比较</p></li>
                            <li><p><code>String 	toGenericString()</code> -- 返回描述此 Constructor 的字符串，其中包括类型参数</p></li>
                            <li><p><code>String 	toString()</code> -- 返回描述此 Constructor 的字符串</p></li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-reflect-Field"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Field</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.reflect.AccessibleObject
        java.lang.reflect.Field

public final class Field extends AccessibleObject implements Member {}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/reflect/Field.html" target="_blank">Field</a> 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。 </p>
                        <p>Array 允许在执行 get 或 set 访问操作期间进行扩展转换，但如果将发生收缩转换，则抛出一个 IllegalArgumentException。</p>
                        <ol>
                            <li><p><code>int 	getModifiers()</code> -- 以整数形式返回由此 Field 对象表示的字段的 Java 语言修饰符</p></li>
                            <li><p><code>String 	getName()</code> -- 返回此 Field 对象表示的字段的名称</p></li>
                            <li><p><code>boolean 	isEnumConstant()</code> -- 如果此字段表示枚举类型的元素，则返回 true；否则返回 false</p></li>
                            <li><p><code>boolean 	isSynthetic()</code> -- 如果此字段是复合字段，则返回 true；否则返回 false</p></li>
                            <li><p><code>Class&lt;?> 	getType()</code> -- 返回一个 Class 对象，它标识了此 Field 对象所表示字段的声明类型</p></li>

                            <li class="group"><p><code>&lt;T extends Annotation> T 	getAnnotation(Class&lt;T> annotationClass)</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>&lt;T extends Annotation> T[] 	getAnnotationsByType(Class&lt;T> annotationClass)</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>Annotation[] 	getDeclaredAnnotations()</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>

                            <li class="group"><p><code>Class&lt;?> 	getDeclaringClass()</code> -- 返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</p></li>
                            <li><p><code>AnnotatedType 	getAnnotatedType()</code> -- 返回一个注释类型对象，该对象表示使用类型来指定由该字段表示的字段的声明类型</p></li>
                            <li><p><code>Type 	getGenericType()</code> -- 返回一个描述此 Field（包括其一般类型）的字符串</p></li>

                            <li class="group"><p><code>Object 	get(Object obj)</code> -- 返回指定对象上此 Field 表示的字段的值</p></li>
                            <li><p><code>boolean 	getBoolean(Object obj)</code> -- 获取一个静态或实例 boolean 字段的值</p></li>
                            <li><p><code>byte 	getByte(Object obj)</code> --  获取一个静态或实例 byte 字段的值</p></li>
                            <li><p><code>char 	getChar(Object obj)</code> --  获取一个静态或实例 char 字段的值</p></li>
                            <li><p><code>short 	getShort(Object obj)</code> --  获取一个静态或实例 short 字段的值</p></li>
                            <li><p><code>int 	getInt(Object obj)</code> --  获取一个静态或实例 int 字段的值</p></li>
                            <li><p><code>long 	getLong(Object obj)</code> --  获取一个静态或实例 long 字段的值</p></li>
                            <li><p><code>float 	getFloat(Object obj)</code> --  获取一个静态或实例 float 字段的值</p></li>
                            <li><p><code>double 	getDouble(Object obj)</code> --  获取一个静态或实例 double 字段的值</p></li>

                            <li class="group"><p><code>void 	set(Object obj, Object value)</code> -- 将字段的值设置为指定对象上的一个 Object 值</p></li>
                            <li><p><code>void 	setBoolean(Object obj, boolean z)</code> -- 将字段的值设置为指定对象上的一个 boolean 值</p></li>
                            <li><p><code>void 	setByte(Object obj, byte b)</code> -- 将字段的值设置为指定对象上的一个 byte 值</p></li>
                            <li><p><code>void 	setChar(Object obj, char c)</code> -- 将字段的值设置为指定对象上的一个 char 值</p></li>
                            <li><p><code>void 	setShort(Object obj, short s)</code> -- 将字段的值设置为指定对象上的一个 short 值</p></li>
                            <li><p><code>void 	setInt(Object obj, int i)</code> -- 将字段的值设置为指定对象上的一个 int 值</p></li>
                            <li><p><code>void 	setLong(Object obj, long l)</code> -- 将字段的值设置为指定对象上的一个 long 值</p></li>
                            <li><p><code>void 	setFloat(Object obj, float f)</code> -- 将字段的值设置为指定对象上的一个 float 值</p></li>
                            <li><p><code>void 	setDouble(Object obj, double d)</code> -- 将字段的值设置为指定对象上的一个 double 值</p></li>

                            <li class="group"><p><code>int 	hashCode()</code> -- 返回此 Field 的哈希码</p></li>
                            <li><p><code>boolean 	equals(Object obj)</code> -- 将此 Field 对象与指定的对象进行比较</p></li>
                            <li><p><code>String 	toGenericString()</code> -- 返回描述此 Field 的字符串，其中包括类型参数</p></li>
                            <li><p><code>String 	toString()</code> -- 返回描述此 Field 的字符串</p></li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-reflect-Method"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Method</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.reflect.AccessibleObject
        java.lang.reflect.Executable
            java.lang.reflect.Method

public final class Method extends Executable {}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/reflect/Method.html" target="_blank">Method</a> 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法）。</p>
                        <p>Method 允许在匹配要调用的实参与底层方法的形参时进行扩展转换；但如果要进行收缩转换，则会抛出 IllegalArgumentException。</p>
                        <ol>
                            <li><p><code>int 	getModifiers()</code> -- 以整数形式返回此 Method 对象所表示方法的 Java 语言修饰符</p></li>
                            <li><p><code>String 	getName()</code> -- 以 String 形式返回此 Method 对象表示的方法名称</p></li>
                            <li><p><code>Class&lt;?> 	getReturnType()</code> -- 返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型</p></li>
                            <li><p><code>int 	getParameterCount()</code> -- 如果此字段表示枚举类型的元素，则返回 true；否则返回 false</p></li>
                            <li><p><code>Object 	invoke(Object obj, Object... args)</code> -- 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法</p></li>
                            <li><p><code>Object 	getDefaultValue()</code> -- 返回由此 Method 实例表示的注释成员的默认值</p></li>

                            <li class="group"><p><code>&lt;T extends Annotation> T 	getAnnotation(Class&lt;T> annotationClass)</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>Annotation[][] 	getParameterAnnotations()</code> -- 返回表示按照声明顺序对此 Method 对象所表示方法的形参进行注释的那个数组的数组</p></li>
                            <li><p><code>Annotation[] 	getDeclaredAnnotations()</code> --参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>


                            <li class="group"><p><code>AnnotatedType 	getAnnotatedReturnType()</code> -- 返回一个注释类型对象，该对象表示使用类型来指定由该可执行文件表示的方法/构造函数的返回类型</p></li>
                            <li><p><code>Class&lt;?>[] 	getParameterTypes()</code> -- 按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型</p></li>
                            <li><p><code>Class&lt;?>[] 	getExceptionTypes()</code> -- 返回 Class 对象的数组，这些对象描述了声明将此 Method 对象表示的底层方法抛出的异常类型</p></li>
                            <li><p><code>Class&lt;?> 	getDeclaringClass()</code> -- 返回表示声明由此 Method 对象表示的方法的类或接口的 Class 对象</p></li>

                            <li class="group"><p><code>Type[] 	getGenericExceptionTypes()</code> -- 返回 Type 对象数组，这些对象描述了声明由此 Method 对象抛出的异常</p></li>
                            <li><p><code>Type[] 	getGenericParameterTypes()</code> -- 按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的</p></li>
                            <li><p><code>Type 	getGenericReturnType()</code> -- 返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象</p></li>
                            <li><p><code>TypeVariable&lt;Method>[] 	getTypeParameters()</code> -- 返回 TypeVariable 对象的数组，这些对象描述了由 GenericDeclaration 对象表示的一般声明按声明顺序来声明的类型变量</p></li>

                            <li class="group"><p><code>boolean 	isBridge()</code> -- 如果此方法是 bridge 方法，则返回 true；否则，返回 false</p></li>
                            <li><p><code>boolean 	isDefault()</code> -- 是否为默认方法(用接口类型声明的具有方法体的非静态方法)</p></li>
                            <li><p><code>boolean 	isSynthetic()</code> -- 如果此方法为复合方法，则返回 true；否则，返回 false</p></li>
                            <li><p><code>boolean 	isVarArgs()</code> -- 如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false</p></li>

                            <li class="group"><p><code>int 	hashCode()</code> -- 返回此 Method 的哈希码</p></li>
                            <li><p><code>boolean 	equals(Object obj)</code> -- 将此 Method 对象与指定的对象进行比较</p></li>
                            <li><p><code>String 	toGenericString()</code> -- 返回描述此 Method 的字符串，其中包括类型参数</p></li>
                            <li><p><code>String 	toString()</code> -- 返回描述此 Method 的字符串</p></li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-reflect-Modifier"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Modifier</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.reflect.Modifier

public class Modifier {
    public static final int PUBLIC           = 0x00000001; // 表示 public 修饰符的 int 值
    public static final int PRIVATE          = 0x00000002; // 表示 private 修饰符的 int 值
    public static final int PROTECTED        = 0x00000004; // 表示 protected 修饰符的 int 值
    public static final int STATIC           = 0x00000008; // 表示 static 修饰符的 int 值
    public static final int FINAL            = 0x00000010; // 表示 final 修饰符的 int 值
    public static final int SYNCHRONIZED     = 0x00000020; // 表示 synchronized 修饰符的 int 值
    public static final int VOLATILE         = 0x00000040; // 表示 volatile 修饰符的 int 值
    public static final int TRANSIENT        = 0x00000080; // 表示 transient 修饰符的 int 的值
    public static final int NATIVE           = 0x00000100; // 表示 native 修饰符的 int 的值
    public static final int INTERFACE        = 0x00000200; // 表示 interface 修饰符的 int 的值
    public static final int ABSTRACT         = 0x00000400; // 表示 abstract 修饰符的 int 的值
    public static final int STRICT           = 0x00000800; // 表示 strictfp 修饰符的 int 的值
}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/reflect/Modifier.html" target="_blank">Modifier</a> 类提供了 static 方法和常量，对类和成员访问修饰符进行解码。</p>
                        <p>修饰符集被表示为整数，用不同的位位置 (bit position) 表示不同的修饰符。</p>
                        <ol>
                            <li><p><code>static int 	classModifiers()</code> -- 可用于 类 的修饰符按位或的结果</p></li>
                            <li><p><code>static int 	interfaceModifiers()</code> -- 可用于 接口 的修饰符按位或的结果</p></li>
                            <li><p><code>static int 	constructorModifiers()</code> -- 可用于 构造方法 的修饰符按位或的结果</p></li>
                            <li><p><code>static int 	fieldModifiers()</code> -- 可用于 字段 的修饰符按位或的结果</p></li>
                            <li><p><code>static int 	methodModifiers()</code> -- 可用于 方法 的修饰符按位或的结果</p></li>
                            <li><p><code>static int 	parameterModifiers()</code> -- 可用于 参数 的修饰符按位或的结果</p></li>

                            <li class="group"><p><code>static String 	toString(int mod)</code> -- 返回 mod 修饰符的 String 形式</p></li>

                            <li class="group"><p><code>static boolean 	isAbstract(int mod)</code> -- 如果整数参数包括 abstract 修饰符，则返回 true，否则返回 false</p></li>
                            <li><p><code>static boolean 	isFinal(int mod)</code> -- 如果整数参数包括 final 修饰符，则返回 true，否则返回 false</p></li>
                            <li><p><code>static boolean 	isInterface(int mod)</code> -- 如果整数参数包括 interface 修饰符，则返回 true，否则返回 false</p></li>
                            <li><p><code>static boolean 	isNative(int mod)</code> -- 如果整数参数包括 native 修饰符，则返回 true，否则返回 false</p></li>
                            <li><p><code>static boolean 	isPrivate(int mod)</code> -- 如果整数参数包括 private 修饰符，则返回 true，否则返回 false</p></li>
                            <li><p><code>static boolean 	isProtected(int mod)</code> -- 如果整数参数包括 protected 修饰符，则返回 true，否则返回 false</p></li>
                            <li><p><code>static boolean 	isPublic(int mod)</code> -- 如果整数参数包括 public 修饰符，则返回 true，否则返回 false</p></li>
                            <li><p><code>static boolean 	isStatic(int mod)</code> -- 如果整数参数包括 static 修饰符，则返回 true，否则返回 false</p></li>
                            <li><p><code>static boolean 	isStrict(int mod)</code> -- 如果整数参数包括 strictfp 修饰符，则返回 true，否则返回 false</p></li>
                            <li><p><code>static boolean 	isSynchronized(int mod)</code> -- 如果整数参数包括 synchronized 修饰符，则返回 true，否则返回 false</p></li>
                            <li><p><code>static boolean 	isTransient(int mod)</code> -- 如果整数参数包括 transient 修饰符，则返回 true，否则返回 false</p></li>
                            <li><p><code>static boolean 	isVolatile(int mod)</code> -- 如果整数参数包括 volatile 修饰符，则返回 true，否则返回 false</p></li>

                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-reflect-Parameter"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Parameter</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.reflect.Parameter

public final class Parameter implements AnnotatedElement {}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/reflect/Parameter.html" target="_blank">Parameter</a> 提供有关方法参数的信息。参数提供有关方法参数的信息，包括其名称和修饰符。它还提供了获取参数属性的另一种方法。</p>
                        <ol>
                            <li><p><code>int 	getModifiers()</code> -- 以整数形式返回此 Parameter 对象所表示构造方法的 Java 语言修饰符</p></li>
                            <li><p><code>String 	getName()</code> -- 以字符串形式返回此 Parameter 的名称</p></li>
							<li><p><code>Executable 	getDeclaringExecutable()</code> -- 此参数的方法/构造方法</p></li>
							<li><p><code>Type 	getParameterizedType()</code> -- 参数的类型</p></li>
                            <li><p><code>Class&lt;?> 	getType()</code> --  返回一个 Class 对象，它标识了此 Parameter 对象所表示字段的声明类型</p></li>

                            <li class="group"><p><code>boolean 	isImplicit()</code> -- 如果在源代码中隐式声明此参数，则返回 true</p></li>
                            <li><p><code>boolean 	isNamePresent()</code> -- 如果参数具有类文件名，则返回 true</p></li>
                            <li><p><code>boolean 	isSynthetic()</code> --  如果此 Parameter 是复合参数，则返回 true</p></li>
                            <li><p><code>boolean 	isVarArgs()</code> -- 如果是可变参数则返回 true</p></li>

                            <li class="group"><p><code>&lt;T extends Annotation> T 	getAnnotation(Class&lt;T> annotationClass)</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>&lt;T extends Annotation> T[] 	getAnnotationsByType(Class&lt;T> annotationClass)</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>&lt;T extends Annotation> T 	getDeclaredAnnotation(Class&lt;T> annotationClass)</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>Annotation[] 	getAnnotations()</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>Annotation[] 	getDeclaredAnnotations()</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>
                            <li><p><code>&lt;T extends Annotation> T[] 	getDeclaredAnnotationsByType(Class&lt;T> annotationClass)</code> -- 参见: <a href="#AnnotedElement">AnnotedElement</a></p></li>

                            <li class="group"><p><code>AnnotatedType 	getAnnotatedType()</code> -- 返回一个注释类型对象，该对象表示使用类型来指定由该字段表示的字段的声明类型</p></li>


                            <li class="group"><p><code>int 	hashCode()</code> -- 返回此 Parameter 的哈希码</p></li>
                            <li><p><code>boolean 	equals(Object obj)</code> -- 将此 Parameter 对象与指定的对象进行比较</p></li>
                            <li><p><code>String 	toString()</code> -- 返回描述此 Parameter 的字符串</p></li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-reflect-Array"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Array</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.reflect.Array

public final class Array {}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/reflect/Array.html" target="_blank">Array</a> 类提供了动态创建和访问 Java 数组的方法。</p>
                        <p>Array 允许在执行 get 或 set 操作期间进行扩展转换，但如果发生收缩转换，则抛出 IllegalArgumentException。</p>
                        <ol>
                            <li><p><code>static Object 	newInstance(Class&lt;?> componentType, int length)</code> -- 创建一个具有指定的组件类型和长度的新数组</p></li>
                            <li><p><code>static Object 	newInstance(Class&lt;?> componentType, int... dimensions)</code> -- 创建一个具有指定的组件类型和维度的新数组</p>
                                <pre class="brush: java;">
int[] arr = (int[]) Array.newInstance(int.class, 2); // 一维数组，{0, 0}

/** 有几个参数，则为几维数组，参数值为每一维度的长度 */
// 二维数组,{{0, 0, 0}, {0, 0, 0}}
int[][] arr = (int[][]) Array.newInstance(int.class, 2, 3);
// 三维数组，{{{0}, {0}}, {{0}, {0}},  {{0}, {0}}};
int[][][] arr = (int[][][]) Array.newInstance(int.class, 3, 2, 1);
</pre>
                            </li>

                            <li class="group"><p><code>static int 	getLength(Object array)</code> -- 以 int 形式返回指定数组对象的长度</p></li>

                            <li class="group"><p><code>static Object 	get(Object array, int index)</code> -- 返回指定数组对象中索引组件的值</p></li>
                            <li><p><code>static boolean 	getBoolean(Object array, int index)</code> -- 以 boolean 形式返回指定数组对象中索引组件的值</p></li>
                            <li><p><code>static byte 	getByte(Object array, int index)</code> -- 以 byte 形式返回指定数组对象中索引组件的值</p></li>
                            <li><p><code>static char 	getChar(Object array, int index)</code> -- 以 char 形式返回指定数组对象中索引组件的值</p></li>
                            <li><p><code>static short 	getShort(Object array, int index)</code> -- 以 short 形式返回指定数组对象中索引组件的值</p></li>
                            <li><p><code>static int 	getInt(Object array, int index)</code> -- 以 int 形式返回指定数组对象中索引组件的值</p></li>
                            <li><p><code>static long 	getLong(Object array, int index)</code> -- 以 long 形式返回指定数组对象中索引组件的值</p></li>
                            <li><p><code>static float 	getFloat(Object array, int index)</code> -- 以 float 形式返回指定数组对象中索引组件的值</p></li>
                            <li><p><code>static double 	getDouble(Object array, int index)</code> -- 以 double 形式返回指定数组对象中索引组件的值</p></li>

                            <li class="group"><p><code>static void 	set(Object array, int index, Object value)</code> -- 将指定数组对象中索引组件的值设置为指定的新值</p></li>
                            <li><p><code>static void 	setBoolean(Object array, int index, boolean z)</code> -- 将指定数组对象中索引组件的值设置为 boolean 值</p></li>
                            <li><p><code>static void 	setByte(Object array, int index, byte b)</code> -- 将指定数组对象中索引组件的值设置为 byte 值</p></li>
                            <li><p><code>static void 	setChar(Object array, int index, char c)</code> -- 将指定数组对象中索引组件的值设置为 chaar 值</p></li>
                            <li><p><code>static void 	setShort(Object array, int index, short s)</code> -- 将指定数组对象中索引组件的值设置为 short 值</p></li>
                            <li><p><code>static void 	setInt(Object array, int index, int i)</code> -- 将指定数组对象中索引组件的值设置为 int 值</p></li>
                            <li><p><code>static void 	setLong(Object array, int index, long l)</code> -- 将指定数组对象中索引组件的值设置为 long 值</p></li>
                            <li><p><code>static void 	setFloat(Object array, int index, float f)</code> -- 将指定数组对象中索引组件的值设置为 float 值</p></li>
                            <li><p><code>static void 	setDouble(Object array, int index, double d)</code> -- 将指定数组对象中索引组件的值设置为 double 值</p></li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-reflect-Proxy"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">InvocationHandler 和 Proxy</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
public interface InvocationHandler {
    Object invoke(Object proxy, Method method, Object[] args); // 在代理实例上处理方法调用并返回结果
}
</pre>
                                <p><a href="docs/docs-java/api/java/lang/reflect/InvocationHandler.html" target="_blank">InvocationHandler</a> 是代理实例的调用处理程序 实现的接口。 </p>
                                <p>每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序的 invoke 方法。</p>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.lang.reflect.Proxy

public class Proxy implements Serializable {
    protected InvocationHandler h;
    protected Proxy(InvocationHandler h) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Proxy.html" target="_blank">Proxy</a> 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。 </p>
                            <ol>
                                <li><p><code>static Object 	newProxyInstance(ClassLoader loader, Class&lt;?>[] interfaces, InvocationHandler h)</code> -- 通过代理构建一个新的实例</p></li>
                                <li><p><code>static boolean 	isProxyClass(Class&lt;?> cl)</code> -- 指定的 cl 是否是一个代理类(代理类要符合一些条件)</p></li>
                                <li><p><code>static InvocationHandler 	getInvocationHandler(Object proxy)</code> -- 获取代理实例的 InvocationHandler(proxy 必须是一个代理实例，由 newProxyInstance 创建)</p></li>
                                <li><p><code>static Class&lt;?> 	getProxyClass(ClassLoader loader, Class&lt;?>... interfaces)</code> -- 返回代理类的 java.lang.Class 对象</p></li>
                            </ol>
							<p>先看一个实例：(要求在不更改 KeyEventHandler 类和 performKeyEvent(KeyEventListener)) 方法的情况下，更改 onKeyEvent 逻辑</p>
                            <p><b>对 KeyEventListener 接口的调用，会交由 KeyEventHandlerProxy.KeyEventInvocationHandler 的 invoke 方法处理，并在不改变 onKeyEvent 的源代码下，新增了动态的逻辑（before onKeyEvent/after onKeyEvent)，这正式 Spring AOP 所做的。</b></p>
							<pre class="brush: java;">
interface KeyEventListener {
    void onKeyEvent();
}

final class KeyEventHandler implements KeyEventListener { // 不允许此类有子类

    @Override
    public void onKeyEvent() {
        Log.d("onKeyEvent");
    }
}

public void performKeyEvent(KeyEventListener listener) {
	log("performKeyEvent before");
	listener.onKeyEvent();
	log("performKeyEvent after");
}

public void execute() {
    KeyEventListener listener = new KeyEventHandler();
    // performKeyEvent(listener); // 原来的逻辑

    KeyEventHandlerProxy proxy = new KeyEventHandlerProxy(listener);
    KeyEventListener proxyListener = proxy.create();
    performKeyEvent(proxyListener); // 修改后的逻辑，在 KeyEventInvocationHandler 的 invoke 方法中添加了逻辑
}

class KeyEventHandlerProxy {
    private KeyEventListener mKeyEventListener;

    public KeyEventHandlerProxy(KeyEventListener mKeyEventListener) {
        this.mKeyEventListener = mKeyEventListener;
    }

    public KeyEventListener create() {
        final ClassLoader classLoader = KeyEventListener.class.getClassLoader();
        final Class&lt;?>[] interfaces = new Class[]{ KeyEventListener.class };
        final KeyEventInvocationHandler handler = new KeyEventInvocationHandler();

        return (KeyEventListener) Proxy.newProxyInstance(classLoader, interfaces, handler);
    }

    class KeyEventInvocationHandler implements InvocationHandler {

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Log.d("before onKeyDown");
            Object result = method.invoke(mKeyEventListener);
            Log.d("after onKeyDown");
            return result;
        }
    }
}
</pre>

                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-reflect-ReflectPermission"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">ReflectPermission</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.security.Permission
        java.security.BasicPermission
            java.lang.reflect.ReflectPermission

public final class ReflectPermission extends BasicPermission {
    public ReflectPermission(String name) {}
    public ReflectPermission(String name, String actions) {}
}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/reflect/ReflectPermission.html" target="_blank">ReflectPermission</a> 反射操作的 Permission 类。ReflectPermission 是一种指定权限，没有动作。当前定义的唯一名称是 suppressAccessChecks，它允许取消由反射对象在其使用点上执行的标准 Java 语言访问检查 - 对于 public、default（包）访问、protected、private 成员。 </p>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-util-Base64"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Base64</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
	java.util.Base64

public class Base64 {
	public static class Encoder {
		byte[] encode(byte[] src) {...}
		int encode(byte[] src, byte[] dst) {...}
		ByteBuffer encode(ByteBuffer buffer) {...}
		String encodeToString(byte[] src) {...}
		Base64.Encoder withoutPadding() {...}
		OutputStream wrap(OutputStream os) {...}
	}

	public static class Decoder {
		byte[] decode(String src) {...}
		byte[] decode(byte[] src) {...}
		int decode(byte[] src, byte[] dst) {...}
		ByteBuffer decode(ByteBuffer buffer) {...}
		InputStream wrap(InputStream is) {...}
	}
}
</pre>
						<p><a href="docs/docs-java/api/java/util/Base64.html" target="_blank">Base64</a> 将每三个 8 bits 二进制转换为四个 6 bits 的二进制(3 * 8 = 4 * 6)，然后将转换后的6 bits 往高位添加 2 个 0,组成四个 8 bits 的二进制，然后按字节在 Base64 码表中查找对应的字符；如果源字符的长度不能被拆分为 3 个字节，结果需要补 '='。</p>
						<pre class="brush: java;">
// 标准 Base64 码表：Base64.getEncoder() 按此码表转换
{
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
	'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
};

// 如果需要转为 URL: Base64.getUrlEncoder(), 则 '+', '/' 替换为: '-', '_'
{
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
	'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'
};
</pre>
						<ol>
							<li><p><code>static Base64.Encoder 	getEncoder()</code> -- 标准转码</p></li>
							<li><p><code>static Base64.Decoder 	getDecoder()</code> -- 标准解码</p></li>
							<li><p><code>static Base64.Encoder 	getUrlEncoder()</code> -- Url 转码</p></li>
							<li><p><code>static Base64.Decoder 	getUrlDecoder()</code> -- Url 解码</p></li>
							<li><p><code>static Base64.Encoder 	getMimeEncoder()</code> -- Mime 转码(每 76 个字符加一个换行输出)</p></li>
							<li><p><code>static Base64.Decoder 	getMimeDecoder()</code> -- Mime 解码</p></li>
							<li><p><code>static Base64.Encoder 	getMimeEncoder(int lineLength, byte[] lineSeparator)</code> -- Mime 转码(指定行长度和换行字符)</p></li>
						</ol>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-Date"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Date, Calendar, TimeZone</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.util.Date

public class Date implements Serializable, Cloneable, Comparable&lt;Date> {
    public Date() { this(System.currentTimeMillis(); }
    public Date(long millis) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/util/Date.html" target="_blank">Date</a> 表示特定的瞬间，精确到毫秒。</p>
                            <p><a href="docs/docs-java/api/java/util/Date.html" target="_blank">Date</a> 类的很多方法已过时，应该使用 Calendar 类实现日期和时间字段之间转换，使用 java.text.DateFormat 类来格式化和解析日期字符串。</p>
                            <p><a href="docs/docs-java/api/java/util/Date.html" target="_blank">Date</a> 有三个直接子类： <a href="docs/docs-java/api/java/sql/Date.html" target="_blank">java.sql.Date</a>, <a href="docs/docs-java/api/java/sql/Time.html" target="_blank">java.sql.Time</a>, <a href="docs/docs-java/api/java/sql/Timestamp.html" target="_blank">java.sql.Timestamp</a>。</p>
                            <ol>
                                <li><p><code>static Date 	from(<a href="docs/docs-java/api/java/time/Instant.html">Instant</a> instant)</code> -- 从 Instant 转化</p></li>
                                <li><p><code><a href="docs/docs-java/api/java/time/Instant.html">Instant</a> 	toInstant()</code> -- 转化为 Instant</p></li>

                                <li class="group"><p><code>boolean 	after(Date when)</code> -- 测试此日期是否在指定日期之后。</p></li>
                                <li><p><code>boolean 	before(Date when)</code> -- 测试此日期是否在指定日期之前。</p></li>
                                <li><p><code>long 	getTime()</code> -- 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数</p></li>
                                <li><p><code>void 	setTime(long time)</code> -- 设置此 Date 对象，以表示 1970 年 1 月 1 日 00:00:00 GMT 以后 time 毫秒的时间点。</p></li>

                                <li class="group"><p><code>int 	compareTo(Date anotherDate)</code> -- 比较两个日期的顺序。</p></li>
                                <li><p><code>boolean 	equals(Object obj)</code> -- 比较两个日期的相等性。</p></li>
                                <li><p><code>Object 	clone()</code> -- 返回此对象的副本。</p></li>
                                <li><p><code>int 	hashCode()</code> -- 返回此对象的哈希码值</p></li>
                                <li><p><code>String 	toString()</code> -- 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.util.Calendar

public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar> {
    /** Calendar 构造器 */
    public static class Builder {}

    public final static int FIELD_COUNT = 17;
    /** get(int) / set(int, int) 方法使用的常量: */
    public final static int ERA = 0; // 返回 GregorianCalendar.AD(公元后) 或 GregorianCalendar.BC(公元前)
    public final static int YEAR = 1; // 年
    public final static int MONTH = 2; // 月, 0 - 11
    public final static int WEEK_OF_YEAR = 3; // 年的星期数, 1 ~
    public final static int WEEK_OF_MONTH = 4; // 月中的星期数, 1 ~
    public final static int DATE = 5; // 月中的某天, 1 ~
    public final static int DAY_OF_MONTH = 5; // 同 DATE
    public final static int DAY_OF_YEAR = 6; // 年中的天数, 1 ~
    public final static int DAY_OF_WEEK = 7; // 星期中的某天, 1 ~
    // 月中的第几个星期, DAY_OF_MONTH 1 到 7 总是对应于 DAY_OF_WEEK_IN_MONTH 1；依此类推。
    public final static int DAY_OF_WEEK_IN_MONTH = 8;
    public final static int AM_PM = 9; // 上午 / 下午
    public final static int HOUR = 10; // 小时, 12 小时制, 0 ~ 11
    public final static int HOUR_OF_DAY = 11; // 小时, 24 小时制, 0 ~ 23
    public final static int MINUTE = 12; // 分钟, 0 ~ 59
    public final static int SECOND = 13; // 秒数, 0 ~ 59
    public final static int MILLISECOND = 14; // 毫秒, 0 ~ 999
    public final static int ZONE_OFFSET = 15; // 以毫秒为单位指示距 GMT 的大致偏移量
    public final static int DST_OFFSET = 16; // 以毫秒为单位指示夏令时的偏移量

    /** 星期 */
    public final static int SUNDAY = 1;
    public final static int MONDAY = 2;
    public final static int TUESDAY = 3;
    public final static int WEDNESDAY = 4;
    public final static int THURSDAY = 5;
    public final static int FRIDAY = 6;
    public final static int SATURDAY = 7;

    /** 月份 */
    public final static int JANUARY = 0;
    public final static int FEBRUARY = 1;
    public final static int MARCH = 2;
    public final static int APRIL = 3;
    public final static int MAY = 4;
    public final static int JUNE = 5;
    public final static int JULY = 6;
    public final static int AUGUST = 7;
    public final static int SEPTEMBER = 8;
    public final static int OCTOBER = 9;
    public final static int NOVEMBER = 10;
    public final static int DECEMBER = 11;
    public final static int UNDECIMBER = 12; // 一年中第十三个月, 阳历没有使用该值，但阴历会使用

    /** 上午 / 下午 */
    public final static int AM = 0;
    public final static int PM = 1;


    public static final int ALL_STYLES = 0;
    public static final int SHORT = 1;
    public static final int LONG = 2;

    public static final int NARROW_FORMAT = 4;
    public static final int NARROW_STANDALONE = NARROW_FORMAT | STANDALONE_MASK;
    public static final int SHORT_FORMAT = 1;
    public static final int LONG_FORMAT = 2;
    public static final int SHORT_STANDALONE = SHORT | STANDALONE_MASK;
    public static final int LONG_STANDALONE = LONG | STANDALONE_MASK;
}
</pre>
                            <p><a href="docs/docs-java/api/java/util/Calendar.html" target="_blank">Calendar</a> 是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p>
                            <p>Calendar 对象能够生成为特定语言和日历风格实现日期-时间格式化所需的所有日历字段值，例如，日语-格里高里历，日语-传统日历。Calendar 定义了某些日历字段返回值的范围，以及这些值的含义。</p>
                            <p><code>Calendar.getInstance()</code> 方法获取的实例其实是其子类 <a href="docs/docs-java/api/java/util/GregorianCalendar.html" target="_blank">GregorianCalendar</a> 的实例，它提供了世界上大多数国家/地区使用的标准日历系统，是一种混合日历，在单一间断性的支持下同时支持儒略历和格里高利历系统，在默认情况下，它对应格里高利日历创立时的格里高利历日期。</p>
                            <p>在 <code>Calendar.getInstance()</code> 方法中调用了 <a href="docs/docs-java/api/java/util/Calendar.Builder.html" target="_blank">Calendar.Builder</a> 来构建 Calendar, 并传入了 <code>System.currentTimeMillis()</code> 为日历的当前时间，也就是说在构建时，已经确定了时间。</p>
                            <ol>
                                <li><p><code>static Calendar 	getInstance()</code> -- 使用默认时区和语言环境获得一个日历。</p></li>
                                <li><p><code>static Calendar 	getInstance(Locale aLocale)</code> -- 使用默认时区和指定语言环境获得一个日历。</p></li>
                                <li><p><code>static Calendar 	getInstance(TimeZone zone)</code> -- 使用指定时区和默认语言环境获得一个日历。</p></li>
                                <li><p><code>static Calendar 	getInstance(TimeZone zone, Locale aLocale)</code> -- 使用指定时区和语言环境获得一个日历</p></li>

                                <li class="group"><p><code>static Locale[] 	getAvailableLocales()</code> --  返回所有语言环境的数组</p></li>
                                <li><p><code>static Set&lt;String> getAvailableCalendarTypes()</code> -- 返回一个不可修改的集合，包含运行时环境中日历支持的所有类型</p></li>

                                <li class="group"><p><code>int 	get(int field)</code> -- 返回给定日历字段的值，此方法返回 fields[field], fileds 数组长度为: Calendar.FIELD_COUNT ,filed 支持的值看前面常量</p></li>
                                <li><p><code>void 	set(int field, int value)</code> -- 将给定的日历字段设置为给定值</p></li>
								<li><p><code>void 	set(int year, int month, int date)</code> -- 设置日历字段</p></li>
								<li><p><code>void 	set(int year, int month, int date, int hourOfDay, int minute)</code> -- 设置日历字段</p></li>
								<li><p><code>void 	set(int year, int month, int date, int hourOfDay, int minute, int second)</code> -- 设置日历字段</p>
                                    <pre class="brush: java;">
Calendar calendar = Calendar.getInstance();
calendar.set(2018, Calendar.JUNE, 15, 16, 20, 40); // 2018/6/15 16:20:40
calendar.set(Calendar.HOUR_OF_DAY, 17); // 2018/6/15 17:20:40
</pre>
                                </li>


								<li class="group"><p><code>abstract  void 	add(int field, int amount)</code> -- 据日历的规则，为给定的日历字段添加或减去指定的时间量</p></li>
								<li><p><code>abstract  void 	roll(int field, boolean up)</code> -- 在给定的时间字段上添加或减去单个时间单元，不更改更大的字段</p></li>
								<li><p><code>void 	roll(int field, int amount)</code> -- 向指定日历字段添加指定（有符号的）时间量，不更改更大的字段</p>
                                    <pre class="brush: java;">
Calendar calendar = Calendar.getInstance();
calendar.set(2018, Calendar.JUNE, 15, 16, 20, 40); // 2018/6/15 16:20:40

calendar.add(Calendar.SECOND, 5); // 2018/6/15 16:20:45
calendar.add(Calendar.SECOND, -55); // 2018/6/15 16:19:50

/** roll 方法不会更改更大字段，如下：当秒数超出时候，分钟数没变 */
calendar.roll(Calendar.SECOND, 20); // 2018/6/15 16:20:10
calendar.roll(Calendar.SECOND, true); // 2018/6/15 16:19:51
calendar.roll(Calendar.SECOND, false); // 2018/6/15 16:19:50


</pre>
                                </li>

								<li class="group"><p><code>void 	setTimeInMillis(long millis)</code> -- 用给定的 long 值设置此 Calendar 的当前时间值。</p></li>
								<li><p><code>long 	getTimeInMillis()</code> -- 返回此 Calendar 的时间值，以毫秒为单位</p></li>
								<li><p><code>Date 	getTime()</code> -- 返回一个表示此 Calendar 时间值</p></li>
								<li><p><code>void 	setTime(Date date)</code> -- 使用给定的 Date 设置此 Calendar 的时间。</p></li>
								<li><p><code>void 	setTimeZone(TimeZone value)</code> -- 使用给定的时区值来设置时区。</p></li>
								<li><p><code>TimeZone 	getTimeZone()</code> -- 获得时区</p></li>
								<li><p><code>void 	setFirstDayOfWeek(int value)</code> -- 设置一星期的第一天是哪一天；美国(SUNDAY)，法国(MONDAY)</p></li>
								<li><p><code>int 	getFirstDayOfWeek()</code> -- 获取一星期的第一天，美国(SUNDAY)，法国(MONDAY)</p></li>
								<li><p><code>int 	getMinimalDaysInFirstWeek()</code> -- 获取一年中第一个星期所需的最少天数</p></li>
								<li><p><code>void 	setMinimalDaysInFirstWeek(int value)</code> -- 设置一年中第一个星期所需的最少天数，例如，如果定义第一个星期包含一年第一个月的第一天，则使用值 1 调用此方法。</p></li>

								<li class="group"><p><code>String 	getDisplayName(int field, int style, Locale locale)</code> -- 返回给定 style 下的日历 field 值的字符串表示形式</p></li>
								<li><p><code>Map&lt;String, Integer> 	getDisplayNames(int field, int style, Locale locale)</code> -- 返回给定 style 和 locale 下包含日历 field 所有名称的 Map 及其相应字段值</p>
                                    <pre class="brush: java;">
// Month 和 Week 有字符表示形式，指定使用完整写法(Calendar.LONG)或者缩写(Calendar.SHORT)，如: Monday - Mon
calendar.getDisplayName(filed, Calendar.LONG, Locale.getDefault());

/** 返回 field 字段的指定 style 的 Map，比如字段为: DAY_OF_WEEK，不同的 style 返回如下：
 * SHORT -- {"Sun":1, "Mon": 2, ...}
 * LONG -- {"Sunday":1, "Monday": 2, ...}
 * ALL_STYLES -- 以上两个
 */
calendar.getDisplayNames(Calendar.DAY_OF_WEEK, Calendar.ALL_STYLES, Locale.getDefault());
</pre>
                                </li>

								<li class="group"><p><code>abstract  int 	getMaximum(int field)</code> -- 返回此 Calendar 实例给定日历字段的最大值</p></li>
								<li><p><code>abstract  int 	getMinimum(int field)</code> -- 返回此 Calendar 实例给定日历字段的最小值</p></li>
								<li><p><code>abstract  int 	getGreatestMinimum(int field)</code> -- 返回此 Calendar 实例给定日历字段的最高的最小值</p></li>
								<li><p><code>abstract  int 	getLeastMaximum(int field)</code> -- 返回此 Calendar 实例给定日历字段的最低的最大值</p></li>
								<li><p><code>int 	getActualMaximum(int field)</code> -- 给定此 Calendar 的时间值，返回指定日历字段可能拥有的最大值</p></li>
								<li><p><code>int 	getActualMinimum(int field)</code> -- 给定此 Calendar 的时间值，返回指定日历字段可能拥有的最小值</p></li>

								<li class="group"><p><code>boolean 	isLenient()</code> -- 判断日期/时间的解释是否为宽松的</p></li>
								<li><p><code>void 	setLenient(boolean lenient)</code> -- 指定日期/时间解释是否是宽松的。</p></li>
                                <li><p><code>boolean 	isSet(int field)</code> -- 确定给定日历字段是否已经设置了一个值</p></li>

								<li class="group"><p><code>boolean 	after(Object when)</code> -- 判断此 Calendar 表示的时间是否在指定 Object 表示的时间之后，返回判断结果。</p></li>
								<li><p><code>boolean 	before(Object when)</code> -- 判断此 Calendar 表示的时间是否在指定 Object 表示的时间之前，返回判断结果。</p></li>
								<li><p><code>void 	clear()</code> -- 将此 Calendar 的所日历字段值和时间值（从历元至现在的毫秒偏移量）设置成未定义。</p></li>
								<li><p><code>void 	clear(int field)</code> -- 将此 Calendar 的给定日历字段值和时间值（从历元至现在的毫秒偏移量）设置成未定义。</p></li>

								<li class="group"><p><code>int 	compareTo(Calendar anotherCalendar)</code> -- 比较两个 Calendar 对象表示的时间值（从历元至现在的毫秒偏移量）。</p></li>
								<li><p><code>Object 	clone()</code> -- 创建并返回此对象的一个副本。</p></li>
								<li><p><code>boolean 	equals(Object obj)</code> -- 将此 Calendar 与指定 Object 比较。</p></li>
								<li><p><code>String 	toString()</code> -- 返回此日历的字符串表示形式。</p></li>
								<li><p><code>int 	hashCode()</code> -- 哈希值</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.util.TimeZone

public abstract class TimeZone implements Serializable, Cloneable {
    public static final int SHORT = 0; // 指出短名称的 getDisplayName() 的风格说明符
    public static final int LONG = 1; // 指出长名称的 getDisplayName() 的风格说明符
}
</pre>
                            <p><a href="docs/docs-java/api/java/util/TimeZone.html" target="_blank">TimeZone</a> 表示时区偏移量，也可以计算夏令时。 </p>
                            <p>通常，使用 getDefault 获取 TimeZone，getDefault 基于程序运行所在的时区创建 TimeZone。</p>
                            <ol>
                                <li><p><code>static String[] 	getAvailableIDs()</code> -- 获取受支持的所有可用 ID。</p></li>
                                <li><p><code>static String[] 	getAvailableIDs(int rawOffset)</code> -- 根据给定的时区偏移量（以毫秒为单位）获取可用的 ID。</p></li>
                                <li><p><code>static TimeZone 	getDefault()</code> -- 获取此主机的默认 TimeZone</p></li>
                                <li><p><code>static TimeZone 	getTimeZone(String ID)</code> -- 获取给定 ID 的 TimeZone</p></li>
                                <li><p><code>static TimeZone 	getTimeZone(ZoneId zoneId)</code> -- 获取给定 ZoneId 的 TimeZone</p></li>
                                <li><p><code>static void 	setDefault(TimeZone zone)</code> -- 设置默认的 TimeZone</p></li>

								<li class="group"><p><code>String 	getID()</code> -- 获取此时区的 ID，如："Asia/Shanghai"</p></li>
								<li><p><code>void 	setID(String ID)</code> -- 设置时区 ID</p></li>

                                <li class="group"><p><code>String 	getDisplayName()</code> -- 返回适合于展示给默认区域的用户的时区名称</p></li>
								<li><p><code>String 	getDisplayName(boolean daylight, int style)</code> -- 返回适合于展示给默认区域的用户的时区名称</p></li>
								<li><p><code>String 	getDisplayName(Locale locale)</code> -- 返回适合于展示给指定区域的用户的时区名称</p></li>
								<li><p><code>String 	getDisplayName(boolean daylight, int style, Locale locale)</code> -- 返回适合于展示给指定区域的用户的时区名称</p></li>

								<li class="group"><p><code>int 	getOffset(long date)</code> -- 从给定日期的 UTC 返回此时区的偏移量</p></li>
								<li><p><code>abstract  int 	getOffset(int era, int year, int month, int day, int dayOfWeek, int milliseconds)</code> -- 获取当前日期的时区偏移量</p></li>
								<li><p><code>abstract  void 	setRawOffset(int offsetMillis)</code> -- 把基准时区偏移量设置到 GMT</p></li>
								<li><p><code> abstract  int 	getRawOffset()</code> -- 返回添加到 UTC 以获取此时区中的标准时间的时间量</p></li>

								<li class="group"><p><code>abstract  boolean 	useDaylightTime()</code> -- 查询此时区是否使用夏令时</p></li>
								<li><p><code>abstract  boolean 	inDaylightTime(Date date)</code> -- 查询给定的日期是否在此时区的夏令时中</p>
									<p><b>夏令时</b> -- 是一种为节约能源而人为规定地方时间的制度，在这一制度实行期间所采用的统一时间称为“夏令时间”。</p>
									<p>夏令时具体作法是：每年从四月中旬第一个星期日的凌晨2时整（北京时间），将时钟拨快一小时，即将表针由2时拨至3时，夏令时开始；到九月中旬第一个星期日的凌晨2时整（北京夏令时），再将时钟拨回一小时，即将表针由2时拨至1时，夏令时结束。</p>
								</li>


								<li class="group"><p><code>int 	getDSTSavings()</code> -- 返回要添加到本地标准时间以获取本地挂钟时间的时间量</p></li>
								<li><p><code>boolean 	hasSameRules(TimeZone other)</code> -- 如果此区域和另一个区域具有相同的规则和偏移量</p></li>
								<li><p><code>Object 	clone()</code> -- 创建此 TimeZone 的一个副本</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-Timer"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Timer 和 TimerTask</h3>
                    </div>
                    <div class="panel-body">
						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object
	java.util.Timer

public class Timer {
	public Timer() {}
	public Timer(boolean isDaemon) {}
	public Timer(String name) {}
	public Timer(String name, boolean isDaemon) {}
}
</pre>
							<p><a href="docs/docs-java/api/java/util/Timer.html" target="_blank">Timer</a> 是一种工具，线程用其安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行。</p>
							<p>与每个 Timer 对象相对应的是单个后台线程，用于顺序地执行所有计时器任务。计时器任务应该迅速完成。如果完成某个计时器任务的时间太长，那么它会“独占”计时器的任务执行线程。因此，这就可能延迟后续任务的执行，而这些任务就可能“堆在一起”，并且在上述不友好的任务最终完成时才能够被快速连续地执行。 </p>
							<p>对 Timer 对象最后的引用完成后，并且 所有未处理的任务都已执行完成后，计时器的任务执行线程会正常终止（并且成为垃圾回收的对象）。但是这可能要很长时间后才发生。默认情况下，任务执行线程并不作为守护线程 来运行，所以它能够阻止应用程序终止。如果调用者想要快速终止计时器的任务执行线程，那么调用者应该调用计时器的 cancel 方法。 </p>
							<p>如果意外终止了计时器的任务执行线程，例如调用了它的 stop 方法，那么所有以后对该计时器安排任务的尝试都将导致 IllegalStateException，就好像调用了计时器的 cancel 方法一样。 </p>
							<p>此类是线程安全的：多个线程可以共享单个 Timer 对象而无需进行外部同步。 </p>
							<ol>
								<li><p><code>void 	cancel()</code> -- 终止此计时器，丢弃所有当前已安排的任务</p></li>
								<li><p><code>int 	purge()</code> -- 从此计时器的任务队列中移除所有已取消的任务</p></li>
								<li class="group"><p><code>void 	schedule(TimerTask task, long delay)</code> -- 安排在指定延迟后执行指定的任务</p></li>
								<li><p><code>void 	schedule(TimerTask task, long delay, long period)</code> -- 指定的任务从指定的延迟后开始进行重复的固定延迟执行，第一次以 delay 为延迟，后面以 period 为间隔无限重复执行任务</p></li>
								<li><p><code>void 	schedule(TimerTask task, Date time)</code> -- 安排在指定的时间执行指定的任务</p></li>
								<li><p><code>void 	schedule(TimerTask task, Date firstTime, long period)</code> -- 安排指定的任务在指定的时间开始进行重复的固定延迟执行</p></li>
								<li><p><code>void 	scheduleAtFixedRate(TimerTask task, long delay, long period)</code> -- 安排指定的任务在指定的延迟后开始进行重复的固定速率执行，区别在于如果由于任何原因（如垃圾回收或其他后台活动）而延迟了某次执行，则将快速连续地出现两次或更多的执行，从而使后续执行能够“追赶上来”。</p></li>
								<li><p><code>void 	scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</code> -- 安排指定的任务在指定的时间开始进行重复的固定速率执行</p></li>
							</ol>
						</div>

						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object
	java.util.TimerTask

public abstract class TimerTask implements Runnable {
 	protected TimerTask() {}
}
</pre>
							<p><a href="docs/docs-java/api/java/util/TimerTask.html" target="_blank">TimerTask</a> 由 Timer 安排为一次执行或重复执行的任务。</p>
							<ol>
								<li><p><code>boolean 	cancel()</code> -- 取消此计时器任务</p></li>
								<li><p><code>abstract  void 	run()</code> -- 此计时器任务要执行的操作</p></li>
								<li><p><code>long 	scheduledExecutionTime()</code> -- 返回此任务最近实际 执行的已安排 执行时间</p></li>
							</ol>
						</div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-List"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">List, Map, Set, Queue, Arrays, Collections...</h3>
                    </div>
                    <div class="panel-body">
						<div class="sub-item">
                            <p><b>Java Collections Framework 结构</b></p>
                            <p>主要包括三大顶级接口：<code>Iterator</code>, <code>Collection</code> 和 <code>Map</code>。基本所有的实现类都继承抽象类 <code>AbstractCollection</code>，数据结构主要分为以下四种: </p>
                            <ul>
                                <li><p><b>List</b> -- 有序的 Collection（也称为序列）；</p>
									<pre class="brush: java;">
List&lt;E> extends Collection&lt;E>
├ AbstractList implements List /** 抽象类，提供 List 接口的骨干实现，一般不直接使用此类 */
│ ├ ArrayList /** 大小可变数组的实现，内部使用数组实现，当内部数组容量不够时，自动增长内部数组的容量 */
│ ├ AbstractSequentialList /** 链接列表骨干实现(非数组) */
│ │ └ LinkedList implements List, Deque /** List 接口的链表实现，并实现 Deque，支持在两端插入和移除元素 */
│ └ Vector /** 实现可增长的对象数组，和 ArrayList 相同，但此类是线程安全的 */
│   └ Stack /** 后进先出（LIFO）的对象堆栈 */
└ CopyOnWriteArrayList /** ArrayList 的一个线程安全的变体，修改操作是复制副本修改，修改完成再更改引用 */

ArrayList -- 大小可变数组的实现，插入和查询比较快，移除/修改慢
LinkedList -- List 接口的链表实现，支持(FIFO/LIFO)，大数据插入/查询操作慢于 ArrayList，但删除/修改操作要快
Vector -- 同样是数组实现，多数方法加了 synchronized 关键字，扩容方式和 ArrayList 有区别
Stack -- 支持 LIFO(push(E)/pop())
CopyOnWriteArrayList -- 同 ArrayList, 添加/修改/删除都是复制副本操作，修改完成再更改引用
</pre>
								</li>

								<li><p><b>Set</b> -- 不包含重复元素的 Collection；</p>
									<pre class="brush: java;">
Set&lt;E> extends Collection&lt;E> /** 有两个子接口 */
└ SortedSet /** 进一步提供关于元素的总体排序的 Set */
   └ NavigableSet /** 扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法 */

Set&lt;E> extends Collection&lt;E> /** 实现类 */
└ AbstractSet implements Set /** 提供 Set 接口的骨干实现 */
  ├ HashSet /** 实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持 */
  │ └ LinkedHashSet /** LinkedHashSet 支持 */
  ├ TreeSet implements NavigableSet /** 基于 TreeMap 的 NavigableSet 实现 */
  ├ EnumSet /** 与枚举类型一起使用的专用 Set 实现，抽象类，提供了若干静态工厂方法创建 */
  ├ ConcurrentSkipListSet implements NavigableSet /** 可缩放并发 NavigableSet 实现 */
  └ CopyOnWriteArraySet /** 对其所有操作使用内部 CopyOnWriteArrayList 的 Set，修改操作是复制副本修改 */

HashSet -- 等同于 HashMap 只存储 K 值
LinkedHashSet -- 等同于 LinkedHashMap 只存储 K 值
TreeSet -- 等同于 TreeMap 只存储 K 值
ConcurrentSkipListSet -- 等同于 ConcurrentSkipListMap 只存储 K 值
CopyOnWriteArraySet -- 等同于 CopyOnWriteArrayList 只存储 K 值
EnumSet -- 和 EnumMap 无关，抽象类，提供了若干静态工厂方法创建，只用于保存指定类型的枚举值
</pre>
								</li>
								<li><p><b>Queue</b> -- 队列，先进先出，子接口为 Deque， 后进先出。</p>
									<pre class="brush: java;">
Queue&lt;E> extends Collection&lt;E> /** 队列，FIFO， 入队：add(E)/offer(E)，出队：remove()/pool() */
├ Deque /** 双向队列，FIFO/LIFO，入栈：push(E)，出栈：pop(), xxXFirst/xxxLast... */
└ BlockingQueue /** 阻塞队列，阻塞出队：take()，延迟入队/出队 */
  ├	TransferQueue /** 生产者可以等待消费者接收元素 */
  └ BlockingDeque extends BlockingQueue, Deque /** 双向阻塞队列 */

Queue&lt;E> extends Collection&lt;E> /** 实现类 */
├ ArrayDeque implements Deque /** 双向队列，Deque 接口的大小可变数组的实现 */
└ AbstractQueue implements Queue /** 提供某些 Queue 操作的骨干实现 */
  ├	PriorityQueue /** 基于优先级的队列，默认自然排序 */
  ├	PriorityBlockingQueue implements BlockingQueue /** 同 PriorityQueue，但是无数据时支持阻塞等待数据 */
  ├	ArrayBlockingQueue implements BlockingQueue /** 由数组支持的阻塞队列，维护插入顺序 */
  ├	LinkedBlockingQueue implements BlockingQueue /** 由链表支持的阻塞队列，维护插入顺序 */
  ├	LinkedBlockingDeque implements BlockingDeque /** 由链表支持的双向阻塞队列，维护插入顺序 */
  ├ ConcurrentLinkedQueue implements Queue /** 链表支持的，线程安全的队列 */
  ├	ConcurrentLinkedDeque implements Deque /** 链表支持的，线程安全的双向队列 */
  ├	DelayQueue implements BlockingQueue /** Delayed 元素的一个阻塞队列，只有在延迟期满时才能从中提取元素 */
  ├	SynchronousQueue implements BlockingQueue /** 同步阻塞队列，不具有数据或链表缓存数据 */
  └	LinkedTransferQueue implements TransferQueue /** 基于链表实现的队列，通过 CAS 避免整个队列的加锁操作 */

LinkedList -- 实现 List 和 Deque 接口
ArrayDeque -- 大小可变的数组实现的双向队列
PriorityQueue -- 基于优先级的队列，默认自动维护自然排序
PriorityBlockingQueue -- 支持阻塞的优先级队列，默认自动维护自然排序
ArrayBlockingQueue -- 由数组支持的阻塞队列，维护插入顺序
LinkedBlockingQueue -- 由链表支持的阻塞队列，维护插入顺序
LinkedBlockingDeque -- 由链表支持的双向阻塞队列，维护插入顺序
ConcurrentLinkedQueue -- 链表支持的，线程安全的队列
ConcurrentLinkedDeque -- 链表支持的，线程安全的双向队列
DelayQueue -- 延时执行任务的队列，重写 compareTo 方法，按时间排序
SynchronousQueue -- 无缓存，取数据的线程先等待，才能发送数据；取数据的线程再次等待，才能发送另外一个数据
LinkedTransferQueue -- 基于链表实现的队列，通过 CAS 的方式避免整个队列的加锁操作
</pre>
								</li>
                                <li><p><b>Map</b> -- 将键映射到值的对象；</p>
                                    <pre class="brush: java;">
Map&lt;K,V> /** 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值 */
├ SortedMap /** 进一步提供关于键的总体排序的 Map */
│ └ NavigableMap /** 扩展的 SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法 */
└ ConcurrentMap /** 提供其他原子 putIfAbsent、remove、replace 方法的 Map */
  └ ConcurrentNavigableMap extends ConcurrentMap, NavigableMap/**递归方式支持子映射的 ConcurrentMap */

Map&lt;K,V> /** 实现类 */
├ AbstractMap implements Map /** 提供 Map 接口的骨干实现 */
│ ├	HashMap /**  Map 接口的哈希表和单向链表实现，数组是主体，链表则是主要为了解决哈希冲突而存在的 */
│ │	└ LinkedHashMap /** 额外维护了一个双向链表用于保持迭代顺序，该迭代顺序可以是插入顺序，也可以是访问顺序 */
│ ├	TreeMap implements NavigableMap /** 基于红黑树（Red-Black tree）的 NavigableMap 实现 */
│ ├	EnumMap /** 与枚举类型键一起使用的专用 Map 实现 */
│ ├	WeakHashMap /** 以弱引用实现的基于哈希表的 Map */
│ ├	IdentityHashMap /** 利用哈希表实现 Map 接口，比较键（和值）时使用引用相等性代替对象相等性 */
│ ├	ConcurrentHashMap implements ConcurrentMap /** 支持获取的完全并发和更新的所期望可调整并发的哈希表 */
│ └	ConcurrentSkipListMap implements ConcurrentNavigableMap /** 可缩放 ConcurrentNavigableMap 实现 */
└ Hashtable implements Map /** 类似 HashMap，但它是同步的，并不允许空的键和值 */
  └ Properties /** 线程安全的，支持从属性文件，xml 文件等读写键值的方便类 */

HashMap -- 基于哈希表的 Map 接口的实现，使用数组+单向链表的方式，数组是主体，链表则是主要为了解决哈希冲突而存在的
LinkedHashMap -- 额外维护了一个双向链表用于保持迭代顺序，可以是插入顺序，也可以是访问顺序，非常适合实现 LRU 算法
TreeMap -- 有序基于红黑树（Red-Black tree）的 NavigableMap 实现，可以指定比较器来排序；如不指定，使用自然排序
WeakHashMap -- 其存储的 Entry 是 WeakReference 的子类，在 GC 后会变成 null
EnumMap -- 自动枚举值排序，K 值一定是枚举类型，基于枚举优化的 Map 实现
IdentityHashMap -- 只认为 k1 == k2 时才认为相等，和 equals 无关
ConcurrentHashMap -- 线程安全的 HashMap 实现，根据散列值锁住了散列值锁对应的那段，因此提高了并发性能
ConcurrentSkipListMap -- 线程安全的并发访问的排序映射表，内部是 SkipList（跳表）结构实现
Hashtable -- 同 HashMap，键值都不能为空，多数操作使用 synchronized 同步，建议使用 ConcurrentHashMap 替代此类
Properties -- 线程安全的，支持从属性文件，xml 文件等读写键值的方便类
</pre>
                                </li>
                            </ul>
                            <p>还有一些用于操作的工具类： <a href="#Arrays">Arrays</a>, <a href="#Collections">Collections</a></p>
                            <p><b>Java Collections Framework</b> 类和接口导航:</p>
                            <ul>
                                <li><p><b>迭代器接口</b>: <a href="#Iterator">Iterator</a>, <a href="#ListIterator">ListIterator</a></p></li>
                                <li><p><b>Comparable 接口</b>: <a href="#Comparable">Comparable</a></p></li>
								<li><p><b>Comparator 接口及实现类</b>: <a href="#Comparator">Comparator</a>, <a href="#Collator">Collator</a>, <a href="#RuleBasedCollator">RuleBasedCollator</a></p></li>
                                <li><p><b>Iterable 及子接口</b>: <a href="#Iterable">Iterable</a>, <a href="#Collection">Collection</a>, <a href="#List">List</a>, <a href="#Queue">Queue</a>, <a href="#Deque">Deque</a>, <a href="#BlockingQueue">BlockingQueue</a>, <a href="#TransferQueue">TransferQueue</a>, <a href="#BlockingDeque">BlockingDeque</a>, <a href="#Set">Set</a>, <a href="#SortedSet">SortedSet</a>, <a href="#NavigableSet">NavigableSet</a></p></li>
                                <li><p><b>Map 及子接口</b>: <a href="#Map">Map</a>, <a href="#SortedMap">SortedMap</a>, <a href="#NavigableMap">MavigableMap</a>, <a href="#ConcurrentMap">ConcurrentMap</a>, <a href="#ConcurrentNavigableMap">ConcurrentNavigableMap</a></p></li>
                                <li><p><b>抽象骨干类</b>: <a href="#AbstractCollection">AbstractCollection</a>, <a href="#AbstractList">AbstractList</a>, <a href="#AbstractMap">AbstractMap</a>, <a href="#AbstractSet">AbstractSet</a>, <a href="#AbstractQueue">AbstractQueue</a></p></li>
                                <li><p><b>List 接口实现类</b>: <a href="#ArrayList">ArrayList</a>, <a href="#AbstractSequentialList">AbstractSequentialList</a>, <a href="#LinkedList">LinkedList</a>, <a href="#Vector">Vector</a>, <a href="#Stack">Stack</a>, <a href="#CopyOnWriteArrayList">CopyOnWriteArrayList</a></p></li>
                                <li><p><b>Map 接口实现类</b>: <a href="#HashMap">HashMap</a>, <a href="#LinkedHashMap">LinkedHashMap</a>, <a href="#WeakHashMap">WeakHashMap</a>, <a href="#TreeMap">TreeMap</a>, <a href="#EnumMap">EnumMap</a>, <a href="#IdentityHashMap">IdentityHashMap</a>, <a href="#ConcurrentHashMap">ConcurrentHashMap</a>, <a href="#ConcurrentSkipListMap">ConcurrentSkipListMap</a>, <a href="#Dictionary">Dictionary(此类未实现 Map 接口)</a>, <a href="#Hashtable">Hashtable</a>, <a href="#Properties">Properties</a></p></li>
                                <li><p><b>Set 接口实现类</b>: <a href="#HashSet">HashSet</a>, <a href="#LinkedHashSet">LinkedHashSet</a>, <a href="#TreeSet">TreeSet</a>, <a href="#EnumSet">EnumSet</a>, <a href="#ConcurrentSkipListSet">ConcurrentSkipListSet</a>, <a href="#CopyOnWriteArraySet">CopyOnWriteArraySet</a></p></li>
                                <li><p><b>Queue 接口实现类</b>: <a href="#PriorityQueue">PriorityQueue</a>, <a href="#ArrayBlockingQueue">ArrayBlockingQueue</a>, <a href="#LinkedBlockingQueue">LinkedBlockingQueue</a>, <a href="#LinkedBlockingDeque">LinkedBlockingDeque</a>, <a href="#PriorityBlockingQueue">PriorityBlockingQueue</a>, <a href="#SynchronousQueue">SynchronousQueue</a>, <a href="#DelayQueue">DelayQueue</a>, <a href="#ConcurrentLinkedQueue">ConcurrentLinkedQueue</a>, <a href="#ConcurrentLinkedDeque">ConcurrentLinkedDeque</a>, <a href="#LinkedTransferQueue">LinkedTransferQueue</a>, <a href="#ArrayDeque">ArrayDeque</a></p></li>
                            </ul>

							<pre class="brush: java; gutter: false;">
Iterator /** 迭代器，Collections 的实现类都有内部类实现此接口，并提供了返回 Iterator 的方法(实现 Iterable 接口) */
 └─ ListIterator /** 列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置 */

java.lang.Comparable /** 此接口强行对实现它的每个类的对象进行整体排序，实现类太多，如: String, Integer... */

Comparator /** 比较器，强行对某个对象 collection 进行整体排序 的比较函数 */
 └─ java.text.Collator /** 区分语言环境的 String 比较，使用此类可为自然语言文本构建搜索和排序例程 */
     └─ java.text.RuleBasedCollator /** 是 Collator 的具体子类，它提供了一个简单的、数据驱动的表 collator */

/** 容器接口继承结构和父接口(不包括非容器接口):
 * java.util.concurrent 包类，在并发编程中很常用的实用工具类，以 * 开头
 * 有两个父接口的只写在深的父接口下，并加 extends 标明，开头加 = 区分 */
java.lang.Iterable /** 实现这个接口允许对象成为 "foreach" 语句的目标，主要是: Iterator&lt;T> iterator() 方法。 */
 └─ Collection /** Collection 层次结构中的根接口 */
	 ├─ List /** 有序的 Collection（也称为序列）,和 Set 不同，通常允许重复的元素 */
	 ├─ Set /** 一个不包含重复元素的 Collection */
	 │	 └─	SortedSet /** 进一步提供关于元素的总体排序 的 Set */
	 │	 	 └─ NavigableSet /** 扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法 */
     └─ Queue /** 队列，FIFO */
	 	 ├─	Deque /** 队列，LIFO */
	 	 └─ * BlockingQueue /** 支持两个附加操作的 Queue */
	 	     ├─	* TransferQueue /** 一个阻塞队列，其中生产者可以等待消费者接收元素 */
	 		 └─ *= BlockingDeque extends BlockingQueue, Deque /** 支持两个附加操作的 Queue */

Map /** 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值 */
 ├─ SortedMap /** 进一步提供关于键的总体排序的 Map */
 │   └─ NavigableMap /** 扩展的 SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法 */
 └─ * ConcurrentMap /** 提供其他原子 putIfAbsent、remove、replace 方法的 Map */
	  └─ *= ConcurrentNavigableMap extends ConcurrentMap, NavigableMap/**递归方式支持子映射的 ConcurrentMap */

/** 容器类继承结构和实现接口(不包括非容器接口): java.util.concurrent 包类，在并发编程中很常用的实用工具类，以 * 开头 */
AbstractCollection implements Collection /** 提供 Collection 接口的骨干实现*/
 ├─	AbstractList implements List /** 提供 List 接口的骨干实现 */
 │	 ├─	ArrayList /** 大小可变数组的实现 */
 │	 ├─	AbstractSequentialList /** 链接列表骨干实现(非数组) */
 │	 │	 └─	LinkedList implements List, Deque /** List 接口的链接列表实现 */
 │	 └─	Vector /** 实现可增长的对象数组，和 ArrayList 相同，但此类是线程安全的 */
 │		 └─	Stack /** 后进先出（LIFO）的对象堆栈 */
 ├─	* CopyOnWriteArrayList implements List /** ArrayList 的一个线程安全的变体，修改操作是复制副本修改 */
 ├─	AbstractMap implements Map /** 提供 Map 接口的骨干实现 */
 │	 ├─	HashMap /** 基于 HashTable 的 Map 接口的实现 */
 │	 │	 └─	LinkedHashMap /** Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序 */
 │	 ├─	WeakHashMap /** 以弱引用 Entry 实现的基于哈希表的 Map，GC 后，Map 的值会变为不可用 */
 │	 ├─	TreeMap implements NavigableMap /** 基于红黑树（Red-Black tree）的 NavigableMap 实现 */
 │	 ├─	EnumMap /** 与枚举类型键一起使用的专用 Map 实现 */
 │	 ├─	IdentityHashMap /** 利用哈希表实现 Map 接口，比较键（和值）时使用引用相等性代替对象相等性 */
 │	 ├─	* ConcurrentHashMap implements ConcurrentMap /** 支持获取的完全并发和更新的所期望可调整并发的哈希表 */
 │	 └─	* ConcurrentSkipListMap implements ConcurrentNavigableMap /** 可缩放的并发 ConcurrentNavigableMap 实现 */
 ├─ AbstractSet implements Set /** 提供 Set 接口的骨干实现 */
 │	 ├─	HashSet /** 实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持 */
 │	 │	 └─	LinkedHashSet /** 具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现 */
 │	 ├─	TreeSet implements NavigableSet /** 基于 TreeMap 的 NavigableSet 实现 */
 │	 ├─	EnumSet /** 与枚举类型一起使用的专用 Set 实现 */
 │	 ├─	* ConcurrentSkipListSet implements NavigableSet /** 可缩放并发 NavigableSet 实现 */
 │	 └─	* CopyOnWriteArraySet /** 对其所有操作使用内部 CopyOnWriteArrayList 的 Set，修改操作是复制副本修改 */
 ├─	AbstractQueue implements Queue /** 提供某些 Queue 操作的骨干实现 */
 │	 ├─	PriorityQueue /** 一个基于优先级堆的无界优先级队列 */
 │	 ├─	* ArrayBlockingQueue implements BlockingQueue /** 一个由数组支持的有界阻塞队列 */
 │	 ├─	* LinkedBlockingQueue implements BlockingQueue /** 一个基于已链接节点的、范围任意的 BlockingBueue */
 │	 ├─	* LinkedBlockingDeque implements BlockingDeque /** 一个基于已链接节点的、任选范围的阻塞双端队列 */
 │	 ├─	* PriorityBlockingQueue implements BlockingQueue /** 无界阻塞队列，使用与类 PriorityQueue 相同的顺序规则 */
 │	 ├─	* SynchronousQueue implements BlockingQueue /** 阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 */
 │	 ├─	* DelayQueue implements BlockingQueue /** Delayed 元素的一个无界阻塞队列，只有在延迟期满时才能从中提取元素 */
 │	 ├─	* ConcurrentLinkedQueue implements Queue /** 一个基于链接节点的无界线程安全队列 */
 │	 ├─	* ConcurrentLinkedDeque implements Deque /** 一个基于双向链接节点的无界线程安全队列 */
 │   └─	* LinkedTransferQueue implements TransferQueue /**  */
 ├─	ArrayDeque implements Deque /** Deque 接口的大小可变数组的实现 */
 └─	Dictionary /** 任何可将键映射到相应值的类（如 Hashtable）的抽象父类 */
 	 └─	Hashtable implements Map /** 实现一个哈希表，该哈希表将键映射到相应的值 */
 	 	└─ Properties /** 表示了一个持久的属性集 */
</pre>
						</div>

						<div class="sub-item">
                            <a id="Arrays" class="offset"></a>
                            <div class="split-item">
								<p><b><code>Arrays</code>  和 <code>Collections</code> 这两个类提供了许多静态方法操作集合和数组。</b></p>
								<p><a href="docs/docs-java/api/java/util/Arrays.html" target="_blank">Arrays</a> 包含用来操作数组（比如排序和搜索）的各种方法。此类还包含一个允许将数组作为列表来查看的静态工厂。</p>
								<ol>
									<li><p><code>static int 	binarySearch(byte[] a, byte key)</code> -- 使用二分搜索法来搜索指定的数组，以获得指定的值</p></li>
									<li><p><code>static int 	binarySearch(char[] a, char key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(short[] a, short key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(int[] a, int key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(long[] a, long key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(float[] a, float key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(double[] a, double key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(Object[] a, Object key)</code> -- 同上</p></li>
									<li><p><code>static &lt;T> int binarySearch(T[] a, T key, Comparator&lt;? super T> c)</code> -- 指定比较器</p></li>

									<li class="group"><p><code>static int 	binarySearch(byte[] a, int fromIndex, int toIndex, byte key)</code> -- 二分搜索法搜索指定的范围的值</p></li>
									<li><p><code>static int 	binarySearch(char[] a, int fromIndex, int toIndex, char key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(short[] a, int fromIndex, int toIndex, short key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(int[] a, int fromIndex, int toIndex, int key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(long[] a, int fromIndex, int toIndex, long key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(float[] a, int fromIndex, int toIndex, float key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(double[] a, int fromIndex, int toIndex, double key)</code> -- 同上</p></li>
									<li><p><code>static int 	binarySearch(Object[] a, int fromIndex, int toIndex, Object key)</code> -- 同上</p></li>
									<li><p><code>static &lt;T> int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator&lt;? super T> c)</code> -- 指定比较器</p></li>

									<li class="group"><p><code>static boolean[] 	copyOf(boolean[] original, int newLength)</code> -- 复制使副本具有指定的长度，截取或用 false 填充</p></li>
									<li><p><code>static byte[] 	copyOf(byte[] original, int newLength)</code> -- 复制，截取或用 0 填充</p></li>
									<li><p><code>static char[] 	copyOf(char[] original, int newLength)</code> -- 复制，截取或用 空字符 填充</p></li>
									<li><p><code>static short[] 	copyOf(short[] original, int newLength)</code> --复制，截取或用 0 填充</p></li>
									<li><p><code>static int[] 	copyOf(int[] original, int newLength)</code> -- 复制，截取或用 0 填充</p></li>
									<li><p><code>static long[] 	copyOf(long[] original, int newLength)</code> -- 复制，截取或用 0 填充</p></li>
									<li><p><code>static float[] 	copyOf(float[] original, int newLength)</code> -- 复制，截取或用 0 填充</p></li>
									<li><p><code>static double[] 	copyOf(double[] original, int newLength)</code> -- 复制，截取或用 0 填充</p></li>
									<li><p><code>static &lt;T> T[] copyOf(T[] original, int newLength)</code> -- 复制，截取或用 null 填充</p></li>
									<li><p><code>static &lt;T,U> T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]> newType)</code> -- 复制，截取或用 null 填充</p></li>

									<li class="group"><p><code>static boolean[] 	copyOfRange(boolean[] original, int from, int to)</code> -- 将指定数组的指定范围复制到一个新数组</p></li>
									<li><p><code>static byte[] 	copyOfRange(byte[] original, int from, int to)</code> -- 同上</p></li>
									<li><p><code>static char[] 	copyOfRange(char[] original, int from, int to)</code> -- 同上</p></li>
									<li><p><code>static short[] 	copyOfRange(short[] original, int from, int to)</code> -- 同上</p></li>
									<li><p><code>static int[] 	copyOfRange(int[] original, int from, int to)</code> -- 同上</p></li>
									<li><p><code>static long[] 	copyOfRange(long[] original, int from, int to)</code> -- 同上</p></li>
									<li><p><code>static float[] 	copyOfRange(float[] original, int from, int to)</code> -- 同上</p></li>
									<li><p><code>static double[] 	copyOfRange(double[] original, int from, int to)</code> -- 同上</p></li>
									<li><p><code>static &lt;T> T[] copyOfRange(T[] original, int from, int to)</code> -- 同上</p></li>
									<li><p><code>static &lt;T,U> T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]> newType)</code> -- 同上</p></li>


									<li class="group"><p><code>static void 	sort(byte[] a)</code> -- 对 a 数组按数字升序进行排序</p></li>
									<li><p><code>static void 	sort(char[] a)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(short[] a)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(int[] a)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(long[] a)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(float[] a)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(double[] a)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(Object[] a)</code> -- 根据元素的自然顺序对指定对象数组按升序进行排序</p></li>
									<li><p><code>static &lt;T> void sort(T[] a, Comparator&lt;? super T> c)</code> -- 根据指定比较器产生的顺序对指定对象数组进行排序</p></li>

									<li class="group"><p><code>static void 	sort(byte[] a, int fromIndex, int toIndex)</code> -- 对 a 数组的指定范围按数字升序进行排序</p></li>
									<li><p><code>static void 	sort(char[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(double[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(float[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(int[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(long[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(Object[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
									<li><p><code>static void 	sort(short[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
									<li><p><code>static &lt;T> void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T> c)</code> -- 指定比较器</p></li>

									<li class="group"><p><code>static void 	fill(boolean[] a, boolean val)</code> -- 将 val 分配给 a 数组的每个元素</p></li>
									<li><p><code>static void 	fill(byte[] a, byte val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(char[] a, char val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(short[] a, short val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(int[] a, int val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(long[] a, long val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(float[] a, float val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(double[] a, double val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(Object[] a, Object val)</code> -- 同上</p></li>

									<li class="group"><p><code>static void 	fill(boolean[] a, int fromIndex, int toIndex, boolean val)</code> -- 用 val 填充 a 数组指定范围中的每个元素</p></li>
									<li><p><code>static void 	fill(byte[] a, int fromIndex, int toIndex, byte val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(char[] a, int fromIndex, int toIndex, char val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(short[] a, int fromIndex, int toIndex, short val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(int[] a, int fromIndex, int toIndex, int val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(long[] a, int fromIndex, int toIndex, long val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(float[] a, int fromIndex, int toIndex, float val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(double[] a, int fromIndex, int toIndex, double val)</code> -- 同上</p></li>
									<li><p><code>static void 	fill(Object[] a, int fromIndex, int toIndex, Object val)</code> -- 同上</p></li>

									<li class="group"><p><code>static &lt;T> List&lt;T> asList(T... a)</code> -- 返回一个受指定数组支持的固定大小的列表</p></li>
									<li><p><code>static boolean 	deepEquals(Object[] a1, Object[] a2)</code> -- 如果两个指定数组彼此是深层相等 的，则返回 true</p></li>
									<li><p><code>static int 	deepHashCode(Object[] a)</code> -- 基于指定数组的“深层内容”返回哈希码</p></li>
									<li><p><code>static String 	deepToString(Object[] a)</code> -- 返回指定数组“深层内容”的字符串表示形式</p></li>

									<li class="group"><p><code>static int 	hashCode(boolean[] a)</code> -- 基于指定数组的内容返回哈希码</p></li>
									<li><p><code>static int 	hashCode(byte[] a)</code> -- 同上</p></li>
									<li><p><code>static int 	hashCode(char[] a)</code> -- 同上</p></li>
									<li><p><code>static int 	hashCode(short[] a)</code> -- 同上</p></li>
									<li><p><code>static int 	hashCode(int[] a)</code> -- 同上</p></li>
									<li><p><code>static int 	hashCode(long[] a)</code> -- 同上</p></li>
									<li><p><code>static int 	hashCode(float[] a)</code> -- 同上</p></li>
									<li><p><code>static int 	hashCode(double[] a)</code> -- 同上</p></li>
									<li><p><code>static int 	hashCode(Object[] a)</code> -- 同上</p>
										<pre class="brush: java;">
/** 对于长度相等的数组 a[n] 和 b[n], 有 a[i] == b[i], 那么 Arrays.hashCode(a) == Arrays.hashCode(b); */
</pre>
									</li>

									<li class="group"><p><code>static boolean 	equals(boolean[] a, boolean[] a2)</code> -- 如果两个指定类型数组彼此相等，则返回 true</p></li>
									<li><p><code>static boolean 	equals(byte[] a, byte[] a2)</code> -- 同上</p></li>
									<li><p><code>static boolean 	equals(char[] a, char[] a2)</code> -- 同上</p></li>
									<li><p><code>static boolean 	equals(short[] a, short[] a2)</code> -- 同上</p></li>
									<li><p><code>static boolean 	equals(int[] a, int[] a2)</code> -- 同上</p></li>
									<li><p><code>static boolean 	equals(long[] a, long[] a2)</code> -- 同上</p></li>
									<li><p><code>static boolean 	equals(float[] a, float[] a2)</code> -- 同上</p></li>
									<li><p><code>static boolean 	equals(double[] a, double[] a2)</code> -- 同上</p></li>
									<li><p><code>static boolean 	equals(Object[] a, Object[] a2)</code> -- 同上</p></li>

									<li class="group"><p><code>static String 	toString(boolean[] a)</code> -- 返回指定数组内容的字符串表示形式，<code>[false, true...]</code></p></li>
									<li><p><code>static String 	toString(byte[] a)</code> -- 同上，<code>[1, 2...]</code></p></li>
									<li><p><code>static String 	toString(char[] a)</code> -- 同上，<code>[a, b...]</code></p></li>
									<li><p><code>static String 	toString(int[] a)</code> -- 同上，<code>[1, 2...]</code></p></li>
									<li><p><code>static String 	toString(long[] a)</code> -- 同上，<code>[1, 2...]</code></p></li>
									<li><p><code>static String 	toString(short[] a)</code> -- 同上，<code>[1, 2...]</code></p></li>
									<li><p><code>static String 	toString(float[] a)</code> -- 同上，<code>[1.0, 2.0...]</code></p></li>
									<li><p><code>static String 	toString(double[] a)</code> -- 同上，<code>[1.0, 2.0...]</code></p></li>
									<li><p><code>static String 	toString(Object[] a)</code> -- 同上，<code>[a[0].toString(), a[1].toString()...]</code></p></li>

									<li class="group"><p><code>static void 	parallelSort(byte[] a)</code> -- 并行排序，在多核设备上，当数组容量在 10000 以上的时候，并行排序比较快</p></li>
									<li><p><code>static void 	parallelSort(char[] a)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSort(short[] a)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSort(int[] a)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSort(long[] a)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSort(float[] a)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSort(double[] a)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T extends Comparable&lt;? super T>> void 	parallelSort(T[] a)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T> void 	parallelSort(T[] a, Comparator&lt;? super T> cmp)</code> -- 同上，Java 8</p></li>

									<li class="group"><p><code>static void 	parallelSort(byte[] a, int fromIndex, int toIndex)</code> -- 指定范围并行排序</p></li>
									<li><p><code>static void 	parallelSort(char[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSort(double[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSort(float[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSort(int[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSort(long[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSort(short[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T extends Comparable&lt;? super T>> void 	parallelSort(T[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T> void 	parallelSort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T> cmp)</code> -- 同上，Java 8</p></li>

									<li class="group"><p><code>static void 	parallelPrefix(int[] array, IntBinaryOperator op)</code> -- 使用函数并行地对给定数组中的每个元素进行累积</p>
										<pre class="brush: java;">
	int[] a = {1, 2, 3, 4};
	Arrays.parallelPrefix(a, new IntBinaryOperator() {
	   @Override
	   public int applyAsInt(int left, int right) {
		   log(left, right);
		   return left * right;
	   }
	});
	log(Arrays.toString(a)); // 计算后：a = [1, 2, 6, 24]
	</pre>
									</li>
									<li><p><code>static void 	parallelPrefix(long[] array, LongBinaryOperator op)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelPrefix(double[] array, DoubleBinaryOperator op)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T> void 	parallelPrefix(T[] array, BinaryOperator&lt;T> op)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelPrefix(int[] array, int fromIndex, int toIndex, IntBinaryOperator op)</code> -- 指定范围，Java 8</p></li>
									<li><p><code>static void 	parallelPrefix(long[] array, int fromIndex, int toIndex, LongBinaryOperator op)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelPrefix(double[] array, int fromIndex, int toIndex, DoubleBinaryOperator op)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T> void 	parallelPrefix(T[] array, int fromIndex, int toIndex, BinaryOperator&lt;T> op)</code> -- 同上，Java 8</p></li>


									<li class="group"><p><code>static void 	setAll(int[] array, IntUnaryOperator generator)</code> -- 使用提供的生成器函数计算每个元素</p>
										<pre class="brush: java;">
	int[] a = {1, 2, 3, 4};
	Arrays.setAll(a, new IntUnaryOperator() {
	   @Override
	   public int applyAsInt(int operand) { // operand 为索引
		   return a[operand] * operand;
	   }
	});
	log(Arrays.toString(a)); // 计算后：a = [0, 2, 6, 12]
	</pre>
									</li>
									<li><p><code>static void 	setAll(long[] array, IntToLongFunction generator)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	setAll(double[] array, IntToDoubleFunction generator)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T> void 	setAll(T[] array, IntFunction&lt;? extends T> generator)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSetAll(int[] array, IntUnaryOperator generator)</code> -- 并行计算</p></li>
									<li><p><code>static void 	parallelSetAll(long[] array, IntToLongFunction generator)</code> -- 同上，Java 8</p></li>
									<li><p><code>static void 	parallelSetAll(double[] array, IntToDoubleFunction generator)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T> void 	parallelSetAll(T[] array, IntFunction&lt;? extends T> generator)</code> -- 同上，Java 8</p></li>

									<li class="group"><p><code>static Spliterator.OfInt 	spliterator(int[] array)</code> -- 创建数组的可分割迭代器，<a href="docs/docs-java/api/java/util/Spliterator.html" target="_blank">Spliterator</a> 是为了并行遍历元素而设计的一个迭代器，相对于顺序遍历迭代器 Iterator，Spliterator 一个是并行遍历的迭代器。</p></li>
									<li><p><code>static Spliterator.OfLong 	spliterator(long[] array)</code> -- 同上，Java 8</p></li>
									<li><p><code>static Spliterator.OfDouble 	spliterator(double[] array)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T> Spliterator&lt;T> 	spliterator(T[] array)</code> -- 同上，Java 8</p></li>
									<li><p><code>static Spliterator.OfInt 	spliterator(int[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
									<li><p><code>static Spliterator.OfLong 	spliterator(long[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
									<li><p><code>static Spliterator.OfDouble 	spliterator(double[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T> Spliterator&lt;T> 	spliterator(T[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>

									<li class="group"><p><code>static IntStream 	stream(int[] array)</code> -- <a href="">IntStream</a> 为支持顺序和并行聚合操作的原始值元素序列，参阅 <a href="docs/docs-java/api/java/util/stream/package-summary.html" target="_blank">java.util.stream</a></p></li>
									<li><p><code>static LongStream 	stream(long[] array)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T> Stream&lt;T> 	stream(T[] array)</code> -- 同上，Java 8</p></li>
									<li><p><code>static DoubleStream 	stream(double[] array)</code> -- 同上，Java 8</p></li>
									<li><p><code>static IntStream 	stream(int[] array, int startInclusive, int endExclusive)</code> -- 指定范围</p></li>
									<li><p><code>static LongStream 	stream(long[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
									<li><p><code>static DoubleStream 	stream(double[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
									<li><p><code>static &lt;T> Stream&lt;T> 	stream(T[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
								</ol>

                            </div>

                            <a id="Collections" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/Collections.html" target="_blank">Collections</a> 此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。它包含在 collection 上操作的多态算法，即“包装器”，包装器返回由指定 collection 支持的新 collection，以及少数其他内容。</p>
								<pre class="brush: java;">
public class Collections {
    public static final List EMPTY_LIST = new EmptyList<>();
    public static final Map EMPTY_MAP = new EmptyMap<>();
    public static final Set EMPTY_SET = new EmptySet<>();
}
</pre>
                            	<ol>
									<li class="group"><p><code>static &lt;T> int binarySearch(List&lt;? extends Comparable&lt;? super T>> list, T key)</code> -- 二分搜索法搜索列表返回索引</p></li>
									<li><p><code>static &lt;T> int binarySearch(List&lt;? extends T> list, T key, Comparator&lt;? super T> c)</code> -- 二分搜索法搜索返回索引</p></li>

									<li class="group"><p><code>static &lt;E> List&lt;E> checkedList(List&lt;E> list, Class&lt;E> type)</code> -- 返回一个动态类型安全视图，只能添加固定类型数据</p>
										<pre class="brush: java;">
List list = new ArrayList<>();
list.add("nate");
list.add(2);

List sList = Collections.checkedList(list, String.class); // sList 只能 add(String)
sList.add("1024");
list.add(4);
log(list, sList, list == sList); // list 和 sList 都包括以上 4 项，却不是同一个对象
// sList.add(2); // 插入非 String, 报 ClassCastException
</pre>
                                	</li>
									<li><p><code>static &lt;E> Collection&lt;E> checkedCollection(Collection&lt;E> c, Class&lt;E> type)</code> -- 同上</p></li>
									<li><p><code>static &lt;E> Queue&lt;E> 	checkedQueue(Queue&lt;E> queue, Class&lt;E> type)</code> -- 同上, Java8</p></li>
									<li><p><code>static &lt;E> Set&lt;E> checkedSet(Set&lt;E> s, Class&lt;E> type)</code> -- 同上</p></li>
									<li><p><code>static &lt;E> SortedSet&lt;E> checkedSortedSet(SortedSet&lt;E> s, Class&lt;E> type)</code> -- 同上</p></li>
									<li><p><code>static &lt;E> NavigableSet&lt;E> 	checkedNavigableSet(NavigableSet&lt;E> s, Class&lt;E> type)</code> -- 同上, Java8</p></li>
									<li><p><code>static &lt;K,V> Map&lt;K,V> checkedMap(Map&lt;K,V> m, Class&lt;K> keyType, Class&lt;V> valueType)</code> -- 同上</p></li>
									<li><p><code>static &lt;K,V> SortedMap&lt;K,V> checkedSortedMap(SortedMap&lt;K,V> m, Class&lt;K> keyType, Class&lt;V> valueType)</code> -- 同上</p></li>
									<li><p><code>static &lt;K,V> NavigableMap&lt;K,V> 	checkedNavigableMap(NavigableMap&lt;K,V> m, Class&lt;K> keyType, Class&lt;V> valueType)</code></p></li>

									<li class="group"><p><code>static  &lt;T> Collection&lt;T> synchronizedCollection(Collection&lt;T> c)</code> -- 返回线程安全支持的 Collection</p></li>
									<li><p><code>static &lt;T> List&lt;T> synchronizedList(List&lt;T> list)</code> -- 返回指定线程安全支持的列表，操作加了 <code>synchronized</code></p></li>
									<li><p><code>static &lt;K,V> Map&lt;K,V> synchronizedMap(Map&lt;K,V> m)</code> -- 返回指定线程安全支持的映射</p></li>
									<li><p><code>static &lt;K,V> SortedMap&lt;K,V> synchronizedSortedMap(SortedMap&lt;K,V> m)</code> -- 返回指定线程安全支持的有序映射</p></li>
									<li><p><code>static &lt;K,V> NavigableMap&lt;K,V> 	synchronizedNavigableMap(NavigableMap&lt;K,V> m)</code> -- 线程安全支持的 NavigableMap</p></li>
									<li><p><code>static &lt;T> Set&lt;T> synchronizedSet(Set&lt;T> s)</code> -- 返回指定线程安全支持的set</p></li>
									<li><p><code>static &lt;T> SortedSet&lt;T> synchronizedSortedSet(SortedSet&lt;T> s)</code> -- 返回指定线程安全支持的有序 set</p></li>
									<li><p><code>static &lt;T> NavigableSet&lt;T> 	synchronizedNavigableSet(NavigableSet&lt;T> s)</code> -- 返回指定线程安全支持的 NavigableSet</p></li>


									<li class="group"><p><code>static &lt;T> Collection&lt;T> unmodifiableCollection(Collection&lt;? extends T> c)</code> -- 返回指定 collection 的不可修改视图</p></li>
									<li><p><code>static &lt;T> List&lt;T> unmodifiableList(List&lt;? extends T> list)</code> -- 返回指定列表的不可修改视图</p></li>
									<li><p><code>static &lt;K,V> Map&lt;K,V> unmodifiableMap(Map&lt;? extends K,? extends V> m)</code> -- 返回指定映射的不可修改视图</p></li>
									<li><p><code>static &lt;K,V> SortedMap&lt;K,V> unmodifiableSortedMap(SortedMap&lt;K,? extends V> m)</code> -- 返回指定有序映射的不可修改视图</p></li>
									<li><p><code>static &lt;K,V> NavigableMap&lt;K,V> 	unmodifiableNavigableMap(NavigableMap&lt;K,? extends V> m)</code> -- 不可修改视图</p></li>
									<li><p><code>static &lt;T> Set&lt;T> unmodifiableSet(Set&lt;? extends T> s)</code> -- 返回指定 set 的不可修改视图</p></li>
									<li><p><code>static &lt;T> SortedSet&lt;T> unmodifiableSortedSet(SortedSet&lt;T> s)</code> -- 返回指定有序 set 的不可修改视图</p></li>
									<li><p><code>static &lt;T> NavigableSet&lt;T> 	unmodifiableNavigableSet(NavigableSet&lt;T> s)</code> -- NavigableSet 不可修改视图</p></li>

									<li class="group"><p><code>static &lt;T> List&lt;T> emptyList()</code> -- 返回空的列表</p></li>
									<li><p><code>static &lt;K,V> Map&lt;K,V> emptyMap()</code> -- 返回空的映射</p></li>
									<li><p><code>static &lt;T> Set&lt;T> emptySet()</code> -- 返回空的 set</p></li>
									<li><p><code>static &lt;T> Enumeration&lt;T> 	emptyEnumeration()</code> -- 返回空的 Enumeration, Java8</p></li>
									<li><p><code>static &lt;T> Iterator&lt;T> 	emptyIterator()</code> -- 返回空的 Iterator, Java8</p></li>
									<li><p><code>static &lt;T> ListIterator&lt;T> 	emptyListIterator()</code> -- 返回空的 ListIterator, Java8</p></li>
									<li><p><code>static &lt;E> SortedSet&lt;E> 	emptySortedSet()</code> -- 返回空的 SortedSet, Java8</p></li>
									<li><p><code>static &lt;E> NavigableSet&lt;E> 	emptyNavigableSet()</code> -- 返回空的 NavigableSet, Java8</p></li>
									<li><p><code>static &lt;K,V> SortedMap&lt;K,V> 	emptySortedMap()</code> -- 返回空的 SortedMap, Java8</p></li>
									<li><p><code>static &lt;K,V> NavigableMap&lt;K,V> 	emptyNavigableMap()</code> -- 返回空的 NavigableMap, Java8</p></li>
									<li><p><code>static &lt;T> Set&lt;T> singleton(T o)</code> -- 返回只包含一个指定对象的不可变 set</p></li>
									<li><p><code>static &lt;T> List&lt;T> singletonList(T o)</code> -- 返回只包含一个指定对象的不可变列表</p></li>
									<li><p><code>static &lt;K,V> Map&lt;K,V> singletonMap(K key, V value)</code> -- 返回一个不可变的映射，它只将指定键映射到指定值</p></li>

									<li class="group"><p><code>static &lt;T> void fill(List&lt;? super T> list, T obj)</code> -- 使用指定元素替换指定列表中的所有元素</p></li>
									<li><p><code>static void 	rotate(List&lt;?> list, int distance)</code> -- 根据指定的距离轮换指定列表中的元素</p>
                                    	<pre class="brush: java;">
list = [1, 2, 3, 4];
rotate(list, 1) ==> [4, 1, 2, 3]
rotate(list, 2) ==> [3, 4, 1, 2]
rotate(list, 3) ==> [2, 3, 4, 1]
</pre>
									</li>
									<li><p><code>static void 	shuffle(List&lt;?> list)</code> -- 使用默认随机源对指定列表进行置换(随机打乱顺序)</p></li>
									<li><p><code>static void 	shuffle(List&lt;?> list, Random rnd)</code> -- 使用指定的随机源对指定列表进行置换</p></li>
									<li><p><code>static void 	swap(List&lt;?> list, int i, int j)</code> -- 在指定列表的指定位置处交换元素</p></li>
									<li><p><code>static void 	reverse(List&lt;?> list)</code> -- 反转指定列表中元素的顺序</p></li>
									<li><p><code>static &lt;T> List&lt;T> nCopies(int n, T o)</code> -- 返回由指定对象的 n 个副本组成的不可变列表</p></li>
									<li><p><code>static &lt;T> boolean replaceAll(List&lt;T> list, T oldVal, T newVal)</code> -- 使用另一个值替换列表中出现的所有某一指定值</p></li>
									<li><p><code>static &lt;T> void copy(List&lt;? super T> dest, List&lt;? extends T> src)</code> -- 将所有元素从一个列表复制到另一个列表</p></li>
									<li><p><code>static int 	indexOfSubList(List&lt;?> src, List&lt;?> target)</code> -- 返回指定源列表中第一次出现指定目标列表的起始位置</p></li>
									<li><p><code>static int 	lastIndexOfSubList(List&lt;?> src, List&lt;?> tar)</code> -- 返回指定源列表中最后一次出现指定目标列表的起始位置</p></li>

									<li class="group"><p><code>static &lt;T extends Object & Comparable&lt;? super T>> T max(Collection&lt;? extends T> coll)</code> -- 自然顺序最大元素</p></li>
									<li><p><code>static &lt;T extends Object & Comparable&lt;? super T>> T min(Collection&lt;? extends T> coll)</code> -- 自然顺序最小元素</p></li>
									<li><p><code>static &lt;T> T max(Collection&lt;? extends T> coll, Comparator&lt;? super T> comp)</code> -- 指定比较器的最大元素</p></li>
									<li><p><code>static &lt;T> T min(Collection&lt;? extends T> coll, Comparator&lt;? super T> comp)</code> -- 指定比较器的最小元素</p></li>

									<li class="group"><p><code>static &lt;T extends Comparable&lt;? super T>> void sort(List&lt;T> list)</code> -- 根据元素的自然顺序对指定列表按升序进行排序</p></li>
									<li><p><code>static  &lt;T> void sort(List&lt;T> list, Comparator&lt;? super T> c)</code> -- 根据指定比较器产生的顺序对指定列表进行排序</p></li>
									<li><p><code>static &lt;T> Comparator&lt;T> reverseOrder()</code> -- 返回一个逆转的比较器</p></li>
									<li><p><code>static &lt;T> Comparator&lt;T>  reverseOrder(Comparator&lt;T> cmp)</code> -- 返回一个比较器，它强行逆转指定比较器的顺序</p></li>


									<li class="group"><p><code>static &lt;T> boolean addAll(Collection&lt;? super T> c, T... elements)</code> -- 将所有指定元素添加到指定 collection 中</p></li>
									<li><p><code>static boolean 	disjoint(Collection&lt;?> c1, Collection&lt;?> c2)</code> -- 是否有相同元素</p></li>
									<li><p><code>static int 	frequency(Collection&lt;?> c, Object o)</code> -- 返回指定 collection 中等于指定对象的元素数</p></li>
									<li><p><code>static &lt;T> Queue&lt;T> asLifoQueue(Deque&lt;T> deque)</code> -- 以后进先出 (Lifo) Queue 的形式返回某个 Deque 的视图</p></li>
									<li><p><code>static &lt;E> Set&lt;E> newSetFromMap(Map&lt;E,Boolean> map)</code> -- 返回指定映射支持的 set</p></li>

									<li class="group"><p><code>static &lt;T> Enumeration&lt;T> enumeration(Collection&lt;T> c)</code> -- 返回一个指定 collection 上的枚举</p></li>
									<li><p><code>static &lt;T> ArrayList&lt;T> list(Enumeration&lt;T> e)</code> -- 返回一个数组列表，它按返回顺序包含指定枚举返回的元素</p>
										<pre class="brush: java;">
List list = Arrays.asList(1, 2, 3, 4);
Enumeration e = Collections.enumeration(list);
// ArrayList l2 = Collections.list(e); // 可以将 e 转换回 ArrayList
while(e.hasMoreElements()) { // 遍历元素
    log(e.nextElement());
}
</pre>
									</li>
								</ol>
                            </div>
                        </div>

						<div  class="sub-item">
                            <a id="Iterator" class="offset"></a>
                            <div class="split-item">
                                <p><b>从顶向下分析 Java Collections Framework：</b></p>
								<p><a href="docs/docs-java/api/java/util/Iterator.html" target="_blank">Iterator</a> 对 Collection 进行迭代的迭代器。</p>
								<pre class="brush: java;">
public interface Iterator&lt;E> {
	boolean hasNext(); // 如果仍有元素可以迭代，则返回 true
 	E next(); // 返回迭代的下一个元素

 	default void remove() {} // 从迭代器指向的 Collection 中移除迭代器返回的最后一个元素
	default void forEachRemaining(Consumer&lt;? super E> action) {}
}

/** 一般在容器类内部实现 Iterator 接口，每次 forEach 循环都会调用 iterator() 方法，返回一个新的 Iterator 对象 */
public class MyList&lt;E> implements Iterable&lt;E> {
    private ArrayList&E> innerList = new ArrayList<>(); // 内部一般有一个数组或者其他数据结构用于保存数据

    @Override
    public  Iterator&lt;E> iterator() {
        return new CustomIterator();
    }

	/** 内部实现 Iterator 接口 */
    private class CustomIterator implements Iterator&lt;E> {
        int cursor = 0; // 作为迭代索引使用

        @Override
        public boolean hasNext() {
            boolean hasNext = false;
            if(cursor < innerList.size()) {
                hasNext = true;
            }
            cursor++;
            return hasNext;
        }

        @Override
        public E next() {
            return innerList.get(cursor - 1);
        }
    }
}
</pre>
                            </div>

                            <a id="ListIterator" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/ListIterator.html" target="_blank">ListIterator</a> 列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。</p>
								<p>ListIterator 没有当前元素；它的光标位置 始终位于调用 previous() 所返回的元素和调用 next() 所返回的元素之间。</p>
								<p>List 接口的 <code>listIterator()</code> 方法会返回此接口实现类的实例。</p>
								<ol>
									<li><p><code>int 	nextIndex()</code> -- 返回对 next 的后续调用所返回元素的索引</p></li>

									<li class="group"><p><code>E 	previous()</code> -- 返回列表中的前一个元素</p></li>
									<li><p><code>int 	previousIndex()</code> -- 返回对 previous 的后续调用所返回元素的索引</p></li>
									<li><p><code>boolean 	hasPrevious()</code> -- 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true</p></li>

									<li class="group"><p><code>void 	add(E e)</code> -- 将指定的元素插入列表</p></li>
									<li><p><code>void 	set(E e)</code> -- 用指定元素替换 next 或 previous 返回的最后一个元素</p></li>
								</ol>
                            </div>
                        </div>

                        <div class="sub-item">
                            <a id="Comparable" class="offset"></a>
                            <div class="split-item">
                                <p><code>java.lang.</code><a href="docs/docs-java/api/java/lang/Comparable.html" target="_blank">Comparable</a> 接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。</p>
                                <p><b>实现此接口的对象列表（和数组）可以通过 Collections.sort（和 Arrays.sort）进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</b></p>
                                <p>对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与 e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。注意，null 不是任何类的实例，即使 e.equals(null) 返回 false，e.compareTo(null) 也将抛出 NullPointerException。</p>
                                <pre class="brush: java;">
public interface Comparable&lt;T> {
    int compareTo(T o); // 如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数
}
</pre>
                            </div>
                        </div>

                        <div  class="sub-item">
                            <a id="Comparator" class="offset"></a>
                            <div class="split-item">
                                <p><a href="docs/docs-java/api/java/util/Comparator.html" target="_blank">Comparator</a> 是比较器，提供强行对某个对象 collection 进行整体排序 的比较函数。</p>
                                <p>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。</p>
                                <p>还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p>
                                <p>当且仅当对于一组元素 S 中的每个 e1 和 e2 而言，c.compare(e1, e2)==0 与 e1.equals(e2) 具有相等的布尔值时，Comparator c 强行对 S 进行的排序才叫做与 equals 一致 的排序。</p>
                                <p>通常来说，让 Comparator 也实现 java.io.Serializable 是一个好主意，因为它们在可序列化的数据结构（像 TreeSet、TreeMap）中可用作排序方法。为了成功地序列化数据结构，Comparator（如果已提供）必须实现 Serializable。</p>
                                <ol>
                                    <li><p><code>int 	compare(T o1, T o2)</code> -- 比较用来排序的两个参数</p></li>
                                    <li><p><code>boolean 	equals(Object obj)</code> -- 指示某个其他对象是否“等于”此 Comparator</p></li>

                                    <li class="group"><p><code>default Comparator&lt;T> 	reversed()</code> -- 当前比较器反转，返回 <code>Collections.reverseOrder(this)</code></p></li>


                                    <li class="group"><p><code>static &lt;T extends Comparable&lt;? super T>> Comparator&lt;T> 	naturalOrder()</code> -- 自然排序</p>
										<pre class="brush: java;">
public static &lt;T extends Comparable&lt;? super T>> Comparator&lt;T> naturalOrder() {
	// Comparators 只具有包可访问性
	return (Comparator&lt;T>) Comparators.NaturalOrderComparator.INSTANCE;
}
</pre>
									</li>
                                    <li><p><code>static &lt;T extends Comparable&lt;? super T>> Comparator&lt;T> 	reverseOrder()</code> -- 反自然排序</p>
										<pre class="brush: java;">
public static &lt;T extends Comparable&lt;? super T>> Comparator&lt;T> reverseOrder() {
	return Collections.reverseOrder();
}
</pre>
									</li>
                                    <li><p><code>static &lt;T> Comparator&lt;T> 	nullsFirst(Comparator&lt;? super T> comparator)</code> -- 返回一个NULL友好的比较器，它认为NULL小于非NULL。当两者都为空时，它们被认为是相等的。如果两者均为非空，则使用指定比较器来确定顺序。如果指定的比较器为NULL，则返回的比较器将所有非空值视为相等。</p></li>
                                    <li><p><code>static &lt;T> Comparator&lt;T> 	nullsLast(Comparator&lt;? super T> comparator)</code> -- 返回一个NULL友好的比较器，它认为NULL大于非NULL。当两者都为空时，它们被认为是相等的。如果两者均为非空，则使用指定比较器来确定顺序。如果指定的比较器为NULL，则返回的比较器将所有非空值视为相等。</p></li>

                                    <li class="group"><p><code>static &lt;T> Comparator&lt;T> 	comparingInt(ToIntFunction&lt;? super T> keyExtractor)</code> -- 返回 int 比较器的比较过程</p>
										<pre class="brush: java;">
ArrayList&lt;Integer> list = new ArrayList<>();
list.add(2);
list.add(6);
list.add(4);
list.add(6);

// 强行认为 4 是最大的
Comparator&lt;Integer> comparator = Comparator.comparingInt(value -> {
	if(value == 4) {
		return Integer.MAX_VALUE;
	}
	return value;
});
list.sort(comparator); // 2,6,6,4
</pre>
									</li>
                                    <li><p><code>static &lt;T> Comparator&lt;T> 	comparingLong(ToLongFunction&lt;? super T> keyExtractor)</code> --  返回 long 比较器的比较过程</p></li>
                                    <li><p><code>static &lt;T> Comparator&lt;T> 	comparingDouble(ToDoubleFunction&lt;? super T> ext)</code> --  返回 double 比较器的比较过程</p></li>
                                    <li><p><code>static &lt;T,U extends Comparable&lt;? super U>> Comparator&lt;T> 	comparing(Function&lt;? super T,? extends U> ext)</code> -- 传入参数 T, 返回 U 类型的比较器</p>
										<pre class="brush: java;">
ArrayList&lt;String> list = new ArrayList<>();
list.add("a");
list.add("ccc");
list.add("bb");

Comparator&lt;String> comparator = Comparator.comparing(s -> s.length());
list.sort(comparator);
</pre>
									</li>
                                    <li><p><code>static &lt;T,U> Comparator&lt;T> 	comparing(Function&lt;? super T,? extends U> ext, Comparator&lt;? super U> ext)</code> -- 参见以下实例</p>
										<pre class="brush: java;">
ArrayList&lt;String> list = new ArrayList<>();
list.add("a");
list.add("ccc");
list.add("bb");


// 第一个 Fuction 函数传入参数 T, 返回 U 类型的比较器，第二个比较器比较 U
Comparator&lt;String> comparator = Comparator.comparing(s -> s.length(), (o1, o2) -> o2.compareTo(o1));
list.sort(comparator); //  ccc, bb, a
										</pre>
									</li>

                                    <li class="group"><p><code>default Comparator&lt;T> 	thenComparingInt(ToIntFunction&lt;? super T> keyExtractor)</code> -- 参照 <code>comparingInt(ToIntFunction)</code> 和 <code>thenComparing(Comparator)</code></p></li>
                                    <li><p><code>default Comparator&lt;T> 	thenComparingLong(ToLongFunction&lt;? super T> keyExtractor)</code> -- 参照 <code>comparingLong(ToLongFunction)</code> 和 <code>thenComparing(Comparator)</code></p></li>
                                    <li><p><code>default Comparator&lt;T> 	thenComparingDouble(ToDoubleFunction&lt;? super T> keyExtractor)</code> -- 参照 <code>comparingDouble(ToDoubleFunction)</code> 和 <code>thenComparing(Comparator)</code></p></li>
                                    <li><p><code>default Comparator&lt;T> 	thenComparing(Comparator&lt;? super T> other)</code> -- 参照 <code>comparingInt(ToIntFunction)</code>, 只有在当前对象的 compare 方法返回 0 时才执行 other</p></li>
									<li><p><code>default &lt;U extends Comparable&lt;? super U>> Comparator&lt;T> 	thenComparing(Function&lt;? super T,? extends U> keyExtractor)</code> -- 参照 <code>comparing(Function)</code> 和 <code>thenComparing(Comparator)</code></p></li>
									<li><p><code>default &lt;U> Comparator&lt;T> 	thenComparing(Function&lt;? super T,? extends U> keyExtractor, Comparator&lt;? super U> keyComparator)</code> -- 参照 <code>comparing(Function, Comparator)</code> 和 <code>thenComparing(Comparator)</code></p></li>

                                </ol>
                            </div>

                            <a id="Collator" class="offset"></a>
                            <div class="split-item">
                                <p><a href="docs/docs-java/api/java/text/Collator.html" target="_blank">Collator</a> 类执行区分语言环境的 String 比较。使用此类可为自然语言文本构建搜索和排序例程。</p>
                                <p>Collator 是一个抽象基类。其子类实现具体的整理策略。Java 平台目前提供了 RuleBasedCollator 子类，它适用于很多种语言。还可以创建其他子类，以处理更多的专门需要。 </p>
                                <p>与其他区分语言环境的类一样，可以使用静态工厂方法 getInstance 来为给定的语言环境获得适当的 Collator 对象。如果需要理解特定整理策略的细节或者需要修改策略，只需查看 Collator 的子类即可。 </p>
                                <pre class="brush: java;">
public abstract class Collator implements Comparator&lt;Object>, Cloneable {
    /** 以下为 Collator 的 strength 值 */
    public final static int PRIMARY = 0;
    public final static int SECONDARY = 1;
    public final static int TERTIARY = 2;
    public final static int IDENTICAL = 3;

    /** 以下为 Decomposition 模式值 */
    public final static int NO_DECOMPOSITION = 0;
    public final static int CANONICAL_DECOMPOSITION = 1;
    public final static int FULL_DECOMPOSITION = 2;

    protected Collator() {} // 受保护的构造方法
}
</pre>
                                <ol>
                                    <li><p><code>static Collator 	getInstance()</code> -- 获取当前默认语言环境的 Collator</p></li>
                                    <li><p><code>static Collator 	getInstance(Locale desiredLocale)</code> -- 获取所需语言环境的 Collator</p></li>
                                    <li><p><code>static Locale[] 	getAvailableLocales()</code> -- 回一个所有受支持语言环境的数组</p></li>

                                    <li class="group"><p><code>abstract int 	compare(String source, String target)</code> -- 根据此 Collator 的整理规则来比较源字符串和目标字符串</p></li>
                                    <li><p><code>abstract CollationKey 	getCollationKey(String src)</code> -- 将 src 转换为可以和其他 CollationKey 按位进行比较的位</p></li>
                                    <li><p><code>abstract int 	hashCode()</code> -- 生成此 Collator 的哈希码</p></li>

                                    <li class="group"><p><code>int 	getDecomposition()</code> -- 获取此 Collator 的 decomposition 模式</p></li>
                                    <li><p><code>int 	getStrength()</code> -- 返回此 Collator 的 strength 属性</p></li>
                                    <li><p><code>void 	setDecomposition(int decompositionMode)</code> -- 设置此 Collator 的 decomposition 模式</p></li>
                                    <li><p><code>void 	setStrength(int newStrength)</code> -- 设置此 Collator 的 strength 属性</p></li>

                                    <li class="group"><p><code>int 	compare(Object o1, Object o2)</code> -- 比较此方法两个参数的顺序</p></li>
                                    <li><p><code>Object 	clone()</code> -- 重写 Cloneable</p></li>
                                    <li><p><code>boolean 	equals(Object that)</code> -- 比较两个 Collator 的相等性</p></li>
                                    <li><p><code>boolean 	equals(String source, String target)</code> -- 根据此 Collator 的整理规则比较两个字符串是否相等的便捷方法</p></li>
                                </ol>
                            </div>

                            <a id="RuleBasedCollator" class="offset"></a>
                            <div class="split-item">
                                <p><a href="docs/docs-java/api/java/text/RuleBasedCollator.html" target="_blank">RuleBasedCollator</a> 是 Collator 的具体子类，它提供了一个简单的、数据驱动的表 collator。可以通过此类来创建基于表的自定义 Collator。 </p>
                                <p>RuleBasedCollator 将字符映射到排序键。为了提高效率，对 RuleBasedCollator 做了如下限制（其他子类可以用于更复杂的语言）： </p>
                                <ul>
                                    <li><p>如果指定了由 "modif" 控制的特殊整理规则，则它将用于整个 Collator 对象；</p></li>
                                    <li><p>所有未指定的字符位于整理顺序的末尾</p></li>
                                </ul>
                                <pre class="brush: java;">
public class RuleBasedCollator extends Collator {

    public RuleBasedCollator(String rules) {}
}
</pre>
                                <ol>
                                    <li><p><code>int 	compare(String source, String target)</code> -- 根据表规则比较存储在两个不同字符串中的字符数据</p></li>
                                    <li><p><code>CollationKey 	getCollationKey(String source)</code> -- 将字符串转换为能够与 CollationKey.compareTo 进行比较的一系列字符</p></li>
                                    <li><p><code>int 	hashCode()</code> -- 生成基于表的 collation 对象的哈希码</p></li>

                                    <li class="group"><p><code>String 	getRules()</code> -- 获取 collation 对象的基于表的规则</p></li>
                                    <li><p><code>CollationElementIterator 	getCollationElementIterator(CharacterIterator source)</code> -- 返回给定 String 的 CollationElementIterator</p></li>
                                    <li><p><code>CollationElementIterator 	getCollationElementIterator(String source)</code> -- 返回给定 String 的 CollationElementIterator</p></li>

                                    <li class="group"><p><code>Object 	clone()</code> -- 标准重写，无语义变化</p></li>
                                    <li><p><code>boolean 	equals(Object obj)</code> -- 比较两个 collation 对象的相等性</p></li>
                                </ol>
                            </div>
                        </div>

                        <div class="sub-item">
                            <a id="Iterable" class="offset"></a>
                            <div class="split-item">
								<p><code>java.lang.</code><a href="docs/docs-java/api/java/lang/Iterable.html" target="_blank">Iterable</a> 实现这个接口允许对象成为 "forEach" 语句的目标。</p>
								<pre class="brush: java;">
public interface Iterable&lt;T> {
	Iterator&lt;T> iterator(); // 返回一个在一组 T 类型的元素上进行迭代的迭代器

	default void forEach(Consumer&lt;? super T> action) {}
	default Spliterator&lt;T> spliterator() {}
}

/** 自定义一个 CustomList(并未实现 List 接口), 允许添加和移除数据，并能迭代其数据 */
public class CustomList&lt;E> implements Iterable&lt;E> {
    // 演示直接使用 ArrayList, 可以仿照 ArrayList 使用数组来实现
    private ArrayList&lt;E> innerList = new ArrayList<>();

    public void add(E e) {
        innerList.add(e);
    }

    public void remove(E e) {
        innerList.remove(e);
    }

    @Override
    public  Iterator&lt;E> iterator() {
        return new CustomIterator();
    }

    /** 内部实现 Iterator 接口 */
    private class CustomIterator implements Iterator&lt;E> {
        int cursor = 0; // 作为迭代索引使用

        @Override
        public boolean hasNext() {
            boolean hasNext = false;
            if(cursor < innerList.size()) {
                hasNext = true;
            }
            cursor++;
            return hasNext;
        }

        @Override
        public E next() {
            return innerList.get(cursor - 1);
        }
    }
}

/** 使用自定义的 CustomList(并未实现 List 接口，没有 size() 方法) */
CustomList&lt;String> list = new CustomList<>();
list.add("1001");
list.add("1002");
list.add("1003");
list.remove("1002");
for (String s : list) { // 这里其实生成了一个新的 CustomIterator 对象
    log(s); // 1001， 1002
}

Iterator&lt;String> iterator  = list.iterator(); // 生成一个新的 CustomIterator 对象
while(iterator.hasNext()) {
    log(iterator.next()); // 1001， 1002
}
</pre>
                            </div>

                            <a id="Collection" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/Collection.html" target="_blank">Collection</a> 表示一组对象，这些对象也称为 Collection 的元素。一些 Collection 允许有重复的元素，而另一些则不允许。一些 Collection 是有序的，而另一些则是无序的。</p>
                                <p>所有通用的 Collection 实现类（通常通过它的一个子接口间接实现 Collection）应该提供两个“标准”构造方法：一个是 void（无参数）构造方法，用于创建空 collection；另一个是带有 Collection 类型单参数的构造方法，用于创建一个具有与其参数相同元素新的 collection。实际上，后者允许用户复制任何 collection，以生成所需实现类型的一个等效 collection。尽管无法强制执行此约定（因为接口不能包含构造方法），但是 Java 平台库中所有通用的 Collection 实现都遵从它。 </p>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 确保此 collection 包含指定的元素</p></li>
									<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 将指定 collection 中的所有元素都添加到此 collection 中</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 从此 collection 中移除指定元素的单个实例，如果存在的话</p></li>
									<li><p><code>default boolean 	removeIf(Predicate&lt;? super E> filter)</code> -- </p></li>
									<li><p><code>boolean 	removeAll(Collection&lt;?> c)</code> -- 移除此 collection 中那些也包含在指定 collection 中的所有元素</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此 collection 的元素上进行迭代的迭代器</p></li>
									<li><p><code>default Spliterator&lt;E> 	spliterator()</code> -- 拆分迭代器(多线程迭代)</p></li>

									<li class="group"><p><code>boolean 	contains(Object o)</code> -- 如果此 collection 包含指定的元素，则返回 true</p></li>
									<li><p><code>boolean 	containsAll(Collection&lt;?> c)</code> -- 如果此 collection 包含指定 c 中的所有元素，则返回 true</p></li>
									<li><p><code>int 	size()</code> -- 返回此 collection 中的元素数</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 如果此 collection 不包含元素，则返回 true</p></li>
									<li><p><code>void 	clear()</code> -- 移除此 collection 中的所有元素</p></li>
									<li><p><code>boolean 	retainAll(Collection&lt;?> c)</code> -- 仅保留此 collection 中那些也包含在指定 collection 的元素</p></li>

									<li class="group"><p><code>int 	hashCode()</code> -- 返回此 collection 的哈希码值</p></li>
									<li><p><code>boolean 	equals(Object o)</code> -- 比较此 collection 与指定对象是否相等。</p></li>
									<li><p><code>Object[] 	toArray()</code> -- 返回包含此 collection 中所有元素的数组</p></li>
									<li><p><code>&lt;T>T[] toArray(T[] a)</code> -- 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同</p></li>

									<li class="group"><p><code>default Stream&lt;E> 	stream()</code> -- 返回一个以该集合作为源的序列流</p></li>
									<li><p><code>default Stream&lt;E> 	parallelStream()</code> -- 返回一个可能的并行流，这个集合作为其源</p></li>

								</ol>
                            </div>

                            <a id="List" class="offset"></a>
                            <div class="split-item">
                                <p><a href="docs/docs-java/api/java/util/List.html" target="_blank">List</a> 是有序的序列,可以对列表中每个元素的插入位置进行精确地控制,根据元素的整数索引访问元素，并搜索列表中的元素。</p>
								<p>与 set 不同，列表通常允许重复的元素。更确切地讲，列表通常允许满足 <code>e1.equals(e2)</code> 的元素对 e1 和 e2，并且如果列表本身允许 null 元素的话，通常它们允许多个 null 元素。</p>
                                <p>List 接口提供了特殊的迭代器，称为 ListIterator，除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法来获取从列表中指定位置开始的列表迭代器。</p>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 添加元素到末尾</p></li>
									<li><p><code>void 	add(int index, E element)</code> -- 在列表的指定位置插入指定元素</p></li>
									<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 添加指定 collection 中的所有元素元素到末尾</p></li>
									<li><p><code>boolean 	addAll(int index, Collection&lt;? extends E> c)</code> -- 添加指定 collection 中的所有元素到此列表的结尾</p></li>
									<li><p><code>E 	remove(int index)</code> -- 移除列表中指定位置的元素</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 移除指定元素</p></li>
									<li><p><code>boolean 	removeAll(Collection&lt;?> c)</code> -- 移除在 c 中的所有元素</p></li>

									<li class="group"><p><code>E 	get(int index)</code> -- 返回列表中指定位置的元素</p></li>
									<li><p><code>E 	set(int index, E element)</code> -- 用指定元素替换列表中指定位置的元素</p></li>
									<li><p><code>int 	indexOf(Object o)</code> -- 返回此列表中第一次出现的指定元素的索引</p></li>
									<li><p><code>int 	lastIndexOf(Object o)</code> -- 返回此列表中最后出现的指定元素的索引</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 迭代器</p></li>
									<li><p><code>ListIterator&lt;E> 	listIterator()</code> -- 返回此列表元素的列表迭代器（按适当顺序）</p></li>
									<li><p><code>ListIterator&lt;E> 	listIterator(int index)</code> -- 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始</p></li>
									<li><p><code>default Spliterator&lt;E> 	spliterator()</code> -- 拆分迭代器</p></li>

									<li class="group"><p><code>void 	clear()</code> -- 清除所有元素</p></li>
									<li><p><code>int 	size()</code> -- 元素数目</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 是否为空</p></li>
									<li><p><code>List&lt;E> 	subList(int from, int to)</code> -- 返回列表中指定的 from（包括 ）和 to（不包括）之间的部分视图</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 是否包含 o 元素</p></li>
									<li><p><code>boolean 	containsAll(Collection&lt;?> c)</code> -- 是否包含 c 中的所有元素</p></li>

									<li class="group"><p><code>default void 	replaceAll(UnaryOperator&lt;E> operator)</code> -- 替换符合条件的所有元素，UnaryOperator 的 <code>E apply(E)</code> 方法返回值即为替换后的值</p></li>
									<li><p><code>boolean 	retainAll(Collection&lt;?> c)</code> -- 仅保留此 collection 中那些也包含在指定 c 的元素</p></li>
									<li><p><code>default void 	sort(Comparator&lt;? super E> c)</code> -- 根据比较器排序</p></li>

									<li class="group"><p><code>boolean 	equals(Object o)</code> -- 是否相等</p></li>
									<li><p><code>int 	hashCode()</code> -- 哈希值</p></li>
									<li><p><code>Object[] 	toArray()</code> -- 返回一个包含所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同</p></li>
								</ol>
                            </div>

                            <a id="Queue" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/Queue.html" target="_blank">Queue</a> 在处理元素前用于保存元素的 collection。除了基本的 Collection 操作外，队列还提供其他的插入、提取和检查操作。每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是用于专门为有容量限制的 Queue 实现设计的；在大多数实现中，插入操作不会失败。 </p>
								<p>队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。不过优先级队列和 LIFO 队列（或堆栈）例外，前者根据提供的比较器或元素的自然顺序对元素进行排序，后者按 LIFO（后进先出）的方式对元素进行排序。无论使用哪种排序方式，队列的头 都是调用 remove() 或 poll() 所移除的元素。在 FIFO 队列中，所有的新元素都插入队列的末尾。其他种类的队列可能使用不同的元素放置规则。每个 Queue 实现必须指定其顺序属性。 </p>
								<p>Queue 接口并未定义阻塞队列的方法，而这在并发编程中是很常见的。BlockingQueue 接口定义了那些等待元素出现或等待队列中有可用空间的方法，这些方法扩展了此接口。 </p>
                                <p>Queue 实现通常不允许插入 null 元素，尽管某些实现（如 LinkedList）并不禁止插入 null。即使在允许 null 的实现中，也不应该将 null 插入到 Queue 中，因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素。 </p>
                                <p>Queue 实现通常未定义 equals 和 hashCode 方法的基于元素的版本，而是从 Object 类继承了基于身份的版本，因为对于具有相同元素但有不同排序属性的队列而言，基于元素的相等性并非总是定义良好的。 </p>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException</p></li>
									<li><p><code>boolean 	offer(E e)</code> -- 将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常</p></li>
									<li class="group"><p><code>E 	peek()</code> -- 获取但不移除此队列的头；如果此队列为空，则返回 null</p></li>
									<li><p><code>E 	element()</code> -- 获取但不移除此队列的头，与 peek 唯一的不同在于：此队列为空时将抛出一个异常</p></li>
									<li><p><code>E 	poll()</code> --  获取并移除此队列的头，如果此队列为空，则返回 null</p></li>
									<li><p><code>E 	remove()</code> -- 获取并移除此队列的头，与 poll 唯一的不同在于：此队列为空时将抛出一个异常</p></li>
								</ol>
                            </div>

                            <a id="Deque" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/Deque.html" target="_blank">Deque</a> 一个线性 collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。 </p>
								<p>此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 Deque 实现设计的；在大多数实现中，插入操作不能失败。 </p>
								<p>注意，在将双端队列用作队列或堆栈时，peek 方法同样正常工作；无论哪种情况下，都从双端队列的开头抽取元素。 </p>
								<ol>
									<li><p><code>void 	addFirst(E e)</code> -- 将指定元素插入此双端队列的开头</p></li>
									<li><p><code>void 	addLast(E e)</code> -- 将指定元素插入此双端队列的末尾</p></li>
									<li><p><code>E 	getFirst()</code> -- 获取但不移除此双端队列的第一个元素</p></li>
									<li><p><code>E 	getLast()</code> -- 获取但不移除此双端队列的最后一个元素</p></li>
									<li><p><code>boolean 	offerFirst(E e)</code> -- 将指定的元素插入此双端队列的开头</p></li>
									<li><p><code>boolean 	offerLast(E e)</code> -- 在不违反容量限制的情况下，将指定的元素插入此双端队列的末尾</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 返回以恰当顺序在此双端队列的元素上进行迭代的迭代器</p></li>
									<li><p><code>Iterator&lt;E> 	descendingIterator()</code> -- 返回以逆向顺序在此双端队列的元素上进行迭代的迭代器</p></li>

									<li class="group"><p><code>E 	peekFirst()</code> -- 获取但不移除此双端队列的第一个元素</p></li>
									<li><p><code>E 	peekLast()</code> -- 获取但不移除此双端队列的最后一个元素</p></li>
									<li><p><code>E 	pollFirst()</code> -- 获取并移除此双端队列的第一个元素</p></li>
									<li><p><code>E 	pollLast()</code> -- 获取并移除此双端队列的最后一个元素</p></li>

									<li class="group"><p><code>E 	pop()</code> -- 从此双端队列所表示的堆栈中弹出一个元素</p></li>
									<li><p><code>void 	push(E e)</code> -- 将一个元素推入此双端队列所表示的堆栈</p></li>

									<li class="group"><p><code>boolean 	remove(Object o)</code> -- 从此双端队列中移除第一次出现的指定元素</p></li>
									<li><p><code>E 	removeFirst()</code> -- 获取并移除此双端队列第一个元素</p></li>
									<li><p><code>E 	removeLast()</code> -- 获取并移除此双端队列的最后一个元素</p></li>
									<li><p><code>boolean 	removeFirstOccurrence(Object o)</code> -- 从此双端队列移除第一次出现的指定元素</p></li>
									<li><p><code>boolean 	removeLastOccurrence(Object o)</code> -- 从此双端队列移除最后一次出现的指定元素</p></li>
								</ol>
                            </div>

                            <a id="BlockingQueue" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/concurrent/BlockingQueue.html" target="_blank">BlockingQueue</a> 支持两个附加操作的 Queue，这两个操作是：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用。 </p>
								<p>其方法以四种形式出现，对于不能立即满足但可能在将来某一时刻可以满足的操作，这四种形式的处理方式不同：</p>
								<ol>
									<li><p>第一种是抛出一个异常；</p></li>
									<li><p>第二种是返回一个特殊值（null 或 false，具体取决于操作）;</p></li>
									<li><p>第三种是在操作可以成功前，无限期地阻塞当前线程；</p></li>
									<li><p>第四种是在放弃前只在给定的最大时间限制内阻塞。</p></li>
								</ol>
								<p>BlockingQueue 实现主要用于生产者-使用者队列，但它另外还支持 Collection 接口。</p>
								<p>BlockingQueue 实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。</p>
								<ol>
									<li><p><code>E 	take()</code> -- 获取并移除此队列的头部，在元素变得可用之前一直等待</p></li>
									<li><p><code>void 	put(E e)</code> -- 将指定元素插入此队列中，将等待可用的空间</p></li>
									<li><p><code>boolean 	offer(E e, long timeout, TimeUnit unit)</code> -- 将指定元素插入此队列中，在到达指定的等待时间前等待可用的空间</p></li>
									<li><p><code>E 	poll(long timeout, TimeUnit unit)</code> -- 获取并移除此队列的头部，在指定的等待时间前等待可用的元素</p></li>
									<li class="group"><p><code>int 	drainTo(Collectio&lt;? super E> c)</code> -- 移除此队列中所有可用的元素，并将它们添加到给定 collection 中</p></li>
									<li><p><code>int 	drainTo(Collection&lt;? super E> c, int maxElements)</code> -- 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</p></li>
									<li><p><code>int 	remainingCapacity()</code> -- 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的附加元素数量</p></li>
								</ol>
                            </div>

                            <a id="TransferQueue" class="offset"></a>
                            <div class="split-item">
                                <p><a href="docs/docs-java/api/java/util/concurrent/TransferQueue.html" target="_blank">TransferQueue</a> 一个阻塞队列，其中生产者可以等待消费者接收元素。</p>
                                <p>传递队列可能是有用的，例如在消息传递应用程序中，生产者有时（使用方法转移（e））等待由消费者调用接收或轮询的元素接收，而在其他时间排队队列元素（通过方法放置）而不等待接收。</p>
                                <p>像其他阻塞队列一样，TransferQueue可能是容量受限的。如果是这样，尝试的传输操作可能最初阻止等待可用空间，或随后等待用户接收。</p>
                                <ol>
                                    <li><p><code>int 	getWaitingConsumerCount()</code> -- 获取正在等待的消费者数量</p></li>
                                    <li><p><code>boolean 	hasWaitingConsumer()</code> -- 是否有正在等待的消费者</p></li>
                                    <li><p><code>void 	transfer(E e)</code> -- 将元素传递给消费者，如果需要的话则等待</p></li>
                                    <li><p><code>boolean 	tryTransfer(E e)</code> -- 如果可能的话，立即将元素传递给等待的消费者</p></li>
                                    <li><p><code>boolean 	tryTransfer(E e, long timeout, TimeUnit unit)</code> -- 在超时时间到达前，将元素传递给等待的消费者</p></li>
                                </ol>
                            </div>

                            <a id="BlockingDeque" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/concurrent/BlockingDeque.html" target="_blank">BlockingDeque</a> 支持两个附加操作的 Queue，这两个操作是：获取元素时等待双端队列变为非空；存储元素时等待双端队列中的空间变得可用。 </p>
								<p>像所有 BlockingQueue 一样，BlockingDeque 是线程安全的，只是它支持双端操作。</p>
								<ol>
									<li><p><code>boolean 	offerFirst(E e, long timeout, TimeUnit unit)</code> -- 将指定的元素插入此双端队列的开头，必要时将在指定的等待时间内等待可用空间</p></li>
									<li><p><code>boolean 	offerLast(E e, long timeout, TimeUnit unit)</code> -- 将指定的元素插入此双端队列的末尾，必要时将在指定的等待时间内等待可用空间</p></li>
									<li><p><code>E pollFirst(long timeout, TimeUnit unit)</code> -- 获取并移除此双端队列的第一个元素，必要时将在指定的等待时间等待可用元素</p></li>
									<li><p><code>E 	pollLast(long timeout, TimeUnit unit)</code> -- 获取并移除此双端队列的最后一个元素，必要时将在指定的等待时间内等待可用元素</p></li>
									<li><p><code>void 	putFirst(E e)</code> -- 将指定的元素插入此双端队列的开头，必要时将一直等待可用空间</p></li>
									<li><p><code>void 	putLast(E e)</code> -- 将指定的元素插入此双端队列的末尾，必要时将一直等待可用空间</p></li>
									<li><p><code>E 	takeFirst()</code> -- 获取并移除此双端队列的第一个元素，必要时将一直等待可用元素</p></li>
									<li><p><code>E 	takeLast()</code> -- 获取并移除此双端队列的最后一个元素，必要时将一直等待可用元素</p></li>
								</ol>
                            </div>

                            <a id="Set" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/Set.html" target="_blank">Set</a> 一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。</p>
								<p>注：如果将可变对象用作 set 元素，那么必须极其小心。如果对象是 set 中某个元素，以一种影响 equals 比较的方式改变对象的值，那么 set 的行为就是不确定的。此项禁止的一个特殊情况是不允许某个 set 包含其自身作为元素。 </p>
								<p>Set 的方法都是从 Collection 继承的。</p>
							</div>

							<a id="SortedSet" class="offset"></a>
							<div class="split-item">
								<p><a href="docs/docs-java/api/java/util/SortedSet.html" target="_blank">SortedSet</a> 进一步提供关于元素的总体排序 的 Set。这些元素使用其自然顺序进行排序，或者根据通常在创建有序 set 时提供的 Comparator 进行排序。该 set 的迭代器将按元素升序遍历 set。提供了一些附加的操作来利用这种排序。</p>
								<p>插入有序 set 的所有元素都必须实现 Comparable 接口（或者被指定的比较器所接受）。另外，所有这些元素都必须是可互相比较的：对于有序 set 中的任意两个元素 e1 和 e2，执行 e1.compareTo(e2)（或 comparator.compare(e1, e2)）都不得抛出 ClassCastException。试图违反此限制将导致违反规则的方法或者构造方法调用抛出 ClassCastException。 </p>
								<p>所有通用有序 set 实现类都应该提供 4 个“标准”构造方法：</p>
									<ul><li><p>1) void（无参数）构造方法，它创建一个空的有序 set，按照元素的自然顺序进行排序；</p></li>
										<li><p>2) 带有一个 Comparator 类型参数的构造方法，它创建一个空的有序 set，根据指定的比较器进行排序；</p></li>
										<li><p>3) 带有一个 Collection 类型参数的构造方法，它创建一个新的有序 set，其元素与参数相同，按照元素的自然顺序进行排序；</p></li>
										<li><p>4) 带有一个 SortedSet 类型参数的构造方法，它创建一个新的有序 set，其元素和排序方法与输入的有序 set 相同。无法保证强制实施此建议，因为接口不能包含构造方法。 </p>
									</ul>
								<ol>
									<li><p><code>E 	first()</code> -- 返回此 set 中当前第一个（最低）元素</p></li>
									<li><p><code>E 	last()</code> -- 返回此 set 中当前最后一个（最高）元素</p></li>
									<li><p><code>SortedSet&lt;E> 	headSet(E toElement)</code> -- 返回此 set 的部分视图，其元素严格小于 toElement</p></li>
									<li><p><code>SortedSet&lt;E> 	tailSet(E fromElement)</code> -- 返回此 set 的部分视图，其元素大于等于 fromElement</p></li>
									<li><p><code>SortedSet&lt;E> 	subSet(E fromElement, E toElement)</code> -- 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）</p></li>
									<li><p><code>Comparator&lt;? super E></code> -- 返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null</p></li>
								</ol>
							</div>

							<a id="NavigableSet" class="offset"></a>
							<div class="split-item">
								<p><a href="docs/docs-java/api/java/util/NavigableSet.html" target="_blank">NavigableSet</a> 扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法。</p>
								<p>方法 lower、floor、ceiling 和 higher 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null。可以按升序或降序访问和遍历 NavigableSet。descendingSet 方法返回 set 的一个视图，该视图表示的所有关系方法和方向方法都是逆向的。升序操作和视图的性能很可能比降序操作和视图的性能要好。此外，此接口还定义了 pollFirst 和 pollLast 方法，它们返回并移除最小和最大的元素（如果存在），否则返回 null。subSet、headSet 和 tailSet 方法与名称相似的 SortedSet 方法的不同之处在于：可以接受用于描述是否包括（或不包括）下边界和上边界的附加参数。任何 NavigableSet 的 Submap 必须实现 NavigableSet 接口。</p>
								<ol>
									<li><p><code>E 	ceiling(E e)</code> -- 返回此 set 中大于等于给定元素的最小元素</p></li>
									<li><p><code>E 	floor(E e)</code> -- 返回此 set 中小于等于给定元素的最大元素</p></li>
									<li><p><code>E 	higher(E e)</code> -- 返回此 set 中严格大于给定元素的最小元素</p></li>
									<li><p><code>E 	lower(E e)</code> -- 返回此 set 中严格小于给定元素的最大元素</p></li>
									<li><p><code>E 	pollFirst()</code> -- 获取并移除第一个（最低）元素</p></li>
									<li><p><code>E 	pollLast()</code> -- 获取并移除最后一个（最高）元素</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	descendingIterator()</code> -- 以降序返回在此 set 的元素上进行迭代的迭代器</p></li>
									<li><p><code>NavigableSet&lt;E> 	descendingSet()</code> -- 返回此 set 中所包含元素的逆序视图</p></li>

									<li class="group"><p><code>NavigableSet&lt;E> 	headSet(E toElement, boolean inclusive)</code> -- </p></li>
									<li><p><code>NavigableSet&lt;E> 	subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)</code> -- 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement</p></li>
									<li><p><code>NavigableSet&lt;E> 	tailSet(E fromElement, boolean inclusive)</code> -- 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement</p></li>
								</ol>
                            </div>
                        </div>

                        <div class="sub-item">
                            <a id="Map" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/Map.html" target="_blank">Map</a> 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 </p>
								<p>Map 接口提供三种 Collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。</p>
								<p>注：将可变对象用作映射键时必须格外小心。当对象是映射中某个键时，如果以影响 equals 比较的方式更改了对象的值，则映射的行为将是不确定的。此项禁止的一种特殊情况是不允许某个映射将自身作为一个键包含。虽然允许某个映射将自身作为值包含，但请格外小心：在这样的映射上 equals 和 hashCode 方法的定义将不再是明确的。 </p>
								<pre class="brush: java;">
public interface Map&lt;K, V> {
	interface Entry&lt;K,V> {
		boolean equals(Object o); // 比较指定对象与此项的相等性
 		K getKey(); // 返回与此项对应的键
 		V getValue(); // 返回与此项对应的值
 		int hashCode(); // 返回此映射项的哈希码值
 		V setValue(V value); // 用指定的值替换与此项对应的值

		static &lt;K extends Comparable&lt;? super K>,V> Comparator&lt;Map.Entry&lt;K,V>> comparingByKey() {}
		static &lt;K,V> Comparator&lt;Map.Entry&lt;K,V>> comparingByKey(Comparator&lt;? super K> cmp) {}
		static &lt;K,V extends Comparable&lt;? super V>> Comparator&lt;Map.Entry&lt;K,V>> comparingByValue() {}
		static &lt;K,V> Comparator&lt;Map.Entry&lt;K,V>> comparingByValue(Comparator&lt;? super V> cmp) {}
	}
}
</pre>
								<ol>
									<li><p><code>V put(K key, V value)</code> -- 将指定的值与此映射中的指定键关联</p></li>
									<li><p><code>void 	putAll(Map&lt;? extends K,? extends V> m)</code> -- 将 m 中的键值添加到此映射</p></li>
									<li><p><code>V get(Object key)</code> -- 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null</p></li>
									<li><p><code>boolean isEmpty()</code> -- 如果此映射未包含键-值映射关系，则返回 true</p></li>
									<li><p><code>int size()</code> -- 返回此映射中的键-值映射关系数</p></li>
									<li><p><code>V remove(Object key)</code> -- 如果存在一个键的映射关系，则将其从此映射中移除</p></li>
									<li><p><code>void clear()</code> -- 从此映射中移除所有映射关系</p></li>

									<li class="group"><p><code>boolean containsKey(Object key)</code> -- 如果此映射包含指定键的映射关系，则返回 true</p></li>
									<li><p><code>Set&lt;K> keySet()</code> -- 返回此映射中包含的键的 Set 视图</p></li>
									<li><p><code>boolean containsValue(Object value)</code> -- 如果此映射将一个或多个键映射到指定值，则返回 true</p></li>
									<li><p><code>Set&lt;Map.Entry&lt;K,V>> entrySet()</code> --  返回此映射中包含的映射关系的 Set 视图</p></li>
									<li><p><code>void putAll(Map&lt;? extends K,? extends V> m)</code> -- 从指定映射中将所有映射关系复制到此映射中</p></li>
									<li><p><code>Collection&lt;V> values()</code> -- 返回此映射中包含的值的 Collection 视图</p></li>

									<li class="group"><p><code>boolean 	equals(Object o)</code> -- 比较元素是否相等</p></li>
									<li><p><code>int 	hashCode()</code> -- 哈希码</p></li>

									<li class="group"><p><code>default V 	compute(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- 替换，添加或删除，与 key 和 BiFunction 的返回值有关</p></li>
									<li><p><code>default V 	computeIfAbsent(K key, Function&lt;? super K,? extends V> mappingFunction)</code> -- 如果 key 不存在于 map 中，并且返回值不为 null, 则相当于 put(key, 返回值)；如果 key 存在于 map 中，并且其值不为 null，不执行回调，返回其值；如果 key 存在于 map 中，并且其值为 null，则执行替换</p></li>
									<li><p><code>default V 	computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- key 存在于 map 中，并其值不为 null, 才会执行回调，返回值不为 null，则替换；返回值为 null, 则删除</p></li>

									<li class="group"><p><code>default void 	forEach(BiConsumer&lt;? super K,? super V> action)</code> -- 迭代键值</p></li>
									<li><p><code>default V 	getOrDefault(Object key, V defaultValue)</code> -- 获取指定 key 的值，如果不存在返回默认值</p></li>
									<li><p><code>default V 	merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V> remappingFunction)</code> -- 替换或添加，可用判断 value 的情况进行操作</p></li>


									<li class="group"><p><code>default V 	putIfAbsent(K key, V value)</code> -- 如果指定的 key 已经在 map 中，并且其值不为 null，返回原有的 value；否则同 put(K, V)，并返回 null</p></li>
									<li><p><code>default boolean 	remove(Object key, Object value)</code> -- 如果存在指定键和值，则移除此键值对</p></li>
									<li><p><code>default V 	replace(K key, V value)</code> -- 替换指定键的值</p></li>
									<li><p><code>default boolean 	replace(K key, V oldValue, V newValue)</code> --  如果存在指定的键和值，则将值替换为指定值</p></li>
									<li><p><code>default void 	replaceAll(BiFunction&lt;? super K,? super V,? extends V> function)</code> -- 使用 BiFunction 替换</p></li>
								</ol>
                            </div>

                            <a id="SortedMap" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/SortedMap.html" target="_blank">SortedMap</a> 进一步提供关于键的总体排序 的 Map。该映射是根据其键的自然顺序进行排序的，或者根据通常在创建有序映射时提供的 Comparator 进行排序。对有序映射的 collection 视图（由 entrySet、keySet 和 values 方法返回）进行迭代时，此顺序就会反映出来。要采用此排序方式，还需要提供一些其他操作（此接口是 SortedSet 的对应映射）。</p>
								<p>插入有序映射的所有键都必须实现 Comparable 接口（或者被指定的比较器接受）。另外，所有这些键都必须是可互相比较的：对有序映射中的任意两个键 k1 和 k2 执行 k1.compareTo(k2)（或 comparator.compare(k1, k2)）都不得抛出 ClassCastException。试图违反此限制将导致违反规则的方法或者构造方法调用抛出 ClassCastException。 </p>
								<ol>
									<li><p><code>K 	firstKey()</code> -- 返回此映射中当前第一个（最低）键</p></li>
									<li><p><code>K 	lastKey()</code> -- 返回映射中当前最后一个（最高）键</p></li>

									<li class="group"><p><code>SortedMap&lt;K, V> 	headMap(K toKey)</code> -- 返回此映射的部分视图，其键值严格小于 toKey</p></li>
									<li><p><code>SortedMap&lt;K, V> 	subMap(K fromKey, K toKey)</code> -- 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）</p></li>
									<li><p><code>SortedMap&lt;K, V> 	tailMap(K fromKey)</code> -- 返回此映射的部分视图，其键大于等于 fromKey</p></li>

									<li class="group"><p><code>Comparator&lt;? super K> 	comparator()</code> -- 返回对此映射中的键进行排序的比较器；</p></li>
								</ol>
                            </div>

                            <a id="NavigableMap" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/NavigableMap.html" target="_blank">NavigableMap</a> 扩展的 SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法。</p>
								<p>方法 lowerEntry、floorEntry、ceilingEntry 和 higherEntry 分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象，如果不存在这样的键，则返回 null。类似地，方法 lowerKey、floorKey、ceilingKey 和 higherKey 只返回关联的键。所有这些方法是为查找条目而不是遍历条目而设计的。 </p>
								<ol>
									<li><p><code>K 	ceilingKey(K key)</code> -- 返回大于等于给定键的最小键</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	ceilingEntry(K key)</code> -- 返回一个键-值映射关系，它与大于等于给定键的最小键关联</p></li>
									<li><p><code>K 	floorKey(K key</code> -- 返回小于等于给定键的最大键</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	floorEntry(K key)</code> -- 返回一个键-值映射关系，它与小于等于给定键的最大键关联</p></li>
									<li><p><code>K 	higherKey(K key)</code> -- 返回严格大于给定键的最小键</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	higherEntry(K key)</code> -- 返回一个键-值映射关系，它与严格大于给定键的最小键关联</p></li>
									<li><p><code>K 	lowerKey(K key)</code> -- 返回严格小于给定键的最大键</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	lowerEntry(K key)</code> -- 返回一个键-值映射关系</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	firstEntry()</code> -- 返回一个与此映射中的最小键关联的键-值映射关系</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	lastEntry()</code> -- 返回与此映射中的最大键关联的键-值映射关系</p></li>

									<li class="group"><p><code>Map.Entry&lt;K,V> 	pollFirstEntry()</code> -- 移除并返回与此映射中的最小键关联的键-值映射关系</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	pollLastEntry()</code> -- 移除并返回与此映射中的最大键关联的键-值映射关系</p></li>

									<li class="group"><p><code>NavigableSet&lt;K> 	descendingKeySet()</code> -- 返回此映射中所包含键的逆序 NavigableSet 视图</p></li>
									<li><p><code>NavigableSet&lt;K> 	navigableKeySet()</code> -- 返回此映射中所包含键的 NavigableSet 视图</p></li>
									<li><p><code>NavigableMap&lt;K,V> 	descendingMap()</code> -- 返回此映射中所包含映射关系的逆序视图</p></li>

									<li class="group"><p><code>NavigableMap&lt;K,V> 	headMap(K toKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey</p></li>
									<li><p><code>NavigableMap&lt;K,V> 	subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</code> -- 返回此映射的部分视图，其键的范围从 fromKey 到 toKey</p></li>
									<li><p><code>NavigableMap&lt;K,V> 	tailMap(K fromKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey</p></li>
								</ol>
                            </div>

                            <a id="ConcurrentMap" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/concurrent/ConcurrentMap.html" target="_blank">ConcurrentMap</a> 提供其他原子 putIfAbsent、remove、replace 方法的 Map。</p>
								<ol>
									<li><p><code>V 	putIfAbsent(K key, V value)</code> -- 如果指定键已经不再与某个值相关联，则将它与给定值关联。</p></li>
									<li><p><code>boolean 	remove(Object key, Object value)</code> -- 只有目前将键的条目映射到给定值时，才移除该键的条目。</p></li>
									<li><p><code>V 	replace(K key, V value)</code> -- 只有目前将键的条目映射到某一值时，才替换该键的条目。</p></li>
									<li><p><code>boolean 	replace(K key, V oldValue, V newValue)</code> -- 只有目前将键的条目映射到给定值时，才替换该键的条目。</p></li>
								</ol>
                            </div>

                            <a id="ConcurrentNavigableMap" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/concurrent/ConcurrentNavigableMap.html" target="_blank">ConcurrentNavigableMap</a> 支持 NavigableMap 操作，且以递归方式支持其可导航子映射的 ConcurrentMap。</p>
								<ol>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	headMap(K toKey)</code> -- 返回此映射的部分视图，其键值严格小于 toKey。</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	headMap(K toKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</code> -- 返回此映射的部分视图，其键的范围从 fromKey 到 toKey。</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	subMap(K fromKey, K toKey)</code> -- 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	tailMap(K fromKey)</code> -- 返回此映射的部分视图，其键大于等于 fromKey。</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	tailMap(K fromKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。</p></li>

									<li class="group"><p><code>NavigableSet&lt;K> 	keySet()</code> -- 返回此映射中所包含键的 NavigableSet 视图。</p></li>
									<li><p><code>NavigableSet&lt;K> 	navigableKeySet()</code> -- 返回此映射中所包含键的 NavigableSet 视图。</p></li>

									<li class="group"><p><code>NavigableSet&lt;K> 	descendingKeySet()</code> -- 返回此映射中所包含键的逆序 NavigableSet 视图。</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	descendingMap()</code> -- 返回此映射中所包含映射关系的逆序视图。</p></li>
								</ol>
                            </div>
						</div>

                        <div class="sub-item">
                            <a id="AbstractCollection" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/AbstractCollection.html" target="_blank">AbstractCollection</a> 此类提供 Collection 接口的骨干实现，以最大限度地减少了实现此接口所需的工作。 </p>
								<pre class="brush: java;">
public abstract class AbstractCollection&lt;E> implements Collection&lt;E> {
    public abstract Iterator&lt;E> iterator();
    public abstract int size();
}
</pre>
								<ul>
									<li><p>要实现一个不可修改的 collection，只需扩展此类，并提供 <code>iterator()</code> 和 <code>size()</code> 方法的实现。</p></li>
									<li><p>要实现可修改的 collection，必须另外重写此类的 <code>add(E)</code> 方法（否则，会抛出 UnsupportedOperationException），iterator 方法返回的迭代器还必须另外实现其 <code>remove()</code> 方法。</p></li>
									<li><p>按照 Collection 接口规范中的建议，通常应提供一个 void （无参数）和 Collection 构造方法。</p></li>
								</ul>
                            </div>
                        </div>

                        <div class="sub-item">
                            <a id="AbstractList" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/AbstractList.html" target="_blank">AbstractList</a> 此类提供 List 接口的骨干实现，以最大限度地减少实现“随机访问”数据存储（如数组）支持的该接口所需的工作。对于连续的访问数据（如链表），应优先使用 AbstractSequentialList，而不是此类。  </p>
								<pre class="brush: java;">
/** 实现了 AbstractCollection 的 iterator() 方法，但未实现 size() 方法 */
public abstract class AbstractList&lt;E> extends AbstractCollection&lt;E> implements List&lt;E> {
    abstract public E get(int index);
}
</pre>
								<ul>
									<li><p>要实现不可修改的列表，只需扩展此类，并提供 <code>get(int)</code> 和 <code>size()</code> 方法的实现；</p></li>
									<li><p>要实现可修改的列表，必须另外重写 <code>set(int, E)</code> 方法（否则将抛出 UnsupportedOperationException）。如果列表为可变大小，则必须另外重写 <code>add(int, E)</code> 和 <code>remove(int)</code> 方法； </p></li>
									<li><p>按照 Collection 接口规范中的建议，通常应该提供一个 void（无参数）和 collection 构造方法。</p></li>
								</ul>
                            </div>

                            <a id="ArrayList" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/ArrayList.html" target="_blank">ArrayList</a> 是 List 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。</p>
								<p>每个 ArrayList 实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。并未指定增长策略的细节，因为这不只是添加元素会带来分摊固定时间开销那样简单。</p>
								<p>在添加大量元素前，应用程序可以使用 <code>ensureCapacity(int)</code> 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</p>
								<p>ArrayList 内部有一个 <code>transient Object[] elementData;</code> 数组，针对 ArrayList 的操作都是操作此数组。当数组长度不够时，调用 <code>elementData = Arrays.copyOf(elementData, newCapacity);</code> 方法，创建一个新的数组，并复制原有数组的数据到新的数组。</p>
								<pre class="brush: java;">
public class ArrayList&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess,
                                Cloneable, java.io.Serializable {
    public ArrayList() {}
    public ArrayList(Collection&lt;? extends E> c) {}
    public ArrayList(int initialCapacity) {} // 构造一个具有指定初始容量的空列表
}
</pre>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 将指定的元素添加到此列表的尾部</p></li>
									<li><p><code>void 	add(int index, E element)</code> -- 将指定的元素插入此列表中的指定位置</p></li>
									<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 按 collection 的迭代器顺序，将所有元素添加到此列表的尾部</p></li>
									<li><p><code>boolean 	addAll(int index, Collection&lt;? extends E> c)</code> -- 从指定的位置将 collection 中所有元素插入到此列表中</p></li>

									<li class="group"><p><code>E 	remove(int index)</code> -- 移除此列表中指定位置上的元素</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 移除此列表中首次出现的指定元素</p></li>
									<li><p><code>protected  void 	removeRange(int from, int to)</code> -- 移除索引在 from（包括）和 to（不包括）之间的所有元素</p></li>
									<li><p><code>void 	clear()</code> -- 移除此列表中的所有元素</p></li>

									<li class="group"><p><code>E 	set(int index, E element)</code> -- 用指定的元素替代此列表中指定位置上的元素</p></li>
									<li><p><code>E 	get(int index)</code> -- 返回此列表中指定位置上的元素。</p></li>

									<li class="group"><p><code>int 	indexOf(Object o)</code> -- 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。</p></li>
									<li><p><code>int 	lastIndexOf(Object o)</code> -- 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。</p></li>
									<li><p><code>boolean 	contains(Object o)</code> --  如果此列表中包含指定的元素，则返回 true。</p></li>

									<li class="group"><p><code>void 	ensureCapacity(int minCapacity)</code> -- 如有必要，增加此 ArrayList 实例的容量</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 如果此列表中没有元素，则返回 true</p></li>
									<li><p><code>int 	size()</code> -- 返回此列表中的元素数</p></li>
									<li><p><code>void 	trimToSize()</code> -- 将此 ArrayList 实例的容量调整为列表的当前大小</p></li>
									<li><p><code>Object 	clone()</code> -- 返回此 ArrayList 实例的浅表副本</p></li>

									<li class="group"><p><code>void 	forEach(Consumer&lt;? super E> action)</code> -- 和 <code>for</code> 循环一样</p></li>
									<li><p><code>Iterator&lt;E> 	iterator()</code> -- 返回迭代器</p></li>
									<li><p><code>ListIterator&lt;E> 	listIterator()</code> -- 返回 ListIterator 迭代器</p></li>
									<li><p><code>ListIterator&lt;E> 	listIterator(int index)</code> -- 返回指定索引开始的 ListIterator 迭代器</p></li>
									<li><p><code>boolean 	removeAll(Collection&lt;?> c)</code> -- 移除在 c 中的元素</p></li>
									<li><p><code>boolean 	removeIf(Predicate&lt;? super E> filter)</code> -- 移除所有符合条件项</p>
									<pre class="brush: java;">
ArrayList&lt;Integer> a1 = new ArrayList<>();
Collections.addAll(a1, 1, 2, 3, 4);
a1.removeIf(filter -> filter % 2 == 0); // 移除了偶数，a1 = [1, 3]
</pre>
									</li>
									<li><p><code>void 	replaceAll(UnaryOperator&lt;E> operator)</code> -- 替换所有符合条件项</p>
										<pre class="brush: java;">
ArrayList&lt;nteger> a1 = new ArrayList<>();
Collections.addAll(a1, 1, 2, 3, 4);
a1.replaceAll(operator -> operator % 2 == 0 ? operator * operator : operator); // a1 = [1, 4, 3, 16]
</pre>
									</li>
									<li><p><code>boolean 	retainAll(Collection&lt;?> c)</code> -- 仅保留那些也包含在 c 的元素</p></li>
									<li><p><code>void 	sort(Comparator&lt;? super E> c)</code> -- 指定比较器排序</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 返回可分割迭代器，用于并行迭代</p></li>
									<li><p><code>List&lt;E> 	subList(int fromIndex, int toIndex)</code> -- 返回在 from（包括）和 to（不包括）子列表</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] toArray(T[] a)</code> -- 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组</p></li>

								</ol>
                            </div>

                            <a id="AbstractSequentialList" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/AbstractSequentialList.html" target="_blank">AbstractSequentialList</a> 此类提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作。对于随机访问数据（如数组），应该优先使用 AbstractList，而不是先使用此类。</p>
								<pre class="brush: java;">
public abstract class AbstractSequentialList&lt;E> extends AbstractList&lt;E> {
    public abstract ListIterator listIterator(int index);
}
</pre>
								<ul>
									<li><p>对于不可修改的列表，程序员只需要实现列表迭代器的 <code>hasNext</code>、<code>next</code>、<code>hasPrevious</code>、<code>previous</code> 和 <code>index</code> 方法即可；</p></li>
									<li><p>对于可修改的列表，程序员应该再另外实现列表迭代器的 <code>set</code> 方法。对于可变大小的列表，程序员应该再另外实现列表迭代器的 <code>remove</code> 和 <code>add</code> 方法。</p></li>
								</ul>
                            </div>

                            <a id="LinkedList" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/LinkedList.html" target="_blank">LinkedList</a> 是 List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p>
								<p>此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。</p>
								<p>所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表。</p>
								<pre class="brush: java;">
public class LinkedList&lt;E> extends AbstractSequentialList&lt;E> implements List&lt;E>, Deque&lt;E>,
                                Cloneable, Serializable {
    public LinkedList() {}
    public LinkedList(Collection&lt;? extends E> c) {}

    transient int size = 0;
    transient Node&lt;E> first; // 始终指向第一个元素
    transient Node&lt;E> last; // 始终指向最后一个元素

    /** 包装数据，一个指针指向前一个节点，一个指针指向下一个节点 */
    private static class Node&lt;E> {
        E item; // 真实数据值
        Node&lt;E> next; // 指向下一个元素
        Node&lt;E> prev; // 指向前一个元素

        Node(Node&lt;E> prev, E element, Node&lt;E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
}
</pre>
								<div class="panel panel-default">
									<div class="panel-heading">
										<a data-toggle="collapse" data-parent="#accordion"
										   href="#java-util-LinkedList-example" aria-expanded="true"
										   class="code-header">
											<span class="glyphicon glyphicon-plus"></span> View Code - Sample
										</a>
									</div>
									<div id="java-util-LinkedList-example" class="panel-collapse collapse"
										 style="" aria-expanded="true">
								<pre class="brush: java;">
/** 一个简单的链表，只有 add(E), size(), get(Int) 方法 */
public class MyLink&lt;E> {
    private Node&lt;E> first;
    private Node&lt;E> last;
    private int size;

    public void add(E v) {
        final Node&lt;E> l = last;
        final Node&lt;E> newNode = new Node<>(l, v, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
    }

    public int size() {
        return size;
    }

    private Node&lt;E> node(int index) {
        if (index < (size >> 1)) { // 从 first 到 last 搜索
            Node&lt;E> x = first;
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else { // 从 last 到 first 搜索
            Node&lt;E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.pre;
            return x;
        }
    }

    public E get(int index) {
        if(index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        return node(index).value;
    }

    class Node&lt;E> {
        Node pre;
        Node next;
        E value;

        public Node(Node&lt;E> prev, E element,  Node&lt;E> next) {
            this.value = element;
            this.next = next;
            this.pre = prev;
        }
    }
}
</pre>
                                </div>
                            </div>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 将指定元素添加到此列表的结尾</p></li>
									<li><p><code>void 	addFirst(E e)</code> -- 将指定元素插入此列表的开头</p></li>
									<li><p><code>void 	addLast(E e)</code> -- 将指定元素添加到此列表的结尾</p></li>
									<li><p><code>void 	add(int index, E element)</code> -- 在此列表中指定的位置插入指定的元素</p></li>
									<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 添加指定 collection 中的所有元素到此列表的结尾</p></li>
									<li><p><code>boolean 	addAll(int index, Collection&lt;? extends E> c)</code> -- 将指定 collection 中的所有元素从指定位置开始插入此列表</p></li>

									<li class="group"><p><code>boolean 	offer(E e)</code> -- 调用 <code>add(E)</code></p></li>
									<li><p><code>boolean 	offerFirst(E e)</code> -- 调用 <code>addFirst(E)</code></p></li>
									<li><p><code>boolean 	offerLast(E e)</code> -- 调用 <code>addLast(E)</code></p></li>

									<li class="group"><p><code>E 	get(int index)</code> -- 返回此列表中指定位置处的元素</p></li>
									<li><p><code>int 	size()</code> -- 返回此列表的元素数</p></li>
									<li><p><code>E 	set(int index, E element)</code> -- 将此列表中指定位置的元素替换为指定的元。</p></li>
									<li><p><code>E 	getFirst()</code> -- 返回此列表的第一个元素，无则抛出异常</p></li>
									<li><p><code>E 	getLast()</code> -- 返回此列表的最后一个元素，无则抛出异常</p></li>
									<li><p><code>E 	element()</code> -- 调用 <code>getFirst()</code></p></li>
									<li><p><code>int 	indexOf(Object o)</code> -- 返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1</p></li>
									<li><p><code>int 	lastIndexOf(Object o)</code> -- 返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1</p></li>

									<li class="group"><p><code>E 	peek()</code> -- 获取但不移除此列表的头（第一个元素）；如果此列表为空，则返回 null</p></li>
									<li><p><code>E 	peekFirst()</code> -- 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null</p></li>
									<li><p><code>E 	peekLast()</code> -- 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null</p></li>

									<li class="group"><p><code>E 	remove(int index)</code> -- 移除此列表中指定位置处的元素</p></li>
									<li><p><code>void 	clear()</code> -- 从此列表中移除所有元素</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 从此列表中移除首次出现的指定元素（如果存在）</p></li>
									<li><p><code>E 	removeFirst()</code> -- 移除并返回此列表的第一个元素，无则抛出异常</p></li>
									<li><p><code>E 	removeLast()</code> -- 移除并返回此列表的最后一个元素，无则抛出异常</p></li>
									<li><p><code>E 	remove()</code> -- 调用 <code>removeFirst()</code></p></li>
									<li><p><code>boolean 	removeFirstOccurrence(Object o)</code> -- 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）</p></li>
									<li><p><code>boolean 	removeLastOccurrence(Object o)</code> -- 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）</p></li>

									<li class="group"><p><code>E 	poll()</code> -- 获取并移除此列表的头；如果此列表为空，则返回 null。</p></li>
									<li><p><code>E 	pollFirst()</code> -- 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。</p></li>
									<li><p><code>E 	pollLast()</code> -- 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。</p></li>

									<li class="group"><p><code>E 	pop()</code> -- 调用 <code>removeFirst()</code></p></li>
									<li><p><code>void 	push(E e)</code> -- 调用 <code>addFirst(E)</code></p></li>


									<li class="group"><p><code>Object 	clone()</code> -- 返回此 LinkedList 的浅表副本</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此列表包含指定元素，则返回 true</p></li>
									<li><p><code>Iterator&lt;E> 	descendingIterator()</code> -- 返回以逆向顺序在此双端队列的元素上进行迭代的迭代器</p></li>
									<li><p><code>ListIterator&lt;E> 	listIterator(int index)</code> -- 返回此列表中的元素的列表迭代器（按适当顺序），从列表中指定位置开始</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 返回可分割迭代器，用于并行迭代</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] toArray(T[] a)</code> -- 返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组；返回数组的运行时类型为指定数组的类型</p></li>
								</ol>
                            </div>

                            <a id="Vector" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/Vector.html" target="_blank">Vector</a> 类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。但是，Vector 的大小可以根据需要增大或缩小，以适应创建 Vector 后进行添加或移除项的操作。 </p>
								<p>每个向量会试图通过维护 capacity 和 capacityIncrement 来优化存储管理。capacity 始终至少应与向量的大小相等；这个值通常比后者大些，因为随着将组件添加到向量中，其存储将按 capacityIncrement 的大小增加存储块。应用程序可以在插入大量组件前增加向量的容量；这样就减少了增加的重分配的量。</p>
								<p>Vector 和 ArrayList 最大区别是: <b>Vector 是线程安全的</b>，Vector 类对集合的元素操作时都加了 <code>synchronized</code>，保证线程安全。</p>
								<pre class="brush: java;">
public class Vector&lt;E> extends AbstractList&lt;E> implements List&lt;E>,
                                RandomAccess, Cloneable, Serializable {
    protected  int capacityIncrement; // 向量的大小大于其容量时，容量自动增加的量
    protected  int 	elementCount; // Vector 对象中的有效组件数
    protected  Object[] elementData; // 存储向量组件的数组缓冲区。

    public Vector() {}
    public Vector(Collection&lt;? extends E> c) {}
    public Vector(int initialCapacity) {} // 使用指定的初始容量和等于零的容量增量构造一个空向量
    public Vector(int initialCapacity, int capacityIncrement) {} // 使用指定的初始容量和容量增量构造一个空的向量
}
</pre>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 将指定元素添加到此向量的末尾</p></li>
									<li><p><code>void 	addElement(E obj)</code> -- 同 <code>add(E)</code>, 无返回值</p></li>
									<li><p><code>void 	add(int index, E element)</code> -- 在此向量的指定位置插入指定的元素</p></li>
									<li><p><code>void 	insertElementAt(E obj, int index)</code> -- 同 <code>add(E, int)，无返回值</code></p></li>
									<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 将指定 Collection 中的所有元素添加到此向量的末尾</p></li>
									<li><p><code>boolean 	addAll(int index, Collection&lt;? extends E> c)</code> -- 在指定位置将指定 Collection 中的所有元素插入到此向量中</p></li>

									<li class="group"><p><code>E 	get(int index)</code> -- 返回向量中指定位置的元素</p></li>
									<li><p><code>E 	elementAt(int index)</code> -- 同 <code>get(int)</code></p></li>
									<li><p><code>E 	firstElement()</code> -- 返回此向量的第一个组件（位于索引 0) 处的项）</p></li>
									<li><p><code>E 	lastElement()</code> -- 返回此向量的最后一个组件</p></li>
									<li><p><code>List&lt;E> 	subList(int from, int to)</code> -- 返回此 List 的部分视图，元素范围为从 from（包括）到 to（不包括）</p></li>

									<li class="group"><p><code>E 	set(int index, E element)</code> -- 用指定的元素替换此向量中指定位置处的元素，并返回被替换的元素</p></li>
									<li><p><code>void 	setElementAt(E obj, int index)</code> -- 将此向量指定 index 处的组件设置为指定的对象</p></li>

									<li class="group"><p><code>E 	remove(int index)</code> -- 移除此向量中指定位置的元素，返回被移除的元素</p></li>
									<li><p><code>void 	removeElementAt(int index)</code> -- 删除指定索引处的组件</p></li>
									<li><p><code>boolean 	removeElement(Object obj)</code> -- 从此向量中移除变量的第一个（索引最小的）匹配项</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 调用 <code>removeElement(Object)</code></p></li>
									<li><p><code>protected  void 	removeRange(int from, int to)</code> -- 移除其索引位于 from（包括）与 to（不包括）之间的所有元素</p></li>
									<li><p><code>boolean 	removeAll(Collection&lt;?> c)</code> -- 从此向量中移除包含在指定 Collection 中的所有元素</p></li>
									<li><p><code>void 	removeAllElements()</code> -- 从此向量中移除全部组件(将数组元素全部置为 null)，并将其大小设置为零</p></li>
									<li><p><code>void 	clear()</code> -- 调用 <code>removeAllElements()</code></p></li>

									<li class="group"><p><code>int 	capacity()</code> -- 返回此向量的当前容量</p></li>
									<li><p><code>int 	size()</code> -- 返回此向量中的组件数</p></li>
									<li><p><code>void 	setSize(int newSize)</code> -- 设置此向量的大小</p></li>
									<li><p><code>void 	ensureCapacity(int minCapacity)</code> -- 增加此向量的容量，以确保其至少能够保存最小容量参数指定的组件数</p></li>
									<li><p><code>void 	trimToSize()</code> -- 对此向量的容量进行微调，使其等于向量的当前大小</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 测试此向量是否不包含组件</p></li>

									<li class="group"><p><code>boolean 	contains(Object o)</code> -- 如果此向量包含指定的元素，则返回 true</p></li>
									<li><p><code>boolean 	containsAll(Collection&lt;?> c)</code> -- 如果此向量包含指定 Collection 中的所有元素，则返回 true</p></li>
									<li><p><code>int 	indexOf(Object o)</code> -- 返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1</p></li>
									<li><p><code>int 	indexOf(Object o, int index)</code> -- 返回此向量中第一次出现的指定元素的索引，从 index 处正向搜索</p></li>
									<li><p><code>int 	lastIndexOf(Object o)</code> -- 返回此向量中最后一次出现的指定元素的索引；如果此向量不包含该元素，则返回 -1</p></li>
									<li><p><code>int 	lastIndexOf(Object o, int index)</code> -- 返回此向量中最后一次出现的指定元素的索引，从 index 处逆向搜索</p></li>

									<li class="group"><p><code>boolean 	retainAll(Collection&lt;?> c)</code> -- 在此向量中仅保留包含在指定 Collection 中的元素</p></li>
									<li><p><code>Enumeration&lt;E> 	elements()</code> -- 返回此向量的组件的枚举</p></li>

									<li class="group"><p><code>void 	copyInto(Object[] anArray)</code> -- 将此向量的组件复制到指定的数组中</p></li>
									<li><p><code>Object[] 	toArray()</code> -- 返回一个数组，包含此向量中以恰当顺序存放的所有元素</p></li>
									<li><p><code>&lt;T> T[] toArray(T[] a)</code> -- 返回一个数组，包含此向量中以恰当顺序存放的所有元素；返回数组的运行时类型为指定数组的类型</p></li>

									<li class="group"><p><code>Object 	clone()</code> -- 返回向量的一个副本</p></li>
									<li><p><code>boolean 	equals(Object o)</code> -- 比较指定对象与此向量的相等性</p></li>
									<li><p><code>String 	toString()</code> -- 返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式</p></li>
									<li><p><code>int 	hashCode()</code> -- 返回此向量的哈希码值</p></li>

									<li class="group"><p><code>void 	forEach(Consumer&lt;? super E> action)</code> -- 参照 <code>ArrayList</code></p></li>
									<li><p><code>Iterator&lt;E> 	iterator()</code> -- 参照 <code>ArrayList</code></p></li>
									<li><p><code>ListIterator&lt;E> 	listIterator()</code> -- 参照 <code>ArrayList</code></p></li>
									<li><p><code>ListIterator&lt;E> 	listIterator(int index)</code> -- 参照 <code>ArrayList</code></p></li>
									<li><p><code>boolean 	removeIf(Predicate&lt;? super E> filter)</code> -- 参照 <code>ArrayList</code></p></li>
									<li><p><code>void 	replaceAll(UnaryOperator&lt;E> operator)</code> -- 参照 <code>ArrayList</code></p></li>
									<li><p><code>void 	sort(Comparator&lt;? super E> c)</code> -- 参照 <code>ArrayList</code></p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 参照 <code>ArrayList</code></p></li>
								</ol>
                            </div>

                            <a id="Stack" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/Stack.html" target="_blank">Stack</a> 类表示后进先出（LIFO）的对象堆栈，是线程安全的。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。它提供了通常的 push 和 pop 操作，以及取堆栈顶点的 peek 方法、测试堆栈是否为空的 empty 方法、在堆栈中查找项并确定到堆栈顶距离的 search 方法。 </p>
								<p>Deque 接口及其实现提供了 LIFO 堆栈操作的更完整和更一致的 set，应该优先使用此 set，而非此类。</p>
								<pre class="brush: java;">
public class Stack&lt;E> extends Vector&lt;E> {
    public Stack() {}
}
</pre>
								<ol>
									<li><p><code>boolean 	empty()</code> -- 同 <code>isEmpty()</code></p></li>
									<li><p><code>E 	peek()</code> -- 同 <code>lastElement()</code>，抛出的异常不同</p></li>
									<li><p><code>E 	pop()</code> -- 先调用 <code>peek()</code>, 再移除最后一个元素</p></li>
									<li><p><code>E 	push(E item)</code> -- 调用 <code>addElement(E)</code>, 返回 item</p></li>
									<li><p><code>int 	search(Object o)</code> -- 从 1 开始，从后面往前数, 如: <code>["aa", "bb"], search("aa") == 2</code></p></li>
								</ol>
                            </div>

                        </div>

                        <div class="sub-item">
                            <a id="CopyOnWriteArrayList" class="offset"></a>
                            <div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/CopyOnWriteArrayList.html" target="_blank">CopyOnWriteArrayList</a> 是 ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 </p>
								<p>这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时，它也很有用。</p>
								<p><b>使用 CopyOnWriteArrayList 可以线程安全地遍历，因为如果另外一个线程在遍历的时候修改 List 的话，实际上会拷贝出一个新的 List上 修改，而不影响当前正在被遍历的 List。这一点和 Vector 是不同的，Vector 会等待遍历完成再修改，使用了同步关键字。</b></p>
								<pre class="brush: java;">
public class CopyOnWriteArrayList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, Serializable {
    public CopyOnWriteArrayList() {}
    public CopyOnWriteArrayList(Collection&lt;? extends E> c) {}
    public CopyOnWriteArrayList(E[] toCopyIn) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 将指定元素添加到此列表的尾部</p></li>
									<li><p><code>boolean 	addIfAbsent(E e)</code> -- 添加元素（如果不存在）</p></li>
									<li><p><code>void 	add(int index, E element)</code> -- 在此列表的指定位置上插入指定元素</p></li>
									<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 将指定 collection 中的所有元素添加此列表的尾部</p></li>
									<li><p><code>boolean 	addAll(int index, Collection&lt;? extends E> c)</code> -- 从指定位置开始，将指定 collection 的所有元素插入此列表</p></li>
									<li><p><code>int 	addAllAbsent(Collection&lt;? extends E> c)</code> -- 添加所有不存在的元素</p></li>

									<li class="group"><p><code>E 	get(int index)</code> -- 返回列表中指定位置的元素</p></li>
									<li><p><code>E 	set(int index, E element)</code> -- 替换列表中指定位置的元素</p></li>

									<li class="group"><p><code>E 	remove(int index)</code> -- 移除列表中指定位置的元素</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 移除指定的元素</p></li>
									<li><p><code>boolean 	removeIf(Predicate&lt;? super E> filter)</code> -- 移除符合条件的元素</p></li>
									<li><p><code>boolean 	removeAll(Collection&lt;?> c)</code> -- 移除存在于 c 中的元素</p></li>
									<li><p><code>void 	replaceAll(UnaryOperator&lt;E> operator)</code> -- 替换符合条件的元素</p></li>
									<li><p><code>boolean 	retainAll(Collection&lt;?> c)</code> -- 只保留此列表中包含在指定 c 中的元素</p></li>

									<li class="group"><p><code>int 	indexOf(Object o)</code> -- 返回此列表中第一次出现的指定元素的索引</p></li>
									<li><p><code>int 	indexOf(E e, int index)</code> -- 从 index 开始向前搜索，此列表中第一次出现的指定元素的索引</p></li>
									<li><p><code>int 	lastIndexOf(Object o)</code> -- 返回此列表中最后一次出现的指定元素的索引</p></li>
									<li><p><code>int 	lastIndexOf(E e, int index)</code> -- 从 index 开始向后搜索，返回最后一次出现的指定元素在此列表中的索引</p></li>


									<li class="group"><p><code>int 	size()</code> -- 返回此列表中的元素数</p></li>
									<li><p><code>void 	clear()</code> -- 从此列表移除所有元素</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 此列表不包含任何元素</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 列表包含指定的元素</p></li>
									<li><p><code>boolean 	containsAll(Collection&lt;?> c)</code> -- 列表包含指定的元素集合</p></li>
									<li><p><code>void 	sort(Comparator&lt;? super E> c)</code> -- 按指定排序器排序</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 返回迭代器</p></li>
									<li><p><code>void 	forEach(Consumer&lt;? super E> action)</code> -- 迭代</p></li>
									<li><p><code>ListIterator&lt;E> 	listIterator()</code> -- 返回列表迭代起</p></li>
									<li><p><code>ListIterator&lt;E> 	listIterator(int index)</code> -- 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 分割迭代器，用于多线程迭代</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 包含此列表中所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回数组的运行时类型是指定数组的运行时类型</p></li>
									<li><p><code>List&lt;E> 	subList(int fromIndex, int toIndex)</code> -- 返回此列表中 fromIndex（包括）和 toIndex（不包括）之间部分的视图</p></li>

									<li class="group"><p><code>Object 	clone()</code> -- 复制</p></li>
									<li><p><code>int 	hashCode()</code> -- 哈希值</p></li>
									<li><p><code>boolean 	equals(Object o)</code> -- 是否相等</p></li>
									<li><p><code>String 	toString()</code> -- 返回此列表的字符串表示形式</p></li>
								</ol>
                            </div>
                        </div>

                        <div class="sub-item">
                            <a id="AbstractMap" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/AbstractMap.html" target="_blank">AbstractMap</a> 此类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作。</p>
								<ul>
									<li><p>要实现不可修改的映射，编程人员只需扩展此类并提供 entrySet 方法的实现即可，该方法将返回映射的映射关系 set 视图。通常，返回的 set 将依次在 AbstractSet 上实现。此 set 不支持 add 或 remove 方法，其迭代器也不支持 remove 方法； </p></li>
									<li><p>要实现可修改的映射，编程人员必须另外重写此类的 put 方法（否则将抛出 UnsupportedOperationException），entrySet().iterator() 返回的迭代器也必须另外实现其 remove 方法。 </p></li>
								</ul>
                            </div>

                            <a id="HashMap" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/HashMap.html" target="_blank">HashMap</a> 基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。</p>
								<p>除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。</p>
								<p>此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>

								<pre class="brush: java;">
public class HashMap&lt;K,V> extends AbstractMap&lt;K,V> implements Map&lt;K,V>, Cloneable, Serializable {
    transient Node&lt;K,V>[] table; // 内部存储的还是包装了的数组

    static class Node&lt;K,V> implements Map.Entry&lt;K,V> {
        final int hash;
        final K key;
        V value;
        Node&lt;K,V> next;

        Node(int hash, K key, V value, Node&lt;K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public HashMap() {}
    public HashMap(int initialCapacity) {}
    public HashMap(int initialCapacity, float loadFactor) {}
    public HashMap(Map&lt;? extends K,? extends V> m) {}
}
</pre>
								<ol>
									<li><p><code>V 	put(K key, V value)</code> -- 添加一个键值对，如果 <code>key</code> 已存在，则替换对应的 <code>value</code>, 并返回被替换的 <code>value</code></p></li>
									<li><p><code>V 	get(Object key)</code> -- 返回指定键所映射的值</p></li>
									<li><p><code>V 	remove(Object key)</code> -- 如果存在指定的键，则移除此键值对</p></li>
									<li><p><code>V 	replace(K key, V value)</code> -- 如果存在指定的键，则将值天替换为指定值</p></li>
									<li><p><code>boolean 	remove(Object key, Object value)</code> -- 如果存在指定键和值，则移除此键值对</p></li>
									<li><p><code>boolean 	replace(K key, V oldValue, V newValue)</code> -- 如果存在指定的键和值，则将值替换为指定值</p></li>
									<li><p><code>V 	getOrDefault(Object key, V defaultValue)</code> -- 如果不存在指定的键，则返回默认值</p></li>

									<li class="group"><p><code>int 	size()</code> -- 返回此映射中的键-值映射关系数</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 是否为空</p></li>
									<li><p><code>void 	clear()</code> -- 清除所有</p></li>

									<li class="group"><p><code>boolean 	containsKey(Object key)</code> -- 是否包含指定的键</p></li>
									<li><p><code>boolean 	containsValue(Object value)</code> -- 是否包含指定的值</p></li>
									<li><p><code>Set&lt;Map.Entry&lt;K,V>> 	entrySet()</code> -- 返回 <code>key-value</code> 的 <code>Set</code> 视图</p></li>
									<li><p><code>Collection&lt;V> 	values()</code> -- 返回值的 <code>Collection</code> 视图</p></li>
									<li><p><code>Set&lt;K> 	keySet()</code> -- 返回 <code>key</code> 的 <code>Set</code> 视图</p></li>

									<li class="group"><p><code>V 	putIfAbsent(K key, V value)</code> -- 如果指定的 <code>key</code> 已经在 map 中，并且其值不为 null，返回原有的 <code>value</code>；否则同 <code>put(K, V)</code>，并返回 null</p></li>
									<li><p><code>V 	compute(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- 替换，添加或删除，看以下情况</p>
										<pre  class="brush: java;">
/** 如果 key 不存在于 map， 并且返回的 v 不为 null, 相当于 put(k, v);
 * 如果 key 存在于 map, 用新的返回值替换原来的值，有个特殊情况，如果返回值为 null, 则相当于 remove(key)。 */
String k = "aa";
hashMap.compute(k, (key, value) -> {
    log(key, value); // key == k, value = get(k)
    String v= "zz";
    return v;
});
</pre>
									</li>
									<li><p><code>V 	computeIfAbsent(K key, Function&lt;? super K,? extends V> mappingFunction)</code> -- 如果 key 不存在于 map 中，并且返回值不为 null, 则相当于 put(key, 返回值)；如果 key 存在于 map 中，并且其值不为 null，不执行回调，返回其值；如果 key 存在于 map 中，并且其值为 null，则执行替换</p></li>
									<li><p><code>V 	computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- key 存在于 map 中，并其值不为 null, 才会执行回调，返回值不为 null，则替换；返回值为 null, 则删除</p></li>

									<li class="group"><p><code>void 	putAll(Map&lt;? extends K,? extends V> m)</code> --  将指定映射的所有映射关系复制到此映射中</p></li>
									<li><p><code>void 	replaceAll(BiFunction&lt;? super K,? super V,? extends V> function)</code> -- 替换符合条件的值</p>
										<pre class="brush: java;">
/** {aa = xx, bb = yy} -> {aa = xx, bb = mm} */
hashMap.replaceAll((key, value) -> {
	log(key, value);
	if(key.equals("bb")) {
		return "mm";
	}
	return value;
});
</pre>
									</li>
									<li><p><code>V 	merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V> remappingFunction)</code> -- 替换或添加，可用判断 value 的情况进行操作</p>
										<pre class="brush: java;">
/** 原数据：{aa = xx, bb = yy} -> {aa = zz, bb = yy} */
String key = "aa";
String value = "zz";

/** 如果 key 不存在于 map 中或对应的 value 为 null，则相当于 put(K, V), 并不会执行下面的回调；
 * 否则执行回调并替换 key 对应的 value 为返回值。
 */
hashMap.merge(key, value, (oldV, value) -> {
    log(oldV, value); // oldV 为 key 对应的原来值
    return value;
});
</pre>
									</li>
									<li><p><code>Object 	clone()</code> -- 复制</p></li>

									<li class="group"><p><code>void 	forEach(BiConsumer&lt;? super K,? super V> action)</code> -- 键值迭代器</p>
										<pre class="brush: java;">
hashMap.forEach(new BiConsumer() {
    @Override
    public void accept(Object key, Object value) {
        log(key, value);
    }
});
</pre>
									</li>
								</ol>
                            </div>

                            <a id="LinkedHashMap" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/LinkedHashMap.html" target="_blank">LinkedHashMap</a> Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。</p>
								<p>此实现可以让客户避免未指定的、由 HashMap（及 Hashtable）所提供的通常为杂乱无章的排序工作，同时无需增加与 TreeMap 相关的成本。</p>
								<p><b>提供特殊的构造方法来创建链接哈希映射，该哈希映射的迭代顺序就是最后访问其条目的顺序，从近期访问最少到近期访问最多的顺序（访问顺序）。这种映射很适合构建 LRU 缓存。</b></p>
								<p>由于增加了维护链接列表的开支，其性能很可能比 HashMap 稍逊一筹，不过这一点例外：LinkedHashMap 的 collection 视图迭代所需时间与映射的大小 成比例。HashMap 迭代时间很可能开支较大，因为它所需要的时间与其容量成比例。</p>
								<pre class="brush: java;">
public class LinkedHashMap&lt;K,V> extends HashMap&lt;K,V> implements Map&lt;K,V> {
    public LinkedHashMap() {}
    public LinkedHashMap(int initialCapacity) {}
    public LinkedHashMap(int initialCapacity, float loadFactor) {}
    public LinkedHashMap(&lt;? extends K,? extends V> m) {}
    public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {} // 可以使用访问排序模式
}

/** 访问顺序排序, 最后访问的数据被移动到最后一条 */
LinkedHashMap&lt;String, String> map = new LinkedHashMap<>(16, 0.75f, true); // accessOrder 为 true
map.put("aa", "xx");
map.put("bb", "yy");
map.put("cc", "zz");

log(map); // {aa=xx, bb=yy, cc=zz}
log(map.get("aa"));
log(map); // {bb=yy, cc=zz, aa=xx}
</pre>
								<ol>
									<li><p><code>protected boolean 	removeEldestEntry(Map.Entry&lt;K,V> eldest)</code> -- 移除其最旧的条目，成功则返回 true</p></li>
								</ol>
                            </div>

                            <a id="WeakHashMap" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/WeakHashMap.html" target="_blank">WeakHashMap</a> 以弱键实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的 Map 实现有所不同。 </p>
								<p>null 值和 null 键都被支持。该类具有与 HashMap 类相似的性能特征,并具有相同的效能参数初始容量 和加载因子。 </p>
								<p>该类主要与这样的键对象一起使用，其 equals 方法使用 == 运算符来测试对象标识。一旦这种键被丢弃，就永远无法再创建了，所以，过段时间后在 WeakHashMap 中查找此键是不可能的，不必对其项已移除而感到惊讶。该类十分适合与 equals 方法不是基于对象标识的键对象一起使用，比如，String 实例。然而，对于这种可重新创建的键对象，键若丢弃，就自动移除 WeakHashMap 条目，这种表现令人疑惑。 </p>
								<p>WeakHashMap 中的每个键对象间接地存储为一个弱引用的指示对象。因此，不管是在映射内还是在映射之外，只有在垃圾回收器清除某个键的弱引用之后，该键才会自动移除。 </p>
								<p>实现注意事项：WeakHashMap 中的值对象由普通的强引用保持。因此应该小心谨慎，确保值对象不会直接或间接地强引用其自身的键，因为这会阻止键的丢弃。注意，值对象可以通过 WeakHashMap 本身间接引用其对应的键；这就是说，某个值对象可能强引用某个其他的键对象，而与该键对象相关联的值对象转而强引用第一个值对象的键。处理此问题的一种方法是，在插入前将值自身包装在 WeakReferences 中，如：m.put(key, new WeakReference(value))，然后，分别用 get 进行解包。 </p>
								<pre class="brush: java;">
public class WeakHashMap&lt;K,V> extends AbstractMap&lt;K,V> implements Map&lt;K,V> {
    public WeakHashMap() {}
    public WeakHashMap(int initialCapacity) {}
    public WeakHashMap(int initialCapacity, float loadFactor) {}
    public WeakHashMap(&lt;? extends K,? extends V> m) {}

	// 它的 Entry 是 WeakReference 的子类
	private static class Entry&lt;K,V> extends WeakReference&lt;Object> implements Map.Entry&lt;K,V> {...}
}

WeakHashMap&lt;String, Integer> map = new WeakHashMap&lt;>();
map.put(new String("a"), 65);
Log.d(map.get("a")); // 65
System.gc();
Log.d(map.get("a")); // null
</pre>
								<ol>
									<li><p><code>V 	put(K key, V value)</code> -- 添加一个键值对，如果 key 已存在，则替换对应的 value, 并返回被替换的 value</p></li>
									<li><p><code>V 	get(Object key)</code> -- 返回指定键所映射的值</p></li>
									<li><p><code>V 	remove(Object key)</code> -- 如果存在指定的键，则移除此键值对</p></li>

									<li class="group"><p><code>void 	clear()</code> -- 清除所有</p></li>
									<li><p><code>int 	size()</code> -- 返回此映射中的键-值映射关系数</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 是否为空</p></li>

									<li class="group"><p><code>boolean 	containsKey(Object key)</code> -- 是否包含指定的键</p></li>
									<li><p><code>boolean 	containsValue(Object value)</code> -- 是否包含指定的值</p></li>

									<li class="group"><p><code>Set&lt;Map.Entry&lt;K,V>> 	entrySet()</code> -- 返回 key-value 的 Set 视图</p></li>
									<li><p><code>Set<&lt;K> 	keySet()</code> -- 返回 key 的 Set 视图</p></li>
									<li><p><code>Collection&lt;V> 	values()</code> -- 返回值的 Collection 视图</p></li>
									<li><p><code>void 	forEach(BiConsumer&lt;? super K,? super V> action)</code> -- 键值迭代器</p></li>

									<li class="group"><p><code>void 	putAll(Map&lt;? extends K,? extends V> m)</code> -- 将指定映射的所有映射关系复制到此映射中</p></li>
									<li><p><code>void 	replaceAll(BiFunction&lt;? super K,? super V,? extends V> function)</code> -- 替换符合条件的值</p></li>
								</ol>
                            </div>

                            <a id="TreeMap" class="offset"></a>
                            <div class="split-item">
                                <p><a href="docs/docs-java/api/java/util/TreeMap.html" target="_blank">TreeMap</a> 基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 </p>
                                <p>注意，如果要正确实现 Map 接口，则有序映射所保持的顺序（无论是否明确提供了比较器）都必须与 equals 一致。</p>
								<p><b>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪。</b></p>
								<ol>
									<li><p>每个节点要么是红色，要么是黑色；</p></li>
									<li><p>根节点必须是黑色；</p></li>
									<li><p>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）；</p></li>
									<li><p>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p></li>
								</ol>
								<p><b>在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件 3 或条件 4，需要通过调整使得查找树重新满足红黑树的条件。</b></p>
								<pre class="brush: java;">
public class TreeMap&lt;K,V> extends AbstractMap&lt;K,V> implements NavigableMap&lt;K,V>,
                                Cloneable, Serializable {
	static final class Entry&lt;K,V> implements Map.Entry&lt;K,V> {
        K key;
        V value;
        Entry&lt;K,V> left; // 红黑树的左孩子
        Entry&lt;K,V> right; // 红黑树的右孩子
        Entry&lt;K,V> parent; // 红黑树的父节点
        boolean color = BLACK; // 红黑树的颜色
	}

    public TreeMap() {}
    public TreeMap(Comparator&lt;? super K> comparator) {}
    public TreeMap(Map&lt;? extends K,? extends V> m) {}
    public TreeMap(SortedMap&lt;K,? extends V> m) {}
}
</pre>
                                <ol>
                                    <li><p><code>V 	put(K key, V value)</code> -- 将指定值与此映射中的指定键进行关联，<b>此方法会进行排序</b></p>
                                        <pre class="brush: java;">
TreeMap&lt;String, Object> map = new TreeMap<>();
map.put("bb", "yy");
map.put("aa", "xx");
log(map); // {aa=xx, bb=yy}, 自动使用 key 的自然顺序排序
</pre>
                                    </li>
                                    <li><p><code>V 	get(Object key)</code> -- 返回指定键所映射的值</p></li>
                                    <li><p><code>void 	putAll(Map&lt;? extends K,? extends V> map)</code> -- </p></li>
                                    <li><p><code>V 	remove(Object key)</code> -- 如果存在指定的键，则移除此键值对</p></li>
                                    <li><p><code>V 	replace(K key, V value)</code> -- 如果存在指定的键，则将值天替换为指定值</p></li>
                                    <li><p><code>boolean 	replace(K key, V oldValue, V newValue)</code> -- 如果存在指定的键值，则将值天替换为指定值</p></li>
                                    <li><p><code>void 	replaceAll(BiFunction&lt;? super K,? super V,? extends V> function)</code> -- 替换符合条件的值</p></li>

                                    <li class="group"><p><code>boolean 	containsKey(Object key)</code> -- 是否包含指定的键</p></li>
                                    <li><p><code>boolean 	containsValue(Object value)</code> -- 是否包含指定的值</p></li>
                                    <li><p><code>int 	size()</code> -- 返回此映射中的键-值映射关系数</p></li>
                                    <li><p><code>void 	clear()</code> -- 清除所有</p></li>
                                    <li><p><code>Object 	clone()</code> -- 是否为空</p></li>
                                    <li><p><code>Collection&lt;V> 	values()</code> -- 返回值的 Collection 视图</p></li>
                                    <li><p><code>void 	forEach(BiConsumer&lt;? super K,? super V> action)</code> -- 迭代</p></li>
                                    <li><p><code>Comparator&lt;? super K> 	comparator()</code> -- 返回比较器</p></li>

                                    <li class="group"><p><code>K 	firstKey()</code> -- 返回此映射中当前第一个（最低）键</p></li>
                                    <li><p><code>K 	lastKey()</code> -- 返回此映射中当前最后一个键</p></li>
                                    <li><p><code>K 	higherKey(K key)</code> -- 返回此映射中大于指定键的键(最接近)</p></li>
									<li><p><code>K 	ceilingKey(K key)</code> -- 返回此映射中大于或等于指定键的键(最接近)</p></li>
									<li><p><code>K 	lowerKey(K key)</code> -- 返回此映射中小于指定键的键(最接近)</p></li>
                                    <li><p><code>K 	floorKey(K key)</code> -- 返回此映射中小于或等于指定键的键(最接近)</p></li>

                                    <li class="group"><p><code>Map.Entry&lt;K,V> 	firstEntry()</code> -- 返回一个与此映射中的最小键关联的键-值映射关系</p></li>
                                    <li><p><code>Map.Entry&lt;K,V> 	lastEntry()</code> -- 返回一个与此映射中的最大键关联的键-值映射关系</p></li>
                                    <li><p><code>Map.Entry&lt;K,V> 	higherEntry(K key)</code> -- 返回此映射中大于指定键的键-值映射关系(最接近)</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	ceilingEntry(K key)</code> -- 返回此映射中大于或等于指定键的键-值映射关系(最接近)</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	lowerEntry(K key)</code> -- 返回此映射中小于指定键的键-值映射关系(最接近)</p></li>
                                    <li><p><code>Map.Entry&lt;K,V> 	floorEntry(K key)</code> -- 返回此映射中小于或等于指定键的键-值映射关系(最接近)</p></li>

                                    <li class="group"><p><code>SortedMap&lt;K,V> 	tailMap(K fromKey)</code> -- 返回此映射的部分视图，其键大于等于 fromKey</p></li>
                                    <li><p><code>SortedMap&lt;K,V> 	headMap(K toKey)</code> -- 返回此映射的部分视图，其键值严格小于 toKey</p></li>
                                    <li><p><code>SortedMap&lt;K,V> 	subMap(K fromKey, K toKey)</code> -- 返回此映射的部分视图，其键值从 fromKey（包括） 到 toKey（不包括）</p></li>

									<li class="group"><p><code>NavigableMap&lt;K,V> 	tailMap(K fromKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey</p></li>
									<li><p><code>NavigableMap&lt;K,V> 	headMap(K toKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）fromKey</p></li>
									<li><p><code>NavigableMap&lt;K,V> 	subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</code> -- 返回此映射的部分视图，其键值从 fromKey（如果 fromInclusive == true，包括） 到 toKey（如果 toInclusive == true，包括）</p></li>


									<li class="group"><p><code>Set&lt;K> 	keySet()</code> -- 键的 Set 视图</p></li>
									<li><p><code>Set&lt;Map.Entry&lt;K,V>> 	entrySet()</code> -- 键-值的 Set 视图</p></li>
									<li><p><code>NavigableMap&lt;K,V> 	descendingMap()</code> -- 返回逆序视图</p></li>
									<li><p><code>NavigableSet&lt;K> 	descendingKeySet()</code> -- 逆序键的 Set 视图</p></li>
									<li><p><code>NavigableSet&lt;K> 	navigableKeySet()</code> -- 键的 NavigableSet 视图</p></li>

                                    <li class="group"><p><code>Map.Entry&lt;K,V> 	pollFirstEntry()</code> -- 移除并返回与此映射中的最小键关联的键-值映射关系</p></li>
                                    <li><p><code>Map.Entry&lt;K,V> 	pollLastEntry()</code> -- 移除并返回与此映射中的最大键关联的键-值映射关系</p></li>
                                </ol>
                            </div>

                            <a id="EnumMap" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/EnumMap.html" target="_blank">EnumMap</a> 与枚举类型键一起使用的专用 Map 实现。枚举映射中所有键都必须来自单个枚举类型，该枚举类型在创建映射时显式或隐式地指定。枚举映射在内部表示为数组。此表示形式非常紧凑且高效。 </p>
								<p>枚举映射根据其键的自然顺序来维护.</p>
								<p>不允许使用 null 键。试图插入 null 键将抛出 NullPointerException。但是，试图测试是否出现 null 键或移除 null 键将不会抛出异常。允许使用 null 值。 </p>
								<pre class="brush: java;">
public class EnumMap&lt;K extends Enum&lt;K>,V> extends AbstractMap&lt;K,V> implements Serializable, Cloneable {
	public EnumMap(Class&lt;K> keyType) {}
	public EnumMap(EnumMap&lt;K,? extends V> m) {}
	public EnumMap(Map&lt;K,? extends V> m) {}
}
</pre>
								<ol>
									<li><p><code>V 	put(K key, V value)</code> -- 将指定值与此映射中指定键关联</p></li>
									<li><p><code>V 	get(Object key)</code> -- 返回指定键所映射的值，如果此映射不包含此键的映射关系，则返回 null</p></li>
									<li><p><code>V 	remove(Object key)</code> -- 从此映射中移除该键的映射关系（如果存在）</p></li>
									<li><p><code>void 	putAll(Map&lt;? extends K,? extends V> m)</code> -- 将指定映射中所有映射关系复制到此映射中</p></li>

									<li class="group"><p><code>void 	clear()</code> -- 从此映射中移除所有映射关系</p></li>
									<li><p><code>int 	size()</code> -- 返回此映射中的键-值映射关系数</p></li>

									<li class="group"><p><code>boolean 	containsKey(Object key)</code> -- 如果此映射包含指定键的映射关系，则返回 true</p></li>
									<li><p><code>boolean 	containsValue(Object value)</code> -- 如果此映射将一个或多个键映射到指定值，则返回 true</p></li>
									<li><p><code>Set&lt;K> 	keySet()</code> -- 返回此映射中所包含键的 Set 视图</p></li>
									<li><p><code>Set&lt;Map.Entry&lt;K,V>> 	entrySet()</code> -- 返回此映射中所包含映射关系的 Set 视图</p></li>
									<li><p><code>Collection&lt;V> 	values()</code> -- 返回此映射中所包含值的 Collection 视图</p></li>

									<li class="group"><p><code>boolean 	equals(Object o)</code> -- 比较指定对象与此映射的相等性</p></li>
									<li><p><code>EnumMap&lt;K,V> 	clone()</code> -- 返回此枚举映射的浅表副本</p></li>
									<li><p><code>int 	hashCode()</code> -- 哈希值</p></li>
								</ol>
                            </div>

                            <a id="IdentityHashMap" class="offset"></a>
                            <div class="split-item">
								<p><a href="docs/docs-java/api/java/util/IdentityHashMap.html" target="_blank">IdentityHashMap</a> 此类利用哈希表实现 Map 接口，比较键（和值）时使用引用相等性代替对象相等性。</p>
								<p>换句话说，在 IdentityHashMap 中，当且仅当 (k1==k2) 时，才认为两个键 k1 和 k2 相等（在正常 Map 实现（如 HashMap）中，当且仅当满足下列条件时才认为两个键 k1 和 k2 相等：(k1==null ? k2==null : e1.equals(e2))）。 </p>
								<p><b>此类不是 通用 Map 实现！此类实现 Map 接口时，它有意违反 Map 的常规协定，该协定在比较对象时强制使用 equals 方法。此类设计仅用于其中需要引用相等性语义的罕见情况。</b></p>
								<p>此类的典型用法是拓扑保留对象图形转换，如序列化或深层复制。要执行这样的转换，程序必须维护用于跟踪所有已处理对象引用的“节点表”。节点表一定不等于不同对象，即使它们偶然相等也如此。此类的另一种典型用法是维护代理对象。例如，调试设施可能希望为正在调试程序中的每个对象维护代理对象。 </p>
								<p>此类提供所有的可选映射操作，并且允许 null 值和 null 键。此类对映射的顺序不提供任何保证；特别是不保证顺序随时间的推移保持不变。 </p>
								<pre class="brush: java;">
public class IdentityHashMap&lt;K,V> extends AbstractMap&lt;K,V> implements Map&lt;K,V>, Serializable, Cloneable {
	public IdentityHashMap() {}
	public IdentityHashMap(int expectedMaxSize) {}
	public IdentityHashMap(Map&lt;? extends K,? extends V> m) {}
}
</pre>
								<ol>
									<li><p><code>V 	put(K key, V value)</code> -- 将指定值与此映射中指定键关联</p></li>
									<li><p><code>V 	get(Object key)</code> -- 返回指定键所映射的值，如果此映射不包含此键的映射关系，则返回 null</p></li>
									<li><p><code>V 	remove(Object key)</code> -- 从此映射中移除该键的映射关系（如果存在）</p></li>
									<li><p><code>void 	putAll(Map&lt;? extends K,? extends V> m)</code> -- 将指定映射中所有映射关系复制到此映射中</p></li>

									<li class="group"><p><code>void 	clear()</code> -- 从此映射中移除所有映射关系</p></li>
									<li><p><code>int 	size()</code> -- 返回此映射中的键-值映射关系数</p></li>

									<li class="group"><p><code>boolean 	containsKey(Object key)</code> -- 如果此映射包含指定键的映射关系，则返回 true</p></li>
									<li><p><code>boolean 	containsValue(Object value)</code> -- 如果此映射将一个或多个键映射到指定值，则返回 true</p></li>
									<li><p><code>Set&lt;K> 	keySet()</code> -- 返回此映射中所包含键的 Set 视图</p></li>
									<li><p><code>Set&lt;Map.Entry&lt;K,V>> 	entrySet()</code> -- 返回此映射中所包含映射关系的 Set 视图</p></li>
									<li><p><code>Collection&lt;V> 	values()</code> -- 返回此映射中所包含值的 Collection 视图</p></li>

									<li class="group"><p><code>boolean 	equals(Object o)</code> -- 比较指定对象与此映射的相等性</p></li>
									<li><p><code>EnumMap&lt;K,V> 	clone()</code> -- 返回此枚举映射的浅表副本</p></li>
									<li><p><code>int 	hashCode()</code> -- 哈希值</p></li>
								</ol>
                            </div>

                            <a id="ConcurrentHashMap" class="offset"></a>
                            <div class="split-item">
                            	<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank">ConcurrentHashMap</a> 支持获取的完全并发和更新的所期望可调整并发的哈希表。此类遵守与 Hashtable 相同的功能规范，并且包括对应于 Hashtable 的每个方法的方法版本。不过，尽管所有操作都是线程安全的，但获取操作不 必锁定，并且不 支持以某种防止所有访问的方式锁定整个表。此类可以通过程序完全与 Hashtable 进行互操作，这取决于其线程安全，而与其同步细节无关。 </p>
								<p>获取操作（包括 get）通常不会受阻塞，因此，可能与更新操作交迭（包括 put 和 remove）。获取会影响最近完成的 更新操作的结果。对于一些聚合操作，比如 putAll 和 clear，并发获取可能只影响某些条目的插入和移除。类似地，在创建迭代器/枚举时或自此之后，Iterators 和 Enumerations 返回在某一时间点上影响哈希表状态的元素。它们不会 抛出 ConcurrentModificationException。不过，迭代器被设计成每次仅由一个线程使用。 </p>
                            	<pre class="brush: java;">
public class ConcurrentHashMap&lt;K,V> extends AbstractMap&lt;K,V> implements ConcurrentMap&lt;K,V>,Serializable {
	public static class KeySetView&lt;K,V> extends CollectionView&lt;K,V,K> implements Set&lt;K>,Serializable {}

	public ConcurrentHashMap() {}
	public ConcurrentHashMap(int initialCapacity) {}
	public ConcurrentHashMap(int initialCapacity, float loadFactor) {}
	public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {}
	public ConcurrentHashMap(Map&lt;? extends K,? extends V> m) {}
}
</pre>
								<ol>
									<li><p><code>V 	put(K key, V value)</code> -- 将指定值与此映射中指定键关联</p></li>
									<li><p><code>V 	putIfAbsent(K key, V value)</code> -- 如果指定键已经不再与某个值相关联，则将它与给定值关联</p></li>
									<li><p><code>V 	get(Object key)</code> -- 返回指定键所映射的值，如果此映射不包含此键的映射关系，则返回 null</p></li>
									<li><p><code>V 	getOrDefault(Object key, V defaultValue)</code> -- 如果指定键返回值为 null, 则返回 defaultValue</p></li>
									<li><p><code>V 	remove(Object key)</code> -- 从此映射中移除该键的映射关系（如果存在）</p></li>
									<li><p><code>boolean 	remove(Object key, Object value)</code> --  只有目前将键的条目映射到给定值时，才移除该键的条目</p></li>
									<li><p><code>void 	putAll(Map&lt;? extends K,? extends V> m)</code> -- 将指定映射中所有映射关系复制到此映射中</p></li>

									<li class="group"><p><code>void 	clear()</code> -- 从此映射中移除所有映射关系</p></li>
									<li><p><code>int 	size()</code> -- 返回此映射中的键-值映射关系数</p></li>

									<li class="group"><p><code>boolean 	containsKey(Object key)</code> -- 如果此映射包含指定键的映射关系，则返回 true</p></li>
									<li><p><code>boolean 	containsValue(Object value)</code> -- 如果此映射将一个或多个键映射到指定值，则返回 true</p></li>
									<li><p><code>boolean 	contains(Object value)</code> -- 同 containsValue</p></li>
									<li><p><code>ConcurrentHashMap.KeySetView&lt;K,V> 	keySet()</code> -- 返回 KeySetView 视图</p></li>
									<li><p><code>ConcurrentHashMap.KeySetView&lt;K,V> 	keySet(V mappedValue)</code> -- 包括一个 mappedValue 的 KeySetView 视图</p></li>
									<li><p><code>static &lt;K> ConcurrentHashMap.KeySetView&lt;K,Boolean> 	newKeySet()</code> -- 创建一个默认值为 true 的新的 map</p></li>
									<li><p><code>static &lt;K> ConcurrentHashMap.KeySetView&lt;K,Boolean> 	newKeySet(int initialCapacity)</code> -- 创建一个指定初始容量默认值为 true 的新的 map</p></li>
									<li><p><code>Set&lt;Map.Entry&lt;K,V>> 	entrySet()</code> -- 返回此映射中所包含映射关系的 Set 视图</p></li>
									<li><p><code>Collection&lt;V> 	values()</code> -- 返回此映射中所包含值的 Collection 视图</p></li>

									<li class="group"><p><code>boolean 	equals(Object o)</code> -- 比较指定对象与此映射的相等性</p></li>
									<li><p><code>EnumMap&lt;K,V> 	clone()</code> -- 返回此枚举映射的浅表副本</p></li>
									<li><p><code>int 	hashCode()</code> -- 哈希值</p></li>

									<li class="group"><p><code>V 	compute(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- 参见 <a href="#HashMap">HashMap</a> 同名方法</p></li>
									<li><p><code>V 	computeIfAbsent(K key, Function&lt;? super K,? extends V> mappingFunction)</code> -- 参见 <a href="#HashMap">HashMap</a> 同名方法</p></li>
									<li><p><code>V 	computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- 参见 <a href="#HashMap">HashMap</a> 同名方法</p></li>

									<li class="group"><p><code>V 	replace(K key, V value)</code> -- 替换指定 key 的 value</p></li>
									<li><p><code>boolean 	replace(K key, V oldValue, V newValue)</code> -- 替换指定 key 的 指定 value 为 newValue</p></li>
									<li><p><code>void 	replaceAll(BiFunction&lt;? super K,? super V,? extends V> function)</code> -- 替换符合条件的 value</p></li>

									<li class="group"><p><code>&lt;U> U 	search(long parallelismThreshold, BiFunction&lt;? super K,? super V,? extends U> searchFunction)</code> -- 并行搜索，直到 searchFunction 返回不为 null</p></li>
									<li><p><code>&lt;U> U 	searchEntries(long parallelismThreshold, Function&lt;Map.Entry&lt;K,V>,? extends U> searchFunction)</code> --以 Map.Entry 的形式 并行搜索，直到 searchFunction 返回不为 null</p></li>
									<li><p><code>&lt;U> U 	searchKeys(long parallelismThreshold, Function&lt;? super K,? extends U> searchFunction)</code> -- 并行搜索 key，直到 searchFunction 返回不为 null</p></li>
									<li><p><code>&lt;U> U 	searchValues(long parallelismThreshold, Function&lt;? super V,? extends U> searchFunction)</code> -- 并行搜索 value，直到 searchFunction 返回不为 null</p></li>

									<li class="group"><p><code>Enumeration&lt;K> 	keys()</code> -- 键的枚举器，可用于迭代</p></li>
									<li><p><code>Enumeration&lt;V> 	elements()</code> -- 值的枚举器，可用于迭代</p></li>
									<li><p><code>long 	mappingCount()</code> -- 返回映射数量</p></li>
									<li><p><code>V 	merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V> remappingFunction)</code> -- 替换或添加，可用判断 value 的情况进行操作</p></li>

									<li class="group"><p><code>void 	forEach(BiConsumer&lt;? super K,? super V> action)</code> -- 迭代键值</p></li>
									<li><p><code>void 	forEach(long parallelismThreshold, BiConsumer&lt;? super K,? super V> action)</code> -- 并行迭代，并传输一个 Map 中可能的大小，以提高性能</p></li>
									<li><p><code>&lt;U> void 	forEach(long parallelismThreshold, BiFunction&lt;? super K,? super V,? extends U> transformer, Consumer&lt;? super U> action)</code> -- 并行迭代，将 transformer 的返回值传输到 action 函数</p></li>
									<li><p><code>void 	forEachEntry(long parallelismThreshold, Consumer&lt;? super Map.Entry&lt;K,V>> action)</code> -- 以 Map.Entry 的形式迭代</p></li>
									<li><p><code>&lt;U> void 	forEachEntry(long parallelismThreshold, Function&lt;Map.Entry&lt;K,V>,? extends U> transformer, Consumer&lt;? super U> action)</code> -- 以 Map.Entry 的形式并行迭代，将 transformer 的返回值传输到 action 函数</p></li>
									<li><p><code>void 	forEachKey(long parallelismThreshold, Consumer&lt;? super K> action)</code> -- 并行迭代 key</p></li>
									<li><p><code>&lt;U> void 	forEachKey(long parallelismThreshold, Function&lt;? super K,? extends U> transformer, Consumer&lt;? super U> action)</code> -- 并行迭代 key，将 transformer 的返回值传输到 action 函数</p></li>
									<li><p><code>void 	forEachValue(long parallelismThreshold, Consumer&lt;? super V> action)</code> -- 并行迭代 value</p></li>
									<li><p><code>&lt;U> void 	forEachValue(long parallelismThreshold, Function&lt;? super V,? extends U> transformer, Consumer&lt;? super U> action)</code> -- 并行迭代 value，将 transformer 的返回值传输到 action 函数</p></li>

									<li class="group"><p><code>&lt;U> U 	reduce(long parallelismThreshold, BiFunction&lt;? super K,? super V,? extends U> transformer, BiFunction&lt;? super U,? super U,? extends U> reducer)</code> -- </p></li>
									<li><p><code>Map.Entry&lt;K,V> 	reduceEntries(long parallelismThreshold, BiFunction&lt;Map.Entry&lt;K,V>,Map.Entry&lt;K,V>,? extends Map.Entry&lt;K,V>> reducer)</code> -- </p></li>
									<li><p><code>&lt;U> U 	reduceEntries(long parallelismThreshold, Function&lt;Map.Entry&lt;K,V>,? extends U> transformer, BiFunction&lt;? super U,? super U,? extends U> reducer)</code> -- </p></li>
									<li><p><code>double 	reduceEntriesToDouble(long parallelismThreshold, ToDoubleFunction&lt;Map.Entry&lt;K,V>> transformer, double basis, DoubleBinaryOperator reducer)</code> -- </p></li>
									<li><p><code>int 	reduceEntriesToInt(long parallelismThreshold, ToIntFunction&lt;Map.Entry&lt;K,V>> transformer, int basis, IntBinaryOperator reducer)</code> -- </p></li>
									<li><p><code>long 	reduceEntriesToLong(long parallelismThreshold, ToLongFunction&lt;Map.Entry&lt;K,V>> transformer, long basis, LongBinaryOperator reducer)</code> -- </p></li>

									<li class="group"><p><code>K 	reduceKeys(long parallelismThreshold, BiFunction&lt;? super K,? super K,? extends K> reducer)</code> -- </p></li>
									<li><p><code>&lt;U> U 	reduceKeys(long parallelismThreshold, Function&lt;? super K,? extends U> transformer, BiFunction&lt;? super U,? super U,? extends U> reducer)</code> -- </p></li>
									<li><p><code>double 	reduceKeysToDouble(long parallelismThreshold, ToDoubleFunction&lt;? super K> transformer, double basis, DoubleBinaryOperator reducer)</code> -- </p></li>
									<li><p><code>int 	reduceKeysToInt(long parallelismThreshold, ToIntFunction&lt;? super K> transformer, int basis, IntBinaryOperator reducer)</code> -- </p></li>
									<li><p><code>long 	reduceKeysToLong(long parallelismThreshold, ToLongFunction&lt;? super K> transformer, long basis, LongBinaryOperator reducer)</code> -- </p></li>
									<li><p><code>double 	reduceToDouble(long parallelismThreshold, ToDoubleBiFunction&lt;? super K,? super V> transformer, double basis, DoubleBinaryOperator reducer)</code> -- </p></li>
									<li><p><code>int 	reduceToInt(long parallelismThreshold, ToIntBiFunction&lt;? super K,? super V> transformer, int basis, IntBinaryOperator reducer)</code> -- </p></li>
									<li><p><code>long 	reduceToLong(long parallelismThreshold, ToLongBiFunction&lt;? super K,? super V> transformer, long basis, LongBinaryOperator reducer)</code> -- </p></li>

									<li class="group"><p><code>V 	reduceValues(long parallelismThreshold, BiFunction&lt;? super V,? super V,? extends V> reducer)</code> -- </p></li>
									<li><p><code>&lt;U> U 	reduceValues(long parallelismThreshold, Function&lt;? super V,? extends U> transformer, BiFunction&lt;? super U,? super U,? extends U> reducer)</code> -- </p></li>
									<li><p><code>double 	reduceValuesToDouble(long parallelismThreshold, ToDoubleFunction&lt;? super V> transformer, double basis, DoubleBinaryOperator reducer)</code> -- </p></li>
									<li><p><code>int 	reduceValuesToInt(long parallelismThreshold, ToIntFunction&lt;? super V> transformer, int basis, IntBinaryOperator reducer)</code> -- </p></li>
									<li><p><code>long 	reduceValuesToLong(long parallelismThreshold, ToLongFunction&lt;? super V> transformer, long basis, LongBinaryOperator reducer)</code> -- </p></li>


								</ol>
                            </div>

                            <a id="ConcurrentSkipListMap" class="offset"></a>
                            <div class="split-item">
                            	<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/ConcurrentSkipListMap.html" target="_blank">ConcurrentSkipListMap</a> 可缩放的并发 ConcurrentNavigableMap 实现。映射可以根据键的自然顺序进行排序，也可以根据创建映射时所提供的 Comparator 进行排序，具体取决于使用的构造方法。 </p>
								<p>此类实现 SkipLists 的并发变体，为 containsKey、get、put、remove 操作及其变体提供预期平均 log(n) 时间开销。多个线程可以安全地并发执行插入、移除、更新和访问操作。迭代器是弱一致 的，返回的元素将反映迭代器创建时或创建后某一时刻的映射状态。它们不 抛出 ConcurrentModificationException，可以并发处理其他操作。升序键排序视图及其迭代器比降序键排序视图及其迭代器更快。 </p>
								<p>此类及此类视图中的方法返回的所有 Map.Entry 对，表示他们产生时的映射关系快照。它们不 支持 Entry.setValue 方法。</p>
								<p>请注意，与在大多数 collection 中不同，这里的 size 方法不是 一个固定时间 (constant-time) 操作。因为这些映射的异步特性，确定元素的当前数目需要遍历元素。此外，批量操作 putAll、equals 和 clear 并不 保证能以原子方式 (atomically) 执行。例如，与 putAll 操作一起并发操作的迭代器只能查看某些附加元素。 </p>
                            	<pre class="brush: java;">
public class ConcurrentSkipListMap&lt;K,V> extends AbstractMap&lt;K,V> implements ConcurrentNavigableMap&lt;K,V>,
								Cloneable, Serializable {
	public ConcurrentSkipListMap() {}
	public ConcurrentSkipListMap(Comparator&lt;? super K> comparator) {}
	public ConcurrentSkipListMap(Map&lt;? extends K,? extends V> m) {}
	public ConcurrentSkipListMap(SortedMap&lt;K,? extends V> m) {}
}
</pre>
								<ol>
									<li><p><code>V 	put(K key, V value)</code> -- 将指定值与此映射中的指定键进行关联，<b>此方法会进行排序</b></p></li>
									<li><p><code>V 	putIfAbsent(K key, V value)</code> -- 如果指定键已经不再与某个值相关联，则将它与给定值关联</p></li>
									<li><p><code>V 	get(Object key)</code> -- 返回指定键所映射的值</p></li>
									<li><p><code>V 	getOrDefault(Object key, V defaultValue)</code> -- 如果指定键返回值为 null, 则返回 defaultValue</p></li>
									<li><p><code>V 	remove(Object key)</code> -- 从此映射中移除该键的映射关系（如果存在）</p></li>
									<li><p><code>boolean 	remove(Object key, Object value)</code> -- 只有目前将键的条目映射到给定值时，才移除该键的条目</p></li>
									<li><p><code>void 	clear()</code> -- 从此映射中移除所有映射关系</p></li>

									<li class="group"><p><code>int 	size()</code> -- 返回此映射中的键-值映射关系数</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 是否为空</p></li>
									<li><p><code>V 	replace(K key, V value)</code> -- 替换指定 key 的 value</p></li>
									<li><p><code>boolean 	replace(K key, V oldValue, V newValue)</code> -- 替换指定 key 的 指定 value 为 newValue</p></li>
									<li><p><code>void 	replaceAll(BiFunction&lt;? super K,? super V,? extends V> function)</code> -- 替换符合条件的 value</p></li>

									<li class="group"><p><code>void 	forEach(BiConsumer&lt;? super K,? super V> action)</code> -- 迭代</p></li>
									<li><p><code>V 	merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V> remappingFunction)</code> -- 替换或添加，可用判断 value 的情况进行操作</p></li>
									<li><p><code>boolean 	containsKey(Object key)</code> -- 是否包含指定键</p></li>
									<li><p><code>boolean 	containsValue(Object value)</code> -- 是否包含指定值</p></li>
									<li><p><code>Collection&lt;V> 	values()</code> -- 返回值的 Collection 视图</p></li>
									<li><p><code>boolean 	equals(Object o)</code> -- 是否相等</p></li>
									<li><p><code>ConcurrentSkipListMap&lt;K,V> 	clone()</code> -- 复制</p></li>
									<li><p><code>Comparator&lt;? super K> 	comparator()</code> -- 返回排序器</p></li>

									<li class="group"><p><code>K 	firstKey()</code> -- 返回此映射中当前第一个（最低）键</p></li>
									<li><p><code>K 	lastKey()</code> -- 返回此映射中当前最后一个键</p></li>
									<li><p><code>K 	ceilingKey(K key)</code> -- 返回此映射中大于或等于指定键的键(最接近)</p></li>
									<li><p><code>K 	floorKey(K key)</code> -- 返回此映射中小于或等于指定键的键(最接近)</p></li>
									<li><p><code>K 	higherKey(K key)</code> -- 返回此映射中大于指定键的键(最接近)</p></li>
									<li><p><code>K 	lowerKey(K key)</code> -- 返回此映射中小于指定键的键(最接近)</p></li>

									<li class="group"><p><code>Map.Entry&lt;K,V> 	firstEntry()</code> -- 返回一个与此映射中的最小键关联的键-值映射关系</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	lastEntry()</code> -- 返回一个与此映射中的最大键关联的键-值映射关系</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	ceilingEntry(K key)</code> -- 返回此映射中大于或等于指定键的键-值映射关系(最接近)</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	floorEntry(K key)</code> -- 返回此映射中小于或等于指定键的键-值映射关系(最接近)</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	higherEntry(K key)</code> -- 返回此映射中大于指定键的键-值映射关系(最接近)</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	lowerEntry(K key)</code> -- 返回此映射中小于指定键的键-值映射关系(最接近)</p></li>

									<li class="group"><p><code>V 	compute(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- 参见 <a href="#HashMap">HashMap</a> 同名方法</p></li>
									<li><p><code>V 	computeIfAbsent(K key, Function&lt;? super K,? extends V> mappingFunction)</code> -- 参见 <a href="#HashMap">HashMap</a> 同名方法</p></li>
									<li><p><code>V 	computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- 参见 <a href="#HashMap">HashMap</a> 同名方法</p></li>

									<li class="group"><p><code>ConcurrentNavigableMap&lt;K,V> 	headMap(K toKey)</code> -- 返回此映射的部分视图，其键值严格小于 toKey</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	headMap(K toKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）fromKey</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	subMap(K fromKey, K toKey)</code> -- 返回此映射的部分视图，其键值从 fromKey（包括） 到 toKey（不包括）</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</code> -- 返回此映射的部分视图，其键值从 fromKey（如果 fromInclusive == true，包括） 到 toKey（如果 toInclusive == true，包括）</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	tailMap(K fromKey)</code> -- 返回此映射的部分视图，其键大于等于 fromKey</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	tailMap(K fromKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey</p></li>

									<li class="group"><p><code>NavigableSet&lt;K> 	keySet()</code> -- 键的 Set 视图</p></li>
									<li><p><code>Set&lt;Map.Entry&lt;K,V>> 	entrySet()</code> -- 键-值的 Set 视图</p></li>
									<li><p><code>ConcurrentNavigableMap&lt;K,V> 	descendingMap()</code> -- 返回逆序视图</p></li>
									<li><p><code>NavigableSet&lt;K> 	descendingKeySet()</code> --  逆序键的 NavigableSet 视图</p></li>
									<li><p><code>NavigableSet&lt;K> 	navigableKeySet()</code> -- 键的 NavigableSet 视图</p></li>

									<li class="group"><p><code>Map.Entry&lt;K,V> 	pollFirstEntry()</code> -- 移除并返回与此映射中的最小键关联的键-值映射关系</p></li>
									<li><p><code>Map.Entry&lt;K,V> 	pollLastEntry()</code> -- 移除并返回与此映射中的最大键关联的键-值映射关系</p></li>
								</ol>
                            </div>
                        </div>

						<div class="sub-item">
							<a id="AbstractSet" class="offset"></a>
							<div class="split-item">
								<p><a href="docs/docs-java/api/java/util/AbstractSet.html" target="_blank">AbstractSet</a> 类提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。</p>
								<p>通过扩展此类来实现一个 set 的过程与通过扩展 AbstractCollection 来实现 Collection 的过程是相同的，除了此类的子类中的所有方法和构造方法都必须服从 Set 接口所强加的额外限制。</p>
								<p>注意，此类并没有重写 AbstractCollection 类中的任何实现。它仅仅添加了 equals 和 hashCode 的实现。</p>
								<pre class="brush: java;">
public abstract class AbstractSet&lt;E> extends AbstractCollection&lt;E> implements Set&lt;E> {}
</pre>
							</div>

							<a id="HashSet" class="offset"></a>
							<div class="split-item">
								<p><a href="docs/docs-java/api/java/util/HashSet.html" target="_blank">HashSet</a> 此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用 null 元素。 </p>
								<p>此类为基本操作提供了稳定性能，这些基本操作包括 add、remove、contains 和 size，假定哈希函数将这些元素正确地分布在桶中。对此 set 进行迭代所需的时间与 HashSet 实例的大小（元素的数量）和底层 HashMap 实例（桶的数量）的“容量”的和成比例。因此，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。 </p>
								<pre class="brush: java;">
public class HashSet&lt;E> extends AbstractSet&lt;E> implements Set&lt;E>, Cloneable, Serializable {
	public HashSet() {} // 其实是构建了一个 HashMap
	public HashSet(Collection&lt;? extends E> c) {}
	public HashSet(int initialCapacity) {}
	public HashSet(int initialCapacity, float loadFactor) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 如果此 set 中尚未包含指定元素，则添加指定元素</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 如果指定元素存在于此 set 中，则将其移除</p></li>
									<li><p><code>void 	clear()</code> -- 从此 set 中移除所有元素</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此 set 包含指定元素，则返回 true</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 如果此 set 不包含任何元素，则返回 true</p></li>
									<li><p><code>int 	size()</code> -- 返回此 set 中的元素的数量</p></li>
									<li><p><code>Iterator&lt;E> 	iterator()</code> -- 返回对此 set 中元素进行迭代的迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 返回对此 set 中元素进行迭代的拆分迭代器</p></li>
									<li><p><code>Object 	clone()</code> -- 返回此 HashSet 实例的浅表副本</p></li>
								</ol>
							</div>

							<a id="LinkedHashSet" class="offset"></a>
							<div class="split-item">
								<p><a href="docs/docs-java/api/java/util/LinkedHashSet.html" target="_blank">LinkedHashSet</a> 具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，即按照将元素插入到 set 中的顺序（插入顺序）进行迭代。注意，插入顺序不 受在 set 中重新插入的 元素的影响。</p>
								<p>此实现可以让客户免遭未指定的、由 HashSet 提供的通常杂乱无章的排序工作，而又不致引起与 TreeSet 关联的成本增加。</p>
								<p>此类提供所有可选的 Set 操作，并且允许 null 元素。与 HashSet 一样，它可以为基本操作（add、contains 和 remove）提供稳定的性能，假定哈希函数将元素正确地分布到存储段中。由于增加了维护链接列表的开支，其性能很可能会比 HashSet 稍逊一筹，不过，这一点例外：LinkedHashSet 迭代所需时间与 set 的大小 成正比，而与容量无关。HashSet 迭代很可能支出较大，因为它所需迭代时间与其容量 成正比。</p>
								<p><b>LinkedHashSet 构造的都是 LinkedHashMap, 其它都同父类 HashSet。</b></p>
								<pre class="brush: java;">
public class LinkedHashSet&lt;E> extends HashSet&lt;E> implements Set&lt;E>, Cloneable, Serializable {
	/** LinkedHashSet 构造的都是 LinkedHashMap */
	public LinkedHashSet() {}
	public LinkedHashSet(Collection&lt;? extends E> c) {}
	public LinkedHashSet(int initialCapacity) }|
	public LinkedHashSet(int initialCapacity, float loadFactor) {}
}
</pre>
							</div>

							<a id="TreeSet" class="offset"></a>
							<div class="split-item">
								<p><a href="docs/docs-java/api/java/util/TreeSet.html" target="_blank">TreeSet</a> 基于 TreeMap 的 NavigableSet 实现。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。 </p>
								<p>此实现为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。</p>
								<p>注意，如果要正确实现 Set 接口，则 set 维护的顺序（无论是否提供了显式比较器）必须与 equals 一致。</p>
								<pre class="brush: java;">
public class TreeSet&lt;E> extends AbstractSet&lt;E> implements NavigableSet&lt;E>, Cloneable, Serializable {
	/** 构造的是一个 TreeMap */
	public TreeSet() {}
	public TreeSet(Collection&lt;? extends E> c) {}
 	public TreeSet(Comparator&lt;? super E> comparator) {}
	public TreeSet(SortedSet&lt;E> s) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 其实是 TreeMap 的 <code>put(e, Object)</code></p></li>
									<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 添加所有元素</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 将指定的元素从 set 中移除</p></li>
									<li><p><code>void 	clear()</code> -- 移除此 set 中的所有元素</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 是否为空</p></li>
									<li><p><code>int 	size()</code> -- 返回 set 中的元素数</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此 set 包含指定的元素，则返回 true</p></li>
									<li><p><code>Comparator&lt;? super E> 	comparator()</code> -- 返回对此 set 中的元素进行排序的比较器</p></li>
									<li><p><code>Object 	clone()</code> -- 返回 TreeSet 实例的浅表副本</p></li>

									<li class="group"><p><code>E 	first()</code> -- 返回此 set 中当前第一个（最低）元素</p></li>
									<li><p><code>E 	last()</code> -- 返回此 set 中当前最后一个（最高）元素</p></li>
									<li><p><code>E 	ceiling(E e)</code> -- 返回此 set 中大于等于给定元素的最小元素</p></li>
									<li><p><code>E 	floor(E e)</code> -- 返回此 set 中小于等于给定元素的最大元素</p></li>
									<li><p><code>E 	higher(E e)</code> -- 返回此 set 中严格大于给定元素的最小元素</p></li>
									<li><p><code>E 	lower(E e)</code> -- 返回此 set 中严格小于给定元素的最大元素</p></li>

									<li class="group"><p><code>E 	pollFirst()</code> -- 获取并移除第一个（最低）元素</p></li>
									<li><p><code>E 	pollLast()</code> -- 获取并移除最后一个（最高）元素</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	descendingIterator()</code> -- 返回在此 set 元素上按降序进行迭代的迭代</p></li>
									<li><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此 set 中的元素上按升序进行迭代的迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 可拆分迭代器</p></li>

									<li class="group"><p><code>SortedSet&lt;E> 	headSet(E toElement)</code> -- 返回此 set 的部分视图，其元素严格小于 toElement</p></li>
									<li><p><code>NavigableSet&lt;E> 	headSet(E toElement, boolean inclusive)</code> -- 返回此 set 的部分视图，其元素小于（或等于，如果 inclusive 为 true）toElement</p></li>
									<li><p><code>SortedSet&lt;E> 	subSet(E fromElement, E toElement)</code> -- 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）</p></li>
									<li><p><code>NavigableSet&lt;E> 	subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)</code> -- 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement</p></li>
									<li><p><code>SortedSet&lt;E> 	tailSet(E fromElement)</code> -- 返回此 set 的部分视图，其元素大于等于 fromElement</p></li>
									<li><p><code>NavigableSet&lt;E> 	tailSet(E fromElement, boolean inclusive)</code> -- 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement</p></li>
									<li><p><code>NavigableSet&lt;E> 	descendingSet()</code> -- 返回此 set 中所包含元素的逆序视图</p></li>

								</ol>
							</div>

							<a id="EnumSet" class="offset"></a>
							<div class="split-item">
								<p><a href="docs/docs-java/api/java/util/EnumSet.html" target="_blank">EnumSet</a> 与枚举类型一起使用的专用 Set 实现。枚举 set 中所有键都必须来自单个枚举类型，该枚举类型在创建 set 时显式或隐式地指定。枚举 set 在内部表示为位向量。此表示形式非常紧凑且高效。此类的空间和时间性能应该很好，足以用作传统上基于 int 的“位标志”的替换形式，具有高品质、类型安全的优势。如果其参数也是一个枚举 set，则批量操作（如 containsAll 和 retainAll）也应运行得非常快。 </p>
								<p>不允许使用 null 元素。试图插入 null 元素将抛出 NullPointerException。但是，试图测试是否出现 null 元素或移除 null 元素将不会抛出异常。 </p>
								<pre class="brush: java;">
public abstract class EnumSet&lt;E extends Enum&lt;E>> extends AbstractSet&lt;E> implements Cloneable,
										Serializable {
	final Enum&lt;?>[] universe;
}
</pre>
								<ol>
									<li><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	allOf(Class&lt;E> elementType)</code> -- 创建一个包含指定元素类型的所有元素枚举 set</p></li>
									<li><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	complementOf(EnumSet&lt;E> s)</code> -- 创建一个其元素类型与指定枚举 set 相同的枚举 set，最初包含指定 set 中所不 包含的此类型的所有元素</p></li>
									<li><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	copyOf(Collection&lt;E> c)</code> -- 创建一个从指定 collection 初始化的枚举 set</p></li>
									<li><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	copyOf(EnumSet&lt;E> s)</code> -- 创建一个其元素类型与指定枚举 set 相同的枚举 set，最初包含相同的元素</p></li>
									<li><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	noneOf(Class&lt;E> elementType)</code> -- 创建一个具有指定元素类型的空枚举 set</p></li>

									<li class="group"><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	of(E e)</code> -- 创建一个最初包含指定元素的枚举 set</p></li>
									<li><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	of(E first, E... rest)</code> -- 创建一个最初包含指定元素的枚举 set</p></li>
									<li><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	of(E e1, E e2)</code> -- 创建一个最初包含指定元素的枚举 set</p></li>
									<li><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	of(E e1, E e2, E e3)</code> -- 创建一个最初包含指定元素的枚举 set</p></li>
									<li><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	of(E e1, E e2, E e3, E e4)</code> -- 创建一个最初包含指定元素的枚举 set</p></li>
									<li><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	of(E e1, E e2, E e3, E e4, E e5)</code> -- 创建一个最初包含指定元素的枚举 set</p></li>
									<li><p><code>static &lt;E extends Enum&lt;E>> EnumSet&lt;E> 	range(E from, E to)</code> -- 创建一个最初包含由两个指定端点所定义范围内的所有元素的枚举 set</p></li>

									<li class="group"><p><code>EnumSet&lt;E> 	clone()</code> -- 返回 set 的副本</p></li>
								</ol>
								<pre class="brush: java;">
enum Day {
	MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

EnumSet&lt;Day> set = EnumSet.noneOf(Day.class);
set.add(Day.MONDAY);
set.add(Day.TUESDAY);
set.forEach(day -> log(day));
</pre>
							</div>

							<a id="CopyOnWriteArraySet" class="offset"></a>
							<div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/CopyOnWriteArraySet.html" target="_blank">CopyOnWriteArraySet</a> 对其所有操作使用内部 <a href="#CopyOnWriteArrayList">CopyOnWriteArrayList</a> 的 Set。因此，它共享以下相同的基本属性： </p>
								<ul>
									<li><p>最适合于具有以下特征的应用程序：set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突；</p></li>
									<li><p>是线程安全的；</p></li>
									<li><p>因为通常需要复制整个基础数组，所以可变操作（add、set 和 remove 等等）的开销很大；</p></li>
									<li><p>迭代器不支持可变 remove 操作；</p></li>
									<li><p>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</p></li>
								</ul>
								<pre class="brush: java;">
public class CopyOnWriteArraySet&lt;E> extends AbstractSet&lt;E> implements Serializable {
	private final CopyOnWriteArrayList&lt;E> al;

	/** 内部使用的是 CopyOnWriteArrayList */
	public CopyOnWriteArraySet() {
		al = new CopyOnWriteArrayList&lt;E>();
	}

	public CopyOnWriteArraySet(Collection&lt;? extends E> c) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 如果指定元素并不存在于此 set 中，则添加它</p></li>
									<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 如果此 set 中没有指定 c 中的所有元素，则将它们都添加到此 set 中</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 如果指定元素存在于此 set 中，则将其移除</p></li>
									<li><p><code>boolean 	removeAll(Collection&lt;?> c)</code> -- 移除此 set 中包含在指定 collection 中的所有元素</p></li>
									<li><p><code>boolean 	removeIf(Predicate&lt;? super E> filter)</code> -- 删除符合条件的项目</p></li>

									<li class="group"><p><code>boolean 	isEmpty()</code> -- 如果此 set 不包含任何元素，则返回 true</p></li>
									<li><p><code>void 	clear()</code> -- 移除此 set 中的所有元素</p></li>
									<li><p><code>int 	size()</code> -- 返回此 set 中的元素数目</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此 set 包含指定元素，则返回 true</p></li>
									<li><p><code>boolean 	containsAll(Collection&lt;?> c)</code> -- 如果此 set 包含指定 collection 的所有元素，则返回 true</p></li>
									<li><p><code>boolean 	retainAll(Collection&lt;?> c)</code> -- 仅保留此 set 中那些包含在指定 collection 中的元素</p></li>

									<li class="group"><p><code>void 	forEach(Consumer&lt;? super E> action)</code> -- 循环</p></li>
									<li><p><code>Iterator&lt;E> 	iterator()</code> -- 迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 拆分迭代器</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回一个包含此 set 所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回一个包含此 set 所有元素的数组</p></li>
									<li><p><code>boolean 	equals(Object o)</code> -- 比较指定对象与此 set 的相等性</p></li>

								</ol>
							</div>

							<a id="ConcurrentSkipListSet" class="offset"></a>
							<div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/ConcurrentSkipListSet.html" target="_blank">ConcurrentSkipListSet</a> 一个基于 <a href="#ConcurrentSkipListMap">ConcurrentSkipListMap</a> 的可缩放并发 NavigableSet 实现。set 的元素可以根据它们的自然顺序进行排序，也可以根据创建 set 时所提供的 Comparator 进行排序，具体取决于使用的构造方法。 </p>
								<p>此实现为 contains、add、remove 操作及其变体提供预期平均 log(n) 时间开销。多个线程可以安全地并发执行插入、移除和访问操作。迭代器是弱一致 的，返回的元素将反映迭代器创建时或创建后某一时刻的 set 状态。它们不 抛出 ConcurrentModificationException，可以并发处理其他操作。升序排序视图及其迭代器比降序排序视图及其迭代器更快。 </p>
								<p>注意，与在大多数 collection 中不同，这里的 size 方法不是 一个固定时间 (constant-time) 操作。由于这些 set 的异步特性，确定元素的当前数目需要遍历元素。此外，批量操作 addAll、removeAll、retainAll 和 containsAll 并不 保证能以原子方式 (atomically) 执行。例如，与 addAll 操作一起并发操作的迭代器只能查看某些附加元素。 </p>
								<pre class="brush: java;">
public class ConcurrentSkipListSet&lt;E> extends AbstractSet&lt;E> implements NavigableSet&lt;E>,
									Cloneable, Serializable {
	/** 构造的是 ConcurrentSkipListMap */
	public ConcurrentSkipListSet() {}
	public ConcurrentSkipListSet(Collection&lt;? extends E> c) {}
	public ConcurrentSkipListSet(Comparator&lt;? super E> comparator) {}
	public ConcurrentSkipListSet(SortedSet&lt;E> s) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 调用的是 <a href="#ConcurrentSkipListMap">ConcurrentSkipListMap</a> 的 <code>putIfAbsent(e, Boolean.TRUE)</code> 方法</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 将指定的元素从 set 中移除</p></li>
									<li><p><code>boolean 	removeAll(Collection&lt;?> c)</code> -- 移除此 set 中的在 c 中的元素</p></li>
									<li><p><code>void 	clear()</code> -- 移除此 set 中的所有元素</p></li>
									<li><p><code>int 	size()</code> -- 返回 set 中的元素数</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 是否为空</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此 set 包含指定的元素，则返回 true</p></li>

									<li class="group"><p><code>E 	first()</code> -- 返回此 set 中当前第一个（最低）元素</p></li>
									<li><p><code>E 	last()</code> -- 返回此 set 中当前最后一个（最高）元素</p></li>
									<li><p><code>E 	ceiling(E e)</code> -- 返回此 set 中大于等于给定元素的最小元素</p></li>
									<li><p><code>E 	floor(E e)</code> -- 返回此 set 中小于等于给定元素的最大元素</p></li>
									<li><p><code>E 	higher(E e)</code> -- 返回此 set 中严格大于给定元素的最小元素</p></li>
									<li><p><code>E 	lower(E e)</code> -- 返回此 set 中严格小于给定元素的最大元素</p></li>

									<li class="group"><p><code>E 	pollFirst()</code> -- 获取并移除第一个（最低）元素</p></li>
									<li><p><code>E 	pollLast()</code> -- 获取并移除最后一个（最高）元素</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	descendingIterator()</code> -- 返回在此 set 元素上按降序进行迭代的迭代</p></li>
									<li><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此 set 中的元素上按升序进行迭代的迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 可拆分迭代器</p></li>

									<li class="group"><p><code>NavigableSet&lt;E> 	headSet(E toElement)</code> -- 返回此 set 的部分视图，其元素严格小于 toElement</p></li>
									<li><p><code>NavigableSet&lt;E> 	headSet(E toElement, boolean inclusive)</code> -- 返回此 set 的部分视图，其元素小于（或等于，如果 inclusive 为 true）toElement</p></li>
									<li><p><code>NavigableSet&lt;E> 	subSet(E fromElement, E toElement)</code> -- 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）</p></li>
									<li><p><code>NavigableSet&lt;E> 	subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)</code> -- 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement</p></li>
									<li><p><code>NavigableSet&lt;E> 	tailSet(E fromElement)</code> -- 返回此 set 的部分视图，其元素大于等于 fromElement</p></li>
									<li><p><code>NavigableSet&lt;E> 	tailSet(E fromElement, boolean inclusive)</code> -- 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement</p></li>
									<li><p><code>NavigableSet&lt;E> 	descendingSet()</code> --  返回此 set 中所包含元素的逆序视图</p></li>

									<li class="group"><p><code>Comparator&lt;? super E> 	comparator()</code> -- 返回对此 set 中的元素进行排序的比较器</p></li>
									<li><p><code>boolean 	equals(Object o)</code> -- 是否相等</p></li>
									<li><p><code>ConcurrentSkipListSet&lt;E> 	clone()</code> -- 返回 TreeSet 实例的浅表副本</p></li>
								</ol>
							</div>
						</div>

						<div class="sub-item">
							<a id="AbstractQueue" class="offset"></a>
							<div class="split-item">
								<p><a href="docs/docs-java/api/java/util/AbstractQueue.html" target="_blank">AbstractQueue</a> 类提供某些 Queue 操作的骨干实现。此类中的实现适用于基本实现不 允许包含 null 元素时。add、remove 和 element 方法分别基于 offer、poll 和 peek 方法，但是它们通过抛出异常而不是返回 false 或 null 来指示失败。 </p>
								<p>扩展此类的 Queue 实现至少必须定义一个不允许插入 null 元素的 Queue.offer(E) 方法，该方法以及 Queue.peek()、Queue.poll()、Collection.size() 和 Collection.iterator() 都支持 Iterator.remove() 方法。通常还要重写其他方法。如果无法满足这些要求，那么可以转而考虑为 AbstractCollection 创建子类。</p>
								<pre class="brush: java;">
public abstract class AbstractQueue&lt;E> extends AbstractCollection&lt;E> implements Queue&lt;E> {
	protected AbstractQueue() {}
}
</pre>
								<ul>
									<li><p><code>boolean 	add(E e)</code> --  将指定的元素插入到此队列中（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用空间，则抛出 IllegalStateException</p></li>
									<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 将指定 collection 中的所有元素都添加到此队列中</p></li>
									<li><p><code>void 	clear()</code> -- 移除此队列中的所有元素</p></li>
									<li><p><code>E 	element()</code> -- 获取但不移除此队列的头</p></li>
									<li><p><code>E 	remove()</code> -- 获取并移除此队列的头</p></li>
								</ul>
							</div>

							<a id="PriorityQueue" class="offset"></a>
							<div class="split-item">
								<p><a href="docs/docs-java/api/java/util/PriorityQueue.html" target="_blank">PriorityQueue</a> 一个基于优先级堆的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。优先级队列不允许使用 null 元素。依靠自然顺序的优先级队列还不允许插入不可比较的对象（这样做可能导致 ClassCastException）。 </p>
								<p>此队列的头 是按指定排序方式确定的最小 元素。如果多个元素都是最小值，则头是其中一个元素——选择方法是任意的。队列获取操作 poll、remove、peek 和 element 访问处于队列头的元素。 </p>
								<p>优先级队列是无界的，但是有一个内部容量，控制着用于存储队列元素的数组大小。它通常至少等于队列的大小。随着不断向优先级队列添加元素，其容量会自动增加。无需指定容量增加策略的细节。 </p>
								<p>实现注意事项：此实现为排队和出队方法（offer、poll、remove() 和 add）提供 O(log(n)) 时间；为 remove(Object) 和 contains(Object) 方法提供线性时间；为获取方法（peek、element 和 size）提供固定时间。 </p>
								<pre class="brush: java;">
public class PriorityQueue&lt;E> extends AbstractQueue&lt;E> implements Serializable {
	transient Object[] queue; // 数组存储数据

	public PriorityQueue() {}
	public PriorityQueue(Collection&lt;? extends E> c) {}
	public PriorityQueue(Comparator&lt;? super E> comparator) {}
	public PriorityQueue(int initialCapacity) {}
	public PriorityQueue(int initialCapacity, Comparator&lt;? super E> comparator) {}
	public PriorityQueue(PriorityQueue&lt;? extends E> c) {}
	public PriorityQueue(SortedSet&lt;? extends E> c) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	offer(E e)</code> -- 将指定的元素插入此优先级队列</p></li>
									<li><p><code>E 	peek()</code> -- 获取但不移除此队列的头</p></li>
									<li><p><code>E 	poll()</code> -- 获取并移除此队列的头</p></li>
									<li><p><code>boolean 	add(E e)</code> -- 调用的是 <code>offer(E)</code></p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 从此队列中移除指定元素的单个实例</p></li>

									<li class="group"><p><code>void 	clear()</code> -- 从此优先级队列中移除所有元素</p></li>
									<li><p><code>int 	size()</code> -- 返回此 collection 中的元素数</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此队列包含指定的元素，则返回 true</p></li>

									<li class="group"><p><code>Comparator&lt;? super E> 	comparator()</code> -- 返回用来对此队列中的元素进行排序的比较器</p></li>
									<li><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此队列中的元素上进行迭代的迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 可拆分迭代器</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回一个包含此队列所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回一个包含此队列所有元素的数组；返回数组的运行时类型是指定数组的类型</p></li>
								</ol>
							</div>

							<a id="ArrayBlockingQueue" class="offset"></a>
							<div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/ArrayBlockingQueue.html" target="_blank">ArrayBlockingQueue</a> 一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。 </p>
								<p>这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。 </p>
								<p>此类支持对等待的生产者线程和使用者线程进行排序的可选公平策略。默认情况下，不保证是这种排序。然而，通过将公平性 (fairness) 设置为 true 而构造的队列允许按照 FIFO 顺序访问线程。公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”。</p>
								<pre class="brush: java;">
public class ArrayBlockingQueue&lt;E> extends AbstractQueue&lt;E> implements BlockingQueue&lt;E>, Serializable {
	public ArrayBlockingQueue(int capacity) {}
	public ArrayBlockingQueue(int capacity, boolean fair) {}
	public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E> c) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 将指定的元素插入到此队列的尾部，如果此队列已满，则抛出 IllegalStateException</p></li>
									<li><p><code>void 	put(E e)</code> -- 将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间</p></li>
									<li><p><code>boolean 	offer(E e)</code> -- 将指定的元素插入到此队列的尾部，如果此队列已满，则返回 false</p></li>
									<li><p><code>boolean 	offer(E e, long timeout, TimeUnit unit)</code> -- 将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间</p></li>
									<li><p><code>E 	peek()</code> -- 获取但不移除此队列的头</p></li>
									<li><p><code>E 	poll()</code> --  获取并移除此队列的头</p></li>
									<li><p><code>E 	poll(long timeout, TimeUnit unit)</code> -- 获取并移除此队列的头部，在指定的等待时间前等待可用的元素</p></li>
									<li><p><code>E 	take()</code> -- 获取并移除此队列的头部，在元素变得可用之前一直等待</p></li>

									<li class="group"><p><code>void 	clear()</code> -- 自动移除此队列中的所有元素</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 从此队列中移除指定元素的单个实例</p></li>
									<li><p><code>int 	drainTo(Collection&lt;? super E> c)</code> -- 移除此队列中所有可用的元素，并将它们添加到给定 collection 中</p></li>
									<li><p><code>int 	drainTo(Collection&lt;? super E> c, int maxElements)</code> -- 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</p></li>


									<li class="group"><p><code>int 	size()</code> -- 返回此队列中元素的数量</p></li>
									<li><p><code>int 	remainingCapacity()</code> -- 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的其他元素数量</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此队列包含指定的元素，则返回 true</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此队列中的元素上按适当顺序进行迭代的迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 可拆分迭代器</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回一个按适当顺序包含此队列中所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型</p></li>
									<li><p><code>String 	toString()</code> -- 返回此 collection 的字符串表示形式</p></li>
								</ol>
							</div>

							<a id="LinkedBlockingQueue" class="offset"></a>
							<div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/LinkedBlockingQueue.html" target="_blank">LinkedBlockingQueue</a> 一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO（先进先出）排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 </p>
								<p>可选的容量范围构造方法参数作为防止队列过度扩展的一种方法。如果未指定容量，则它等于 Integer.MAX_VALUE。除非插入节点会使队列超出容量，否则每次插入后会动态地创建链接节点。 </p>
								<pre class="brush: java;">
public class LinkedBlockingQueue&lt;E> extends AbstractQueue&lt;E> implements BlockingQueue&lt;E>, Serializable {
	public LinkedBlockingQueue() {}
	public LinkedBlockingQueue(int capacity) {}
	public LinkedBlockingQueue(Collection&lt;? extends E> c) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 将指定的元素插入到此队列的尾部，如果此队列已满，则抛出 IllegalStateException</p></li>
									<li><p><code>void 	put(E e)</code> -- 将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间</p></li>
									<li><p><code>boolean 	offer(E e)</code> -- 将指定的元素插入到此队列的尾部，如果此队列已满，则返回 false</p></li>
									<li><p><code>boolean 	offer(E e, long timeout, TimeUnit unit)</code> -- 将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间</p></li>
									<li><p><code>E 	peek()</code> -- 获取但不移除此队列的头</p></li>
									<li><p><code>E 	poll()</code> --  获取并移除此队列的头</p></li>
									<li><p><code>E 	poll(long timeout, TimeUnit unit)</code> -- 获取并移除此队列的头部，在指定的等待时间前等待可用的元素</p></li>
									<li><p><code>E 	take()</code> -- 获取并移除此队列的头部，在元素变得可用之前一直等待</p></li>

									<li class="group"><p><code>void 	clear()</code> -- 自动移除此队列中的所有元素</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 从此队列中移除指定元素的单个实例</p></li>
									<li><p><code>int 	drainTo(Collection&lt;? super E> c)</code> -- 移除此队列中所有可用的元素，并将它们添加到给定 collection 中</p></li>
									<li><p><code>int 	drainTo(Collection&lt;? super E> c, int maxElements)</code> -- 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</p></li>


									<li class="group"><p><code>int 	size()</code> -- 返回此队列中元素的数量</p></li>
									<li><p><code>int 	remainingCapacity()</code> -- 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的其他元素数量</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此队列包含指定的元素，则返回 true</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此队列中的元素上按适当顺序进行迭代的迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 可拆分迭代器</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回一个按适当顺序包含此队列中所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型</p></li>
									<li><p><code>String 	toString()</code> -- 返回此 collection 的字符串表示形式</p></li>
								</ol>
							</div>

							<a id="LinkedBlockingDeque" class="offset"></a>
							<div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/LinkedBlockingDeque.html" target="_blank">LinkedBlockingDeque</a> 一个基于已链接节点的、任选范围的阻塞双端队列。</p>
								<p> 可选的容量范围构造方法参数是一种防止过度膨胀的方式。如果未指定容量，那么容量将等于 Integer.MAX_VALUE。只要插入元素不会使双端队列超出容量，每次插入后都将动态地创建链接节点。</p>
								<pre class="brush: java;">
public class LinkedBlockingDeque&lt;E> extends AbstractQueue&lt;E> implements BlockingDeque&lt;E>, Serializable {
	public LinkedBlockingDeque() {}
	public LinkedBlockingDeque(Collection&lt;? extends E> c) {}
	public LinkedBlockingDeque(int capacity) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	offerLast(E e)</code> -- 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的末尾，并在成功时返回 true；如果当前没有空间可用，则返回 false。</p></li>
									<li><p><code>boolean 	offerLast(E e, long timeout, TimeUnit unit)</code> --将指定的元素插入此双端队列的末尾，必要时将在指定的等待时间内等待可用空间</p></li>
									<li><p><code>boolean 	offer(E e)</code> -- 调用 <code>offerLast(E)</code></p></li>
									<li><p><code>boolean 	offer(E e, long timeout, TimeUnit unit)</code> -- 将指定的元素插入此双端队列的末尾，必要时将在指定的等待时间内等待可用空间</p></li>
									<li><p><code>boolean 	offerFirst(E e)</code> -- 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的开头，并在成功时返回 true；如果当前没有空间可用，则返回 false</p></li>
									<li><p><code>boolean 	offerFirst(E e, long timeout, TimeUnit unit)</code> -- 将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），必要时将在指定的等待时间内一直等待可用空间</p></li>

									<li class="group"><p><code>E 	getFirst()</code> -- 获取，但不移除此双端队列的第一个元素</p></li>
									<li><p><code>E 	element()</code> -- 调用 <code>getFirst()</code></p></li>
									<li><p><code>E 	getLast()</code> -- 获取，但不移除此双端队列的最后一个元素</p></li>

									<li class="group"><p><code>E 	peekFirst()</code> -- 获取，但不移除此双端队列的第一个元素；如果此双端队列为空，则返回 null</p></li>
									<li><p><code>E 	peek()</code> -- 调用 <code>peekFirst()</code></p></li>
									<li><p><code>E 	peekLast()</code> -- 获取，但不移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null</p></li>

									<li class="group"><p><code>void 	put(E e)</code> -- 调用 <code>putLast(E)</code></p></li>
									<li><p><code>void 	putFirst(E e)</code> -- 将指定的元素插入此双端队列的开头，必要时将一直等待可用空间</p></li>
									<li><p><code>void 	putLast(E e)</code> -- 将指定的元素插入此双端队列的末尾，必要时将一直等待可用空间</p></li>

									<li class="group"><p><code>E 	poll()</code> -- 调用 <code>pollFirst()</code></p></li>
									<li><p><code>E 	poll(long timeout, TimeUnit unit)</code> -- 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素），如有必要将在指定的等待时间内等待可用元素</p></li>
									<li><p><code>E 	pollFirst()</code> -- 获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null</p></li>
									<li><p><code>E 	pollFirst(long timeout, TimeUnit unit)</code> -- 获取并移除此双端队列的第一个元素，必要时将在指定的等待时间等待可用元素</p></li>
									<li><p><code>E 	pollLast()</code> -- 获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null</p></li>
									<li><p><code>E 	pollLast(long timeout, TimeUnit unit)</code> -- 获取并移除此双端队列的最后一个元素，必要时将在指定的等待时间内等待可用元素</p></li>

									<li class="group"><p><code>boolean 	add(E e)</code> -- 调用 <code>addLast(E)</code></p></li>
									<li><p><code>void 	addFirst(E e)</code> -- 调用 <code>offerFirst(E)</code>, 为 false 则抛出异常</p></li>
									<li><p><code>void 	addLast(E e)</code> -- 调用 <code>offerLast(E)</code>, 为 false 则抛出异常</p></li>

									<li class="group"><p><code>E 	remove()</code> -- 调用 <code>removeFirst()</code></p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 调用 <code>removeFirstOccurrence(Object)</code></p></li>
									<li><p><code>E 	removeFirst()</code> -- 调用 <code>pollFirst()</code>, 如果返回值为 null 则抛出 NoSuchElementException 异常</p></li>
									<li><p><code>boolean 	removeFirstOccurrence(Object o)</code> -- 从此双端队列移除第一次出现的指定元</p></li>
									<li><p><code>E 	removeLast()</code> -- 调用 <code>pollLast()</code>, 如果返回值为 null 则抛出 NoSuchElementException 异常</p></li>
									<li><p><code>boolean 	removeLastOccurrence(Object o)</code> -- 从此双端队列移除最后一次出现的指定元素</p></li>

									<li class="group"><p><code>E 	pop()</code> -- 调用 <code>removeFirst(E)</code></p></li>
									<li><p><code>void 	push(E e)</code> --  调用 <code>addFirst(E)</code></p></li>

									<li class="group"><p><code>E 	take()</code> -- 调用 <code>takeFirst()</code></p></li>
									<li><p><code>E 	takeFirst()</code> -- 获取并移除此双端队列的第一个元素，必要时将一直等待可用元素</p></li>
									<li><p><code>E 	takeLast()</code> -- 获取并移除此双端队列的最后一个元素，必要时将一直等待可用元素</p></li>

									<li class="group"><p><code>int 	drainTo(Collection&lt;? super E> c)</code> -- 移除此队列中所有可用的元素，并将它们添加到给定 collection 中</p></li>
									<li><p><code>int 	drainTo(Collection&lt;? super E> c, int maxElements)</code> -- 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</p></li>

									<li class="group"><p><code>int 	size()</code> -- 返回此队列中元素的数量</p></li>
									<li><p><code>void 	clear()</code> -- 自动移除此队列中的所有元素</p></li>
									<li><p><code>int 	remainingCapacity()</code> -- 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的其他元素数量</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此队列包含指定的元素，则返回 true</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此队列中的元素上按适当顺序进行迭代的迭代器</p></li>
									<li><p><code>Iterator&lt;E> 	descendingIterator()</code> -- 逆序迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 可拆分迭代器</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回一个按适当顺序包含此队列中所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型</p></li>
									<li><p><code>String 	toString()</code> -- 返回此 deque 的字符串表示形式</p></li>
								</ol>
							</div>

							<a id="PriorityBlockingQueue" class="offset"></a>
							<div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/PriorityBlockingQueue.html" target="_blank">PriorityBlockingQueue</a> 一个无界阻塞队列，它使用与类 PriorityQueue 相同的顺序规则，并且提供了阻塞获取操作。虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败（导致 OutOfMemoryError）。此类不允许使用 null 元素。依赖自然顺序的优先级队列也不允许插入不可比较的对象（这样做会导致抛出 ClassCastException）。 </p>
								<p>此类及其迭代器可以实现 Collection 和 Iterator 接口的所有可选 方法。iterator() 方法中提供的迭代器并不 保证以特定的顺序遍历 PriorityBlockingQueue 的元素。如果需要有序地进行遍历，则应考虑使用 Arrays.sort(pq.toArray())。此外，可以使用方法 drainTo 按优先级顺序移除 全部或部分元素，并将它们放在另一个 collection 中。 </p>
								<p>在此类上进行的操作不保证具有同等优先级的元素的顺序。如果需要实施某一排序，那么可以定义自定义类或者比较器，比较器可使用修改键断开主优先级值之间的联系。</p>
								<pre class="brush: java;">
public class PriorityBlockingQueue&lt;E> extends AbstractQueue&lt;E> implements BlockingQueue&lt;E>,Serializable {
	public PriorityBlockingQueue() {}
	public PriorityBlockingQueue(Collection&lt;? extends E> c) {}
	public PriorityBlockingQueue(int initialCapacity) {}
	public PriorityBlockingQueue(int initialCapacity, Comparator&lt;? super E> comparator) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	offer(E e)</code> -- 将指定元素插入此优先级队列</p></li>
									<li><p><code>boolean 	offer(E e, long timeout, TimeUnit unit)</code> -- 调用 <code>offer(E)</code>, 后面两个参数未使用</p></li>
									<li><p><code>void 	put(E e)</code> -- 调用 <code>offer(E)</code></p></li>
									<li><p><code>boolean 	add(E e)</code> -- 调用 <code>offer(E)</code></p></li>

									<li class="group"><p><code>E 	peek()</code> -- 获取但不移除此队列的头；如果此队列为空，则返回 null</p></li>
									<li><p><code>E 	poll()</code> -- 获取并移除此队列的头，如果此队列为空，则返回 null</p></li>
									<li><p><code>E 	poll(long timeout, TimeUnit unit)</code> --  获取并移除此队列的头部，在指定的等待时间前等待可用的元素</p></li>
									<li><p><code>E 	take()</code> -- 获取并移除此队列的头部，在元素变得可用之前一直等待</p></li>

									<li class="group"><p><code>int 	drainTo(Collection&lt;? super E> c)</code> -- 移除此队列中所有可用的元素，并将它们添加到给定 collection 中</p></li>
									<li><p><code>int 	drainTo(Collection&lt;? super E> c, int maxElements)</code> -- 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</p></li>

									<li class="group"><p><code>boolean 	remove(Object o)</code> -- 从队列中移除指定元素的单个实例</p></li>
									<li><p><code>void 	clear()</code> -- 完全移除此队列中的所有元素</p></li>
									<li><p><code>int 	size()</code> -- 返回此 collection 中的元素数</p></li>
									<li><p><code>int 	remainingCapacity()</code> -- 总是返回 Integer.MAX_VALUE，因为 PriorityBlockingQueue 没有容量限制</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果队列包含指定的元素，则返回 true</p></li>
									<li><p><code>Comparator&lt;? super E> 	comparator()</code> -- 返回用于对此队列元素进行排序的比较器</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此队列元素上进行迭代的迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 拆分迭代器</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回包含此队列所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回一个包含此队列所有元素的数组；返回数组的运行时类型是指定数组的类型</p></li>
									<li><p><code>String 	toString()</code> -- 返回此 collection 的字符串表示形式</p></li>
								</ol>
							</div>

							<a id="SynchronousQueue" class="offset"></a>
							<div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/SynchronousQueue.html" target="_blank">SynchronousQueue</a> 一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。</p>
								<p>同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。队列的头 是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），SynchronousQueue 作为一个空 collection。此队列不允许 null 元素。 </p>
								<p>同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。 </p>
								<p>对于正在等待的生产者和使用者线程而言，此类支持可选的公平排序策略。默认情况下不保证这种排序。但是，使用公平设置为 true 所构造的队列可保证线程以 FIFO 的顺序进行访问。 </p>
								<pre class="brush: java;">
public class SynchronousQueue&lt;E> extends AbstractQueue&lt;E> implements BlockingQueue&lt;E>, Serializable {
	public SynchronousQueue() {}
	public SynchronousQueue(boolean fair) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	offer(E e)</code> -- 如果另一个线程正在等待以便接收指定元素，则将指定元素插入到此队列</p></li>
									<li><p><code>boolean 	offer(E e, long timeout, TimeUnit unit)</code> -- 将指定元素插入到此队列，如有必要则等待指定的时间，以便另一个线程接收它</p></li>
									<li><p><code>E 	take()</code> -- 获取并移除此队列的头，如有必要则等待另一个线程插入它</p></li>
									<li><p><code>E 	peek()</code> -- 始终返回 null</p></li>
									<li><p><code>E 	poll()</code> -- 如果另一个线程当前正要使用某个元素，则获取并移除此队列的头</p></li>
									<li><p><code>E 	poll(long timeout, TimeUnit unit)</code> -- 获取并移除此队列的头，如有必要则等待指定的时间，以便另一个线程插入它</p></li>
									<li><p><code>void 	put(E e)</code> -- 将指定元素添加到此队列，如有必要则等待另一个线程接收它</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 始终返回 false</p></li>
									<li><p><code>boolean 	removeAll(Collection&lt;?> c)</code> -- 始终返回 false</p></li>

									<li class="group"><p><code>void 	clear()</code> -- 不执行任何操作</p></li>
									<li><p><code>int 	size()</code> -- 始终返回 0</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 始终返回 true</p></li>
									<li><p><code>int 	remainingCapacity()</code> -- 始终返回 0</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 始终返回 false</p></li>
									<li><p><code>boolean 	containsAll(Collection&lt;?> c)</code> -- 除非给定 collection 为空，否则返回 false</p></li>
									<li><p><code>boolean 	retainAll(Collection&lt;?> c)</code> -- 始终返回 false</p></li>

									<li class="group"><p><code>int 	drainTo(Collection&lt;? super E> c)</code> -- 移除此队列中所有可用的元素，并将它们添加到给定 collection 中</p></li>
									<li><p><code>int 	drainTo(Collection&lt;? super E> c, int maxElements)</code> -- 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</p></li>


									<li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 返回一个空迭代器，其中 hasNext 始终返回 false</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 拆分迭代器</p></li>


									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回一个 0 长度的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 将指定数组的第 0 个元素设置为 null（如果该数组有非 0 的长度）并返回它</p></li>
								</ol>
							</div>

							<a id="DelayQueue" class="offset"></a>
							<div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/DelayQueue.html" target="_blank">DelayQueue</a> 是 Delayed 元素的一个无界阻塞队列，只有在延迟期满时才能从中提取元素。</p>
								<p>该队列的头部 是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于等于 0 的值时，将发生到期。即使无法使用 take 或 poll 移除未到期的元素，也不会将这些元素作为正常元素对待。例如，size 方法同时返回到期和未到期元素的计数。此队列不允许使用 null 元素。 </p>
								<pre class="brush: java;">
public class DelayQueue&lt;E extends Delayed> extends AbstractQueue&lt;E> implements BlockingQueue&lt;E> {
	public DelayQueue() {}
	public DelayQueue(Collection&lt;? extends E> c)	{}
}

DelayQueue&lt;MyDelayed> queue = new DelayQueue<>();
new MyDelayedService(queue).start();
queue.offer(new MyDelayed(1, TimeUnit.SECONDS, () -> {
	Log.d("task 1 removed!");
}));
queue.offer(new MyDelayed(5, TimeUnit.SECONDS, () -> {
	Log.d("task 2 removed!");
}));
queue.offer(new MyDelayed(2, TimeUnit.SECONDS, () -> {
	Log.d("task 3 removed!");
}));

class MyDelayedService extends Thread {
	DelayQueue&lt;MyDelayed> queue;

	public MyDelayedService(DelayQueue&lt;MyDelayed> queue) {
		this.queue = queue;
	}

	@Override
	public void run() {
		super.run();
		while (true) {
			try {
				MyDelayed data = queue.take();
				data.getTask().run();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}

public class MyDelayed implements Delayed {
	private long endTime;
	private Runnable task;

	public MyDelayed(long delay, TimeUnit unit, Runnable task) {
		this.endTime = unit.toMillis(delay) + System.currentTimeMillis();
		this.task = task;
	}

	public Runnable getTask() {
		return task;
	}

	@Override
	public long getDelay(TimeUnit unit) {
		return unit.convert(endTime, TimeUnit.NANOSECONDS) -
									unit.convert(System.currentTimeMillis(), TimeUnit.NANOSECONDS);
	}

	@Override
	public int compareTo(Delayed o) {
		if (this == o)
			return 1;
		if (o == null)
			return -1;
		long diff = this.getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS);
		return diff < 0 ? -1 : (diff == 0 ? 0 : 1);
	}
}
</pre>
								<ol>
									<li><p><code>boolean 	offer(E e)</code> -- 将指定元素插入此延迟队列</p></li>
									<li><p><code>boolean 	offer(E e, long timeout, TimeUnit unit)</code> -- 调用 <code>offer(E)</code>, 后面两个参数未使用</p></li>
									<li><p><code>boolean 	add(E e)</code> -- 调用 <code>offer(E)</code></p></li>
									<li><p><code>void 	put(E e)</code> -- 调用 <code>offer(E)</code></p></li>

									<li class="group"><p><code>E 	peek()</code> -- 获取但不移除此队列的头部；如果此队列为空，则返回 null</p></li>
									<li><p><code>E 	poll()</code> -- 获取并移除此队列的头，如果此队列不包含具有已到期延迟时间的元素，则返回 null</p></li>
									<li><p><code>E 	poll(long timeout, TimeUnit unit)</code> -- 获取并移除此队列的头部，在可从此队列获得到期延迟的元素，或者到达指定的等待时间之前一直等待</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 从此队列中移除指定元素的单个实例（如果存在），无论它是否到期</p></li>
									<li><p><code>E 	take()</code> -- 获取并移除此队列的头部，在可从此队列获得到期延迟的元素之前一直等待</p></li>

									<li class="group"><p><code>int 	size()</code> -- 返回此 collection 中的元素数</p></li>
									<li><p><code>void 	clear()</code> -- 自动移除此延迟队列的所有元素</p></li>
									<li><p><code>int 	remainingCapacity()</code> -- 因为 DelayQueue 没有容量限制，所以它总是返回 Integer.MAX_VALUE</p></li>
									<li><p><code>int 	drainTo(Collection&lt;? super E> c)</code> -- 移除此队列中所有可用的元素，并将它们添加到给定 collection 中</p></li>
									<li><p><code>int 	drainTo(Collection&lt;? super E> c, int maxElements)</code> -- 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</p></li>
									<li><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此队列所有元素（既包括到期的，也包括未到期的）上进行迭代的迭代器</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回包含此队列所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回一个包含此队列所有元素的数组；返回数组的运行时类型是指定数组的类型</p></li>
								</ol>
							</div>

							<a id="ConcurrentLinkedQueue" class="offset"></a>
							<div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/ConcurrentLinkedQueue.html" target="_blank">ConcurrentLinkedQueue</a> 一个基于链接节点的无界线程安全队列。此队列按照 FIFO（先进先出）原则对元素进行排序。</p>
								<p>队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。 </p>
								<p>此实现采用了有效的“无等待 (wait-free)”算法。</p>
								<p>需要小心的是，与大多数 collection 不同，size 方法不是 一个固定时间操作。由于这些队列的异步特性，确定当前元素的数量需要遍历这些元素。</p>
								<pre class="brush: java;">
public class ConcurrentLinkedQueue&lt;E> extends AbstractQueue&lt;E> implements Queue&lt;E>, Serializable {
	public ConcurrentLinkedQueue() {}
	public ConcurrentLinkedQueue(Collection&lt;? extends E> c) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	offer(E e)</code> -- 将指定元素插入此队列的尾部</p></li>
									<li><p><code>boolean 	add(E e)</code> -- 调用 <code>offer(E)</code></p></li>
									<li><p><code>E 	peek()</code> -- 获取但不移除此队列的头；如果此队列为空，则返回 null</p></li>
									<li><p><code>E 	poll()</code> -- 获取并移除此队列的头，如果此队列为空，则返回 null</p></li>
									<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 将 c 中所有元素插入此队列</p></li>

									<li class="group"><p><code>boolean 	remove(Object o)</code> -- 从队列中移除指定元素的单个实例</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 如果此队列不包含任何元素，则返回 true</p></li>
									<li><p><code>int 	size()</code> -- 返回此队列中的元素数量</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此队列包含指定元素，则返回 true</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此队列元素上以恰当顺序进行迭代的迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 拆分迭代器</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回以恰当顺序包含此队列所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回以恰当顺序包含此队列所有元素的数组；返回数组的运行时类型是指定数组的运行时类型</p></li>
								</ol>
							</div>

							<a id="ConcurrentLinkedDeque" class="offset"></a>
							<div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/ConcurrentLinkedDeque.html" target="_blank">ConcurrentLinkedDeque</a> 一个基于链接双向节点的无界线程安全队列。此队列按照 FIFO（先进先出）原则对元素进行排序。</p>
								<p>并行插入、删除和访问操作安全地跨多个线程执行。当许多线程将共享对一个公共集合的访问时，并发进程是一个合适的选择。与大多数其他并发收集实现一样，此类不允许使用空元素。</p>
								<p>迭代器和拆分迭代器是弱一致的。</p>
								<p>注意，与大多数集合不同的是，大小方法不是固定时间操作。由于这些属性的异步性质，确定当前元素的数量需要遍历元素，因此如果在遍历期间修改该集合，则可能报告不准确的结果。</p>
								<pre class="brush: java;">
public class ConcurrentLinkedDeque&lt;E> extends AbstractCollection&lt;E> implements Deque&lt;E>, Serializable {
    public ConcurrentLinkedDeque() {}
    public ConcurrentLinkedDeque(Collection&lt;? extends E> c) {}
}
</pre>
								<ol>
									<li><p><code>    boolean 	offer(E e)</code> -- 调用 <code>offerLast(E)</code></p></li>
									<li><p><code>boolean 	add(E e)</code> -- 调用 <code>offerLast(E)</code></p></li>
									<li><p><code>void 	addLast(E e)</code> -- 调用 <code>offerLast(E)</code></p></li>
									<li><p><code>boolean 	offerFirst(E e)</code> -- 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的开头，并在成功时返回 true；如果当前没有空间可用，则返回 false</p></li>
									<li><p><code>boolean 	offerLast(E e)</code> -- 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的末尾，并在成功时返回 true；如果当前没有空间可用，则返回 false。</p></li>
									<li><p><code>void 	addFirst(E e)</code> -- 则将指定的元素插入此双端队列的开头</p></li>
									<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 按 c 的顺序将数据插入此双端队列</p></li>

									<li class="group"><p><code>E 	remove()</code> -- 调用 <code>removeFirst()</code></p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 移除指定元素</p></li>
									<li><p><code>E 	removeFirst()</code> -- 调用 <code>pollFirst()</code>, 如果为空则抛出 NoSuchElementException</p></li>
									<li><p><code>E 	removeLast()</code> -- 调用 <code>pollLast()</code>, 如果为空则抛出 NoSuchElementException</p></li>
									<li><p><code>boolean 	removeFirstOccurrence(Object o)</code> -- 此双端队列移除第一次出现的指定元素</p></li>
									<li><p><code>boolean 	removeLastOccurrence(Object o)</code> -- 从此双端队列移除最后一次出现的指定元素</p></li>

									<li class="group"><p><code>E 	pop()</code> -- 调用 <code>removeFirst()</code></p></li>
									<li><p><code>void 	push(E e)</code> -- 调用 <code>addFirst(E)</code></p></li>

									<li class="group"><p><code>E 	element()</code> -- 调用 <code>getFirst()</code></p></li>
									<li><p><code>E 	getFirst()</code> -- 调用 <code>peekFirst()</code>, 如果为空则抛出 NoSuchElementException<</p></li>
									<li><p><code>E 	getLast()</code> -- 调用 <code>peekLast()</code>, 如果为空则抛出 NoSuchElementException<</p></li>

									<li class="group"><p><code> E 	peek()</code> -- 调用 <code>peekFirst()</code></p></li>
									<li><p><code>E 	peekFirst()</code> -- 获取，但不移除此双端队列的第一个元素；如果此双端队列为空，则返回 null</p></li>
									<li><p><code>E 	peekLast()</code> -- 获取，但不移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null</p></li>

									<li class="group"><p><code>E 	poll()</code> -- 调用 <code>pollFirst()</code></p></li>
									<li><p><code>E 	pollFirst()</code> -- 获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null</p></li>
									<li><p><code>E 	pollLast()</code> -- 获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null</p></li>

									<li class="group"><p><code>int 	size()</code> -- 返回此队列中元素的数量</p></li>
									<li><p><code>void 	clear()</code> -- 自动移除此队列中的所有元素</p></li>
									<li><p><code> boolean 	isEmpty()</code> -- 是否为空</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此队列包含指定的元素，则返回 true</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	descendingIterator()</code> -- 返回逆序迭代器</p></li>
									<li><p><code>Iterator&lt;E> 	iterator()</code> -- 返回迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 返回拆分迭代器</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回一个按适当顺序包含此队列中所有元素的数组</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型</p></li>
								</ol>
							</div>

							<a id="LinkedTransferQueue" class="offset"></a>
							<div class="split-item">
								<p><code>java.util.concurrent.</code><a href="docs/docs-java/api/java/util/concurrent/LinkedTransferQueue.html" target="_blank">LinkedTransferQueue</a> 基于链接节点的无界传输队列。该队列针对任何给定的生产商订购元素FIFO（先进先出）。</p>
								<p>队列的头部是队列中的元素，对于某些生产者来说是最长的时间。队列的尾部是队列中的元素，对于某些生产者来说是最短的时间。</p>
								<p>注意，与大多数集合不同的是，<code>size()</code> 方法不是固定时间操作。由于这些队列的异步性质，确定当前元素的数量需要遍历元素，因此如果在遍历期间修改该集合，则可能报告不准确的结果。</p>
								<pre class="brush: java;">
public class LinkedTransferQueue&lt;E> extends AbstractQueue&lt;E> implements TransferQueue&lt;E>, Serializable {
    public LinkedTransferQueue() {}
    public LinkedTransferQueue(Collection&lt;? extends E> c) {}
}
</pre>
								<ol>
									<li><p><code>boolean 	add(E e)</code> -- 将元素插入队列，始终返回 true</p></li>
									<li><p><code>boolean 	offer(E e)</code> -- 同 <code>add(E)</code></p></li>
									<li><p><code>boolean 	offer(E e, long timeout, TimeUnit unit)</code> --  同 <code>offer(E)</code>，后面两个参数未使用</p></li>
									<li><p><code>void 	put(E e)</code> -- 将元素插入队列</p></li>
									<li><p><code>E 	peek()</code> -- 获取，但不移除此双端队列的第一个元素；如果此双端队列为空，则返回 null</p></li>
									<li><p><code>E 	poll()</code> -- 获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null</p></li>
									<li><p><code>E 	poll(long timeout, TimeUnit unit)</code> --  获取并移除此双端队列的第一个元素，如果需要的话，等待到指定的等待时间</p></li>
									<li><p><code>E 	take()</code> -- 获取并移除此队列的头部，在元素变得可用之前一直等待</p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 移除指定元素</p></li>

									<li class="group"><p><code>int 	drainTo(Collection<&lt;? super E> c)</code> -- 移除此队列中所有可用的元素，并将它们添加到给定 collection 中</p></li>
									<li><p><code>int 	drainTo(Collection&lt;? super E> c, int maxElements)</code> -- 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</p></li>


									<li class="group"><p><code>int 	size()</code> -- 返回此 collection 中的元素数</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 是否为空</p></li>
									<li><p><code>int 	remainingCapacity()</code> -- 总是返回 Integer.MAX_VALUE</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 是否包含指定元素</p></li>

									<li class="group"><p><code>int 	getWaitingConsumerCount()</code> -- 获取正在等待的消费者数量</p></li>
									<li><p><code>boolean 	hasWaitingConsumer()</code> -- 是否有正在等待的消费者</p></li>
									<li><p><code>void 	transfer(E e)</code> -- 将元素传递给消费者，如果需要的话则等待</p></li>
									<li><p><code>boolean 	tryTransfer(E e)</code> -- 如果可能的话，立即将元素传递给等待的消费者</p></li>
									<li><p><code>boolean 	tryTransfer(E e, long timeout, TimeUnit unit)</code> -- 在超时时间到达前，将元素传递给等待的消费者</p></li>

									<li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 拆分迭代器</p></li>


								</ol>
							</div>

						</div>

						<div class="sub-item">
							<a id="ArrayDeque" class="offset"></a>
							<div class="split-item">
								<p><a href="docs/docs-java/api/java/util/ArrayDeque.html" target="_blank">ArrayDeque</a> 是 Deque 接口的大小可变数组的实现。数组双端队列没有容量限制；它们可根据需要增加以支持使用。</p>
								<p>它们不是线程安全的；在没有外部同步时，它们不支持多个线程的并发访问。禁止 null 元素。此类很可能在用作堆栈时快于 Stack，在用作队列时快于 LinkedList。 </p>
								<p>大多数 ArrayDeque 操作以摊销的固定时间运行。异常包括 remove、removeFirstOccurrence、removeLastOccurrence、contains、iterator.remove() 以及批量操作，它们均以线性时间运行。 </p>
								<pre class="brush: java;">
public class ArrayDeque&lt;E> extends AbstractCollection&lt;E> implements Deque&lt;E>, Cloneable, Serializable {
	public ArrayDeque() {}
	public ArrayDeque(Collection&lt;? extends E> c) {}
	public ArrayDeque(int numElements) {}
}
</pre>
								<ol>
									<li><p><code>void 	addLast(E e)</code> -- 将指定元素插入此双端队列的末尾</p></li>
									<li><p><code>void 	addFirst(E e)</code> -- 将指定元素插入此双端队列的开头</p></li>
									<li><p><code>boolean 	add(E e)</code> -- 调用 <code>addLast(E)</code>, 始终返回 true</p></li>
									<li><p><code>boolean 	offer(E e)</code> -- 调用 <code>offerLast(E)</code></p></li>
									<li><p><code>boolean 	offerFirst(E e)</code> -- 调用 <code>offerFirst(E)</code>, 始终返回 true</p></li>
									<li><p><code>boolean 	offerLast(E e)</code> -- 调用 <code>addLast(E)</code>, 始终返回 true</p></li>

									<li class="group"><p><code>E 	remove()</code> -- 调用 <code>removeFirst()</code></p></li>
									<li><p><code>boolean 	remove(Object o)</code> -- 调用 <code>removeFirstOccurrence(Object)</code></p></li>
									<li><p><code>E 	removeFirst()</code> -- 调用 <code>pollFirst()</code>, 如果返回值为 null 则抛出 NoSuchElementException 异常</p></li>
									<li><p><code>E 	removeLast()</code> -- 调用 <code>pollLast()</code>, 如果返回值为 null 则抛出 NoSuchElementException 异常</p></li>
									<li><p><code>boolean 	removeFirstOccurrence(Object o)</code> -- 移除此双端队列中第一次出现的指定元素（当从头部到尾部遍历双端队列时）</p></li>
									<li><p><code>boolean 	removeLastOccurrence(Object o)</code> -- 获取并移除此双端队列的最后一个元素</p></li>

									<li class="group"><p><code>E 	pop()</code> -- 调用 <code>removeFirst()</code></p></li>
									<li><p><code>void 	push(E e)</code> -- 调用 <code>addFirst(E)</code></p></li>

									<li class="group"><p><code>E 	peek()</code> -- 调用 <code>peekFirst()</code></p></li>
									<li><p><code>E 	peekFirst()</code> -- 获取，但不移除此双端队列的第一个元素；如果此双端队列为空，则返回 null</p></li>
									<li><p><code>E 	peekLast()</code> -- 获取，但不移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null</p></li>

									<li class="group"><p><code>E 	poll()</code> -- 调用 <code>pollFirst()</code></p></li>
									<li><p><code>E 	pollFirst()</code> -- 获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null</p></li>
									<li><p><code>E 	pollLast()</code> -- 获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null</p></li>

									<li class="group"><p><code>E 	element()</code> -- 调用 <code>getFirst()</code></p></li>
									<li><p><code>E 	getFirst()</code> -- 获取，但不移除此双端队列的第一个元素</p></li>
									<li><p><code>E 	getLast()</code> -- 获取，但不移除此双端队列的最后一个元素</p></li>


									<li class="group"><p><code>void 	clear()</code> -- 从此双端队列中移除所有元</p></li>
									<li><p><code>ArrayDeque&lt;E> 	clone()</code> -- 返回此双端队列的副本</p></li>
									<li><p><code>boolean 	contains(Object o)</code> -- 如果此双端队列包含指定元素，则返回 true</p></li>

									<li class="group"><p><code>boolean 	isEmpty()</code> -- 如果此双端队列未包含任何元素，则返回 true</p></li>
									<li><p><code>int 	size()</code> -- 返回此双端队列中的元素数</p></li>
									<li><p><code>Iterator&lt;E> 	descendingIterator()</code> -- 返回以逆向顺序在此双端队列的元素上进行迭代的迭代器</p></li>
									<li><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此双端队列的元素上进行迭代的迭代器</p></li>
									<li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 拆分迭代器</p></li>

									<li class="group"><p><code>Object[] 	toArray()</code> -- 返回一个以恰当顺序包含此双端队列所有元素的数组（从第一个元素到最后一个元素）</p></li>
									<li><p><code>&lt;T> T[] 	toArray(T[] a)</code> -- 返回一个以恰当顺序包含此双端队列所有元素的数组（从第一个元素到最后一个元素）；返回数组的运行时类型是指定数组的运行时类型</p></li>
								</ol>
							</div>
						</div>

                        <div class="sub-item">
                            <a id="Dictionary" class="offset"></a>
                            <div class="split-item">
                            	<p><a href="docs/docs-java/api/java/util/Dictionary.html" target="_blank">Dictionary</a> 类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类。每个键和每个值都是一个对象。在任何一个 Dictionary 对象中，每个键至多与一个值相关联。给定一个 Dictionary 和一个键，就可以查找所关联的元素。任何非 null 对象都可以用作键或值。 </p>
								<p>常，应该在此类的实现中使用 equals 方法，以决定两个键是否相同。 </p>
                            	<pre class="brush: java;">
public abstract class Dictionary&lt;K,V> {}
</pre>
								<ol>
									<li><p><code>abstract V 	put(K key, V value)</code> -- 将指定 key 映射到此 dictionary 中指定 value</p></li>
									<li><p><code>abstract V 	get(Object key)</code> -- 返回此 dictionary 中该键所映射到的值</p></li>
									<li><p><code>abstract V 	remove(Object key)</code> -- 从此 dictionary 中移除 key （及其相应的 value）</p></li>

									<li class="group"><p><code>abstract boolean 	isEmpty()</code> -- 测试此 dictionary 是否不存在从键到值的映射</p></li>
									<li><p><code>abstract int 	size()</code> -- 返回此 dictionary 中条目（不同键）的数量</p></li>
									<li><p><code>abstract Enumeration&lt;K> 	keys()</code> -- 返回此 dictionary 中的键的枚举</p></li>
									<li><p><code>abstract Enumeration&lt;V> 	elements()</code> -- 返回此 dictionary 中值的枚举</p></li>
								</ol>
                            </div>

                            <a id="Hashtable" class="offset"></a>
                            <div class="split-item">
                            	<p><a href="docs/docs-java/api/java/util/Hashtable.html" target="_blank">Hashtable</a> 类实现一个哈希表，该哈希表将键映射到相应的值。任何非 null 对象都可以用作键或值。</p>
								<p>为了成功地在哈希表中存储和获取对象，用作键的对象必须实现 hashCode 方法和 equals 方法。</p>
								<p>Hashtable 的实例有两个参数影响其性能：初始容量 和加载因子。容量 是哈希表中桶 的数量，初始容量 就是哈希表创建时的容量。注意，哈希表的状态为 open：在发生“哈希冲突”的情况下，单个桶会存储多个条目，这些条目必须按顺序搜索。加载因子 是对哈希表在其容量自动增加之前可以达到多满的一个尺度。初始容量和加载因子这两个参数只是对该实现的提示。关于何时以及是否调用 rehash 方法的具体细节则依赖于该实现。</p>
								<p>通常，默认加载因子(.75)在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查找某个条目的时间（在大多数 Hashtable 操作中，包括 get 和 put 操作，都反映了这一点）。</p>
								<p>初始容量主要控制空间消耗与执行 rehash 操作所需要的时间损耗之间的平衡。如果初始容量大于 Hashtable 所包含的最大条目数除以加载因子，则永远 不会发生 rehash 操作。但是，将初始容量设置太高可能会浪费空间。</p>
								<p>如果很多条目要存储在一个 Hashtable 中，那么与根据需要执行自动 rehashing 操作来增大表的容量的做法相比，使用足够大的初始容量创建哈希表或许可以更有效地插入条目。</p>
                            	<pre class="brush: java;">
public class Hashtable&lt;K,V> extends Dictionary&lt;K,V> implements Map&lt;K,V>, Cloneable, Serializable {
	public Hashtable() {} // 用默认的初始容量 (11) 和加载因子 (0.75) 构造一个新的空哈希表
	public Hashtable(int initialCapacity) {}
	public Hashtable(int initialCapacity, float loadFactor) {}
	public Hashtable(Map&lt;? extends K,? extends V> t) {}
}
</pre>
								<ol>
									<li><p><code>V 	put(K key, V value)</code> -- 将指定值与此映射中的指定键进行关联</p></li>
									<li><p><code>V 	putIfAbsent(K key, V value)</code> -- 如果指定键已经不再与某个值相关联，则将它与给定值关联</p></li>
									<li><p><code>void 	putAll(Map&lt;? extends K,? extends V> t)</code> -- 将指定映射中所有映射关系复制到此映射中</p></li>
									<li><p><code>V 	get(Object key)</code> -- 返回指定键所映射的值</p></li>
									<li><p><code>V 	getOrDefault(Object key, V defaultValue)</code> -- 如果指定键返回值为 null, 则返回 defaultValue</p></li>
									<li><p><code>V 	remove(Object key)</code> -- 从哈希表中移除该键及其相应的值</p></li>
									<li><p><code>boolean 	remove(Object key, Object value)</code> -- 只有目前将键的条目映射到给定值时，才移除该键的条目</p></li>

									<li class="group"><p><code>int 	size()</code> -- 返回此哈希表中的键的数量</p></li>
									<li><p><code>void 	clear()</code> -- 从此映射中移除所有映射关系</p></li>
									<li><p><code>boolean 	isEmpty()</code> -- 是否为空</p></li>
									<li><p><code>boolean 	containsKey(Object key)</code> -- 如果此映射包含指定键的映射关系，则返回 true</p></li>
									<li><p><code>boolean 	containsValue(Object value)</code> -- 如果此映射将一个或多个键映射到指定值，则返回 true</p></li>
									<li><p><code>boolean 	contains(Object value)</code> -- 同 containsValue</p></li>

									<li class="group"><p><code>V 	compute(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- 参见 <a href="#HashMap">HashMap</a> 同名方法</p></li>
									<li><p><code>V 	computeIfAbsent(K key, Function&lt;? super K,? extends V> mappingFunction)</code> -- 参见 <a href="#HashMap">HashMap</a> 同名方法</p></li>
									<li><p><code>V 	computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- 参见 <a href="#HashMap">HashMap</a> 同名方法</p></li>

									<li class="group"><p><code>V 	replace(K key, V value)</code> -- 替换指定 key 的 value</p></li>
									<li><p><code>boolean 	replace(K key, V oldValue, V newValue)</code> -- 替换指定 key 的 指定 value 为 newValue</p></li>
									<li><p><code>void 	replaceAll(BiFunction&lt;? super K,? super V,? extends V> function)</code> -- 替换符合条件的 value</p></li>

									<li class="group"><p><code>Enumeration&lt;K> 	keys()</code> -- 键的枚举器，可用于迭代</p></li>
									<li><p><code>Enumeration&lt;V> 	elements()</code> -- 值的枚举器，可用于迭代</p></li>
									<li><p><code>Set&lt;K> 	keySet()</code> -- 返回 Key 的 Set 视图</p></li>
									<li><p><code>Set&lt;Map.Entry&lt;K,V>> 	entrySet()</code> -- 返回 Entry 的 Set 视图</p></li>
									<li><p><code>Collection&lt;V> 	values()</code> -- 返回此映射中包含的键的 Collection 视图</p></li>

									<li class="group"><p><code>void 	forEach(BiConsumer&lt;? super K,? super V> action)</code> -- 迭代</p></li>
									<li><p><code>V 	merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V> remappingFunction)</code> -- 替换或添加，可用判断 value 的情况进行操作</p></li>

									<li class="group"><p><code>boolean 	equals(Object o)</code> -- 比较指定对象与此映射的相等性</p></li>
									<li><p><code>Object 	clone()</code> -- 返回此枚举映射的浅表副本</p></li>
									<li><p><code>int 	hashCode()</code> -- 哈希值</p></li>
									<li><p><code>protected void 	rehash()</code> -- 增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素</p></li>
									<li><p><code>String 	toString()</code> -- 返回此 Hashtable 对象的字符串表示形式</p></li>
								</ol>
                            </div>

							<a id="Properties" class="offset"></a>
							<div class="split-item">
								<p><a href="docs/docs-java/api/java/util/Properties.html" target="_blank">Properties</a> 表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。 </p>
								<p>一个属性列表可包含另一个属性列表作为它的“默认值”；如果未能在原有的属性列表中搜索到属性键，则搜索第二个属性列表。 </p>
								<p>因为 Properties 继承于 Hashtable，所以可对 Properties 对象应用 put 和 putAll 方法。但不建议使用这两个方法，因为它们允许调用者插入其键或值不是 String 的项。相反，应该使用 setProperty 方法。如果在“不安全”的 Properties 对象（即包含非 String 的键或值）上调用 store 或 save 方法，则该调用将失败。类似地，如果在“不安全”的 Properties 对象（即包含非 String 的键）上调用 propertyNames 或 list 方法，则该调用将失败。</p>
								<p>此类是线程安全的：多个线程可以共享单个 Properties 对象而无需进行外部同步。</p>
								<pre class="brush: java;">
public class Properties extends Hashtable&lt;Object, Object> {
	protected Properties defaults; // 一个属性列表，包含属性列表中所有未找到值的键的默认值

	public Properties() {}
	public Properties(Properties defaults) {}
}
</pre>
								<ol>
									<li><p><code>Object 	setProperty(String key, String value)</code> -- 调用 Hashtable 的方法 put</p></li>
									<li><p><code>String 	getProperty(String key)</code> -- 用指定的键在此属性列表中搜索属性</p></li>
									<li><p><code>String 	getProperty(String key, String defaultValue)</code> -- 用指定的键在此属性列表中搜索属性，没有则返回默认值</p></li>

									<li class="group"><p><code>void 	store(OutputStream out, String comments)</code> -- 以适合使用 <code>load(InputStream)</code> 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。</p></li>
									<li><p><code>void 	store(Writer writer, String comments)</code> -- 以适合使用 <code>load(Reader)</code> 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符</p>
										<pre class="brush: java;">
/** 将 System.getProperties() 属性写入属性文件: */
Properties prop = System.getProperties();
try {
	prop.store(new FileOutputStream("./system.properties"), "System.getProperties() 方法");
} catch (IOException e) {
	e.printStackTrace();
}

// system.properties 内容如下:
#System.getProperties() 方法
#Mon Jul 30 17:50:52 CST 2018
java.runtime.name=Java(TM) SE Runtime Environment
sun.boot.library.path=/home/nate/installed/jdk1.8.0_65/jre/lib/i386
java.vm.version=25.65-b01
......
</pre>
									</li>
									<li><p><code>void 	storeToXML(OutputStream os, String comment)</code> -- 发出一个表示此表中包含的所有属性的 XML 文档</p></li>
									<li><p><code>void 	storeToXML(OutputStream os, String comment, String encoding)</code> -- 使用指定的编码发出一个表示此表中包含的所有属性的 XML 文档</p>
										<pre class="brush: java;">
/** 将 System.getProperties() 属性写入 xml 文件: */
Properties prop = System.getProperties();
try {
	prop.storeToXML(new FileOutputStream("./system.properties.xml"), "System.getProperties() 方法");
} catch (IOException e) {
	e.printStackTrace();
}

// system.properties.xml 内容如下:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>
&lt;!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
&lt;properties>
	&lt;comment>System.getProperties() 方法&lt;/comment>
	&lt;entry key="java.runtime.name">Java(TM) SE Runtime Environment&lt;/entry>
	&lt;entry key="sun.boot.library.path">/home/nate/installed/jdk1.8.0_65/jre/lib/i386&lt;/entry>
	&lt;entry key="java.vm.version">25.65-b01&lt;/entry>
	......
&lt;/properties>
</pre>
									</li>

									<li class="group"><p><code>void 	load(InputStream inStream)</code> -- 从输入流中读取属性列表（键和元素对）</p></li>
									<li><p><code>void 	load(Reader reader)</code> -- 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）</p></li>
									<li><p><code>void 	loadFromXML(InputStream in)</code> -- 将指定输入流中由 XML 文档所表示的所有属性加载到此属性表中</p></li>

									<li class="group"><p><code>void 	list(PrintStream out)</code> -- 将属性列表输出到指定的输出流</p></li>
									<li><p><code>void 	list(PrintWriter out)</code> -- 将属性列表输出到指定的输出流</p></li>

									<li class="group"><p><code>Enumeration&lt;?> 	propertyNames()</code> -- 返回此属性列表中所有键的枚举，包括默认属性列表中的不同键，如果同一名称的键尚未从主属性列表中找到</p></li>
									<li><p><code>Set&lt;String> 	stringPropertyNames()</code> -- 返回此属性列表中的键集</p></li>
								</ol>
								<p><b>系统属性键值：</b></p>
								<pre class="brush: java;">
Properties prop = System.getProperties();
prop.stringPropertyNames().forEach(s -> log(s, prop.getProperty(s)));
// prop.list(System.out);
</pre>
							</div>
						</div>

                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-function"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title"><code>java.util.function</code> 包</h3>
                    </div>
                    <div class="panel-body">
						<div class="sub-item">
                            <p><code>java.util.function</code> 包为 JDK8 添加的，是功能接口，为 lambda 表达式和方法引用提供目标类型。</p>
                            <p>每个功能接口都有一个抽象的方法，称为功能接口的功能方法，lambda表达式的参数和返回类型匹配或修改。</p>
                            <p>该软件包中的接口是 JDK 所使用的通用功能接口，也可供用户代码使用。虽然它们没有识别一个完整的函数形状集合，lambda 表达式可以被应用，但是它们提供了足够的覆盖共同需求的功能。</p>
                            <p>接口列表和简要说明:</p>
                            <pre class="brush: java;">
Supplier&lt;T> --          T get();                // 供应者，用于返回一个数据
Consumer&lt;T> --          void accept(T t);       // 消费者，消费一个数据
BiConsumer&lt;T, U> --     void accept(T t, U u);  // 消费者，消费相关联的两个数据
Predicate&lt;T> --         boolean test(T t);      // 测试一个数据是否符合条件
BiPredicate&lt;T, U> --    boolean test(T t, U u); // 测试相关联的两个数据是否符合条件
Function&lt;T, R> --       R apply(T t);           // 对数据进行变换返回新的类型数据
 └ UnaryOperator&lt;T> --  T apply(T t);           // Function 简单化，参数和返回值类型相同
BiFunction&lt;T, U, R> --  R apply(T t, U u);      // 对相关联的两个数据进行变换返回新的类型数据
 └ BinaryOperator&lt;T> -- T apply(T t, T t);      // BiFunction 简单化，参数和返回值类型相同

// 1.Supplier 变种
BooleanSupplier /** 用于获取一个 boolean 对象 */
IntSupplier /** 参照 Supplier， 用于获取一个 int */
LongSupplier /** 参照 Supplier， 用于获取一个 long */
DoubleSupplier /** 参照 Supplier， 用于获取一个 double */

// 2.Consumer 变种
IntConsumer /** 参照 Consumer， 接收一个 int，然后对 int 执行某些操作 */
LongConsumer /** 参照 Consumer， 接收一个 long，然后对 long 执行某些操作 */
DoubleConsumer /** 参照 Consumer， 接收一个 double，然后对 double 执行某些操作 */
ObjIntConsumer&lt;T> /** 参照 Consumer， 接收一个 T 和 一个 int */
ObjLongConsumer&lt;T> /** 参照 Consumer， 接收一个 T 和 一个 long */
ObjDoubleConsumer&lt;T> /** 参照 Consumer， 接收一个 T 和 一个 double */

// 3.Predicate 变种
IntPredicate /** 参照 Predicate， 接收一个 int，看其是否符合某些条件(返回 true 或 false) */
LongPredicate /** 参照 Predicate， 接收一个 long，看其是否符合某些条件(返回 true 或 false) */
DoublePredicate /** 参照 Predicate， 接收一个 double，看其是否符合某些条件(返回 true 或 false) */

// 4.Function 及 BiFunction 变种
IntFunction&lt;R> /** 参照 Function， 接收一个 int，返回 R 类型对象 */
LongFunction&lt;R> /** 参照 Function， 接收一个 long，返回 R 类型对象 */
DoubleFunction&lt;R> /** 参照 Function， 接收一个 double，返回 R 类型对象 */

IntToLongFunction /** 参照 Function， 接收一个 int，返回 long */
IntToDoubleFunction /** 参照 Function， 接收一个 int，返回 double */
LongToIntFunction /** 参照 Function， 接收一个 long，返回 int */
LongToDoubleFunction  /** 参照 Function， 接收一个 long，返回 double */
DoubleToIntFunction /** 参照 Function， 接收一个 double，返回 int */
DoubleToLongFunction /** 参照 Function， 接收一个 double，返回 long */

ToIntFunction&lt;T>  /** 参照 Function， 接收 T 返回 int */
ToLongFunction&lt;T> /** 参照 Function， 接收 T 返回 long */
ToDoubleFunction&lt;T> /** 参照 Function， 接收 T, 返回 double */
ToIntBiFunction&lt;T,U> /** 参照 BiFunction， 接收 T, U, 返回 int */
ToLongBiFunction&lt;T,U> /** 参照 BiFunction， 接收 T, U, 返回 long */
ToDoubleBiFunction&lt;T,U> /** 参照 BiFunction， 接收 T, U, 返回 double */

// 5.UnaryOperator 变种 */
IntUnaryOperator /** 参照 UnaryOperator， 接收一个int，返回一个新的或经过加工的 int */
LongUnaryOperator /** 参照 UnaryOperator， 接收一个 long，返回一个新的或经过加工的 long */
DoubleUnaryOperator /** 参照 UnaryOperator， 接收一个 double，返回一个新的或经过加工的 double */

// 6.BinaryOperator 变种 */
IntBinaryOperator /** 参照 BinaryOperator， 接收两个 int, 返回经过比较的 int */
LongBinaryOperator /** 参照 BinaryOperator， 接收两个 long, 返回经过比较的 long */
DoubleBinaryOperator /** 参照 BinaryOperator， 接收两个 double, 返回经过比较的 double */
</pre>
                            <p>标注为 <code>FunctionalInterface</code> 的接口被称为函数式接口，该接口只能有一个自定义方法，但是可以包括从 Object 类继承而来的方法。如果一个接口只有一个方法，则编译器会认为这就是一个函数式接口。是否是一个函数式接口，需要注意的有以下几点：</p>
                            <ul>
                                <li>该注解只能标记在”有且仅有一个抽象方法”的接口上；</li>
                                <li>JDK8 接口中的静态方法和默认方法，都不算是抽象方法；</li>
                                <li>接口默认继承 java.lang.Object，所以如果接口显示声明覆盖了 Object 中方法，那么也不算抽象方法；</li>
                                <li>该注解不是必须的，如果一个接口符合”函数式接口”定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了 @FunctionInterface，那么编译器会报错；</li>
                                <li>在一个接口中定义两个自定义的方法，就会产生 FunctionalInterfaceTest is not a functional interface 错误.</li>
                            </ul>
							<p>使用实例：</p>
							<pre class="brush: java;">
// 1.Consumer&lt;T> -- 对接收的 T 对象进行某些操作
private void logString(Consumer&lt;String> action, String str) {
	action.accept(str);
}

Consumer&lt;String> str = s -> log(s);
Consumer&lt;String> strAndLeng = s -> log(s, s.length());
logString(str, "hello"); // hello
logString(strAndLeng, "hello"); // hello 5

// 2.BiConsumer&lt;T,U> -- 对接收的 T,U 对象进行某些操作
BiConsumer&lt;String, Integer> bi = (s, i) -> log(s + " 的长度" + (s.length() == i ? "是 " : "不是 ") + i);
bi.accept("hello", 4); // hello 的长度不是 4

// 3.Function&lt;T,R> -- 接收 T 对象，返回 R
Function&lt;Integer, String> f = i -> i > 100 ? i + " 的值大于 100." : i + " 的值不大于 100.";
log(f.apply(50)); //  50 的值不大于 100.

// 4.UnaryOperator&lt;T -- 继承Function&lt;T,T>， 接收一个 T 对象，返回一个新的或经过加工的 T 对象
UnaryOperator&lt;String> u = s -> s.concat(" world!");
og(u.apply("hello")); // hello world!

// 5.BiFunction&lt;T,U,R> -- 接收 T 和 U(一般是相关的，如 Map 的 K, V), 返回 R
BiFunction&lt;String, Integer, Integer> bf = (k, v) -> {
	if("year".equals(k)) { return v; }
	else if("month".equals(k)) { return ++v; }
	else { return v; }
};
log(bf.apply("year", 2018)); // 2018
log(bf.apply("month", 7)); // 8

// 6.BinaryOprator&ltT> -- 继承自 BiFunction&lt;T,T,T> 传入两个 T 对象，返回经过比较的 T 对象
BinaryOperator&lt;Integer> bo = BinaryOperator.minBy(Comparator.naturalOrder());
log(bo.apply(3,  2)); // 2
bo = BinaryOperator.maxBy(Comparator.naturalOrder());
log(bo.apply(3,  2)); // 3
bo = (i, j) -> i + j;
log(bo.apply(3,  2)); // 5

// 7.Predicate&lt;T> -- 接收一个 T 对象，看其是否符合某些条件(返回 true 或 false)
Predicate&lt;Integer> p = i -> i > 5;
log(p.test(2), p.negate().test(2)); // false(2 > 5), true(2 !> 5)
log(p.test(6), p.negate().test(6)); // true(6 > 5), false(6 !> 5)
log(p.or(i -> i < 10).test(2)); // true(2 > 5 || 2 < 10)

// 8.BiPredicate&lt;T,U> -- 接收 T 和 R，看其是否符合某些条件(返回 true 或 false)
BiPredicate&lt;String,Integer> bp = (k, v) -> k.length() == v;
log(bp.test("hello", 5)); // true

// 9.Supplier&lt;T> -- 用于获取一个指定类型为 T 的对象
Supplier&lt;Integer> s = () -> (int) (Math.random() * (10 - 0) + 0); // 0-9 随机数
log(s.get());
</pre>
                        </div>

                        <div class="sub-item">
                            <p><a href="docs/docs-java/api/java/util/function/Consumer.html" target="_blank">Consumer&lt;T></a> 接口用于传入一个对象，然后对这个对象执行某些操作。</p>
							<p><a href="#Iterable">Iterable</a> 接口的 <code>forEach(Consumer)</code> 方法使用 Consumer 作为参数，迭代元素。</p>
                            <pre class="brush: java;">
public interface Consumer&lt;T> {
    void accept(T t);

    default Consumer&lt;T> andThen(Consumer&lt;? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}

/** 先执行 consumer 对象的 accept 方法，再执行 andThen 中的 lambda 方式表示的 Consumer */
BookConsumer&lt;Book> consumer = new BookConsumer<>();
Consumer&lt;Book> then = consumer.andThen(book -> log("then", book.id));
then.accept(new Book(10));

class Book {
    Book(int id){
        this.id = id;
    }
    int id;
}

class BookConsumer&lt;T extends Book> implements Consumer&lt;T> {

    @Override
    public void accept(T t) {
        log(t.id);
        t.id++;
    }
}
</pre>
                        </div>

						<div class="sub-item">
							<p><a href="docs/docs-java/api/java/util/function/BiConsumer.html" target="_blank">BiConsumer&lt;T, U></a> 接口用于传入两个相关联的对象，然后对这两个对象执行某些操作。</p>
							<p><a href="#Map">Map</a> 的 <code>forEach(BiConsumer)</code> 方法使用了 BiConsumer 作为参数，迭代键值。</p>
							<pre class="brush: java;">
public interface BiConsumer&lt;T, U> {
	void accept(T t, U u);

	default BiConsumer&lt;T, U> andThen(BiConsumer&lt;? super T, ? super U> after) {
        Objects.requireNonNull(after);

        return (l, r) -> { accept(l, r); after.accept(l, r); };
    }
}
</pre>
						</div>

						<div class="sub-item">
							<p><a href="docs/docs-java/api/java/util/function/Function.html" target="_blank">Function&lt;T, R></a> 传入一个 T 对象，返回的是 R 对象。</p>
							<p><a href="#Map">Map</a> 接口的 <code>V computeIfAbsent(K, Function)</code> 方法，使用 Function 来获取值。</p>
							<pre class="brush: java;">
public interface Function&lt;T, R> {
	R apply(T t);

	static &lt;T> Function&lt;T, T> identity() {
        return t -> t;
    }

	default &lt;V> Function&lt;V, R> compose(Function&lt;? super V, ? extends T> before) {
        Objects.requireNonNull(before);
        return (V v) -> apply(before.apply(v));
    }

	default &lt;V> Function&lt;T, V> andThen(Function&lt;? super R, ? extends V> after) {
        Objects.requireNonNull(after);
        return (T t) -> after.apply(apply(t));
    }
}
</pre>
						</div>

						<div class="sub-item">
							<p><a href="docs/docs-java/api/java/util/function/UnaryOperator.html" target="_blank">UnaryOperator&lt;T></a> 继承 <code>Function&lt;T, T></code>, 重写了 <code>identity()</code> 方法。</p>
							<p><a href="#List">List</a> 接口的 <code>default void replaceAll(UnaryOperator)</code> 使用 UnaryOperator 来替换符合条件的数据。</p>
							<pre class="brush: java;">
public interface UnaryOperator&lt;T> extends Function&lt;T, T> {
    static &lt;T> UnaryOperator&lt;T> identity() {
        return t -> t;
    }
}
</pre>
						</div>

						<div class="sub-item">
							<p><a href="docs/docs-java/api/java/util/function/BiFunction.html" target="_blank">BiFunction&lt;T, U, R></a> 传入 T 和 U(一般是相关的，如 Map 的 K, V), 返回 R。</p>
							<p><a href="#Map">Map</a> 接口的 <code>default V compute(K, BiFunction)</code> 方法，使用 BiFunction 来替换，添加或删除值。</p>
							<pre class="brush: java;">
public interface BiFunction&lt;T, U, R> {
	R apply(T t, U u);

	default &lt;V> BiFunction&lt;T, U, V> andThen(Function&lt;? super R, ? extends V> after) {
		Objects.requireNonNull(after);
		return (T t, U u) -> after.apply(apply(t, u));
	}
}
</pre>
						</div>

						<div class="sub-item">
							<p><a href="docs/docs-java/api/java/util/function/BinaryOperator.html" target="_blank">BinaryOprator&lt;T></a> 继承自 BiFunction&lt;T,T,T> 传入两个 T 对象，返回经过比较的 T 对象。</p>
							<pre class="brush: java;">
public interface BinaryOperator&lt;T> extends BiFunction&lt;T,T,T> {
	public static &lt;T> BinaryOperator&lt;T> minBy(Comparator&lt;? super T> comparator) {
        Objects.requireNonNull(comparator);
        return (a, b) -> comparator.compare(a, b) <= 0 ? a : b;
    }

	public static &lt;T> BinaryOperator&lt;T> maxBy(Comparator&lt;? super T> comparator) {
        Objects.requireNonNull(comparator);
        return (a, b) -> comparator.compare(a, b) >= 0 ? a : b;
    }
}
</pre>
						</div>

						<div class="sub-item">
							<p><a href="docs/docs-java/api/java/util/function/Predicate.html" target="_blank">Predicate</a> /** 传入一个 T 对象，看其是否符合某些条件(返回 true 或 false) */</p>
							<p><a href="#Collection">Collection</a> 接口的 <code>default boolean removeIf(Predicate)</code> 使用 Predicate 参数移除符合条件的项(Predicate 的 test(T) 方法返回 true)</p>
							<pre class="brush: java;">
public interface Predicate&lt;T> {
	boolean test(T t);

	// 符合此 Predicate， 并且符合 other
	default Predicate&lt;T> and(Predicate&lt;? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) && other.test(t);
    }

	// 返回反向的 Predicate
	default Predicate&lt;T> negate() {
        return (t) -> !test(t);
    }

	// // 符合此 Predicate 或者符合 other
	default Predicate&lt;T> or(Predicate&lt;? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) || other.test(t);
    }

	static &lt;T> Predicate&lt;T> isEqual(Object targetRef) {
        return (null == targetRef) ? Objects::isNull : object -> targetRef.equals(object);
    }
}
</pre>
						</div>

						<div class="sub-item">
							<p><a href="docs/docs-java/api/java/util/function/BiPredicate.html" target="_blank">BiPreoicate&lt;T, U></a> 传入 T 和 R(一般是相关的，如 Map 的 K, V)，看其是否符合某些条件(返回 true 或 false)。</p>
							<pre class="brush: java;">
public interface BiPredicate&lt;T, U> {
	boolean test(T t, U u);
	/* 参照 Predicate */
	default BiPredicate&lt;T, U> and(BiPredicate&lt;? super T, ? super U> other) {}
	default BiPredicate&lt;T, U> negate() {}
	default BiPredicate&lt;T, U> or(BiPredicate&lt;? super T, ? super U> other) {}
}
</pre>
						</div>

						<div class="sub-item">
							<p><a href="docs/docs-java/api/java/util/function/Supplier.html" target="_blank">Supplier</a> 用于获取一个指定类型对象。</p>
							<pre class="brush: java;">
public interface Supplier&lt;T> {
    T get();
}
</pre>
						</div>

						<div class="sub-item">
							<p><a href="docs/docs-java/api/java/util/function/BooleanSupplier.html" target="_blank">BooleanSupplier</a> 用于获取一个 boolean 对象。</p>
							<p></p>
							<pre class="brush: java;">
public interface BooleanSupplier {
    boolean getAsBoolean();
}
</pre>
						</div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-stream"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">java.util.stream 包</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface BaseStream&lt;T,S extends BaseStream&lt;T,S>> extends AutoCloseable {}

public interface Stream&lt;T> extends BaseStream&lt;T,Stream&lt;T>> {
    public interface Builder&lt;T> extends Consumer&lt;T> {
        void accept(T t);
        default Builder&lt;T> add(T t) {...}
        Stream&lt;T> build();
    }
}

public interface IntStream extends BaseStream&lt;Integer,IntStream> {
    public static interface Builder {}
}

public interface LongStream extends BaseStream&lt;Long,LongStream> {
    public static interface Builder {}
}

public interface DoubleStream extends BaseStream&lt;Double,DoubleStream> {
    public static interface Builder {}
}
</pre>
                            <p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
                            <p>Stream 风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>
                            <p><b>Java 中的 Stream 并不会存储元素，而是按需计算。Stream 只能被消费一次(中间操作可以有多次)，否则会报 <code>IllegalStateException</code></b></p>
                            <pre class="brush: java;">
List&lt;String> strings = new ArrayList<>();
Collections.addAll(strings, "A", "B", "C");
Stream&lt;String> stream = strings.stream();
strings.clear();
stream.forEach(LogUtil::log); // 没有元素被打印，因为 数据源 已被清空
</pre>
                            <p>和以前的 Collection 操作不同， Stream 操作还有两个基础的特征：</p>
                            <ul>
                                <li><p><b>Pipelining</b> -- 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格。 这样做可以对操作进行优化， 比如延迟执行和短路。</p></li>
                                <li><p><b>内部迭代</b> -- 以前对集合遍历都是通过 Iterator 或者 For-Each 的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream 提供了内部迭代的方式， 通过访问者模式实现。</p></li>
                            </ul>

                            <p>先来看一个 Stream 的应用：</p>
                            <pre class="brush: java;">
// 将 JDK 支持的 java.secure.Provider 的 Service 按类型分组
Map&lt;String, List&lt;Provider.Service>> map = Providers.getProviderList().providers().stream()
            .map(Provider::getServices)   // 转换操作，将 Provider 的 Service 提取出来
            .flatMap(Collection::stream)  // 打平操作
            .collect(Collectors.groupingBy(Provider.Service::getType)); // 分组

map.keySet().stream().sorted().forEach(k -> {
    log(k);
    List&lt;Provider.Service> services =  map.get(k);
    for (Provider.Service service : services) {
        log("  -- ", service.getAlgorithm(), service.getClassName());
    }
});
</pre>

                            <p>Stream 是支持元素流功能性操作的类，以下操作可以获取一个 Stream 的实例：</p>
                            <pre class="brush: java;">
java.util.Arrays 类提供了以下静态方法将数组转为 Stream 对象：
    static &lt;T> Stream&lt;T> stream(T[] array) {...}
    static IntStream stream(int[] array) {...}
    static LongStream stream(long[] array) {...}
    static DoubleStream stream(double[] array) {...}

    static &lt;T> Stream&lt;T> stream(T[] array, int startInclusive, int endExclusive) {...}
    static IntStream stream(int[] array, int startInclusive, int endExclusive) {...}
    static LongStream stream(long[] array, int startInclusive, int endExclusive) {...}
    static DoubleStream stream(double[] array, int startInclusive, int endExclusive) {...}

java.util.Collection&lt;E> 接口(List,Set,Queue)提供了将集合的元素转为 Stream 的默认实现：
    default Stream&lt;E> stream() {...}
    default Stream&lt;E> parallelStream() {...}

java.util.stream.StreamSupport 类提供以下静态方法生成 Stream 对象：
    static &lt;T> Stream&lt;T> stream(Spliterator&lt;T> spliterator, boolean parallel) {...}
    static &lt;T> Stream&lt;T> stream(Supplier&lt;? extends Spliterator&lt;T>> supplier,
        int characteristics, boolean parallel) {...}
    static IntStream intStream(Spliterator.OfInt spliterator, boolean parallel) {...}
    static IntStream intStream(Supplier&lt;? extends Spliterator.OfInt> supplier,
        int characteristics, boolean parallel) {...}
    static LongStream longStream(Spliterator.OfLong spliterator, boolean parallel) {...}
    static LongStream longStream(Supplier&lt;? extends Spliterator.OfLong> supplier,
        int characteristics, boolean parallel) {...}
    static DoubleStream doubleStream(Spliterator.OfDouble spliterator, boolean parallel) {...}
    static DoubleStream doubleStream(Supplier&lt;? extends Spliterator.OfDouble> supplier,
        int characteristics, boolean parallel) {...}
</pre>
                        </div>

                        <div class="sub-item">
                            <p><a href="docs/docs-java/api/java/util/stream/BaseStream.html" target="_blank">BaseStream</a> 是流的基本接口，它们是支持顺序和并行聚合操作的元素序列。</p>
                            <ol>
                                <li><p><code>Iterator&lt;T> 	iterator()</code> -- 返回此流的元素的迭代器</p></li>
                                <li><p><code>Spliterator&lt;T> 	spliterator()</code> -- 返回此流的元素的拼接器</p></li>

                                <li class="group"><p><code>S 	sequential()</code> -- 返回顺序的等效流</p></li>
                                <li><p><code>S 	parallel()</code> -- 返回并行的等效流(多线程执行)</p></li>
                                <li><p><code>S 	unordered()</code> -- 返回无序的等效流</p></li>

                                <li class="group"><p><code>boolean 	isParallel()</code> -- 此流是否并行执行终端操作</p></li>

                                <li class="group"><p><code>S 	onClose(Runnable closeHandler)</code> -- 返回带有附加关闭处理程序的等效流</p></li>
                                <li><p><code>void 	close()</code> -- 关闭此流</p></li>
                            </ol>
                            <p><a href="docs/docs-java/api/java/util/stream/Stream.html" target="_blank">Stream</a> 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
                            <ol>
                                <li><p><code>static &lt;T> Stream&lt;T> 	empty()</code> -- 空的顺序流</p></li>
                                <li><p><code>static &lt;T> Stream&lt;T> 	of(T t)</code> -- 包含单个元素的顺序流</p></li>
                                <li><p><code>static &lt;T> Stream&lt;T> 	of(T... values)</code> -- 包含指定元素的数序流</p></li>
                                <li><p><code>static &lt;T> Stream&lt;T> 	generate(Supplier&lt;T> s)</code> -- 无限连续的无序流</p></li>
                                <li><p><code>static &lt;T> Stream&lt;T> 	iterate(T seed, UnaryOperator&lt;T> f)</code> -- 无限连续有序流</p></li>
                                <li><p><code>static &lt;T> Stream&lt;T> 	concat(Stream&lt;? extends T> a, Stream&lt;? extends T> b)</code> -- 懒惰连接两个流</p></li>

                                <li class="group"><p><code>static &lt;T> Stream.Builder&lt;T> 	builder()</code> -- 返回一个 Stream 的构建器</p></li>

                                <li class="group"><p><code>long 	count()</code> -- 返回此流中的元素数</p></li>

                                <li class="group"><p><code>void 	forEach(Consumer&lt;? super T> action)</code> -- 迭代</p></li>
                                <li><p><code>void 	forEachOrdered(Consumer&lt;? super T> action)</code> -- 保证顺序迭代(包括并行流)</p></li>

                                <li class="group"><p><code>Object[] 	toArray()</code> -- 返回一个包含此流的元素的数组</p></li>
                                <li><p><code>&lt;A> A[] 	toArray(IntFunction&lt;A[]> generator)</code> -- 返回一个包含此流的元素的数组</p>
                                    <pre class="brush: java;">
IntFunction&lt;String[]> function = String[]::new;
String[] arr = Stream.of(1, 3, 9, 8, 7, 10).map(i -> {
    if(i < 6) return "不及格";
    else if(i < 8) return "及格";
    else return "优秀";
}).toArray(function); // ["不及格","不及格","优秀","优秀","及格","优秀"]
                                    </pre>
                                </li>

                                <li class="group"><p><code>boolean 	allMatch(Predicate&lt;? super T> predicate)</code> -- 是否所有元素满足指定条件</p></li>
                                <li><p><code>boolean 	noneMatch(Predicate&lt;? super T> predicate)</code> -- 是否所有元素不满足指定条件</p></li>
                                <li><p><code>boolean 	anyMatch(Predicate&lt;? super T> predicate)</code> -- 是否有元素满足指定条件</p></li>


                                <li class="group"><p><code>Stream&lt;T> 	filter(Predicate&lt;? super T> predicate)</code> -- 过滤</p></li>
                                <li><p><code>Stream&lt;T> 	peek(Consumer&lt;? super T> action)</code> -- 惰性操作，在消费元素时对每个元素执行提供的操作</p>
                                    <pre class="brush: java;">
int sum = Stream.of(1, 2, 3, 4, 5)
            .peek(i -> System.out.print(String.format("%s %s ", i, i == 5 ? "=" : "+")))
            .mapToInt(value -> value)
            .sum(); // 此处才开始消费，如果不消费，那么 peek 中的函数也不会执行
System.out.println(sum); // 1 + 2 + 3 + 4 + 5 = 15
</pre>
                                </li>
                                <li><p><code>Stream&lt;T> 	skip(long n)</code> -- 跳过指定数量元素</p></li>
                                <li><p><code>Stream&lt;T> 	sorted()</code> -- 排序</p></li>
                                <li><p><code>Stream&lt;T> 	sorted(Comparator&lt;? super T> comparator)</code> -- 排序</p></li>
                                <li><p><code>Stream&lt;T> 	limit(long maxSize)</code> -- 指定最多获取数量</p></li>
                                <li><p><code>Stream&lt;T> 	distinct()</code> -- 逆向</p></li>

                                <li class="group"><p><code>&lt;R> Stream&lt;R> 	map(Function&lt;? super T,? extends R> mapper)</code> -- 转换</p>
                                <li><p><code>&lt;R> Stream&lt;R> 	flatMap(Function&lt;? super T,? extends Stream&lt;? extends R>> mapper)</code> -- 转换为 R 元素 Stream 流</p></li>

                                <li class="group"><p><code>&lt;R> R 	collect(Supplier&lt;R> supplier, BiConsumer&lt;R,? super T> accumulator, BiConsumer&lt;R,R> combiner)</code> -- 可变还原操作</p></li>
                                <li><p><code>&lt;R,A> R 	collect(Collector&lt;? super T,A,R> collector)</code> -- 可变还原操作，参见 <a href="#java-util-stream-Collectors">Collectors</a></p>
                                    <pre class="brush: java;">
public interface Collector&lt;T, A, R> {
  Supplier&lt;A> supplier();            // 创建新的元素准本并入
  BiConsumer&lt;A, T> accumulator();    // 将新的数据元素和原元素进行消费
  BinaryOperator&lt;A> combiner();      // 合并
  Function&lt;A, R> finisher();         // 对结果进行最终变换
  Set&lt;Characteristics> characteristics();

  enum Characteristics {
     CONCURRENT,      // 标识 Collector 是并发的
     UNORDERED,       // 标识 Collector 不保证顺序
     IDENTITY_FINISH  // 标识 Collector 的 finisher 可以被删除，不会被调用
  }

  static&lt;T, R> Collector&lt;T, R, R> of(Supplier&lt;R> supplier, BiConsumer&lt;R, T> accumulator,
    BinaryOperator&lt;R> combiner, Characteristics... characteristics) {...}

  static&lt;T, A, R> Collector&lt;T, A, R> of(Supplier&lt;A> supplier, BiConsumer&lt;A, T> accumulator,
    BinaryOperator&lt;A> combiner, Function&lt;A, R> finisher, Characteristics... characteristics) {...}
}
</pre>
                                </li>



                                <li class="group"><p><code>IntStream 	mapToInt(ToIntFunction&lt;? super T> mapper)</code> -- 转换为 IntStream</p></li>
                                <li><p><code>IntStream 	flatMapToInt(Function&lt;? super T,? extends IntStream> mapper)</code> -- 同上，转换函数的返回值类型不一样</p></li>
                                <li><p><code>LongStream 	mapToLong(ToLongFunction&lt;? super T> mapper)</code> -- 转换为 LongStream</p></li>
                                <li><p><code>LongStream 	flatMapToLong(Function&lt;? super T,? extends LongStream> mapper)</code> -- 转换为 LongStream</p></li>
                                <li><p><code>DoubleStream 	mapToDouble(ToDoubleFunction&lt;? super T> mapper)</code> -- 转换为 DoubleStream</p></li>
                                <li><p><code>DoubleStream 	flatMapToDouble(Function&lt;? super T,? extends DoubleStream> mapper)</code> -- 同上，转换函数的返回值类型不一样</p></li>

                                <li class="group"><p><code>Optional&lt;T> 	findAny()</code> -- 获取任意一个元素(针对并行流而言，顺序流为第一个元素)</p></li>
                                <li><p><code>Optional&lt;T> 	findFirst()</code> -- 获取第一个元素</p></li>
                                <li><p><code>Optional&lt;T> 	max(Comparator&lt;? super T> comparator)</code> -- 最大值</p></li>
                                <li><p><code>Optional&lt;T> 	min(Comparator&lt;? super T> comparator)</code> -- 最小值</p></li>

                                <li class="group"><p><code>Optional&lt;T> 	reduce(BinaryOperator&lt;T> accumulator)</code> -- 累积函数</p>
                                    <pre class="brush: java;">
String value = Arrays.asList("A", "B", "C").stream().reduce(new BinaryOperator&lt;String>() {
    @Override
    public String apply(String s1, String s2) {
        return s1 + s2; // A,B -> AB,C
    }
}).orElse("None");
log(value); // ABC
</pre>
                                </li>
                                <li><p><code>T 	reduce(T identity, BinaryOperator&lt;T> accumulator)</code> -- 同上，前面接一个初始值</p>
                                    <pre class="brush: java;">
String value = stream.reduce("start:", new BinaryOperator&lt;String>() {
    @Override
    public String apply(String s, String s2) {
        return s + s2; // start:,A -> start:A  B -> start:AB  C
    }
});
log(value); // start:ABC
</pre>
                                </li>
                                <li><p><code>&lt;U> U 	reduce(U identity, BiFunction&lt;U,? super T,U> accumulator, BinaryOperator&lt;U> combiner)</code> -- 同上,执行 <code>accumulator</code> 的计算</p></li>
                            </ol>

                            <a id="java-util-stream-Collectors" class="offset"></a>
                            <p><a href="docs/docs-java/api/java/util/stream/Collectors.html" target="_blank">Collectors</a> 是实现各种有用的归约操作的收集器实现。</p>
                            <pre class="brush: java;">
public class Score {
    String name; int score;
    public Score(String name, int score) { this.name = name; this.score = score; }
}

List<&lt;core> scores = Arrays.asList(new Score("A", 70), new Score("B", 80), new Score("C", 90));
Supplier&lt;Stream&lt;Score>> s = scores::stream;
</pre>
                            <ol>
                                <li><p><code>static &lt;T> Collector&lt;T,?,Long> 	counting()</code> -- 数量，对于 Stream，可以直接使用 <code>count()</code> 函数</p></li>

                                <li class="group"><p><code>static Collector&lt;CharSequence,?,String> 	joining()</code> -- 拼接</p></li>
                                <li><p><code>static Collector&lt;CharSequence,?,String> 	joining(CharSequence delimiter)</code> -- 拼接，指定分隔符</p></li>
                                <li><p><code>static Collector&lt;CharSequence,?,String> 	joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</code> -- 拼接，指定分隔符，前缀，后缀</p>
                                    <pre class="brush: java;">
log(s.get().map(score -> score.name).collect(Collectors.joining())); // ABC
log(s.get().map(score -> score.name).collect(Collectors.joining("-"))); // A-B-C
log(s.get().map(score -> score.name).collect(Collectors.joining("-", "<", ">"))); // &lt;A-B-C>
</pre>
                                </li>

                                <li class="group"><p><code>static &lt;T,K> Collector&lt;T,?,Map&lt;K,List&lt;T>>> 	groupingBy(Function&lt;? super T,? extends K> classifier)</code> -- 分组</p>
                                    <pre class="brush: java;">
Map&lt;String, List&lt;Score>> groups = s.get().collect(Collectors.groupingBy(score -> {
    if(score.score < 60) return "差";
    else if(score.score < 80) return "良";
    else return "优";
})); // {"优":[{"name":"B","score":80},{"name":"C","score":90}],"良":[{"name":"A","score":70}]}
</pre>
                                </li>
                                <li><p><code>static &lt;T,K> Collector&lt;T,?,ConcurrentMap&lt;K,List&lt;T>>> 	groupingByConcurrent(Function&lt;? super T,? extends K> classifier)</code> -- 同上，并发支持</p></li>
                                <li><p><code>static &lt;T,K,A,D> Collector&lt;T,?,Map&lt;K,D>> 	groupingBy(Function&lt;? super T,? extends K> classifier, Collector&lt;? super T,A,D> downstream)</code> -- 分组后再计算</p>
                                    <pre class="brush: java;">
Map&lt;String, Double> map = s.get().collect(Collectors.groupingBy(score -> {
        if(score.score < 60) return "差";
        else if(score.score < 80) return "良";
        else return "优";
    }, Collectors.averagingInt(score -> score.score))); // {"优":85.0,"良":70.0}
</pre>
                                </li>
                                <li><p><code>static &lt;T,K,A,D> Collector&lt;T,?,ConcurrentMap&lt;K,D>> 	groupingByConcurrent(Function&lt;? super T,? extends K> classifier, Collector&lt;? super T,A,D> downstream)</code> -- 同上，并发支持</p></li>
                                <li><p><code>static &lt;T,K,D,A,M extends Map&lt;K,D>> Collector&lt;T,?,M> 	groupingBy(Function&lt;? super T,? extends K> classifier, Supplier&lt;M> mapFactory, Collector&lt;? super T,A,D> downstream)</code> -- </p>
                                    <pre class="brush: java;">
Map&lt;String, List&lt;Score>> maps = s.get().collect(Collectors.groupingBy(score -> {
        if(score.score < 60) return "差";
        else if(score.score < 80) return "良";
        else return "优";
    }, (Supplier&lt;Map&lt;String, List&lt;Score>>>) HashMap::new,  // 提供转换类型
        Collectors.mapping(t -> t, Collectors.toList()) // 下游处理
    )); // [{"优":[{"name":"B","score":80},{"name":"C","score":90}],"良":[{"name":"A","score":70}]}]

</pre>
                                </li>
                                <li><p><code>static &lt;T,K,A,D,M extends ConcurrentMap&lt;K,D>> Collector&lt;T,?,M> 	groupingByConcurrent(Function&lt;? super T,? extends K> classifier, Supplier&lt;M> mapFactory, Collector&lt;? super T,A,D> downstream)</code> -- 同上，并发支持</p></li>

                                <li class="group"><p><code>static &lt;T,U,A,R> Collector&lt;T,?,R> 	mapping(Function&lt;? super T,? extends U> mapper, Collector&lt;? super U,A,R> downstream)</code> -- 转换</p>
                                    <pre class="brush: java;">
String result = s.get().collect(Collectors.mapping(score -> score.name + ":" + score.score,
        Collectors.joining("|") // 下游处理
    ));
// 以下操作等价
result = s.get().map(score -> score.name + ":" + score.score).collect(Collectors.joining("|"));
log(result); // A:70|B:80|C:90
</pre>
                                </li>

                                <li class="group"><p><code>static &lt;T> Collector&lt;T,?,Optional&lt;T>> 	maxBy(Comparator&lt;? super T> comparator)</code> -- 最大值</p></li>
                                <li><p><code>static &lt;T> Collector&lt;T,?,Optional&lt;T>> 	minBy(Comparator&lt;? super T> comparator)</code> -- 最小值</p>
                                    <pre class="brush: java;">
Score score = s.get().collect(Collectors.maxBy((s1, s2) -> s1.score - s2.score )).get();
// 以下操作等价
score = s.get().max((s1, s2) -> s1.score - s2.score).get();
</pre>
                                </li>

                                <li class="group"><p><code>static &lt;T> Collector&lt;T,?,Map&lt;Boolean,List&lt;T>>> 	partitioningBy(Predicate&lt;? super T> predicate)</code> -- 分组</p></li>
                                <li><p><code>static &lt;T,D,A> Collector&lt;T,?,Map&lt;Boolean,D>> 	partitioningBy(Predicate&lt;? super T> predicate, Collector&lt;? super T,A,D> downstream)</code> -- 同上，下游处理</p>
                                    <pre class="brush: java;">
Map&lt;Boolean, List&lt;Score>> parts = s.get().collect(Collectors.partitioningBy(it -> it.score > 80));
// [{"false":[{"name":"A","score":70},{"name":"B","score":80}],"true":[{"name":"C","score":90}]}]
</pre>
                                </li>

                                <li class="group"><p><code>static &lt;T> Collector&lt;T,?,Optional&lt;T>> 	reducing(BinaryOperator&lt;T> op)</code> -- 累积函数, 同 Stream 的 <code>reduce</code></p></li>
                                <li><p><code>static &lt;T> Collector&lt;T,?,T> 	reducing(T identity, BinaryOperator&lt;T> op)</code> -- 累积函数</p></li>
                                <li><p><code>static &lt;T,U> Collector&lt;T,?,U> 	reducing(U identity, Function&lt;? super T,? extends U> mapper, BinaryOperator&lt;U> op)</code> -- 累积函数</p>
                                    <pre class="brush: java">
Score score1 = s.get().collect(Collectors.reducing((s1, s2) -> s1.score > s2.score?s1:s2)).get();
// 以下操作等价
score1 = s.get().reduce((s1, s2) -> s1.score > s2.score ? s1 : s2).get();
</pre>
                                </li>

                                <li class="group"><p><code>static &lt;T> Collector&lt;T,?,Double> 	averagingInt(ToIntFunction&lt;? super T> mapper)</code> -- 平均值</p></li>
                                <li><p><code>static &lt;T> Collector&lt;T,?,Double> 	averagingLong(ToLongFunction&lt;? super T> mapper)</code> -- 平均值</p></li>
                                <li><p><code>static &lt;T> Collector&lt;T,?,Double> 	averagingDouble(ToDoubleFunction&lt;? super T> mapper)</code> -- 平均值</p>
                                    <pre class="brush: java;">
log(s.get().collect(Collectors.averagingInt(value -> value.score)));    // 类型转为 int
log(s.get().collect(Collectors.averagingLong(value -> value.score)));   // 类型转为 long
log(s.get().collect(Collectors.averagingDouble(value -> value.score))); // 类型转为 double
                                    </pre>
                                </li>

                                <li class="group"><p><code>static &lt;T> Collector&lt;T,?,Integer> 	summingInt(ToIntFunction&lt;? super T> mapper)</code> -- 和求和差不多</p></li>
                                <li><p><code>static &lt;T> Collector&lt;T,?,Double> 	summingDouble(ToDoubleFunction&lt;? super T> mapper)</code> -- 同上</p></li>
                                <li><p><code>static &lt;T> Collector&lt;T,?,Long> 	summingLong(ToLongFunction&lt;? super T> mapper)</code> -- 同上</p></li>
                                <li><p><code>static &lt;T> Collector&lt;T,?,IntSummaryStatistics> 	summarizingInt(ToIntFunction&lt;? super T> mapper)</code> -- 结果包含了 max,min,count,sum 信息</p></li>
                                <li><p><code>static &lt;T> Collector&lt;T,?,LongSummaryStatistics> 	summarizingLong(ToLongFunction&lt;? super T> mapper)</code> -- 同上</p></li>
                                <li><p><code>static &lt;T> Collector&lt;T,?,DoubleSummaryStatistics> 	summarizingDouble(ToDoubleFunction&lt;? super T> mapper)</code> -- 同上</p>
                                    <pre class="brush: java;">
int sum = s.get().collect(Collectors.summingInt(item -> item.score));

IntSummaryStatistics value = s.get().collect(Collectors.summarizingInt(item -> item.score));
log(value.getSum(), value.getAverage(), value.getCount());
</pre>
                                </li>

                                <li class="group"><p><code>static &lt;T,C extends Collection&lt;T>> Collector&lt;T,?,C> 	toCollection(Supplier&lt;C> collectionFactory)</code> -- 存入 Collection</p></li>
                                <li><p><code>static &lt;T> Collector&lt;T,?,List&lt;T>> 	toList()</code> -- 存入 List</p></li>
                                <li><p><code>static &lt;T> Collector&lt;T,?,Set&lt;T>> 	toSet()</code> -- 存入 Set</p></li>

                                <li class="group"><p><code>static &lt;T,K,U> Collector&lt;T,?,Map&lt;K,U>> 	toMap(Function&lt;? super T,? extends K> keyMapper, Function&lt;? super T,? extends U> valueMapper)</code> -- 存入 Map</p></li>
                                <li class="group"><p><code>static &lt;T,K,U> Collector&lt;T,?,ConcurrentMap&lt;K,U>> 	toConcurrentMap(Function&lt;? super T,? extends K> keyMapper, Function&lt;? super T,? extends U> valueMapper)</code> -- 同上，支持并发</p></li>
                                <li><p><code>static &lt;T,K,U> Collector&lt;T,?,Map&lt;K,U>> 	toMap(Function&lt;? super T,? extends K> keyMapper, Function&lt;? super T,? extends U> valueMapper, BinaryOperator&lt;U> mergeFunction)</code> -- 存入 Map</p></li>
                                <li><p><code>static &lt;T,K,U> Collector&lt;T,?,ConcurrentMap&lt;K,U>> 	toConcurrentMap(Function&lt;? super T,? extends K> keyMapper, Function&lt;? super T,? extends U> valueMapper, BinaryOperator&lt;U> mergeFunction)</code> -- 同上，支持并发</p></li>
                                <li><p><code>static &lt;T,K,U,M extends Map&lt;K,U>> Collector&lt;T,?,M> 	toMap(Function&lt;? super T,? extends K> keyMapper, Function&lt;? super T,? extends U> valueMapper, BinaryOperator&lt;U> mergeFunction, Supplier&lt;M> mapSupplier)</code> -- 存入 Map</p></li>
                                <li><p><code>static &lt;T,K,U,M extends ConcurrentMap&lt;K,U>> Collector&lt;T,?,M> 	toConcurrentMap(Function&lt;? super T,? extends K> keyMapper, Function&lt;? super T,? extends U> valueMapper, BinaryOperator&lt;U> mergeFunction, Supplier&lt;M> mapSupplier)</code> -- 同上，支持并发</p></li>

                                <li class="group"><p><code>static &lt;T,A,R,RR> Collector&lt;T,A,RR> 	collectingAndThen(Collector&lt;T,A,R> downstream, Function&lt;R,RR> finisher)</code> -- 下游处理后，可以额外转换</p>
                                    <pre class="brush: java;">
Score score1 = s.get().collect(Collectors.collectingAndThen(Collectors.toList(), list -> {
    for (Score item : list) {
        if(item.score == 90) return item;
    }
    return null;
}));
</pre>
                                </li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-Random"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Random 子类及 SplittableRandom</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.util.Random                            // 伪随机数生成器
        java.security.SecureRandom              // 加密安全的伪随机数生成器
        java.util.concurrent.ThreadLocalRandom  // 线程优化的伪随机数生成器

java.lang.Object
    java.util.SplittableRandom                  // 并行计算的均匀伪随机值的生成器(不是加密安全的)

public class Random implements Serializable {
    public Random() {...}
    public Random(long seed) {...}
}

public class SecureRandom extends Random {
    public SecureRandom() {...}
    public Random(byte[] seed) {...}
}

public class ThreadLocalRandom extends Random {}

public final class SplittableRandom {
    public SplittableRandom() {...}
    public SplittableRandom(long seed) {...}
}
</pre>
                        <p><a href="docs/docs-java/api/java/util/Random.html" target="_blank">Random</a> 是伪随机数生成器，相同的随机数种子总是生成同样的随机数。</p>
                        <p><a href="docs/docs-java/api/java/util/concurrent/ThreadLocalRandom.html" target="_blank">ThreadLocalRandom</a> 是线程优化的伪随机数生成器，将随机数生成器隔离到当前线程，在并发程序中使用它而不是共享 Random 对象，通常会更少的开销和争用。必须使用静态方法 <code>current()</code> 获取实例，并且不支持设置随机数种子。</p>
                        <p><a href="docs/docs-java/api/java/util/SecureRandom.html" target="_blank">SecureRandom</a> 加密安全的伪随机数生成器，不管是否相同的随机数种子总是生成不同的随机数。</p>
                        <p><a href="docs/docs-java/api/java/util/SplittableRandom.html" target="_blank">SplittableRandom</a> 和 Random 类似，但是在 <code>split()</code> 后会生成一个不同的实例，主要在 JDK 内部使用。</p>
                        <ol>
                            <li><p><code>void 	setSeed(long seed)</code> -- 更新随机数种子</p></li>

                            <li class="group"><p><code>int 	nextInt()</code> -- 范围 <code>[Integer.MIN_VALUE, Integer.MAX_VALUE]</code></p></li>
                            <li><p><code>int 	nextInt(int bound)</code> -- 范围 <code>[0,bound)</code></p></li>
                            <li><p><code>protected int 	next(int bits)</code> -- 指定二进制位数</p></li>
                            <li><p><code>boolean 	nextBoolean()</code> -- 范围 <code>true / false</code></p></li>
                            <li><p><code>void 	nextBytes(byte[] bytes)</code> -- 长度为 bytes.length 的随机 byte 数组</p></li>
                            <li><p><code>long 	nextLong()</code> -- 范围 <code>[Long.MIN_VALUE, Long.MAX_VALUE]</code></p></li>
                            <li><p><code>float 	nextFloat()</code> -- 范围 <code>[0.0, 1.0]</code></p></li>
                            <li><p><code>double 	nextDouble()</code> -- 范围 <code>[0.0, 1.0]</code></p></li>
                            <li><p><code>double 	nextGaussian()</code> -- 高斯分布 double 值，平均值为 0.0 ，标准差 1.0</p></li>

                            <li class="group"><p><code>IntStream 	ints()</code> -- 无限 int 流， 范围 <code>[Integer.MIN_VALUE, Integer.MAX_VALUE]</code></p></li>
                            <li><p><code>IntStream 	ints(int randomNumberOrigin, int randomNumberBound)</code> -- 无限 int 流， 范围 <code>[randomNumberOrigin, randomNumberBound)</code></p></li>
                            <li><p><code>IntStream 	ints(long streamSize)</code> -- 有限 int 流， 范围 <code>[Integer.MIN_VALUE, Integer.MAX_VALUE]</code></p></li>
                            <li><p><code>IntStream 	ints(long streamSize, int randomNumberOrigin, int randomNumberBound)</code> -- 有限 int 流， 范围 <code>[randomNumberOrigin, randomNumberBound)</code></p></li>
                            <li class="group"><p><code>LongStream 	longs()</code> -- 参照 ints</p></li>
                            <li><p><code>LongStream 	longs(long streamSize)</code> -- 参照 ints</p></li>
                            <li><p><code>LongStream 	longs(long randomNumberOrigin, long randomNumberBound)</code> -- 参照 ints</p></li>
                            <li><p><code>LongStream 	longs(long streamSize, long randomNumberOrigin, long randomNumberBound)</code> -- 参照 ints</p></li>
                            <li class="group"><p><code>DoubleStream 	doubles()</code> -- 参照 ints, 范围 <code>[0.0, 1.0]</code></p></li>
                            <li><p><code>DoubleStream 	doubles(double randomNumberOrigin, double randomNumberBound)</code> -- 参照 ints, 范围 <code>[randomNumberOrigin, randomNumberBound)</code></p></li>
                            <li><p><code>DoubleStream 	doubles(long streamSize)</code> -- 参照 ints, 范围 <code>[0.0, 1.0]</code></p></li>
                            <li><p><code>DoubleStream 	doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)</code> -- 参照 ints, 范围 <code>[randomNumberOrigin, randomNumberBound)</code></p></li>
                        </ol>
                        <p><a href="docs/docs-java/api/java/security/SecureRandom.html" target="_blank">SecureRandom</a> 提供了一个加密的强随机数生成器。</p>
                        <p>支持 <b>SecureRandom</b> 的算法:</p>
                        <pre class="brush: java;">
/** 支持 SecureRandom 的算法如下: NativePRNG, SHA1PRNG, NativePRNGBlocking, NativePRNGNonBlocking */
for (Provider provider : Providers.getProviderList().toArray()) {
    provider.getServices().forEach(s -> {
        if("SecureRandom".equalsIgnoreCase(s.getType())) {
            log(s.getAlgorithm());
        }
    });
}
</pre>
                        <ol>
                            <li><p><code>static SecureRandom 	getInstanceStrong()</code> -- 使用 <code>NativePRNGBlocking</code> 算法</p></li>
                            <li><p><code>static SecureRandom 	getInstance(String algorithm)</code> -- 指定算法，默认为 <code>NativePRNG</code></p></li>
                            <li><p><code>static SecureRandom 	getInstance(String algorithm, Provider provider)</code> -- 指定提供者和算法</p></li>
                            <li><p><code>static SecureRandom 	getInstance(String algorithm, String provider)</code> -- 指定提供者和算法</p></li>

                            <li class="group"><p><code>void 	setSeed(long seed)</code> -- 重设随机种子</p></li>
                            <li><p><code>static byte[] 	getSeed(int numBytes)</code> -- 获取随机种子</p></li>
                            <li><p><code>void 	setSeed(byte[] seed)</code> -- 重设随机种子</p></li>
                            <li><p><code>byte[] 	generateSeed(int numBytes)</code> -- 生成指定长度随机种子</p></li>

                            <li class="group"><p><code>String 	getAlgorithm()</code> -- 获取算法</p></li>
                            <li><p><code>Provider 	getProvider()</code> -- 获取算法提供者</p></li>

                            <li class="group"><p><code>protected int 	next(int numBits)</code> -- 生成一个包含用户指定数量的伪随机位的整数</p></li>
                            <li><p><code>void 	nextBytes(byte[] bytes)</code> -- 生成用户指定的随机字节数</p></li>

                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-Optional"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Optional 和 Objects</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
public final class Optional&lt;T> {}

/** 还有以下 Optional 变种 */
public final class OptionalInt {}
public final class OptionalLong {}
public final class OptionalDouble {}
</pre>
                        <p><a href="docs/docs-java/api/java/util/Optional.html" target="_blank">Optional</a> 是一个简单的容器，其值可能是 null 或者不是 null。</p>
                        <p><a href="docs/docs-java/api/java/util/Optional.html" target="_blank">Optional</a> 只用作函数的返回值，作为字段或方法参数都是不可取的。</p>
                        <ol>
                            <li><p><code>static &lt;T> Optional&lt;T> 	empty()</code> -- 值为 NULL 的 Optional</p></li>
                            <li><p><code>static &lt;T> Optional&lt;T> 	of(T value)</code> -- 值为 value 的 Optional(value 不能为 NULL)</p></li>
                            <li><p><code>static &lt;T> Optional&lt;T> 	ofNullable(T value)</code> -- 值为 value 的 Optional(value 可能为 NULL)</p></li>

                            <li class="group"><p><code>T 	get()</code> -- 获取值，如果为 NULL 则抛出异常</p></li>
                            <li><p><code>T 	orElse(T other)</code> -- 值为 NULL 则返回 other(other 可为 NULL)</p></li>
                            <li><p><code>T 	orElseGet(Supplier&lt;? extends T> other)</code> -- 值为 NULL 则从 Supplier 中获取(other 不能为 NULL)</p></li>
                            <li><p><code>&lt;X extends Throwable> T 	orElseThrow(Supplier&lt;? extends X> exceptionSupplier)</code> -- 值为 NULL 则从 Supplier 中获取异常</p></li>

                            <li class="group"><p><code>boolean 	isPresent()</code> -- 值是否为 NULL</p></li>
                            <li><p><code>void 	ifPresent(Consumer&lt;? super T> consumer)</code> -- 值不为 NULL 则执行 Consumer 代码(consumer 不能为 NULL)</p></li>

                            <li class="group"><p><code>Optional&lt;T> 	filter(Predicate&lt;? super T> predicate)</code> -- 过滤，如果符合条件则返回本身，否则返回 <code>empty()</code></p></li>
                            <li><p><code>&lt;U> Optional&lt;U> 	map(Function&lt;? super T,? extends U> mapper)</code> -- 转换，值不为 NULL 才执行转换</p></li>
                            <li><p><code>&lt;U> Optional&lt;U> 	flatMap(Function&lt;? super T,Optional&lt;U>> mapper)</code> -- 同上</p></li>

                            <li class="group"><p><code>int 	hashCode()</code> -- NULL 支持的 hashCode</p></li>
                            <li><p><code>boolean 	equals(Object obj)</code> -- NULL 支持的 equals</p></li>
                            <li><p><code>String 	toString()</code> -- NULL 支持的 toString</p></li>
                        </ol>
                        <p><a href="docs/docs-java/api/java/util/Objects.html" target="_blank">Objects</a> 包括一些静态的工具方法，用于操作 Object、或是对某些操作进行前提检测。</p>
                        <ol>
                            <li><p><code>static &lt;T> T 	requireNonNull(T obj)</code> -- 获取不为 NULL 的对象，否个抛出异常</p></li>
                            <li><p><code>static &lt;T> T 	requireNonNull(T obj, String message)</code> -- 同上</p></li>
                            <li><p><code>static &lt;T> T 	requireNonNull(T obj, Supplier&lt;String> messageSupplier)</code> -- 同上</p></li>

                            <li class="group"><p><code>static boolean 	isNull(Object obj)</code> -- 为 NULL 返回 true</p></li>
                            <li><p><code>static boolean 	nonNull(Object obj)</code> -- 不为 NULL 返回 true</p></li>

                            <li><p><code>static &lt;T> int 	compare(T a, T b, Comparator&lt;? super T> c)</code> -- 比较两个对象</p></li>

                            <li class="group"><p><code>static int 	hashCode(Object o)</code> -- 为输入值生成哈希码，NULL 返回 0</p></li>
                            <li><p><code>static int 	hash(Object... values)</code> -- 为输入值序列生成哈希码</p></li>
                            <li><p><code>static boolean 	equals(Object a, Object b)</code> -- 是否相等</p></li>
                            <li><p><code>static boolean 	deepEquals(Object a, Object b)</code> -- 是否深层相等</p></li>
                            <li><p><code>static String 	toString(Object o)</code> -- 返回非 null参数调用 toString和 NULL 参数的 "null"</p></li>
                            <li><p><code>static String 	toString(Object o, String nullDefault)</code> -- 返回非 null 参数调用 toString 和 null 参数的 nullDefault</p></li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-util-concurrent-atomic"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title"><code>java.util.concurrent.atomic</code> 包</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p><a href="docs/docs-java/api/java/util/concurrent/atomic/package-summary.html" target="_blank">java.util.concurrent.atomic</a> 支持对单个变量进行无锁线程安全编程的小型类工具包。</p>
							<p>无锁采用 CAS(compare and swap) 算法来处理线程冲突, 其原理如下:</p>
							<p>CAS 包含 3 个参数 CAS(V,E,N).V 表示要更新的变量, E 表示预期值, N 表示新值。</p>
							<p>仅当 V 值等于 E 值时, 才会将 V 的值设为 N, 如果 V 值和 E 值不同, 则说明已经有其他线程做了更新, 则当前线程什么都不做. 最后, CAS 返回当前 V 的真实值. CAS 操作是抱着乐观的态度进行的, 它总是认为自己可以成功完成操作.
								当多个线程同时使用 CAS 操作一个变量时, 只有一个会胜出, 并成功更新, 其余均会失败.失败的线程不会被挂起,
								仅是被告知失败, 并且允许再次尝试, 当然也允许失败的线程放弃操作.基于这样的原理, CAS 操作即使没有锁,
								也可以发现其他线程对当前线程的干扰, 并进行恰当的处理。</p>
						</div>

						<div class="sub-item">
							<pre class="brush: java;">

</pre>
							<p><a href="docs/docs-java/api/" target="_blank"></a></p>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-util-concurrent-locks"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title"><code>java.util.concurrent.locks</code> 包</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">

							<p><a href="docs/docs-java/api/java/util/concurrent/locks/package-summary.html" target="_blank">java.util.concurrent.locks</a></p>
						</div>

						<div class="sub-item">
							<pre class="brush: java;">

</pre>
							<p><a href="docs/docs-java/api/" target="_blank"></a></p>
						</div>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-Formatter"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Formatter</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.util.Formatter

public final class Formatter implements Closeable, Flushable {
	public enum BigDecimalLayoutForm {
		SCIENTIFIC,
        DECIMAL_FLOAT
    };

	public Formatter() {}
    public Formatter(Appendable a) {}
    public Formatter(Appendable a, Locale l) {}
    public Formatter(File file) {}
    public Formatter(File file, String csn) {}
    public Formatter(File file, String csn, Locale l) {}
    public Formatter(Locale l) {}
    public Formatter(OutputStream os) {}
    public Formatter(OutputStream os, String csn) {}
    public Formatter(OutputStream os, String csn, Locale l) {}
    public Formatter(PrintStream ps) {}
    public Formatter(String fileName) {}
    public Formatter(String fileName, String csn) {}
    public Formatter(String fileName, String csn, Locale l)
}
</pre>
                        <p><a href="docs/docs-java/api/java/util/Formatter.html" target="_blank">Formatter</a> 是 <code>printf</code> 风格的格式字符串的解释程序。此类提供了对布局对齐和排列的支持，以及对数值、字符串和日期/时间数据的常规格式和特定于语言环境的输出的支持。</p>
                        <p>Java 语言的格式化输出在很大程度上受到 C 语言 printf 的启发。虽然一些格式字符串与 C 类似，但已进行了某些定制，以适应 Java 语言，并且利用了其中一些特性。此外，Java 的格式比 C 的格式更严格；例如，如果转换与标志不兼容，则会抛出异常。在 C 中，不适用的标志会被忽略。这样，便于 C 程序员识别这些格式字符串，而又不必与 C 中的那些标志完全兼容。</p>

                        <ol>
                            <li><p><code>Formatter 	format(String format, Object... args)</code> -- 使用指定格式字符串和参数将一个格式化字符串</p>
                                <pre class="brush: java;">
String s = String.format("%s %s %d", "abc", "123", 1024); // 此方法其实调用的是 Formatter 的方法

Formatter formatter = new Formatter().format("%s %s %d", "abc", "123", 1024);
log(formatter.toString()); // abc 123 1024
</pre>
                            </li>
                            <li><p><code>String 	toString()</code> -- 返回对输出的目标文件调用 toString() 的结果</p></li>
                            <li><p><code>void 	close()</code> -- 关闭</p></li>
                            <li><p><code>void 	flush()</code> -- 刷新</p></li>
                            <li><p><code>Formatter 	format(Locale l, String format, Object... args)</code> -- 使用指定的语言环境、格式字符串和参数</p></li>
                            <li><p><code>IOException 	ioException()</code> -- 返回由此 formatter 的 Appendable 方法上次抛出的 IOException 异常</p></li>
                            <li><p><code>Locale 	locale()</code> -- 返回构造此 formatter 时设置的语言环境</p></li>
                            <li><p><code>Appendable 	out()</code> -- 返回输出的目标文件</p></li>
                        </ol>

                        <p><b>Formatter 格式说明：</b></p>
                        <ol>
                            <li><p>常规类型、字符类型和数值类型的格式说明符的语法如下： </p>
                                <pre class="brush: bash;">
%[argument_index$][flags][width][.precision]conversion
# 可选的 argument_index 是一个十进制整数，用于表明参数在参数列表中的位置。第一个参数由 "1$" 引用，依此类推
# 可选 flags 是修改输出格式的字符集。有效标志集取决于转换类型(一般用不上)
# 可选 width 是一个十进制整数，表明要向输出中写入的最少字符数(正数左侧填充空格，负数右侧填充空格)
# 可选 precision 是一个非负十进制整数，通常用来限制字符数。特定行为取决于转换类型
# 所需 conversion 是一个表明应该如何格式化参数的字符。给定参数的有效转换集取决于参数的数据类型

format("%s - %d", "nate", 1024); // nate - 1024
format("%2$s - %1$d", 1024, "nate"); // 先使用第二个为 String 的参数，再使用第一个为 int 的参数: nate - 1024
format("%6s - %d", "nate", 1024); // 左侧填充了 2 个空格:     nate - 1024
format("%-6s - %d", "nate", 1024); // 右侧填充了 2 个空格: nate   - 1024
format("%.2s - %d", "nate", 1024); // 最多限制为 2 个字符: na - 1024

## 参数的数据类型
# 's', 'S' -- 字符串
# 'b', 'B' -- boolean 类型, null 或 false 为 false, 其他都为 true
# 'd' -- 整数
# 'f' -- 浮点数
# 'h', 'H' -- 十六进制
# 'o' -- 八进制
# 'c', 'C' -- char
# 'e', 'E' -- 计算机科学记数法表示的十进制数
# 'g', 'G' -- 根据精度和舍入运算后的值
# 'x', 'X' -- 结果被格式化为十六进制整数
# 'a', 'A' -- 结果被格式化为带有效位数和指数的十六进制浮点数
# 't', 'T' -- 日期和时间转换字符的前缀（参照下面）
</pre>
                            </li>
                            <li><p>用来表示日期和时间类型的格式说明符的语法如下：</p>
                                <pre class="brush: bash;">
%[argument_index$][flags][width]conversion
# 可选的 argument_index、flags 和 width 的定义同上
# 所需的 conversion 是一个由两字符组成的序列。第一个字符是 't' 或 'T'。第二个字符表明所使用的格式

# 4 个参数分别为年份，月份，一月中的多少天，时间
format("%1$tY %1$tm %1$td %1$tT", Calendar.getInstance()); // 2018 07 18 16:19:56

## 日期/时间转换(conversion 第二个字符)
## 1.格式化日期
# 'B' -- 特定于语言环境的月份全称，例如 "January" 和 "February"。
# 'b' -- 特定于语言环境的月份简称，例如 "Jan" 和 "Feb"。
# 'h' -- 与 'b' 相同。
# 'A' -- 特定于语言环境的星期几全称，例如 "Sunday" 和 "Monday"
# 'a' -- 特定于语言环境的星期几简称，例如 "Sun" 和 "Mon"
# 'C' -- 除以 100 的四位数表示的年份，被格式化为必要时带前导零的两位数，即 00 - 99
# 'Y' -- 年份，被格式化为必要时带前导零的四位数（至少），例如，0092 等于格里高利历的 92 CE。
# 'y' -- 年份的最后两位数，被格式化为必要时带前导零的两位数，即 00 - 99。
# 'j' -- 一年中的天数，被格式化为必要时带前导零的三位数，例如，对于格里高利历是 001 - 366。
# 'm' -- 月份，被格式化为必要时带前导零的两位数，即 01 - 13。
# 'd' -- 一个月中的天数，被格式化为必要时带前导零两位数，即 01 - 31
# 'e' -- 一个月中的天数，被格式化为两位数，即 1 - 31

# 2. 格式化时间
# 'H' -- 24 小时制的小时，被格式化为必要时带前导零的两位数，即 00 - 23。
# 'I' -- 12 小时制的小时，被格式化为必要时带前导零的两位数，即 01 - 12。
# 'k' -- 24 小时制的小时，即 0 - 23。
# 'l' -- 12 小时制的小时，即 1 - 12。
# 'M' -- 小时中的分钟，被格式化为必要时带前导零的两位数，即 00 - 59。
# 'S' -- 分钟中的秒，被格式化为必要时带前导零的两位数，即 00 - 60 （"60" 是支持闰秒所需的一个特殊值）。
# 'L' -- 秒中的毫秒，被格式化为必要时带前导零的三位数，即 000 - 999。
# 'N' -- 秒中的毫微秒，被格式化为必要时带前导零的九位数，即 000000000 - 999999999。
# 'p' -- 特定于语言环境的 上午或下午 标记以小写形式表示，例如 "am" 或 "pm"。使用转换前缀 'T' 可以强行转换为大写形式
# 'z' -- 相对于 GMT 的 RFC 822 格式的数字时区偏移量，例如 -0800。
# 'Z' -- 表示时区缩写形式的字符串。Formatter 的语言环境将取代参数的语言环境（如果有）。
# 's' -- 自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的秒数
# 'Q' -- 自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的毫秒数

# 3. 日期/时间组合
# 'R' -- 24 小时制的时间，被格式化为 "%tH:%tM"
# 'T' -- 24 小时制的时间，被格式化为 "%tH:%tM:%tS"。
# 'r' -- 12 小时制的时间，被格式化为 "%tI:%tM:%tS %Tp"。上午或下午标记 ('%Tp') 的位置可能与语言环境有关。
# 'D' -- 日期，被格式化为 "%tm/%td/%ty"。
# 'F' -- ISO 8601 格式的完整日期，被格式化为 "%tY-%tm-%td"。
# 'c' -- 日期和时间，被格式化为 "%ta %tb %td %tT %tZ %tY"，例如 "Sun Jul 20 16:17:00 EDT 1969"。
</pre>
                            </li>
                            <li><p>与参数不对应的格式说明符的语法如下： </p>
                                <pre class="brush: bash;">
%[flags][width]conversion
# 可选 flags 和 width 的定义同上
# 所需的 conversion 是一个表明要在输出中所插内容的字符

format("Today is %tA.", Calendar.getInstance()); // Today is Wednesday.
</pre>
                            </li>
                        </ol>


                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-Observable"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Observable</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.util.Observable

public class Observable {}

public interface Observer {
    void update(Observable o, Object arg);
}
</pre>
                        <p><a href="docs/docs-java/api/java/util/Observable.html" target="_blank">Observable</a> 表示模型视图范例中的 Observable 对象，或者说“数据”。可将其子类化，表示应用程序想要观察的对象。 </p>
                        <p>一个 Observable 对象可以有一个或多个观察者。观察者可以是实现了 Observer 接口的任意对象。一个 Observable 实例改变后，调用 Observable 的 notifyObservers 方法的应用程序会通过调用观察者的 update 方法来通知观察者该实例发生了改变。 </p>
                        <p>未指定发送通知的顺序。Observable 类中所提供的默认实现将按照其注册的重要性顺序来通知 Observers，但是子类可能改变此顺序，从而使用非固定顺序在单独的线程上发送通知，或者也可能保证其子类遵从其所选择的顺序。 </p>
                        <ol>
                            <li><p><code>void 	addObserver(Observer o)</code> -- 添加此观察者到 Observable</p></li>
                            <li><p><code>void 	notifyObservers()</code> -- 如果 hasChanged 方法指示对象已改变（要主动调用 <code>setChanged()</code>），则通知其所有观察者</p></li>
                            <li><p><code>void 	notifyObservers(Object arg)</code> -- 同上，加一个参数</p></li>

                            <li class="group"><p><code>boolean 	hasChanged()</code> -- 测试对象是否改变</p></li>
                            <li><p><code>protected void 	clearChanged()</code> -- 指示对象不再改变</p></li>
                            <li><p><code>protected void 	setChanged()</code> -- 标记此 Observable 对象为已改变的对象</p></li>

                            <li class="group"><p><code>int 	countObservers()</code> -- 返回 Observable 对象的观察者数目</p></li>
                            <li><p><code>void 	deleteObserver(Observer o)</code> -- 从对象的观察者集合中删除某个观察者</p></li>
                            <li><p><code>void 	deleteObservers()</code> -- 清除观察者列表，使此对象不再有任何观察者</p></li>
                        </ol>
                        <p>使用 Observerable 和 Observer 实现简单的 List 数据添加和删除通知到 Listener:</p>
                        <pre class="brush: java;">
public class ListOservable&lt;T> extends Observable {
    private List&lt;T> datas = new ArrayList<>();

    public void add(T t) {
        datas.add(t);
        setChanged();
        notifyObservers(t);
    }

    public T get(int index) {
        return datas.get(index);
    }

    public void remove(int index) {
        T t = datas.remove(index);
        setChanged();
        notifyObservers(t);
    }
}

class Listener implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        log("Listener", arg);
    }
}
                        </pre>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-UUID"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">UUID</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.util.UUID

public final class UUID implements java.io.Serializable, Comparable&lt;UUID> {
    public UUID(long mostSigBits, long leastSigBits) {}
}
</pre>
                        <p><a href="docs/docs-java/api/java/util/UUID.html" target="_blank">UUID</a> 表示通用唯一标识符 (UUID) 的类。 UUID 表示一个 128 位的值。 </p>
                        <p>这些通用标识符具有不同的变体。此类的方法用于操作 Leach-Salz 变体，不过构造方法允许创建任何 UUID 变体（将在下面进行描述）。</p>
                        <p>Leach-Salz 变体 UUID 的布局如下： long 型数据的 最高 / 最低 有效位由以下无符号字段组成： </p>
                        <pre class="brush: java;">
// 最高有效位:
0xFFFFFFFF00000000 time_low
0x00000000FFFF0000 time_mid
0x000000000000F000 version
0x0000000000000FFF time_hi

// 最低有效位:
0xC000000000000000 variant
0x3FFF000000000000 clock_seq
0x0000FFFFFFFFFFFF node
</pre>
                        <p>variant 字段包含一个表示 UUID 布局的值。以上描述的位布局仅在 UUID 的 variant 值为 2（表示 Leach-Salz 变体）时才有效。</p>
                        <p>version 字段保存描述此 UUID 类型的值。有 4 种不同的基本 UUID 类型：基于时间的 UUID、DCE 安全 UUID、基于名称的 UUID 和随机生成的 UUID。 这些类型的 version 值分别为 1、2、3 和 4。 </p>
                        <ol>

                            <li><p><code>static UUID 	randomUUID()</code> -- 获取类型为 4（伪随机生成的）UUID 的静态工厂</p></li>
                            <li><p><code>static UUID 	fromString(String name)</code> --  根据 toString() 方法中描述的字符串标准表示形式创建 UUID</p></li>
                            <li><p><code>static UUID 	nameUUIDFromBytes(byte[] name)</code> -- 根据指定的字节数组获取类型 3（基于名称的）UUID 的静态工厂</p></li>

                            <li class="group"><p><code>int 	variant()</code> -- 与此 UUID 相关联的变体号</p></li>
                            <li><p><code>int 	version()</code> -- 与此 UUID 相关联的版本号</p></li>
                            <li><p><code>int 	clockSequence()</code> -- 与此 UUID 相关联的时钟序列值</p></li>

                            <li class="group"><p><code>long 	node()</code> -- 与此 UUID 相关的节点值</p></li>
                            <li><p><code>long 	timestamp()</code> -- 与此 UUID 相关联的时间戳值</p></li>
                            <li><p><code>long 	getMostSignificantBits()</code> -- 返回此 UUID 的 128 位值中的最高有效 64 位</p></li>
                            <li><p><code>long 	getLeastSignificantBits()</code> -- 返回此 UUID 的 128 位值中的最低有效 64 位</p></li>

                            <li class="group"><p><code>int 	hashCode()</code> -- 返回此 UUID 的哈希码</p></li>
                            <li><p><code>boolean 	equals(Object obj)</code> -- 将此对象与指定对象比较</p></li>
                            <li><p><code>String 	toString()</code> -- 返回表示此 UUID 的 String 对象</p></li>
                            <li><p><code>int 	compareTo(UUID val)</code> -- 将此 UUID 与指定的 UUID 比较</p></li>

                        </ol>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-util-Scanner"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Scanner</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">
public final class Scanner implements Iterator&lt;String>, Closeable {
	public Scanner(String source) {...}
	public Scanner(InputStream source) {...}
	public Scanner(InputStream source, String charsetName) {...}
	public Scanner(File source) {...}
	public Scanner(File source, String charsetName) {...}
	public Scanner(Path source) {...}
	public Scanner(Path source, String charsetName) {...}
	public Scanner(Readable source) {...}
	public Scanner(ReadableByteChannel source) {...}
	public Scanner(ReadableByteChannel source, String charsetName) {...}
}
</pre>
						<p><a href="docs/docs-java/api/java/uti/Scanner.html" target="_blank">Scanner</a> 是一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。</p>
						<p><a href="docs/docs-java/api/java/uti/Scanner.html" target="_blank">Scanner</a> 使用分隔符模式将其输入分解为标记，默认情况下该分隔符模式与空白匹配。然后可以使用不同的 next 方法将得到的标记转换为不同类型的值。 </p>
						<ol>

							<li><p><code>Pattern 	delimiter()</code> -- 返回此 Scanner 当前正在用于匹配分隔符的 Pattern</p></li>
							<li><p><code>Scanner 	useDelimiter(Pattern pattern)</code> -- </p></li>
							<li><p><code>Scanner 	useDelimiter(String pattern)</code> -- </p></li>


							<li><p><code>Scanner 	skip(Pattern pattern)</code> -- </p></li>
							<li><p><code>Scanner 	skip(String pattern)</code> -- </p></li>
							<li><p><code>Scanner 	useLocale(Locale locale)</code> -- </p></li>
							<li><p><code>Scanner 	useRadix(int radix)</code> -- </p></li>

							<li class="group"><p><code>String 	findInLine(Pattern pattern)</code> -- 试图在忽略分隔符的情况下查找下一个指定模式</p></li>
							<li><p><code>String 	findInLine(String pattern)</code> -- 试图在忽略分隔符的情况下查找下一个从指定字符串构造的模式</p></li>
							<li><p><code>String 	findWithinHorizon(Pattern pattern, int horizon)</code> -- 试图查找下一个指定模式</p></li>
							<li><p><code>String 	findWithinHorizon(String pattern, int horizon)</code> -- 试图在忽略分隔符的情况下查找下一个从指定字符串构造的模式</p></li>


							<li class="group"><p><code>boolean 	hasNext()</code> -- 如果此扫描器的输入中有另一个标记，则返回 true</p></li>
							<li><p><code>boolean 	hasNext(Pattern pattern)</code> -- 如果下一个完整标记与指定模式匹配，则返回 true</p></li>
							<li><p><code>boolean 	hasNext(String pattern)</code> -- 如果下一个标记与从指定字符串构造的模式匹配，则返回 true</p></li>
							<li><p><code>boolean 	hasNextBigDecimal()</code> -- </p></li>
							<li><p><code>boolean 	hasNextBigInteger()</code> -- </p></li>
							<li><p><code>boolean 	hasNextBigInteger(int radix)</code> -- </p></li>
							<li><p><code>boolean 	hasNextBoolean()</code> -- </p></li>
							<li><p><code>boolean 	hasNextByte()</code> -- </p></li>
							<li><p><code>boolean 	hasNextByte(int radix)</code> -- </p></li>
							<li><p><code>boolean 	hasNextDouble()</code> -- </p></li>
							<li><p><code>boolean 	hasNextFloat()</code> -- </p></li>
							<li><p><code>boolean 	hasNextInt()</code> -- </p></li>
							<li><p><code>boolean 	hasNextInt(int radix)</code> -- </p></li>
							<li><p><code>boolean 	hasNextLine()</code> -- </p></li>
							<li><p><code>boolean 	hasNextLong()</code> -- </p></li>
							<li><p><code>boolean 	hasNextLong(int radix)</code> -- </p></li>
							<li><p><code>boolean 	hasNextShort()</code> -- </p></li>
							<li><p><code>boolean 	hasNextShort(int radix)</code> -- </p></li>

							<li class="group"><p><code>String 	next()</code> -- </p></li>
							<li><p><code>String 	next(Pattern pattern)</code> -- </p></li>
							<li><p><code>String 	next(String pattern)</code> -- </p></li>
							<li><p><code>BigDecimal 	nextBigDecimal()</code> -- </p></li>
							<li><p><code>BigInteger 	nextBigInteger()</code> -- </p></li>
							<li><p><code>BigInteger 	nextBigInteger(int radix)</code> -- </p></li>
							<li><p><code>boolean 	nextBoolean()</code> -- </p></li>
							<li><p><code>byte 	nextByte()</code> -- </p></li>
							<li><p><code>byte 	nextByte(int radix)</code> -- </p></li>
							<li><p><code>double 	nextDouble()</code> -- </p></li>
							<li><p><code>float 	nextFloat()</code> -- </p></li>
							<li><p><code>int 	nextInt()</code> -- </p></li>
							<li><p><code>int 	nextInt(int radix)</code> -- </p></li>
							<li><p><code>String 	nextLine()</code> -- </p></li>
							<li><p><code>long 	nextLong()</code> -- </p></li>
							<li><p><code>long 	nextLong(int radix)</code> -- </p></li>
							<li><p><code>short 	nextShort()</code> -- </p></li>
							<li><p><code>short 	nextShort(int radix)</code> -- </p></li>

							<li class="group"><p><code>Scanner 	reset()</code> -- </p></li>
							<li><p><code>int 	radix()</code> -- </p></li>
							<li><p><code>MatchResult 	match()</code> -- </p></li>

							<li><p><code>IOException 	ioException()</code> -- </p></li>
							<li><p><code>Locale 	locale()</code> -- </p></li>

							<li><p><code>void 	remove()</code> -- </p></li>

							<li><p><code>void 	close()</code> -- 关闭此扫描器</p></li>

							<li><p><code>String 	toString()</code> -- </p></li>
						</ol>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-concurrent-Executor"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">java.util.concurrent.Executor 及实现类</h3>
                    </div>
                    <div class="panel-body">
						<div class="sub-item">
						<pre class="brush: java;">
java.lang.Object
	java.util.concurrent.Executor

public interface Executor {
    void execute(Runnable command);
}
</pre>
						<p><a href="docs/docs-java/api/java/util/concurrent/Executor.html" target="_blank">Executor</a> 执行已提交的 Runnable 任务的对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法。通常使用 Executor 而不是显式地创建线程。</p>
						<p>不过，Executor 接口并没有严格地要求执行是异步的。在最简单的情况下，执行程序可以在调用者的线程中立即运行已提交的任务： </p>
						<pre class="brush: java;">
 class DirectExecutor implements Executor {
     public void execute(Runnable r) {
         r.run();
     }
 }
</pre>
						<p>更常见的是，任务是在某个不是调用者线程的线程中执行的。以下执行程序将为每个任务生成一个新线程。 </p>
						<pre class="brush: java;">
 class ThreadPerTaskExecutor implements Executor {
     public void execute(Runnable r) {
         new Thread(r).start();
     }
 }
</pre>
						<p>许多 Executor 实现都对调度任务的方式和时间强加了某种限制。以下执行程序使任务提交与第二个执行程序保持连续，这说明了一个复合执行程序。</p>
						<pre class="brush: java;">
class SerialExecutor implements Executor {
     final Queue&lt;Runnable> tasks = new ArrayDeque&lt;Runnable>();
     final Executor executor;
     Runnable active;

     SerialExecutor(Executor executor) {
         this.executor = executor;
     }

     public synchronized void execute(final Runnable r) {
         tasks.offer(new Runnable() {
             public void run() {
                 try {
                     r.run();
                 } finally {
                     scheduleNext();
                 }
             }
         });
         if (active == null) {
             scheduleNext();
         }
     }

     protected synchronized void scheduleNext() {
         if ((active = tasks.poll()) != null) {
             executor.execute(active);
         }
     }
}
</pre>
						<p>此包中提供的 Executor 实现实现了 ExecutorService，这是一个使用更广泛的接口。ThreadPoolExecutor 类提供一个可扩展的线程池实现。Executors 类为这些 Executor 提供了便捷的工厂方法。 </p>
						</div>

						<div class="sub-item">
							<p><b>Execuror 子接口，实现类和相关类</b></p>
							<ul>
								<li><p><a href="docs/docs-java/api/java/util/concurrent/ExecutorService.html" target="_blank">ExecutorService</a> 接口是 Executor 子接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。</p>
									<p>可以关闭 ExecutorService，这将导致其拒绝新任务。提供两个方法来关闭 ExecutorService。<code>shutdown()</code> 方法在终止前允许执行以前提交的任务，而 <code>shutdownNow()</code> 方法阻止等待任务启动并试图停止当前正在执行的任务。在终止时，执行程序没有任务在执行，也没有任务在等待执行，并且无法提交新任务。应该关闭未使用的 ExecutorService 以允许回收其资源。 </p>
									<p>通过创建并返回一个可用于取消执行和/或等待完成的 Future，方法 submit 扩展了基本方法 Executor.execute(java.lang.Runnable)。方法 invokeAny 和 invokeAll 是批量执行的最常用形式，它们执行任务 collection，然后等待至少一个，或全部任务完成</p>
									<pre class="brush: java;">
public interface ExecutorService extends Executor {
	boolean isShutdown(); // 此执行程序是否已关闭
	void shutdown(); // 启动一次顺序关闭，执行以前提交的任务，但不接受新任务
	List&lt;Runnable> shutdownNow(); // 试图停止所有正在执行的任务，暂停处理正在等待的任务，并返回等待执行的任务列表

	Future&lt;?> submit(Runnable task); // 提交一个返回值的任务用于执行，并返回一个表示该任务的 Future
	&lt;T> Future&lt;T> submit(Runnable task, T result); // 提交一个 Runnable 任务用于执行
	&lt;T> Future&lt;T> submit(Callable&lt;T> task); // 提交一个 Runnable 任务用于执行

	boolean isTerminated(); // 如果关闭后所有任务都已完成，则返回 true
	// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行
	boolean awaitTermination(long timeout, TimeUnit unit);

	// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表
	&lt;T> List&lt;Future&lt;T>> invokeAll(Collection&lt;? extends Callable&lt;T>> tasks);
	// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表
	&lt;T> List&lt;Future&lt;T>> invokeAll(Collection&lt;? extends Callable&lt;T>> ts, long tout, TimeUnit unit);
	// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果
	&lt;T> T invokeAny(Collection&lt;? extends Callable&lt;T>> tasks);
	// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果
	&lt;T> T invokeAny(Collection&lt;? extends Callable&lt;T>> tasks, long timeout, TimeUnit unit);
}
</pre>
								</li>
								<li><p><a href="docs/docs-java/api/java/util/concurrent/AbstractExecutorService.html" target="_blank">AbstractExecutorService</a> 提供 ExecutorService 执行方法的默认实现。此类使用 newTaskFor 返回的 RunnableFuture 实现 submit、invokeAny 和 invokeAll 方法，默认情况下，RunnableFuture 是此包中提供的 FutureTask 类。</p>
									<pre class="brush: java;">
/** 此类实现了接口的 submit(...) 和 invoke... 方法 */
public abstract class AbstractExecutorService implements ExecutorService {
	// 为给定可调用任务返回一个 RunnableFuture。
	protected &lt;T> RunnableFuture&lt;T> newTaskFor(Callable&lt;T> callable) {}
	// 为给定可运行任务和默认值返回一个 RunnableFuture
	protected &lt;T> RunnableFuture&lt;T> newTaskFor(Runnable runnable, T value) {}
}
</pre>
								</li>
								<li><p><a href="docs/docs-java/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank">ScheduledExecutorService</a> 接口也是一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令。 </p>
									<p>schedule 方法使用各种延迟创建任务，并返回一个可用于取消或检查执行的任务对象。scheduleAtFixedRate 和 scheduleWithFixedDelay 方法创建并执行某些在取消前一直定期运行的任务。 </p>
									<p>所有的 schedule 方法都接受相对 延迟和周期作为参数，而不是绝对的时间或日期。</p>
									<pre class="brush: java;">
public interface ScheduledExecutorService extends ExecutorService {
	// 创建并执行在给定延迟后启用的 ScheduledFuture。
	&lt;V> ScheduledFuture&lt;V> schedule(Callable&lt;V> callable, long delay, TimeUnit unit);
	// 创建并执行在给定延迟后启用的一次性操作。
	ScheduledFuture&lt;?> schedule(Runnable command, long delay, TimeUnit unit);
    /* 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initDelay 后开始执行，
	 * 然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。*/
 	ScheduledFuture&lt;?> scheduleAtFixedRate(Runnable r, long initDelay, long period, TimeUnit unit);
	// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟
 	ScheduledFuture&lt;?> scheduleWithFixedDelay(Runnable r, long initDelay, long delay, TimeUnit unit);
}
</pre>
								</li>
								<li><p><a href="" target="_blank">ThreadPoolExecutor</a> 类是一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务。</p>
									<p>因为它的构造函数参数较多，使用容易出错，通常使用 Executors 工厂方法配置(具体使用参照: <a href="index.html#java-thread-pool">线程池</a>)。</p>
									<p>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 </p>
									<p>为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）、Executors.newFixedThreadPool(int)（固定大小线程池）和 Executors.newSingleThreadExecutor()（单个后台线程），它们均为大多数使用场景预定义了设置。</p>
									<pre class="brush: java;">
public class ThreadPoolExecutor extends AbstractExecutorService {
	/** 以下 4 个内部类都用于被拒绝任务的处理程序，都实现 RejectedExecutionHandler 接口
	 * AbortPolicy -- 将抛出 RejectedExecutionException。
 	 * CallerRunsPolicy -- 直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则丢弃该任务。
	 * DiscardOldestPolicy -- 放弃最旧的未处理请求，然后重试 execute；如果执行程序已关闭，则会丢弃该任务。
	 * DiscardPolicy -- 默认情况下它将丢弃被拒绝的任务。
	 */
	public static class AbortPolicy implements RejectedExecutionHandler {}
	public static class CallerRunsPolicy implements RejectedExecutionHandler {}
	public static class DiscardOldestPolicy implements RejectedExecutionHandler {}
	public static class DiscardPolicy implements RejectedExecutionHandler {}

	public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,
							  	TimeUnit unit, BlockingQueue&lt;Runnable> workQueue) {}
	public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,
                              	TimeUnit unit, BlockingQueue&lt;Runnable> workQueue,
							  	RejectedExecutionHandler handler) {}
	public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,
                              	TimeUnit unit, BlockingQueue&lt;Runnable> workQueue,
                              	ThreadFactory threadFactory) {}
	public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,
                              	TimeUnit unit, BlockingQueue&lt;Runnable> workQueue,
                              	ThreadFactory threadFactory, RejectedExecutionHandler handler) {}

	protected void afterExecute(Runnable r, Throwable t); // 基于完成执行给定 Runnable 所调用的方法。
	protected void beforeExecute(Thread t, Runnable r); // 在执行给定线程中的给定 Runnable 之前调用的方法。
	protected void terminated(); // 当 Executor 已经终止时调用的方法。
	protected void finalize(); // 当不再引用此执行程序时，调用 shutdown。

	public boolean isTerminated(); // 如果关闭后所有任务都已完成，则返回 true。
 	public boolean isTerminating(); // 如果此执行程序处于在 shutdown 或 shutdownNow 之后正在终止但尚未完全终止的过程中，则返回 true。
	public boolean awaitTermination(long timeout, TimeUnit unit); // 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。

	public boolean isShutdown(); // 如果此执行程序已关闭，则返回 true。
 	public void shutdown(); // 按过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务。
 	public List&lt;Runnable> shutdownNow(); // 尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表。

	public void allowCoreThreadTimeOut(boolean value); // 如果在保持活动时间内没有任务到达，新任务到达时正在替换（如果需要），则设置控制核心线程是超时还是终止的策略。
	public boolean 	allowsCoreThreadTimeOut(); // 如果此池允许核心线程超时和终止，如果在 keepAlive 时间内没有任务到达，新任务到达时正在替换（如果需要），则返回 true。

	public void execute(Runnable command); // 在将来某个时间执行给定任务。

 	public int getActiveCount(); // 返回主动执行任务的近似线程数。
 	public long getCompletedTaskCount(); // 返回已完成执行的近似任务总数。
	public long getTaskCount(); // 返回曾计划执行的近似任务总数。

 	public int getCorePoolSize(); // 返回核心线程数。
	public void setCorePoolSize(int corePoolSize); // 设置核心线程数。
 	public int getMaximumPoolSize(); // 返回允许的最大线程数。
	public void setMaximumPoolSize(int maximumPoolSize); // 设置允许的最大线程数。
 	public int getPoolSize(); // 返回池中的当前线程数。
	public int getLargestPoolSize(); // 返回曾经同时位于池中的最大线程数。

 	public long getKeepAliveTime(TimeUnit unit); // 返回线程保持活动的时间，该时间就是超过核心池大小的线程可以在终止前保持空闲的时间值。
 	public void setKeepAliveTime(long time, TimeUnit unit); // 设置线程在终止前可以保持空闲的时间限制。


 	public RejectedExecutionHandler getRejectedExecutionHandler(); // 返回用于未执行任务的当前处理程序。
	public void setRejectedExecutionHandler(RejectedExecutionHandler handler); // 设置用于未执行任务的新处理程序。
 	public ThreadFactory getThreadFactory(); // 返回用于创建新线程的线程工厂。
	public void setThreadFactory(ThreadFactory threadFactory); // 设置用于创建新线程的线程工厂。

 	public int prestartAllCoreThreads(); // 启动所有核心线程，使其处于等待工作的空闲状态。
 	public boolean prestartCoreThread(); // 启动核心线程，使其处于等待工作的空闲状态。

	public BlockingQueue&lt;Runnable> getQueue(); // 返回此执行程序使用的任务队列。
	public void purge(); // 尝试从工作队列移除所有已取消的 Future 任务。
	public boolean remove(Runnable task); // 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。
}
</pre>
								</li>
								<li><p><a href="" target="_blank">Executors</a> 此包中所定义的 Executor、ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 类的工厂和实用方法。此类支持以下各种方法：</p>
									<ul>
										<li><p>创建并返回设置有常用配置字符串的 ExecutorService 的方法。</p></li>
										<li><p>创建并返回设置有常用配置字符串的 ScheduledExecutorService 的方法。</p></li>
										<li><p>创建并返回“包装的”ExecutorService 方法，它通过使特定于实现的方法不可访问来禁用重新配置。</p></li>
										<li><p>创建并返回 ThreadFactory 的方法，它可将新创建的线程设置为已知的状态。</p></li>
										<li><p>创建并返回非闭包形式的 Callable 的方法，这样可将其用于需要 Callable 的执行方法中。</p></li>
									</ul>
									<pre class="brush: java;">
public class Executors {
	static ExecutorService newCachedThreadPool() {}
	static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {}
	static ExecutorService newFixedThreadPool(int nThreads) {}
	static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {}
	static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {}
	static ScheduledExecutorService newScheduledThreadPool(int corePoolSize,
										ThreadFactory threadFactory) {}
	static ExecutorService newSingleThreadExecutor() {}
	static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {}
	static ScheduledExecutorService newSingleThreadScheduledExecutor() {}
	static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {}

	static ThreadFactory defaultThreadFactory() {}
	static Callable&lt;Object> callable(Runnable task) {}
	static &lt;T> Callable&lt;T> callable(Runnable task, T result) {}
	static Callable&lt;Object> callable(PrivilegedAction&lt;?> action) {}
	static Callable&lt;Object> callable(PrivilegedExceptionAction&lt;?> action) {}

	static &lt;T> Callable&lt;T> privilegedCallable(Callable&lt;T> callable) {}
	static &lt;T> Callable&lt;T> privilegedCallableUsingCurrentClassLoader(Callable&lt;T> callable) {}
	static ThreadFactory privilegedThreadFactory() {}
	static ExecutorService unconfigurableExecutorService(ExecutorService executor) {}
	static ScheduledExecutorService unconfigurableScheduledExecutorService(
										ScheduledExecutorService executor) {}
}
</pre>
								</li>
								<li><p><a href="" target="_blank">ScheduledThreadPoolExecutor</a> 可另行安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。 </p>
									<p>一旦启用已延迟的任务就执行它，但是有关何时启用，启用后何时执行则没有任何实时保证。按照提交的先进先出 (FIFO) 顺序来启用那些被安排在同一执行时间的任务。 </p>
									<p>虽然此类继承自 ThreadPoolExecutor，但是几个继承的调整方法对此类并无作用。特别是，因为它作为一个使用 corePoolSize 线程和一个无界队列的固定大小的池，所以调整 maximumPoolSize 没有什么效果。 </p>
									<pre class="brush: java;">
public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor
										implements ScheduledExecutorService {
	public ScheduledThreadPoolExecutor(int corePoolSize) {}
	public ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler) {}
	public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {}
	public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory,
											RejectedExecutionHandler handler) {}

	protected &lt;V> RunnableScheduledFuture&lt;V> decorateTask(Callable&lt;V> callable,
										RunnableScheduledFuture&lt;V> task) {}
	protected &lt;V> RunnableScheduledFuture&lt;V> decorateTask(Runnable runnable,
										RunnableScheduledFuture&lt;V> task) {}
	public void execute(Runnable command) {}
	public boolean getContinueExistingPeriodicTasksAfterShutdownPolicy() {}
	public boolean getExecuteExistingDelayedTasksAfterShutdownPolicy() {}
	public BlockingQueue&lt;Runnable> getQueue() {}
	public boolean getRemoveOnCancelPolicy() {}
	public &lt;V> ScheduledFuture&lt;V> schedule(Callable&lt;V> callable, long delay, TimeUnit unit) {}
	public ScheduledFuture&lt;?> schedule(Runnable command, long delay, TimeUnit unit) {}
	public ScheduledFuture&lt;?> scheduleAtFixedRate(Runnable command, long initialDelay,
										long period, TimeUnit unit) {}
	public ScheduledFuture&lt;?> scheduleWithFixedDelay(Runnable command, long initialDelay,
										long delay, TimeUnit unit) {}
	public void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value) {}
	public void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value) {}
	public void setRemoveOnCancelPolicy(boolean value) {}
	public void shutdown() {}
	public List&lt;Runnable> shutdownNow() {}
	public &lt;T> Future&lt;T> submit(Callable&lt;T> task) {}
	public Future&lt;?> submit(Runnable task) {}
	public &lt;T> Future&lt;T> submit(Runnable task, T result) {}
}
</pre>
								</li>
								<li>
									<p><a href="docs/docs-java/api/java/util/concurrent/RejectedExecutionHandler.html" target="_blank">RejectedExecutionHandler</a> 接口是无法由 ThreadPoolExecutor 执行的任务的处理程序。ThreadPoolExecutor 的 4 个内部类都实现此接口。</p>
									<pre class="brush: java;">
public interface RejectedExecutionHandler {
	// 当 execute 不能接受某个任务时，可以由 ThreadPoolExecutor 调用的方法
	void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
</pre>
								</li>
							</ul>
						</div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-concurrent-Future"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">java.util.concurrent.Future 及实现类</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
public interface Future&lt;V> {
	boolean cancel(boolean mayInterruptIfRunning); // 试图取消对此任务的执行
	boolean isCancelled(); // 如果在任务正常完成前将其取消，则返回 true
	boolean isDone(); // 如果任务已完成，则返回 true
	V get(); // 如有必要，等待计算完成，然后获取其结果
	V get(long timeout, TimeUnit unit); // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果
}
</pre>
						<p><a href="docs/docs-java/api/java/util/concurrent/Future.html" target="_blank">Future</a> 表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如有必要，计算完成前可以阻塞此方法。取消则由 cancel 方法来执行。还提供了其他方法，以确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?> 形式类型、并返回 null 作为底层任务的结果。 </p>
						<p><b>Future 的子接口及实现类:</b></p>
						<ul>
							<li><p><a href="docs/docs-java/api/java/util/concurrent/RunnableFuture.html" target="_blank">RunnableFuture</a> 成功执行 run 方法可以完成 Future 并允许访问其结果。</p>
								<pre class="brush: java;">
public interface RunnableFuture&lt;V> extends Runnable, Future&lt;V> {
	void run(); // 在未被取消的情况下，将此 Future 设置为计算的结果
}
</pre>
							</li>
							<li><p><a href="docs/docs-java/api/java/util/concurrent/ScheduledFuture.html" target="_blank">ScheduledFuture</a> 一个延迟的、结果可接受的操作，可将其取消。通常已安排的 future 是用 ScheduledExecutorService 安排任务的结果。 </p>
								<pre class="brush: java;">
public interface ScheduledFuture&lt;V> extends Delayed, Future&lt;V> {}

/**  一种混合风格的接口，用来标记那些应该在给定延迟时间之后执行的对象。
 *  此接口的实现必须定义一个 compareTo 方法，该方法提供与此接口的 getDelay 方法一致的排序。
 */
public interface Delayed extends Comparable&lt;Delayed> {
	long getDelay(TimeUnit unit); // 返回与此对象相关的剩余延迟时间，以给定的时间单位表示
}
</pre>
							</li>
							<li><p><a href="docs/docs-java/api/java/util/concurrent/RunnableScheduledFuture.html" target="_blank">RunnableScheduledFuture</a> 成功执行 run 方法可以完成 Future 并允许访问其结果。 </p>
								<pre class="brush: java;">
public interface RunnableScheduledFuture&lt;V> extends RunnableFuture&lt;V>, ScheduledFuture&lt;V> {
	boolean isPeriodic(); // 如果这是一个定期任务，则返回 true
}
</pre>
							</li>
							<li><p><a href="docs/docs-java/api/java/util/concurrent/FutureTask.html" target="_blank">FutureTask</a> 可取消的异步计算。利用开始和取消计算的方法、查询计算是否完成的方法和获取计算结果的方法，此类提供了对 Future 的基本实现。仅在计算完成时才能获取结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。 </p>
								<p>可使用 FutureTask 包装 Callable 或 Runnable 对象。因为 FutureTask 实现了 Runnable，所以可将 FutureTask 提交给 Executor 执行。 </p>
								<p>除了作为一个独立的类外，此类还提供了 protected 功能，这在创建自定义任务类时可能很有用。</p>
								<pre class="brush: java;">
public class FutureTask&lt;V> implements RunnableFuture&lt;V> {
	public FutureTask(Callable&lt;V> callable) {}
	public FutureTask(Runnable runnable, V result) {}

	protected void done() {} // 当此任务转换到状态 isDone 时，调用受保护的方法
	// 执行计算而不设置其结果，然后将此 Future 重置为初始状态，如果计算遇到异常或已取消，则该操作失败
	protected boolean runAndReset() {}
	protected void set(V v) {} // 除非已经设置了此 Future 或已将其取消，否则将其结果设置为给定的值
	// 除非已经设置了此 Future 或已将其取消，否则报告一个 ExecutionException，并将给定的 throwable 作为其原因
	protected void setException(Throwable t) {}

	public boolean cancel(boolean mayInterruptIfRunning) {} // 试图取消对此任务的执行
	public boolean isCancelled() {} // 如果在任务正常完成前将其取消，则返回 true
	public boolean isDone() {} // 如果任务已完成，则返回 true

	public void run() {} // 除非已将此 Future 取消，否则将其设置为其计算的结果

	public V get() {} // 如有必要，等待计算完成，然后获取其结果
	public V get(long timeout, TimeUnit unit) {} // 如有必要，最多等待为所给定的时间之后，获取其结果
}
</pre>
							</li>
						</ul>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-io-InputStream"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">InputStream & OutputStream</h3>
					</div>
					<div class="panel-body">
						<div class="col-md-6">
							<pre class="brush: java;">
interface DataInput // 基本类型读取支持
 └ interface ObjectInput // 对象读支持

InputStream
├ FileInputStream   // 从文件获得输入字节流
├ ByteArrayInputStream // 内存字节流
├ ObjectInputStream    // 反序列化流
├ PipedInputStream     // 管道输入流
├ SequenceInputStream  // 输入流的有序集合
├ AudioInputStream     // 音频输入流
└ FilterInputStream // InputStream 的装饰者
  ├ BufferedInputStream // 缓冲支持
  ├ DataInputStream     // 基本类型支持
  ├ DigestInputStream   // 摘要支持(MD5, SHA)
  ├ CheckedInputStream  // 完整性验证
  ├ CipherInputStream   // 加密支持
  │ -
  ├ ProgressMonitorInputStream // 进度支持
  ├ PushbackInputStream // 回退流
  ├ DeflaterInputStream // 压缩输入
  └ InflaterInputStream // 解压输入
    ├ GZIPInputStream   // GZIP
	└ ZipInputStream    // Zip
	  └ JarInputStream  // Jar
</pre>
						</div>
						<div class="col-md-6">
							<pre class="brush: java;">
interface DataOutput  // 基本类型写入支持
 └ interface ObjectOutput // 对象写支持

OutputStream
├ FileOutputStream // 将字节流写入文件
├ ByteArrayOutputStream // 内存字节流
├ ObjectOutputStream    // 序列化流
├ PipedOutputStream     // 管道输出流
│ -
│ -
└ FilterOutputStream // OutputStream 的装饰
  ├ BufferedOutputStream // 缓冲支持
  ├ DataOutputStream     // 基本类型支持
  ├ DigestOutputStream   // 摘要(MD5, SHA)
  ├ CheckedOutputStream  // 完整性验证
  ├ CipherOutputStream   // 加密支持
  ├ PrintStream // 打印流，可以是其他的输出流
  │	-
  │	-
  ├ InflaterOutputStream // 解压输出
  └ DeflaterOutputStream // 压缩输出
	├ GZIPOutputStream   // GZip
	└ ZipOutputStream    // Zip
	  └ JarOutputStream  // Jar
</pre>
						</div>


						<pre class="brush: java;">
public abstract class InputStream implements Closeable {
	abstract int read();      		// 从输入流中读取数据的下一个字节

	int read(byte[] b) {...} // 从输入流中读取最多 b.length 的字节，并将其存储在缓冲区数组 b 中
	int read(byte[] b, int off, int len) {...} // 将输入流中指定偏移量 off 最多 len 个数据字节读入 byte 数组

	int available() {...}    // 返回此输入流下一个方法调用可以不受阻塞地从此输入流读取的估计字节数
	boolean markSupported() {...}	// 测试此输入流是否支持 mark 和 reset 方法
	void mark(int readlimit) {...}	// 在此输入流中标记当前的位置
	void reset() {...}				// 将此流重新定位到最后一次对此输入流调用 mark 方法时的位置
	long skip(long n) {...}         // 跳过和丢弃此输入流中数据的 n 个字节

	void close() {...}				// 关闭此输入流并释放与该流关联的所有系统资源
}

public abstract class OutputStream implements Closeable, Flushable {
	abstract void write(int b); // 将指定的字节写入此输出流

	void write(byte[] b) {...}                   // 将 b.length 个字节从指定的 byte 数组写入此输出流
	void write(byte[] b, int off, int len) {...} // 同上, 从偏移量 off 开始的 len 个字节写入此输出流

	void flush() {...}          // 刷新此输出流并强制写出所有缓冲的输出字节
	void close() {...}          // 关闭此输出流并释放与此流有关的所有系统资源
}

/** 用于 Java 基本类型和对象读取的流 */
class DataInputStream extends FilterInputStream implements DataInput
class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants

/** 用于 Java 基本类型和对象写入的流 */
class DataOutputStream extends FilterOutputStream implements DataOutput
class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants

/** 支持对随机访问文件的读取和写入，包括读写基本类型/对象/按行读等方法 */
class RandomAccessFile implements DataOutput, DataInput, Closeable
</pre>
						<p><a href="docs/docs-java/api/java/io/InputStream.html" target="_blank">InputStream</a> 抽象类是表示字节输入流的所有类的超类。需要定义 InputStream 子类的应用程序必须总是提供返回下一个输入字节的方法。  </p>
						<p><a href="docs/docs-java/api/java/io/OutputStream.html" target="_blank">OutputStream</a> 抽象类是表示输出字节流的所有类的超类。需要定义 OutputStream 子类的应用程序必须始终提供至少一种可写入一个输出字节的方法。  </p>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-io-Reader"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Reader & Writer</h3>
					</div>
					<div class="panel-body">
						<div class="col-md-6">
							<pre class="brush: java;">
Reader
├ StringReader
├ CharArrayReader
├ PipedReader
├ BufferedReader
│ └ LineNumberReader
├ FilterReader
│ └ PushbackReader
│ -
└ InputStreamReader
  └ FileReader
</pre>
						</div>
						<div class="col-md-6">
							<pre class="brush: java;">
Writer
├ StringWriter
├ CharArrayWriter
├ PipedWriter
├ BufferedWriter
│ -
├ FilterWriter
│ -
├ PrintWriter
└ OutputStreamWriter
  └ FileWriter
</pre>
						</div>

						<pre class="brush: java;">
public abstract class Reader implements Readable, Closeable {
	abstract int read(char[] cbuf, int off, int len);
	abstract void close();

	boolean ready() {...}
	int read() {...}
	int read(char[] cbuf) {...}
	int read(CharBuffer target) {...}

	boolean markSupported() {...}
	void mark(int readAheadLimit) {...}
	void reset() {...}
	long skip(long n) {...}
}

public abstract class Writer implements Appendable, Closeable, Flushable {
	abstract void write(char[] cbuf, int off, int len);
	abstract void flush();
	abstract void close();

	void write(char[] cbuf) {...}
	void write(int c) {...}
	void write(String str) {...}
	void write(String str, int off, int len) {...}

	Writer append(char c) {...}
	Writer append(CharSequence csq) {...}
	Writer append(CharSequence csq, int start, int end) {...}
}
</pre>

						<p><a href="docs/docs-java/api/java/io/Reader.html" target="_blank">Reader</a> 读取字符流的抽象类。子类必须实现的方法只有 <code>read(char[], int, int)</code> 和 <code>close()</code>。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。 </p>
						<p><a href="docs/docs-java/api/java/io/Writer.html" target="_blank">Writer</a> 写入字符流的抽象类。子类必须实现的方法仅有 <code>write(char[], int, int)</code>、<code>flush()</code> 和 <code>close()</code>。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。 </p>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-io-File"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">File & RandomAccessFile</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<pre class="brush: java;">
public class File implements Serializable, Comparable&lt;File> {
	/* 文件的操作很多方法都是使用这个 FileSystem 来处理，因为不同的文件系统的需要做不同的实现
	 * 在 Unix 和 Win 平台下分别是： UnixFileSystem 和 WinNTFileSystem 的实例
     * UnixFileSystem 在 Unix 下的 JDK 中，WinNTFileSystem 在 Win 下的 JDK 中才能找到
	 */
	private static final FileSystem fs = DefaultFileSystem.getFileSystem();

	// System.getProperty("file.separator")
	public static final char separatorChar = fs.getSeparator();			// '/' or '\'
    public static final String separator = "" + separatorChar;			// 以上属性的字符常形式
	// System.getProperty("path.separator")
    public static final char pathSeparatorChar = fs.getPathSeparator();	// ':' or ';'， 环境变量分割用这个
    public static final String pathSeparator = "" + pathSeparatorChar;	// 以上属性的字符常形式

	public File(URI uri) {...}						// 使用 Uri 构建
	public File(String pathname) {...}				// 使用路径和名字构建
	public File(String parent, String child) {...}  // 两个参数一般是目录和文件
	public File(File parent, String child) {...}    // 同上
}
</pre>
							<p><a href="docs/docs-java/api/java/io/File.html" target="_blank">File</a> 文件和目录路径名的抽象表示形式。</p>
							<p>夸平台创建目录:</p>
							<pre class="brush: java;">
/** 如果创建失败则返回 NULL */
public static File mkdirs(File base, String... dirs) {
	StringBuilder builder = new StringBuilder();
	for (String s : dirs) {
		builder.append(s).append(File.separator);
	}
	File newDir = new File(base, builder.toString());
	if(newDir.exists()) {
		return newDir;
	} else {
		boolean state = newDir.mkdirs();
		if(state) {
			return newDir;
		}
	}
	return null;
}
</pre>
							<ol>
								<li><p><code>static File[] 	listRoots()</code> -- 列出可用的文件系统根, Unix 为 <code>/</code></p></li>
								<li><p><code>static File 	createTempFile(String prefix, String suffix)</code> -- 创建临时文件，前缀长度 >= 3</p></li>
								<li><p><code>static File 	createTempFile(String prefix, String suffix, File directory)</code> -- 同上，指定目录</p>
									<pre class="brush: java;">
/* 创建临时文件，如果文件已存在，那么 "随机 Long" 改变，直到创建成功
 * -- prefix.length >= 3, 不支持目录
 * -- suffix 若为 null 则默认为 .tmp
 * -- directory 若为 null 则默认为 System.getProperty("java.io.tmpdir")
 * 文件名为: prefix + 随机 Long + suffix, 比如: /tmp/xxx2972538647935704570.txt
 */
File f = File.createTempFile("xxx", ".txt");
</pre>
								</li>

								<li class="group"><p><code>boolean 	exists()</code> -- 文件或目录是否存在</p></li>

								<li class="group"><p><code>boolean 	createNewFile()</code> -- 当且仅当不存在时候创建一个新的空文件；目录必须存在，否则 IO 异常</p></li>
								<li><p><code>boolean 	mkdir()</code> -- 创建目录；父目录必须存在，否则 IO 异常</p></li>
								<li><p><code>boolean 	mkdirs()</code> -- 创建目录，包括创建不在在的父目录</p></li>

								<li class="group"><p><code>boolean 	isFile()</code> -- 是否是文件，如果不存在也返回 false</p></li>
								<li><p><code>boolean 	isDirectory()</code> -- 是否是目录，如果不存在也返回 false</p></li>
								<li><p><code>boolean 	isAbsolute()</code> -- 是否为绝对路径名， Unix 为 <code>/</code> 开头， Win 为 <code>盘符:\</code> 或 <code>\\</code></p></li>
								<li><p><code>boolean 	isHidden()</code> -- 是否是一个隐藏文件；在 UNIX 上以句点 <code>.</code> 开头；在 Win 系统上被标记为隐藏</p></li>

								<li class="group"><p><code>boolean 	canRead()</code> -- 是否可以读取</p></li>
								<li><p><code>boolean 	canWrite()</code> -- 是否可以写</p></li>
								<li><p><code>boolean 	canExecute()</code> -- 是否可执行</p></li>

								<li class="group"><p><code>long 	getTotalSpace()</code> -- 分区大小</p></li>
								<li><p><code>long 	getFreeSpace()</code> -- 分区中未分配的字节数</p></li>
								<li><p><code>long 	getUsableSpace()</code> -- 分区中可用于此虚拟机的字节数</p></li>

								<li class="group"><p><code>long 	lastModified()</code> -- 最后一次被修改的时间</p></li>
								<li><p><code>boolean 	setLastModified(long time)</code> -- 设置最后一次修改时间</p></li>
								<li><p><code>long 	length()</code> -- 文件的长度</p></li>

								<li class="group"><p><code>boolean 	renameTo(File dest)</code> -- 重命名</p></li>

								<li class="group"><p><code>boolean 	delete()</code> -- 删除，目录不为空不能删除</p></li>
								<li><p><code>void 	deleteOnExit()</code> -- 在虚拟机终止时请求删除(先请求删除目录中的文件，再删除目录不成功？)</p></li>

								<li class="group"><p><code>String 	getPath()</code> -- 路径名(可能是相对的)，包括文件</p></li>
								<li><p><code>String 	getName()</code> -- 目录名或文件名</p></li>
								<li><p><code>String 	getAbsolutePath()</code> -- 绝对路径名</p></li>
								<li><p><code>File 	getAbsoluteFile()</code> -- 同上，返回 File</p></li>
								<li><p><code>String 	getParent()</code> -- 上级目录(可能是相对的)</p></li>
								<li><p><code>File 	getParentFile()</code> -- 同上，返回 File</p></li>
								<li><p><code>String 	getCanonicalPath()</code> -- 规范路径名字符串，规范路径名是绝对路径名，并且是惟一的。首先将路径名转换为绝对路径名，通常涉及到从路径名中移除多余的名称（比如 "." 和 ".."）、解析符号连接（对于 UNIX 平台），以及将驱动器号转换为标准大小写形式</p></li>
								<li><p><code>File 	getCanonicalFile()</code> -- 同上，返回 File</p></li>


								<li class="group"><p><code>String[] 	list()</code> -- 获取所有目录名和文件名(包括隐藏的)</p></li>
								<li><p><code>File[] 	listFiles()</code> -- 同上，返回文件</p></li>
								<li><p><code>String[] 	list(FilenameFilter filter)</code> -- 获取名字符合条件的目录和文件</p></li>
								<li><p><code>File[] 	listFiles(FilenameFilter filter)</code> -- 同上，返回文件</p></li>
								<li><p><code>File[] 	listFiles(FileFilter filter)</code> -- 获取符合条件的目录和文件</p></li>

								<li class="group"><p><code>boolean 	setReadOnly()</code> -- 设为只读</p></li>
								<li><p><code>boolean 	setReadable(boolean readable, boolean ownerOnly)</code> -- 设置所有者或所有用户的读权限</p></li>
								<li><p><code>boolean 	setReadable(boolean readable)</code> -- 设置所有者读权限的一个便捷方法</p></li>
								<li><p><code>boolean 	setWritable(boolean writable, boolean ownerOnly)</code> -- 设置所有者或所有用户的写权限</p></li>
								<li><p><code>boolean 	setWritable(boolean writable)</code> -- 设置所有者写权限的一个便捷方法</p></li>
								<li><p><code>boolean 	setExecutable(boolean executable, boolean ownerOnly)</code> -- 设置所有者或所有用户的执行权限</p></li>
								<li><p><code>boolean 	setExecutable(boolean executable)</code> -- 设置所有者执行权限的一个便捷方法</p></li>

								<li class="group"><p><code>Path 	toPath()</code> -- 将路径转为 <code>java.nio.file.Path</code></p></li>
								<li><p><code>URI 	toURI()</code> -- 将路径转为 Uri 形式：<code>file:/tmp/files/demo.tmp</code></p></li>

								<li class="group"><p><code>int 	compareTo(File pathname)</code> -- 比较</p></li>
								<li><p><code>boolean 	equals(Object obj)</code> -- 是否相等</p></li>
								<li><p><code>int 	hashCode()</code> -- 路径名的哈希码</p></li>
								<li><p><code>String 	toString()</code> -- 路径名字符串</p></li>
							</ol>
						</div>

						<div class="sub-item">
							<pre class="brush: java;">

public class RandomAccessFile implements DataOutput, DataInput, Closeable {
	/** mode 支持的 4 中模式(区分大小写，并保证顺序):
	 * r   -- 以只读方式打开, 任何 write 方法都将导致抛出 IOException
	 * rw  -- 以读取和写入方式打开, 如果该文件尚不存在，则尝试创建该文件
	 * rwd -- 在 rw 基础上还要求对文件内容的每个更新都同步写入到底层存储设备
	 * rws -- 在 rw 基础上还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备
	 */
	public RandomAccessFile(File file, String mode) {...}
	public RandomAccessFile(String name, String mode) {...}
}
</pre>
							<p><a href="docs/docs-java/api/java/io/RandomAccessFile.html" target="_blank">RandomAccessFile</a> 支持对随机访问文件的读取和写入。</p>
							<p><a href="docs/docs-java/api/java/io/RandomAccessFile.html" target="_blank">RandomAccessFile</a> 实现 <a href="docs/docs-java/api/java/io/DataInput.html" target="_blank">DataInput</a> 接口，因此支持 Java 基本类型和 UTF 编码的 String 读取操作。</p>
							<p><a href="docs/docs-java/api/java/io/RandomAccessFile.html" target="_blank">RandomAccessFile</a> 实现 <a href="docs/docs-java/api/java/io/DataOutput.html" target="_blank">DataOutput</a> 接口，因此支持 Java 基本类型和 UTF 编码的 String 写入操作。</p>
							<p>随机访问文件的行为类似存储在文件系统中的一个大型 byte 数组。存在指向该隐含数组的光标或索引，称为文件指针；输入操作从文件指针开始读取字节，并随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，并随着对字节的写入而前移此文件指针。写入隐含数组的当前末尾之后的输出操作导致该数组扩展。</p>
							<p>通常，如果此类中的所有读取例程在读取所需数量的字节之前已到达文件末尾，则抛出 <code>EOFException</code>。如果由于某些原因无法读取任何字节，而不是在读取所需数量的字节之前已到达文件末尾，则抛出 <code>IOException</code>，而不是 <code>EOFException</code>。需要特别指出的是，如果流已被关闭，则可能抛出 <code>IOException</code>。 </p>
							<ol>

								<li><p><code>void 	write(int b)</code> -- 此方法虽然也是一个 int 参数，但是只写入了 int 的低 8 位,范围 [0,255]</p></li>
								<li><p><code>void 	write(byte[] b)</code> -- 将 b.length 个字节从指定 byte 数组写入到此文件，并从当前文件指针开始</p></li>
								<li><p><code>void 	write(byte[] b, int off, int len)</code> -- 将 len 个字节从指定 byte 数组写入到此文件，并从偏移量 off 处开始</p></li>

								<li class="group"><p><code>void 	writeBoolean(boolean v)</code> -- 实际写入一个字节(true 为 0x01, false 为 0x00)</p></li>
								<li><p><code>boolean 	readBoolean()</code> -- 实际读取一个字节(0x00 则为 false, 否则为 true)</p></li>
								<li><p><code>void 	writeByte(int v)</code> -- 按单字节值将 byte 写入该文件</p></li>
								<li><p><code>byte 	readByte()</code> -- 从此文件读取一个有符号的八位值</p></li>
								<li><p><code>void 	writeChar(int v)</code> -- 写入两个字节，使用 UTF-16 编码，如果字符不在 BMP 平面(超过两个字节)，那么需要使用 UTF-16 分开两次写</p></li>
								<li><p><code>char 	readChar()</code> -- 从此文件读取一个字符</p></li>
								<li><p><code>void 	writeShort(int v)</code> -- 按两个字节将 short 写入该文件，先写高字节</p></li>
								<li><p><code>short 	readShort()</code> -- 从此文件读取一个有符号的 16 位数</p></li>
								<li><p><code>void 	writeInt(int v)</code> -- 按四个字节将 int 写入该文件，先写高字节</p></li>
								<li><p><code>int 	readInt()</code> -- 从此文件读取一个有符号的 32 位整数</p></li>
								<li><p><code>void 	writeLong(long v)</code> -- 按八个字节将 long 写入该文件，先写高字节</p></li>
								<li><p><code>long 	readLong()</code> -- 从此文件读取一个有符号的 64 位整数</p></li>
								<li><p><code>float 	readFloat()</code> -- 从此文件读取一个 float</p></li>
								<li><p><code>void 	writeFloat(float v)</code> -- 使用 Float 类中的 floatToIntBits 方法将浮点参数转换为一个 int，然后按四字节数量将该 int 值写入该文件，先写高字节</p></li>
								<li><p><code>void 	writeDouble(double v)</code> -- 使用 Double 类中的 doubleToLongBits 方法将双精度参数转换为一个 long，然后按八字节数量将该 long 值写入该文件，先定高字节</p></li>
								<li><p><code>double 	readDouble()</code> -- 从此文件读取一个 double</p></li>

								<li class="group"><p><code>void 	writeBytes(String s)</code> -- 按字节序列将该字符串写入该文件</p></li>
								<li><p><code>void 	writeChars(String s)</code> -- 按字符序列将一个字符串写入该文件</p></li>
								<li><p><code>void 	writeUTF(String str)</code> -- 使用 modified UTF-8 编码以与机器无关的方式将一个字符串写入该文件</p></li>

								<li class="group"><p><code>int 	read()</code> -- 此方法虽然返回一个 int 值，但是只会读取一个字节,范围 [0,255]</p></li>
								<li><p><code>int 	read(byte[] b)</code> -- 将最多 b.length 个数据字节从此文件读入 byte 数组</p></li>
								<li><p><code>int 	read(byte[] b, int off, int len)</code> -- 将最多 len 个数据字节从此文件读入 byte 数组</p></li>

								<li class="group"><p><code>String 	readUTF()</code> -- 从此文件读取一个字符串</p></li>
								<li><p><code>String 	readLine()</code> -- 从此文件读取文本的下一行</p></li>

								<li><p><code>void 	readFully(byte[] b)</code> -- 将 b.length 个字节从此文件读入 byte 数组，并从当前文件指针开始</p></li>
								<li><p><code>void 	readFully(byte[] b, int off, int len)</code> -- 将正好 len 个字节从此文件读入 byte 数组，并从当前文件指针开始</p></li>

								<li class="group"><p><code>int 	readUnsignedByte()</code> -- 从此文件读取一个无符号的八位数</p></li>
								<li><p><code>int 	readUnsignedShort()</code> -- 从此文件读取一个无符号的 16 位数</p></li>

								<li class="group"><p><code>void 	seek(long pos)</code> -- 设置到此文件开头测量到的文件指针偏移量，在该位置发生下一个读取或写入操作</p></li>
								<li><p><code>int 	skipBytes(int n)</code> -- 尝试跳过输入的 n 个字节以丢弃跳过的字节</p></li>
								<li><p><code>long 	getFilePointer()</code> -- 返回此文件中的当前偏移量</p></li>

								<li class="group"><p><code>FileChannel 	getChannel()</code> -- 返回与此文件关联的唯一 FileChannel 对象，参见 <a href="#java-nio-Channel">NIO 的 Channel</a></p></li>
								<li><p><code>FileDescriptor 	getFD()</code> -- 返回与此流关联的不透明文件描述符对象 </p></li>

								<li class="group"><p><code>long 	length()</code> -- 返回此文件的长度</p></li>
								<li><p><code>void 	setLength(long newLength)</code> -- 设置此文件的长度</p></li>

								<li class="group"><p><code>void 	close()</code> -- 关闭此随机访问文件流并释放与该流关联的所有系统资源</p></li>
							</ol>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-io-Console"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Console</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">
public final class Console implements Flushable {...}

Console console = System.console();
if(null == console) { return; }

console.printf("Input your name:\n");
String line = console.readLine();
console.printf("hello -> %s\n", line);
</pre>
						<p><a href="docs/docs-java/api/java/io/Console.html" target="_blank">Console</a> 包含多个方法，可访问与当前 Java 虚拟机关联的基于字符的控制台设备（如果有）。</p>
						<p><b><a href="docs/docs-java/api/java/io/Console.html" target="_blank">Console</a> 类的一个好处是输入密码而不会会显。但是它只能在控制台运行，IDE 中将无法运行。这一点和 <a href="docs/docs-java/api/java/util/Scanner.html" target="_blank">Scanner</a> 不同。</b></p>
						<p>虚拟机是否具有控制台取决于底层平台，还取决于调用虚拟机的方式。如果虚拟机从一个交互式命令行开始启动，且没有重定向标准输入和输出流，那么其控制台将存在，并且通常连接到键盘并从虚拟机启动的地方显示。如果虚拟机是自动启动的（例如，由后台作业调度程序启动），那么它通常没有控制台。 </p>
						<p>如果此虚拟机具有控制台，那么它将由此类唯一的实例 <code>System.console()</code> 表示。如果没有可用的控制台设备，那么对该方法的调用将返回 null。</p>
						<ol>
							<li><p><code>Console 	format(String fmt, Object... args)</code> -- 使用指定格式字符串和参数将格式化字符串写入此控制台的输出流中</p></li>
							<li><p><code>Console 	printf(String format, Object... args)</code> -- 使用指定格式字符串和参数将格式化字符串写入此控制台输出流的便捷方法</p></li>

							<li class="group"><p><code>void 	flush()</code> -- 刷新控制台，并强制立即写入所有缓冲的输出</p></li>

							<li class="group"><p><code>Reader 	reader()</code> -- 获取与此控制台关联的唯一 Reader 对象</p></li>
							<li><p><code>PrintWriter 	writer()</code> -- 获取与此控制台关联的唯一 PrintWriter 对象</p></li>

							<li class="group"><p><code>String 	readLine()</code> -- 从控制台读取单行文本</p></li>
							<li><p><code>String 	readLine(String fmt, Object... args)</code> -- 提供一个格式化提示，然后从控制台读取单行文本</p></li>
							<li><p><code>char[] 	readPassword()</code> -- 从控制台读取密码，禁用回显</p></li>
							<li><p><code>char[] 	readPassword(String fmt, Object... args)</code> -- 提供一个格式化提示，然后从控制台读取密码，禁用回显</p></li>
						</ol>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-nio-intro"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">NIO 简介</h3>
					</div>
					<div class="panel-body">
                        <p><b>NIO</b> 主要有三大核心部分：<b>Buffer</b>, <b>Channel</b> 和 <b>Selector</b>。传统 IO 基于字节流和字符流进行操作，而 <b>NIO</b> 基于 <b>Channel</b> 和 <b>Buffer</b> 进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<b>Selector</b> 用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p>
						<p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成 Buffer 对象，并提供了一组方法，用来方便的访问该块内存。</p>
						<p><b>NIO</b> 和传统 IO 之间第一个最大的区别是，IO 是面向流的，<b>NIO</b> 是面向缓冲区的。 Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。<b>NIO</b> 的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
						<p>IO 的各种流是阻塞的。这意味着，当一个线程调用 <code>read()</code> 或 <code>write()</code>时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 <b>NIO</b> 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道。</p>
                        <p><b>一个使用 NIO 读写文件的例子</b></p>
                        <pre class="brush: java;">
try {
    File f = File.createTempFile("nio", ".txt"); // 创建一个临时文件，并在退出时删除
    f.deleteOnExit();

    RandomAccessFile rw = new RandomAccessFile(f, "rw");
    FileChannel channel = rw.getChannel();
    ByteBuffer buffer = ByteBuffer.allocate(1024); // 注意此 Buffer 的大小

    // UTF-8 编码将字节存入 ByteBuffer
    for (int i = 0; i < 10; i++) {
        buffer.put("a3 αβ 你好 \uD83C\uDCA1\uD83C\uDCA2\n".getBytes());
    }
    buffer.flip(); // 准备写： limit = position; position = 0;
    channel.write(buffer);

    // 文件回到开始位置，准备读
    rw.seek(0);
    byte[] bytes = new byte[(int) f.length()];
    int index = 0;

    buffer = ByteBuffer.allocate(24);
    int bytesRead = channel.read(buffer);
    while (bytesRead != -1) {
        buffer.flip();
        while(buffer.hasRemaining()){
            bytes[index++] = buffer.get();
        }
        buffer.clear();
        bytesRead = channel.read(buffer);
    }
    rw.close();

    log(new String(bytes, StandardCharsets.UTF_8));
} catch (IOException e) {
    e.printStackTrace();
}
</pre>
                        <p><a href="docs/docs-java/api/java/nio/channels/Channels.html" target="_blank">java.nio.channel.Channels</a> <b>定义了支持 <code>java.io</code> 包中的流类与 <code>java.nio.channel</code> 包中的信道类之间进行互操作的静态方法。 针对信道和流的实用工具方法。</b></p>
                        <ol>
                            <li><p><code>static ReadableByteChannel 	newChannel(InputStream in)</code> -- 构造从给定流读取字节的信道</p></li>
                            <li><p><code>static WritableByteChannel 	newChannel(OutputStream out)</code> -- 构造向给定流写入字节的信道</p></li>

                            <li class="group"><p><code>static InputStream 	newInputStream(ReadableByteChannel ch)</code> -- 构造从给定信道读取字节的流</p></li>
                            <li><p><code>static OutputStream 	newOutputStream(WritableByteChannel ch)</code> -- 构造向给定信道写入字节的流</p></li>
                            <li><p><code>static InputStream 	newInputStream(AsynchronousByteChannel ch)</code> -- 构造从给定异步信道读取字节的流</p></li>
                            <li><p><code>static OutputStream 	newOutputStream(AsynchronousByteChannel ch)</code> --  构造向给定异步信道写入字节的流</p></li>

                            <li class="group"><p><code>static Reader 	newReader(ReadableByteChannel ch, CharsetDecoder dec, int minBufferCap)</code> -- 构造一个 reader，用给定的解码器对取自给定信道的字节进行解码</p></li>
                            <li><p><code>static Reader 	newReader(ReadableByteChannel ch, String csName)</code> -- 构造一个 reader，根据命名的 charset 对取自给定信道的字节进行解码</p></li>
                            <li><p><code>static Writer 	newWriter(WritableByteChannel ch, CharsetEncoder enc, int minBufferCap)</code> -- 构造一个 writer，用给定的编码器对字符进行编码，并将所得的字节写入给定的信道</p></li>
                            <li><p><code>static Writer 	newWriter(WritableByteChannel ch, String csName)</code> -- 构造一个 writer，根据指定的 charset 对字符进行编码，并将所得的字节写入给定的信道</p></li>
                        </ol>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-nio-Buffer"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Buffer 及子类</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
Buffer                  /** 特定基本类型元素的线性有限序列 */
   ├ ByteBuffer         /** byte 缓冲区 */
   │ └ MappedByteBuffer /** FileChannel 的 map 方法会返回此实例 */
   ├ CharBuffer         /** char 缓冲区 */
   ├ ShortBuffer        /** short 缓冲区 */
   ├ IntBuffer          /** int 缓冲区 */
   ├ LongBuffer         /** long 缓冲区 */
   ├ FloatBuffer        /** float 缓冲区 */
   └ DoubleBuffer       /** double 缓冲区 */

public abstract class Buffer {
    // mark <= position <= limit <= capacity
    private int mark = -1;          // 标记
    private int position = 0;       // 位置
    private int limit;              // 限制
    private int capacity;           // 容量
}
</pre>
                            <p><a href="docs/docs-java/api/java/nio/Buffer.html" target="_blank">Buffer</a> 用于和 NIO 通道进行交互， 一个用于特定基本类型数据的容器。 </p>
                            <p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成 Buffer 对象，并提供了一组方法，用来方便的访问该块内存。</p>
                            <p>缓冲区是特定基本类型元素的线性有限序列(数组)。除内容外，缓冲区的基本属性还包括容量、限制和位置：</p>
                            <ul>
                                <li><p><b>容量</b> -- 是它所包含的元素的数量。缓冲区的容量不能为负并且不能更改。</p></li>
                                <li><p><b>限制</b> -- 是第一个不应该读取或写入的元素的索引。缓冲区的限制不能为负，并且不能大于其容量。</p></li>
                                <li><p><b>位置</b> -- 是下一个要读取或写入的元素的索引。缓冲区的位置不能为负，并且不能大于其限制。</p></li>
                            </ul>
                            <p>标记、位置、限制和容量值遵守以下不变式： <code>标记 <= 位置 <= 限制 <= 容量</code></p>
                            <p>此类的每个子类都定义了两种 <b>获取</b> 和 <b>放置</b> 操作：</p>
                            <ul>
                                <li><p><b>相对</b> 操作读取或写入一个或多个元素，它从当前位置开始，然后将位置增加所传输的元素数。</p></li>
                                <li><p><b>绝对</b> 操作采用显式元素索引，该操作不影响位置。</p></li>
                            </ul>
                            <p>新创建的缓冲区总有一个 0 位置和一个未定义的标记。初始限制可以为 0，也可以为其他值，这取决于缓冲区类型及其构建方式。一般情况下，缓冲区的初始内容是未定义的。 </p>
                            <p>除了访问位置、限制、容量值的方法以及做标记和重置的方法外，此类还定义了以下可对缓冲区进行的操作： </p>
                            <ul>
                                <li><p><code>clear()</code> -- 使缓冲区为一系列新的通道读取或相对放置 操作做好准备：它将限制设置为容量大小，将位置设置为 0。 </p></li>
                                <li><p><code>flip()</code> -- 使缓冲区为一系列新的通道写入或相对获取 操作做好准备：它将限制设置为当前位置，然后将位置设置为 0。 </p></li>
                                <li><p><code>rewind()</code> -- 使缓冲区为重新读取已包含的数据做好准备：它使限制保持不变，将位置设置为 0。</p></li>
                            </ul>
                            <p>每个缓冲区都是可读取的，但并非每个缓冲区都是可写入的。每个缓冲区类的转变方法都被指定为可选操作，当对只读缓冲区调用时，将抛出 <code>ReadOnlyBufferException</code>。只读缓冲区不允许更改其内容，但其标记、位置和限制值是可变的。可以调用其 <code>isReadOnly</code> 方法确定缓冲区是否为只读。 </p>
                            <p>多个当前线程使用缓冲区是不安全的。如果一个缓冲区由不止一个线程使用，则应该通过适当的同步来控制对该缓冲区的访问。</p>
                            <ol>
                                <li><p><code>final int 	position() </code> -- 返回位置 <code>position</code></p></li>
                                <li><p><code>final int 	limit() </code> -- 返回限制 <code>limit</code></p></li>
                                <li><p><code>final int capacity() </code> -- 返回容量 <code>capacity</code></p></li>

                                <li class="group"><p><code>final Buffer 	mark() </code> -- 在此缓冲区的位置设置标记 <code>mark = position</code></p></li>
                                <li><p><code>final Buffer 	position(int newPosition) </code> -- 设置此缓冲区的位置，遵循：<code>标记 <= 位置 <= 限制 <= 容量</code></p>
                                    <pre class="brush: java;">position = newPosition; if(mark > position) mark = -1;</pre>
                                </li>
                                <li><p><code>final Buffer 	limit(int newLimit) </code> -- 设置此缓冲区的限制，遵循：<code>标记 <= 位置 <= 限制 <= 容量</code></p>
                                    <pre class="brush: java;">limit = newLimit; if(position > limit) position = limit; if(mark > limit) mark = -1;</pre>
                                </li>

                                <li class="group"><p><code>abstract  boolean 	hasArray() </code> -- 告知此缓冲区是否具有可访问的底层实现数组</p></li>
                                <li><p><code>abstract  Object 	array() </code> -- 返回此缓冲区的底层实现数组</p></li>
                                <li><p><code>abstract  int 	arrayOffset() </code> -- 返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量</p></li>
                                <li><p><code>abstract  boolean 	isDirect() </code> -- 告知此缓冲区是否为直接缓冲区</p></li>
                                <li><p><code>abstract  boolean 	isReadOnly() </code> -- 告知此缓冲区是否为只读缓冲区</p></li>

                                <li class="group"><p><code>final boolean 	hasRemaining() </code> -- 告知在当前位置和限制之间是否有元素<code>position < limit</code></p></li>
                                <li><p><code>final int 	remaining() </code> -- 返回当前位置与限制之间的元素数<code>limit - position</code></p></li>

                                <li class="group"><p><code>final Buffer 	flip() </code> -- 反转此缓冲区：<code>limit = position; position = 0; mark = -1;</code></p></li>
                                <li><p><code>final Buffer 	clear() </code> -- 清除此缓冲区：<code>position = 0; limit = capacity; mark = -1;</code></p></li>
                                <li><p><code>final Buffer 	reset() </code> -- 将此缓冲区的位置重置为以前标记的位置：<code>position = mark;</code>;mark 少于 0 抛出异常；</p></li>
                                <li><p><code>final Buffer 	rewind() </code> -- 重绕此缓冲区：<code>position = 0; mark = -1;</code></p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <p><a href="docs/docs-java/api/java/nio/ByteBuffer.html" target="_blank">ByteBuffer</a> 是字节缓冲区。</p>
                            <p><a href="docs/docs-java/api/java/nio/ByteBuffer.html" target="_blank">ByteBuffer</a> 有两个内部子类，由静态方法构建。</p>
                            <ul>
                                <li><p><b>DirectByteBuffer</b> -- 是无可访问的底层实现数组支持的直接字节缓冲区。</p></li>
                                <li><p><b>HeapByteBuffer</b> -- 是有可访问的底层实现数组支持的非直接字节缓冲区。</p></li>
                            </ul>
                            <p>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。 </p>
                            <p>直接字节缓冲区可以通过调用此类的 <code>allocateDirect</code> 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。 </p>
                            <p>此类定义了除 boolean 之外，读写所有其他基本类型值的方法。这些基本值可以根据缓冲区的当前字节顺序与字节序列互相进行转换，并可以通过 order 方法获取和修改。特定的字节顺序由 ByteOrder 类的实例表示。字节缓冲区的初始顺序始终是 BIG_ENDIAN。 </p>
                            <ol>
                                <li><p><code>static ByteBuffer 	allocateDirect(int capacity)</code> -- 指定容量无可访问的底层实现数组的直接字节缓存</p></li>
                                <li><p><code>static ByteBuffer 	allocate(int capacity)</code> -- 指定容量有可访问的底层实现数组的非直接字节缓存</p></li>
                                <li><p><code>static ByteBuffer 	wrap(byte[] array)</code> -- 同上，容量和限制为 <code>array.length</code>, <code>position = 0</code>元素被写入缓存</p></li>
                                <li><p><code>static ByteBuffer 	wrap(byte[] array, int offset, int length)</code> -- 同上，但是 <code>position = offset</code></p></li>

                                <li class="group"><p><code>abstract ByteBuffer 	asReadOnlyBuffer()</code> -- 转为只读模式</p></li>
                                <li><p><code>abstract CharBuffer 	asCharBuffer()</code> -- 返回 CharBuffer 视图来操作(<b>注意操作的还是当前的 Buffer)</b></p>
                                    <pre class="brush: java;">
ByteBuffer buffer = ByteBuffer.allocate(5);
buffer.put((byte) 1); // buffer 的值为： 0[1],1[0],2[0],3[0],4[0]

CharBuffer cBuffer = buffer.asCharBuffer();
cBuffer.put('a');   // buffer 的值变为： 0[1],1[0],2[97],3[0],4[0]
</pre>
                                </li>
                                <li><p><code>abstract ShortBuffer 	asShortBuffer()</code> -- 返回 ShortBuffer 视图来操作(<b>注意操作的还是当前的 Buffer)</b></p></li>
                                <li><p><code>abstract IntBuffer 	asIntBuffer()</code> -- 返回 IntBuffer 视图来操作(<b>注意操作的还是当前的 Buffer)</b></p></li>
                                <li><p><code>abstract LongBuffer 	asLongBuffer()</code> -- 返回 LongBuffer 视图来操作(<b>注意操作的还是当前的 Buffer)</b></p></li>
                                <li><p><code>abstract FloatBuffer 	asFloatBuffer()</code> -- 返回 FloatBuffer 视图来操作(<b>注意操作的还是当前的 Buffer)</b></p></li>
                                <li><p><code>abstract DoubleBuffer 	asDoubleBuffer()</code> -- 返回 DoubleBuffer 视图来操作(<b>注意操作的还是当前的 Buffer)</b></p></li>

                                <li class="group"><p><code>abstract ByteBuffer 	put(byte b)</code> -- 在 position 处写入 b, 并且把 position 加 1</p></li>
                                <li><p><code>abstract ByteBuffer 	put(int index, byte b)</code> -- 绝对 put 方法</p></li>
                                <li><p><code>abstract ByteBuffer 	putChar(char value)</code> -- 在 position 处写入 value, 并且把 position 加 2</p></li>
                                <li><p><code>abstract ByteBuffer 	putChar(int index, char value)</code> -- 写入 char 值的绝对 put 方法</p></li>
                                <li><p><code>abstract ByteBuffer 	putShort(short value)</code> -- 在 position 处写入 value, 并且把 position 加 2</p></li>
                                <li><p><code>abstract ByteBuffer 	putShort(int index, short value)</code> -- 写入 short 值的绝对 put 方法</p></li>
                                <li><p><code>abstract ByteBuffer 	putInt(int value)</code> -- 在 position 处写入 value, 并且把 position 加 4</p></li>
                                <li><p><code>abstract ByteBuffer 	putInt(int index, int value)</code> -- 写入 int 值的绝对 put 方法</p></li>
                                <li><p><code>abstract ByteBuffer 	putLong(long value)</code> -- 在 position 处写入 value, 并且把 position 加 8</p></li>
                                <li><p><code>abstract ByteBuffer 	putLong(int index, long value)</code> -- 写入 long 值的绝对 put 方法</p></li>
                                <li><p><code>abstract ByteBuffer 	putFloat(float value)</code> -- 在 position 处写入 value, 并且把 position 加 4</p></li>
                                <li><p><code>abstract ByteBuffer 	putFloat(int index, float value)</code> -- 写入 float 值的绝对 put 方法</p></li>
                                <li><p><code>abstract ByteBuffer 	putDouble(double value)</code> -- 在 position 处写入 value, 并且把 position 加 8</p></li>
                                <li><p><code>abstract ByteBuffer 	putDouble(int index, double value)</code> -- 写入 double 值的绝对 put 方法</p></li>

                                <li class="group"><p><code>ByteBuffer 	put(byte[] src)</code> -- 在 position 处写入 src, 并且把 position 加 <code>src.length</code></p></li>
                                <li><p><code>ByteBuffer 	put(byte[] src, int offset, int length)</code> -- 在 position 处写入 <code>src[offset],src[src.length-1]</code>, 并且把 position 加 <code>src.length - offset</code></p></li>
                                <li><p><code>ByteBuffer 	put(ByteBuffer src)</code> -- 写入 src 的 position 到 limit 的元素</p></li>

                                <li class="group"><p><code>abstract byte 	get()</code> -- 读取一个字节，并把 position 加 1</p></li>
                                <li><p><code>abstract byte 	get(int index)</code> -- 读取指定位置的字节</p></li>
                                <li><p><code>abstract char 	getChar()</code> -- 读取 2 个字节作为一个 char 返回，并把 position 加 2</p></li>
                                <li><p><code>abstract char 	getChar(int index)</code> -- 读取指定位置连续的 2 个字节作为一个 char 返回</p></li>
                                <li><p><code>abstract short 	getShort()</code> -- 读取 2 个字节作为一个 short 返回，并把 position 加 2</p></li>
                                <li><p><code>abstract short 	getShort(int index)</code> -- 读取指定位置连续的 2 个字节作为一个 short 返回</p></li>
                                <li><p><code>abstract int 	getInt()</code> -- 读取 4 个字节作为一个 int 返回，并把 position 加 4</p></li>
                                <li><p><code>abstract int 	getInt(int index)</code> -- 读取指定位置连续的 4 个字节作为一个 int 返回</p></li>
                                <li><p><code>abstract long 	getLong()</code> -- 读取 8 个字节作为一个 long 返回，并把 position 加 8</p></li>
                                <li><p><code>abstract long 	getLong(int index)</code> -- 读取指定位置连续的 8 个字节作为一个 long 返回</p></li>
                                <li><p><code>abstract float 	getFloat()</code> -- 读取 4 个字节作为一个 float 返回，并把 position 加 4</p></li>
                                <li><p><code>abstract float 	getFloat(int index)</code> -- 读取指定位置连续的 4 个字节作为一个 float 返回</p></li>
                                <li><p><code>abstract double 	getDouble()</code> -- 读取 8 个字节作为一个 double 返回，并把 position 加 8</p></li>
                                <li><p><code>abstract double 	getDouble(int index)</code> -- 读取指定位置连续的 8 个字节作为一个 double 返回</p></li>

                                <li class="group"><p><code>ByteBuffer 	get(byte[] dst)</code> -- 读取 <code>dst.length()</code> 长度的字节写入 dst，把 position 加 <code>dst.length()</code></p></li>
                                <li><p><code>ByteBuffer 	get(byte[] dst, int offset, int length)</code> -- 读取 <code>dst.length() - offset</code> 长度的字节写入 <code>[dst[offset],dst[dst.length - 1]]</code>，把 position 加 <code>dst.length() - offset</code></p></li>

                                <li class="group"><p><code>abstract boolean 	isDirect()</code> -- 告知此缓冲区是否为直接缓冲区</p></li>
                                <li><p><code>boolean 	hasArray()</code> -- 告知此缓冲区是否具有可写的底层实现数组</p></li>
                                <li><p><code>byte[] 	array()</code> -- 返回此缓冲区的底层实现数组</p></li>
                                <li><p><code>int 	arrayOffset()</code> -- 返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量</p></li>

                                <li class="group"><p><code>ByteOrder 	order()</code> -- 获取此缓冲区的字节顺序</p></li>
                                <li><p><code>ByteBuffer 	order(ByteOrder bo)</code> -- 修改此缓冲区的字节顺序</p></li>

                                <li class="group"><p><code>abstract ByteBuffer 	compact()</code> -- 压缩此缓冲区</p></li>
                                <li><p><code>abstract ByteBuffer 	duplicate()</code> -- 创建共享此缓冲区内容的新的字节缓冲区</p></li>
                                <li><p><code>abstract ByteBuffer 	slice()</code> -- 创建新的字节缓冲区，其内容是此缓冲区内容的共享子序列</p></li>

                                <li class="group"><p><code>int 	hashCode()</code> -- 返回此缓冲区的当前哈希码</p></li>
                                <li><p><code>int 	compareTo(ByteBuffer that)</code> -- 将此缓冲区与另一个缓冲区进行比较</p></li>
                                <li><p><code>String 	toString()</code> -- 返回汇总了此缓冲区状态的字符串</p></li>
                                <li><p><code>boolean 	equals(Object ob)</code> -- 判断此缓冲区是否与另一个对象相同</p></li>
                            </ol>
                        </div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-nio-channels-Channel"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Channel 及实现类</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
                            <p><b>NIO Channel:</b></p>
                            <ul>
                                <li><p><a href="#java-nio-channels-FileChannel">FileChannel</a></p></li>
                                <li>
                                    <p><a href="#java-nio-channels-SelectableChannel">SelectableChannel</a></p>
                                    <ul>
                                        <li><p><a href="#java-nio-channels-DatagramChannel">DatagramChannel</a></p></li>
                                        <li><p><a href="#java-nio-channels-SocketChannel">SocketChannel</a></p></li>
                                        <li><p><a href="#java-nio-channels-ServerSocketChannel">ServerSocketChannel</a></p></li>
                                    </ul>
                                </li>

                            </ul>
							<pre class="brush: java;">
/** Channel 的顶级接口结构 */
Channel extends Closeable, AutoCloseable
 ├ InterruptibleChannel                         // 可 异步关闭 和 中断 的通道
 ├ AsynchronousChannel                          // 异步通道
 │  └ AsynchronousByteChannel                   // 异步字节读写通道
 ├ ReadableByteChannel                          // 可从字节缓存读取字节的通道
 │  ├ ByteChannel extends WritableByteChannel   // 可读取和写入字节的通道，结合了读/写接口
 │  │  └ SeekableByteChannel                    // position 支持的可读写字节数组
 │  └ ScatteringByteChannel                     // 从字节缓存数组读取字节的通道(分散)
 ├ WritableByteChannel                          // 可从字节缓存写入字节的通道
 │  └ GatheringByteChannel                      // 从字节缓存数组写入字节的通道(聚集)
 └ NetworkChannel                               // 网络套接字通道
    └ MulticastChannel                          // 支持组播的网络套接字通道

/** Channel 的实现类结构 */
AbstractInterruptibleChannel implements InterruptibleChannel // 可中断通道的基本实现类
 ├ FileChannel implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel
 └ SelectableChannel // 可通过 Selector 实现多路复用的通道
   └ AbstractSelectableChannel // 多路复用通道的基本实现类
    ├ DatagramChannel implements ByteChannel,ScatteringByteChannel,GatheringByteChannel,MulticastChannel
    ├ SocketChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel
    ├ ServerSocketChannel implements NetworkChannel
    ├ Pipe.SinkChannel implements GatheringByteChannel
    └ Pipe.SourceChannel implements ScatteringByteChannel

AsynchronousFileChannel implements AsynchronousChannel
AsynchronousSocketChannel implements AsynchronousByteChannel, NetworkChannel
AsynchronousServerSocketChannel implements AsynchronousChannel, NetworkChannel

public interface Channel extends Closeable {
    boolean isOpen();                // 判断此通道是否处于打开状态
    void close() throws IOException; // 关闭此通道
}

/** 可 异步关闭 和 中断 的通道 */
public interface InterruptibleChannel extends Channel {
    void close() throws IOException; // 此方法行为和 Channel 相同
}

/** 异步通道 */
public interface AsynchronousChannel extends Channel {
    void close() throws IOException; // 此方法行为和 Channel 相同
}

/** 异步字节读写通道 */
public interface AsynchronousByteChannel extends AsynchronousChannel {
    Future&lt;Integer> read(ByteBuffer dst);
    Future&lt;Integer> write(ByteBuffer src);
    &lt;A> void read(ByteBuffer dst, A attachment, CompletionHandler&lt;Integer,? super A> handler);
    &lt;A> void write(ByteBuffer src, A attachment, CompletionHandler&lt;Integer,? super A> handler);
}

/** 可读取字节的通道 */
public interface ReadableByteChannel extends Channel {
    int read(ByteBuffer dst) throws IOException;
}

/** 从字节缓存数组读取字节的通道 */
public interface ScatteringByteChannel extends ReadableByteChannel {
    long read(ByteBuffer[] dsts) throws IOException;
    long read(ByteBuffer[] dsts, int offset, int length) throws IOException;
}

/** 可写入字节的通道 */
public interface WritableByteChannel extends Channel {
    int write(ByteBuffer src) throws IOException;
}

/** 从字节缓存数组写入字节的通道 */
public interface GatheringByteChannel extends WritableByteChannel {
    long write(ByteBuffer[] srcs) throws IOException;
    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException;
}

/** 可读取和写入字节的通道，结合了读/写接口 */
public interface ByteChannel extends ReadableByteChannel, WritableByteChannel {}

/** position 支持的可读写字节数组 */
public interface SeekableByteChannel extends ByteChannel {
    long position() throws IOException;                                // 返回通道的 position
    SeekableByteChannel position(long newPosition) throws IOException; // 更改此通道的 position
    long size() throws IOException;                                    // 返回此通道连接实体的大小
    SeekableByteChannel truncate(long size) throws IOException;        // 截断此通道连接实体为指定大小
}

/** 网络套接字通道 */
public interface NetworkChannel extends Channel {
    NetworkChannel bind(SocketAddress local) throws IOException;    // 通道套接字绑定到本地地址
    SocketAddress getLocalAddress() throws IOException;             // 获取通道套接字绑定的本地地址

    &lt;T> NetworkChannel setOption(SocketOption&lt;T> name, T value) throws IOException; // 设置套接字选项值
    Set&lt;SocketOption&lt;?>> supportedOptions();                  // 返回套接字支持的选项值
}

/** 支持组播的网络套接字通道 */
public interface MulticastChannel extends NetworkChannel {
    MembershipKey join(InetAddress group, NetworkInterface netf) throws IOException;
    MembershipKey join(InetAddress group, NetworkInterface netf, InetAddress source) throws IOException;
}
</pre>
							<p><a href="docs/docs-java/api/java/nio/channels/Channel.html" target="_blank">Channel</a> 用于 I/O 操作的连接。</p>
                            <p>通道表示到实体，如硬件设备、文件、网络套接字或可以执行一个或多个不同 I/O 操作的程序组件的开放的连接。 </p>
                            <p>通道可处于打开或关闭状态。创建通道时它处于打开状态，一旦将其关闭，则保持关闭状态。一旦关闭了某个通道，试图对其调用 I/O 操作就会导致 <code>ClosedChannelException</code> 被抛出。通过调用通道的 <code>isOpen</code> 方法可测试通道是否处于打开状态。 </p>
                            <p>正如扩展和实现此接口的各个接口和类规范中所描述的，一般情况下通道对于多线程的访问是安全的。 </p>
							<p>NIO 中的 Channel 的主要实现有：</p>


						</div>

                        <a class="offset" id="java-nio-channels-FileChannel"></a>
						<div class="sub-item">
							<pre class="brush: java;">
public abstract class FileChannel extends AbstractInterruptibleChannel implements SeekableByteChannel,
                                GatheringByteChannel, ScatteringByteChannel {
    protected FileChannel() {}

    /** 文件映射模式的类型安全的枚举 */
    public static class MapMode {
        // 只读映射模式
        public static final MapMode READ_ONLY = new MapMode("READ_ONLY");
        // 读取/写入映射模式
        public static final MapMode READ_WRITE = new MapMode("READ_WRITE");
        // 专用（写入时拷贝）映射模式
        public static final MapMode PRIVATE = new MapMode("PRIVATE");

        private final String name;
        private MapMode(String name) { this.name = name; }
        public String toString() { return name; }
    }
}
</pre>
							<p><a href="docs/docs-java/api/java/nio/FileChannel.html" target="_blank">FileChannel</a> 用于读取、写入、映射和操作文件的通道。</p>
                            <ul>
                                <li><p><code>FileInputStream.getChannel()</code> -- 只用于读取，任何写入操作将会报 NonWritableChannelException 异常</p></li>
                                <li><p><code>FileOutputStream.getChannel()</code> -- 只用于写入，任何读取操作将会报 NonReadableChannelException 异常</p></li>
                                <li><p><code>RandomAccessFile.getChannel()</code> -- 可用于读写，取决于 mode 参数</p></li>
                            </ul>
                            <p><a href="docs/docs-java/api/java/nio/FileChannel.html" target="_blank">FileChannel</a> 在其文件中有一个当前 position，可对其进行查询和修改。该文件本身包含一个可读写的长度可变的字节序列，并且可以查询该文件的当前大小。写入的字节超出文件的当前大小时，则增加文件的大小；截取 该文件时，则减小文件的大小。文件可能还有某个相关联的元数据，如访问权限、内容类型和最后的修改时间；此类未定义访问元数据的方法。 </p>
                            <p>除了字节通道中常见的读取、写入和关闭操作外，此类还定义了下列特定于文件的操作：</p>
                            <ul>
                                <li><p>以不影响通道当前位置的方式，对文件中绝对位置的字节进行读取或写入。</p></li>
                                <li><p>将文件中的某个区域直接映射到内存中；对于较大的文件，这通常比调用普通的 read 或 write 方法更为高效。</p></li>
                                <li><p>强制对底层存储设备进行文件的更新，确保在系统崩溃时不丢失数据。</p></li>
                                <li><p>以一种可被很多操作系统优化为直接向文件系统缓存发送或从中读取的高速传输方法，将字节从文件传输到某个其他通道中，反之亦然。</p></li>
                                <li><p>可以锁定某个文件区域，以阻止其他程序对其进行访问。</p></li>
                            </ul>
                            <p>多个并发线程可安全地使用文件通道。可随时调用关闭方法，正如 Channel 接口中所指定的。对于涉及通道位置或者可以更改其文件大小的操作，在任意给定时间只能进行一个这样的操作；如果尝试在第一个操作仍在进行时发起第二个操作，则会导致在第一个操作完成之前阻塞第二个操作。可以并发处理其他操作，特别是那些采用显式位置的操作；但是否并发处理则取决于基础实现，因此是未指定的。 </p>
                            <ol>
                                <li><p><code>static FileChannel 	open(Path path, OpenOption... options)</code> -- 打开或创建文件，返回访问文件的通道</p></li>
                                <li><p><code>static FileChannel 	open(Path path, Set&lt;&lt;? extends OpenOption> options, FileAttribute&lt;?>... attrs)</code> -- 打开或创建文件，返回访问文件的通道</p>
                                    <pre class="brush: java;">
public interface OpenOption {}

public enum StandardOpenOption implements OpenOption {
    CREATE,                // 如果文件不存在创建；存在则打开
    CREATE_NEW,            // 如果文件已存在，返回失败
    READ,                  // 只读
    WRITE,                 // 写
    APPEND,                // 追加
    TRUNCATE_EXISTING,     // 如果已存在，且为写访问而打开的，那么它的长度将被截断为 0
    DELETE_ON_CLOSE,       // 关闭时删除文件
    SPARSE,                // 稀疏文件(在创建一个文件的时候，就预先分配了文件需要的连续存储空间)
    SYNC,                  // 要求对文件内容或元数据的每次更新都同步写入底层存储设备
    DSYNC;                 // 要求对文件内容的每次更新都同步写入底层存储设备
}
</pre>
                                </li>

                                <li class="group"><p><code>abstract long 	position()</code> -- 返回此通道的文件位置</p></li>
                                <li><p><code>abstract FileChannel 	position(long newPosition)</code> -- 设置此通道的文件位置</p></li>
                                <li><p><code>abstract long 	size()</code> -- 返回此通道的文件的当前大小</p></li>

                                <li class="group"><p><code>abstract int 	read(ByteBuffer dst)</code> -- 将字节序列从此通道读入给定的缓冲区</p></li>
                                <li><p><code>abstract int 	read(ByteBuffer dst, long position)</code> -- 从给定的文件位置开始，将字节序列从此通道读入给定的缓冲区</p></li>
                                <li><p><code>long 	read(ByteBuffer[] dsts)</code> -- 将字节序列从此通道依次读入给定的缓冲区</p></li>
                                <li><p><code>abstract long 	read(ByteBuffer[] dsts, int offset, int length)</code> -- 同上，指定偏移和大小</p></li>

                                <li class="group"><p><code>abstract int 	write(ByteBuffer src)</code> -- 将字节序列从给定的缓冲区写入此通道</p></li>
                                <li><p><code>abstract int 	write(ByteBuffer src, long position)</code> -- 从给定的文件位置开始，将字节序列从给定缓冲区写入此通道</p></li>
                                <li><p><code>long 	write(ByteBuffer[] srcs)</code> -- 将字节序列从给定的缓冲区依次写入此通道</p></li>
                                <li><p><code>abstract long 	write(ByteBuffer[] srcs, int offset, int length)</code> -- 同上，指定偏移和大小</p></li>

                                <li class="group"><p><code>abstract long 	transferFrom(ReadableByteChannel src, long position, long count)</code> -- 将字节从给定的可读取字节通道传输到此通道的文件中(<b>写文件</b>)</p></li>
                                <li><p><code>abstract long 	transferTo(long position, long count, WritableByteChannel target)</code> -- 将字节从此通道的文件传输到给定的可写入字节通道(<b>读文件</b>)</p></li>

                                <li class="group"><p><code>FileLock 	lock()</code> -- 获取对此通道的文件的独占锁定(如果别的进程获取了独有锁会阻塞，直到独有锁被别的进程释放)</p></li>
                                <li><p><code>abstract FileLock 	lock(long position, long size, boolean shared)</code> -- 获取此通道的文件给定区域上的锁定</p></li>
                                <li><p><code>FileLock 	tryLock()</code> -- 试图获取对此通道的文件的独占锁定(如果别的进程获取了独有锁也不会阻塞，但是会抛出 IO 异常)</p></li>
                                <li><p><code>abstract FileLock 	tryLock(long position, long size, boolean shared)</code> -- 试图获取对此通道的文件给定区域的锁定</p></li>

                                <li class="group"><p><code>abstract MappedByteBuffer 	map(FileChannel.MapMode mode, long position, long size)</code> -- 将此通道的文件区域直接映射到内存中</p></li>
                                <li class="group"><p><code>abstract void 	force(boolean metaData)</code> -- 强制将所有对此通道的文件更新写入包含该文件的存储设备中</p></li>

                                <li class="group"><p><code>abstract FileChannel 	truncate(long size)</code> -- 将此通道的文件截取为给定大小</p></li>
                            </ol>
						</div>

                        <a class="offset" id="java-nio-channels-SelectableChannel"></a>
                        <div class="sub-item">
							<pre class="brush: java;">
public abstract class SelectableChannel extends AbstractInterruptibleChannel {
    protected SelectableChannel() {}
}

/** 表示 SelectableChannel 在 Selector 中的注册的标记 */
public abstract class SelectionKey {
    public static int OP_ACCEPT = 1 << 0;  // 套接字接受操作的操作集位
    public static int OP_CONNECT = 1 << 1; // 套接字连接操作的操作集位
    public static int OP_READ = 1 << 2;    // 取操作的操作集位
    public static int OP_WRITE = 1 << 3;   // 写入操作的操作集位

    protected SelectionKey() {}

    Object attach(Object ob) {...} // 将给定的对象附加到此键
    Object attachment() {...}      // 获取当前的附加对象

    abstract Selector selector();  // 返回为此选择器创建的键
    abstract SelectableChannel channel(); // 返回为之创建此键的通道

    abstract int interestOps();                 // 获取此键的 interest 集合
    abstract SelectionKey interestOps(int ops); // 将此键的 interest 集合设置为给定值
    abstract int readyOps();                    // 获取此键的 ready 操作集合

    boolean isConnectable() {...}  // 测试此键的通道是否已完成其套接字连接操作
    boolean isAcceptable() {...}   // 测试此键的通道是否已准备好接受新的套接字连接
    boolean isReadable() {...}     // 测试此键的通道是否已准备好进行读取
    boolean isWritable() {...}     // 测试此键的通道是否已准备好进行写入

    abstract void cancel();        // 请求取消此键的通道到其选择器的注册
    abstract boolean isValid();    // 告知此键是否有效
}
</pre>
                            <p><a href="docs/docs-java/api/java/nio/channels/SelectableChannel.html" target="_blank">SelectableChannel</a> 是可通过 Selector 实现多路复用的通道。</p>
                            <p>为了与选择器一起使用，此类的实例必须首先通过 <code>register</code> 方法进行注册。此方法返回一个表示该通道已向选择器注册的新 <a href="docs/docs-java/api/java/nio/channels/SelectionKey.html" target="_blank">SelectionKey</a> 对象。 </p>
                            <p>向选择器注册后，通道在注销 之前将保持注册状态。注销涉及释放选择器已分配给该通道的所有资源。 </p>
                            <p>不能直接注销通道；相反，必须取消 表示通道注册的键。取消某个键要求在选择器的下一个选择操作期间注销通道。可通过调用某个键的 <code>cancel</code> 方法显式地取消该键。无论是通过调用通道的 <code>close</code> 方法，还是中断阻塞于该通道上 I/O 操作中的线程来关闭该通道，都会隐式地取消该通道的所有键。 </p>
                            <p>一个通道至多只能在任意特定选择器上注册一次。 </p>
                            <p>可选择的通道要么处于阻塞 模式，要么处于非阻塞 模式。在阻塞模式中，每一个 I/O 操作完成之前都会阻塞在其通道上调用的其他 I/O 操作。在非阻塞模式中，永远不会阻塞 I/O 操作，并且传输的字节可能少于请求的数量，或者可能根本不传输字节。可通过调用可选择通道的 isBlocking 方法来确定其阻塞模式。 </p>
                            <p>新创建的可选择通道总是处于阻塞模式。在结合使用基于选择器的多路复用时，非阻塞模式是最有用的。向选择器注册某个通道前，必须将该通道置于非阻塞模式，并且在注销之前可能无法返回到阻塞模式。 </p>
                            <ol>

                                <li><p><code><a href="docs/docs-java/api/java/nio/channels/SelectionKey.html" target="_blank">SelectionKey</a>  	register(<a href="#java-nio-channels-Selector">Selector</a> sel, int ops)</code> -- 向给定的选择器注册此通道，返回一个选择键</p></li>
                                <li><p><code>abstract <a href="docs/docs-java/api/java/nio/channels/SelectionKey.html" target="_blank">SelectionKey</a>  	register(<a href="#java-nio-channels-Selector">Selector</a> sel, int ops, Object att)</code> -- 向给定的选择器注册此通道，返回一个选择键</p></li>

                                <li class="group"><p><code>abstract SelectorProvider 	provider()</code> -- 返回创建此通道的提供者</p></li>

                                <li class="group"><p><code>abstract boolean 	isBlocking()</code> -- 判断此通道上的每个 I/O 操作在完成前是否被阻塞</p></li>
                                <li><p><code>abstract SelectableChannel 	configureBlocking(boolean block)</code> -- 调整此通道的阻塞模式</p></li>
                                <li><p><code>abstract Object 	blockingLock()</code> -- 获取其 configureBlocking 和 register 方法实现同步的对象</p></li>

                                <li class="group"><p><code>abstract boolean 	isRegistered()</code> -- 判断此通道当前是否已向任何选择器注册</p></li>
                                <li><p><code>abstract <a href="docs/docs-java/api/java/nio/channels/SelectionKey.html" target="_blank">SelectionKey</a>  	keyFor(Selector sel)</code> -- 获取表示通道向给定选择器注册的键</p></li>
                                <li><p><code>abstract int 	validOps()</code> -- 返回一个操作集，标识此通道所支持的操作</p></li>
                            </ol>
                        </div>

                        <a class="offset" id="java-nio-channels-DatagramChannel"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public abstract class DatagramChannel extends AbstractSelectableChannel implements ByteChannel,
        ScatteringByteChannel, GatheringByteChannel, MulticastChannel {
    protected DatagramChannel(SelectorProvider provider) {...}
}
</pre>
                            <p><a href="docs/docs-java/api/java/nio/channels/DatagramChannel.html" target="_blank">DatagramChannel</a> 针对面向数据报套接字(UDP)的可选择通道。 </p>
                            <ol>

                                <li><p><code>static DatagramChannel 	open()</code> -- 打开数据报通道</p></li>
                                <li><p><code>static DatagramChannel 	open(ProtocolFamily family)</code> -- 打开数据报通道</p></li>

                                <li class="group"><p><code>abstract DatagramChannel 	connect(SocketAddress remote)</code> -- 连接此通道的套接字</p></li>
                                <li><p><code>abstract DatagramChannel 	disconnect()</code> -- 断开此通道套接字的连接</p></li>
                                <li><p><code>abstract boolean 	isConnected()</code> -- 判断是否已连接此通道的套接字</p></li>

                                <li class="group"><p><code>abstract DatagramChannel 	bind(SocketAddress local)</code> -- 将通道的套接字绑定到本地地址</p></li>

                                <li class="group"><p><code>abstract &lt;T> DatagramChannel 	setOption(SocketOption&lt;T> name, T value)</code> -- 配置套接字选项</p>
                                    <pre class="brush: java;">
/** SocketOption 参数支持 java.net.StandardSocketOptions 的以下成员：
 * DatagramChannel -- 支持前面 8 个参数类型
 * ServerSocketChannel -- 支持 IP_TOS 和 SO_REUSEADDR
 * SocketChannel -- 支持后面 6 个参数类型
 */
public final class StandardSocketOptions {
    static SocketOption&lt;NetworkInterface> IP_MULTICAST_IF  // 多播数据报的网络接口
    static SocketOption&lt;Boolean> IP_MULTICAST_LOOP         // 多播数据报是否环回
    static SocketOption&lt;Integer> IP_MULTICAST_TTL          // 多播数据报的生存时间
    static SocketOption&lt;Integer> IP_TOS                    // IP 报头服务类型的八位字节
    static SocketOption&lt;Boolean> SO_BROADCAST              // 允许传输广播数据报

    static SocketOption&lt;Integer> SO_SNDBUF                 // 套接字发送缓冲区的大小
    static SocketOption&lt;Integer> SO_RCVBUF                 // 套接字接收缓冲区的大小
    static SocketOption&lt;Boolean> SO_REUSEADDR              // 是否重复使用地址

    static SocketOption&lt;Boolean> SO_KEEPALIVE              // 是否 Keep-Alive
    static SocketOption&lt;Integer> SO_LINGER                 // 如果存在数据，则在关闭时延迟
    static SocketOption&lt;Boolean> TCP_NODELAY               // 是否禁用 Nagle 算法
}
</pre>
                                </li>

                                <li class="group"><p><code>abstract SocketAddress 	receive(ByteBuffer dst)</code> -- 通过此通道接收数据报</p></li>
                                <li><p><code>abstract int 	send(ByteBuffer src, SocketAddress target)</code> -- 通过此通道发送数据报</p></li>

                                <li class="group"><p><code>abstract int 	read(ByteBuffer dst)</code> -- 将字节序列从此通道读入给定的缓冲区</p></li>
                                <li><p><code>long 	read(ByteBuffer[] dsts)</code> -- 将字节序列从此通道依次读入给定的缓冲区</p></li>
                                <li><p><code>abstract long 	read(ByteBuffer[] dsts, int offset, int length)</code> -- 同上，指定偏移和大小</p></li>

                                <li class="group"><p><code>abstract int 	write(ByteBuffer src)</code> -- 将字节序列从给定的缓冲区写入此通道</p></li>
                                <li><p><code>long 	write(ByteBuffer[] srcs)</code> -- 将字节序列从给定的缓冲区依次写入此通道</p></li>
                                <li><p><code>abstract long 	write(ByteBuffer[] srcs, int offset, int length)</code> -- 同上，指定偏移和大小</p></li>

                                <li class="group"><p><code>int 	validOps()</code> -- 返回一个操作集，标识此通道所支持的操作，参见: <a href="#java-nio-channels-SelectableChannel">SelectableChannel</a></p></li>
                                <li><p><code>abstract DatagramSocket 	socket()</code> -- 获取与此通道关联的数据报套接字</p></li>
                                <li><p><code>abstract SocketAddress 	getLocalAddress()</code> -- 返回此通道的套接字绑定到的本地套接字地址</p></li>
                                <li><p><code>abstract SocketAddress 	getRemoteAddress()</code> -- 返回此通道的套接字连接到的远程地址</p></li>
                            </ol>
                        </div>

                        <a class="offset" id="java-nio-channels-SocketChannel"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public abstract class SocketChannel extends AbstractSelectableChannel implements ByteChannel,
        ScatteringByteChannel, GatheringByteChannel, NetworkChannel {
    protected SocketChannel(SelectorProvider provider) {...}
}
</pre>
                            <p><a href="docs/docs-java/api/java/nio/channels/SocketChannel.html" target="_blank">SocketChannel</a> 针对面向流的连接套接字的可选择通道。 </p>
                            <p>套接字通道不是连接网络套接字的完整抽象。</p>
                            <ul>
                                <li><p><code>static SocketChannel 	open()</code> -- 打开套接字通道</p></li>
                                <li><p><code>static SocketChannel 	open(SocketAddress remote)</code> -- 打开套接字通道并将其连接到远程地址</p></li>

                                <li><p><code>abstract SocketChannel 	bind(SocketAddress local)</code> -- 将通道的套接字绑定到本地地址</p></li>
                                <li><p><code>abstract boolean 	connect(SocketAddress remote)</code> -- </p></li>
                                <li><p><code>abstract boolean 	finishConnect()</code> -- 完成套接字通道的连接过程</p></li>

                                <li><p><code>abstract boolean 	isConnected()</code> -- 判断是否已连接此通道的网络套接字</p></li>
                                <li><p><code>abstract boolean 	isConnectionPending()</code> -- 判断此通道上是否正在进行连接操作</p></li>

                                <li class="group"><p><code>abstract int 	read(ByteBuffer dst)</code> -- 将字节序列从此通道读入给定的缓冲区</p></li>
                                <li><p><code>long 	read(ByteBuffer[] dsts)</code> -- 将字节序列从此通道依次读入给定的缓冲区</p></li>
                                <li><p><code>abstract long 	read(ByteBuffer[] dsts, int offset, int length)</code> -- 同上，指定偏移和大小</p></li>

                                <li class="group"><p><code>abstract int 	write(ByteBuffer src)</code> -- 将字节序列从给定的缓冲区写入此通道</p></li>
                                <li><p><code>long 	write(ByteBuffer[] srcs)</code> -- 将字节序列从给定的缓冲区依次写入此通道</p></li>
                                <li><p><code>abstract long 	write(ByteBuffer[] srcs, int offset, int length)</code> -- 同上，指定偏移和大小</p></li>

                                <li><p><code>abstract SocketChannel 	shutdownInput()</code> -- 在不关闭通道的情况下关闭读取连接</p></li>
                                <li><p><code>abstract SocketChannel 	shutdownOutput()</code> -- 在不关闭通道的情况下关闭写入连接</p></li>

                                <li><p><code>abstract &lt;T> SocketChannel 	setOption(SocketOption&lt;T> name, T value)</code> -- 配置套接字选项，参见 <a href="#java-nio-channels-SelectableChannel">SelectableChannel</a></p></li>

                                <li class="group"><p><code>int 	validOps()</code> -- 返回一个操作集，标识此通道所支持的操作，参见: <a href="#java-nio-channels-SelectableChannel">SelectableChannel</a></p></li>
                                <li><p><code>abstract Socket 	socket()</code> -- 获取与此通道关联的数据报套接字</p></li>
                                <li><p><code>abstract SocketAddress 	getLocalAddress()</code> -- 返回此通道的套接字绑定到的本地套接字地址</p></li>
                                <li><p><code>abstract SocketAddress 	getRemoteAddress()</code> -- 返回此通道的套接字连接到的远程地址</p></li>
                            </ul>
                        </div>

                        <a class="offset" id="java-nio-channels-ServerSocketChannel"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public abstract class ServerSocketChannel extends AbstractSelectableChannel implements NetworkChannel {
    protected ServerSocketChannel(SelectorProvider provider) {...}
}
</pre>
                            <p><a href="docs/docs-java/api/java/nio/channels/ServerSocketChannel.html" target="_blank">ServerSocketChannel</a> 针对面向流的侦听套接字的可选择通道。 </p>
                            <p>服务器套接字通道不是侦听网络套接字的完整抽象。</p>
                            <ul>

                                <li><p><code>static ServerSocketChannel 	open()</code> -- 打开服务器套接字通道</p></li>

                                <li><p><code>ServerSocketChannel 	bind(SocketAddress local)</code> -- 将通道的套接字绑定到本地地址</p></li>
                                <li><p><code>abstract ServerSocketChannel 	bind(SocketAddress local, int backlog)</code> -- 同上，指定挂起连接的最大数目</p></li>
                                <li><p><code>abstract SocketChannel 	accept()</code> -- 接受到此通道套接字的连接</p></li>

                                <li class="group"><p><code>abstract &lt;T> ServerSocketChannel 	setOption(SocketOption&lt;T> name, T value)</code> -- 配置套接字选项，参见 <a href="#java-nio-channels-SelectableChannel">SelectableChannel</a></p></li>
                                <li class="group"><p><code>int 	validOps()</code> -- 返回一个操作集，标识此通道所支持的操作，参见: <a href="#java-nio-channels-SelectableChannel">SelectableChannel</a></p></li>
                                <li><p><code>abstract DatagramSocket 	socket()</code> -- 获取与此通道关联的数据报套接字</p></li>
                                <li><p><code>abstract SocketAddress 	getLocalAddress()</code> -- 返回此通道的套接字绑定到的本地套接字地址</p></li>
                            </ul>
                            <pre class="brush: java;">
/** TCP Server */
void server() {
    try {
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.bind(new InetSocketAddress(6024));

        while(true) {
            SocketChannel socketChannel = serverSocketChannel.accept();

            // 从连接的 client 读取数据
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int readyBytes = socketChannel.read(buffer);
            while(readyBytes > 0) {
                byte[] bytes = new byte[readyBytes];
                buffer.flip();
                buffer.get(bytes);
                log("accepted", new String(bytes, StandardCharsets.UTF_8));
                readyBytes = socketChannel.read(buffer);
            }

            // 如入数据到 client
            buffer.clear();
            buffer.put("Hi".getBytes());
            buffer.flip();
            socketChannel.write(buffer);
        }

    } catch (IOException e) {
        e.printStackTrace();
    }
}

/** TCP Client */
void client() {
    try {
        SocketChannel socketChannel = SocketChannel.open();
        socketChannel.connect(new InetSocketAddress("192.168.0.192", 6024));

        // 发送数据到 server
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        buffer.put("Hello".getBytes());
        buffer.flip();
        socketChannel.write(buffer);

        // 从 server 读取数据
        buffer.clear();
        int bytesReady = socketChannel.read(buffer);
        while(bytesReady > 0) {
            byte[] bytes = new byte[bytesReady];
            buffer.flip();
            buffer.get(bytes);
            log("accepted", new String(bytes, StandardCharsets.UTF_8));
            bytesReady = socketChannel.read(buffer);
        }

        socketChannel.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</pre>
                        </div>
                    </div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-nio-channels-Selector"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Selector 及相关类</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<pre class="brush: java;">
public abstract class Selector implements Closeable {
    protected Selector() {}
}
</pre>
							<p><a href="docs/docs-java/api/java/nio/channels/Selector.html" target="_blank">Selector</a> 是 <a href="#java-nio-channels-SelectableChannel">SelectableChannel</a> 对象的多路复用器。 </p>
                            <p>可通过调用此类的 <code>open</code> 方法创建选择器，该方法将使用系统的默认选择器提供者创建新的选择器。也可通过调用自定义选择器提供者的 <code>openSelector</code> 方法来创建选择器。通过选择器的 <code>close</code> 方法关闭选择器之前，它一直保持打开状态。 </p>
                            <ol>
                                <li><p><code>static Selector 	open()</code> -- 打开一个选择器</p></li>

                                <li class="group"><p><code>abstract Set&lt;SelectionKey> 	keys()</code> -- 返回此选择器的键集</p></li>
                                <li><p><code>abstract Set&lt;SelectionKey> 	selectedKeys()</code> -- 返回此选择器的已选择键集</p></li>

                                <li class="group"><p><code>abstract SelectorProvider 	provider()</code> -- 返回创建此通道的提供者</p></li>

                                <li class="group"><p><code>abstract int 	select()</code> -- 阻塞到至少有一个通道在注册的事件上就绪了。返回的 int 值表示有多少通道已经就绪。亦即，自上次调用此方法后有多少通道变成就绪状态。如果调用此方法，因为有一个通道变成就绪状态，返回了 1，若再次调用此方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的 channel 没有做任何操作，现在就有两个就绪的通道，但在每次 select() 方法调用之间，只有一个通道就绪了。</p></li>
                                <li><p><code>abstract int 	select(long timeout)</code> -- 同上，指定最长阻塞时间</p></li>
                                <li><p><code>abstract int 	selectNow()</code> -- 不会阻塞，不管什么通道就绪都立刻返回(此方法执行非阻塞的选择操作)</p></li>

                                <li class="group"><p><code>abstract boolean 	isOpen()</code> -- 选择器是否已打开</p></li>
                                <li><p><code>abstract Selector 	wakeup()</code> -- 使尚未返回的第一个选择操作立即返回</p></li>
                                <li><p><code>abstract void 	close()</code> -- 关闭此选择器</p></li>
                            </ol>
						</div>

						<div class="sub-item">
							<pre class="brush: java;">
/** 一个 Server 可以在同一个线程上接收多个客户端收发数据 */
void server() {
    try {
        ServerSocketChannel ssc = ServerSocketChannel.open();
        ssc.bind(new InetSocketAddress(6024));
        ssc.configureBlocking(false);

        Selector selector = Selector.open();
        // 注册 channel，并且指定感兴趣的事件是 Accept
        ssc.register(selector, SelectionKey.OP_ACCEPT);

        ByteBuffer readBuff = ByteBuffer.allocate(1024);
        ByteBuffer writeBuff = ByteBuffer.allocate(128);

        while (true) {
            int nReady = selector.select();
            Set&lt;SelectionKey> keys = selector.selectedKeys();
            Iterator&lt;SelectionKey> it = keys.iterator();

            while (it.hasNext()) {
                SelectionKey key = it.next();
                it.remove();

                if (key.isAcceptable()) {
                    // 创建新的连接，并且把连接注册到selector上，而且，
                    // 声明这个channel只对读操作感兴趣。
                    SocketChannel socketChannel = ssc.accept();
                    socketChannel.configureBlocking(false);
                    socketChannel.register(selector, SelectionKey.OP_READ);
                } else if (key.isReadable()) {
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    readBuff.clear();
                    int readed = socketChannel.read(readBuff);

                    readBuff.flip();
                    String fromClient = new String(readBuff.array(), 0, readed);
                    System.out.println(Thread.currentThread().getName() + "received : " + fromClient);
                    key.interestOps(SelectionKey.OP_WRITE);
                } else if (key.isWritable()) {
                    writeBuff.rewind();
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    writeBuff.put("received".getBytes());
                    writeBuff.flip();
                    socketChannel.write(writeBuff);
                    key.interestOps(SelectionKey.OP_READ);
                }
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}

void client() {
     try {
        SocketChannel socketChannel = SocketChannel.open();
        socketChannel.connect(new InetSocketAddress("192.168.0.192", 6024));

        ByteBuffer writeBuffer = ByteBuffer.allocate(32);
        ByteBuffer readBuffer = ByteBuffer.allocate(32);

        writeBuffer.put((new Random().nextInt() + "hello").getBytes());
        writeBuffer.flip();

        while (true) {
            writeBuffer.rewind();
            socketChannel.write(writeBuffer);
            readBuffer.clear();

            int readed = socketChannel.read(readBuffer);
            System.out.println(new String(readBuffer.array(), 0, readed));
            Thread.sleep(1000);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</pre>
							<p><a href="docs/docs-java/api/" target="_blank"></a></p>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-nio-charset-Charset"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Charset 及相关类</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object
    java.nio.charset.Charset

public abstract class Charset implements Comparable&lt;Charset> {
    protected Charset(String canonicalName, String[] aliases) {...}
}
</pre>
							<p><a href="docs/docs-java/api/java/nio/charset/Charset.html" target="_blank">Charset</a> 16 位的 Unicode 代码单元序列和字节序列之间的指定映射关系。定义了用于创建解码器和编码器以及获取与 charset 关联的各种名称的方法。</p>
                            <p>此类也定义了用于测试是否支持特定 charset 的静态方法、通过名称查找 charset 实例的静态方法，以及构造一个包含目前 Java 虚拟机支持的每个 charset 的映射静态方法。通过类 CharsetProvider 中定义的服务提供者接口可以添加对新 charset 的支持。 </p>
                            <p>Java 平台的每一种实现都需要支持以下标准 charset，在 JDK 7 中规范化了以下名称:</p>
                            <pre class="brush: java;">
public final class StandardCharsets {
    /** 7 位 ASCII 字符 */
    public static final Charset US_ASCII = Charset.forName("US-ASCII");
    /** ISO 拉丁字母表 */
    public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
    /** 8 位 UCS 转换格式 */
    public static final Charset UTF_8 = Charset.forName("UTF-8");
    /** 16 位 UCS 转换格式，Big Endian（最低地址存放高位字节）字节顺序 */
    public static final Charset UTF_16BE = Charset.forName("UTF-16BE");
    /** 16 位 UCS 转换格式，Little-endian（最高地址存放低位字节）字节顺序 */
    public static final Charset UTF_16LE = Charset.forName("UTF-16LE");
    /** 16 位 UCS 转换格式，字节顺序由可选的字节顺序标记来标识 */
    public static final Charset UTF_16 = Charset.forName("UTF-16");
}
                            </pre>
                            <ol>
                                <li><p><code>static Charset 	defaultCharset()</code> -- 返回此 Java 虚拟机的默认 charset</p></li>
                                <li><p><code>static Charset 	forName(String charsetName)</code> -- 返回指定 charset 的 charset 对象</p></li>
                                <li><p><code>static boolean 	isSupported(String charsetName)</code> -- 通知是否支持指定的 charset</p></li>
                                <li><p><code>static SortedMap&lt;String,Charset> 	availableCharsets()</code> -- 构造从规范 charset 名称到 charset 对象的有序映射</p></li>

                                <li class="group"><p><code>String 	name()</code> -- 返回此 charset 的规范名称</p></li>
                                <li><p><code>String 	displayName()</code> -- 返回此 charset 用于默认语言环境的可读名称</p></li>
                                <li><p><code>String 	displayName(Locale locale)</code> -- 返回此 charset 用于给定语言环境的可读名称</p></li>
                                <li><p><code>Set&lt;String> 	aliases()</code> -- 返回包含此 charset 各个别名的集合</p></li>

                                <li class="group"><p><code>boolean 	canEncode()</code> -- 通知此 charset 是否支持编码</p></li>
                                <li><p><code>ByteBuffer 	encode(CharBuffer cb)</code> -- 将此 charset 中的 Unicode 字符编码成字节的便捷方法</p></li>
                                <li><p><code>ByteBuffer 	encode(String str)</code> --  将此 charset 中的字符串编码成字节的便捷方法</p></li>
                                <li><p><code>CharBuffer 	decode(ByteBuffer bb)</code> --  将此 charset 中的字节解码成 Unicode 字符的便捷方法</p></li>
                                <li><p><code>abstract CharsetDecoder 	newDecoder()</code> -- 为此 charset 构造新的解码器</p></li>
                                <li><p><code>abstract CharsetEncoder 	newEncoder()</code> -- 为此 charset 构造新的编码器</p></li>

                                <li class="group"><p><code>boolean 	isRegistered()</code> -- 通知此 charset 是否已在 IANA Charset Registry 中注册</p></li>
                                <li><p><code>abstract boolean 	contains(Charset cs)</code> -- 通知此 charset 是否包含给定的 charset</p></li>

                                <li class="group"><p><code>boolean 	equals(Object ob)</code> -- 通知此对象是否和其他对象相等</p></li>
                                <li><p><code>int 	hashCode()</code> -- 计算此 charset 的哈希码</p></li>
                                <li><p><code>int 	compareTo(Charset that)</code> -- 比较此 charset 与其他 charset</p></li>
                                <li><p><code>String 	toString()</code> -- 返回描述此 charset 的字符串</p></li>
                            </ol>

						</div>

						<div class="sub-item">
                            <p><a href="docs/docs-java/api/java/nio/charset/CharsetEncoder.html" target="_blank">CharsetEncoder</a> 能够把 16 位 Unicode 字符序列转换成特定 charset 中字节序列的引擎。</p>
                            <p><a href="docs/docs-java/api/java/nio/charset/CharsetDecoder.html" target="_blank">CharsetDecoder</a> 能够把特定 charset 中的字节序列转换成 16 位 Unicode 字符序列的引擎。</p>
							<pre class="brush: java;">
Charset utf8 = StandardCharsets.UTF_8;
CharsetEncoder encoder = utf8.newEncoder();
CharsetDecoder decoder = utf8.newDecoder();

CharBuffer charBuffer = CharBuffer.allocate(1000);
// a3 αβ 你好 🂡🂢, utf-8 编码分别是: 单字节，双字节，三字节，四字节
charBuffer.put("a3 αβ 你好 \uD83C\uDCA1\uD83C\uDCA2");
try {
    // 编码
    charBuffer.flip();
    ByteBuffer byteBuffer = encoder.encode(charBuffer);
    byte[] bytes = new byte[byteBuffer.limit()];
    byteBuffer.get(bytes);
    log(bytesToHex(bytes));

    // 解码
    byteBuffer.flip();
    charBuffer = decoder.decode(byteBuffer);
    char[] arr = new char[charBuffer.limit()];
    charBuffer.get(arr);
    log(new String(arr));
} catch (CharacterCodingException e) {
    e.printStackTrace();
}
</pre>

						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-nio-file-Files"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Files 及相关类</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
                            <p><a href="#java-nio-file-Files">Path</a> 和 <a href="#java-nio-file-Files-class">Files</a></p>
							<pre class="brush: java;">
public interface Path extends Comparable&lt;Path>, Iterable&lt;Path>, Watchable {...}

/** 可以向监视服务注册的对象，以便监视它的更改和事件 */
public interface Watchable {
  WatchKey register(WatchService watcher, WatchEvent.Kind&lt;?>... events);
  WatchKey register(WatchService watcher, WatchEvent.Kind&lt;?>[] events, WatchEvent.Modifier... modifiers);
}
</pre>
                            <p><a href="docs/docs-java/api/java/nio/file/Path.html" target="_blank">Path</a> 接口表示一种可用于在文件系统中定位文件的对象。它通常表示依赖于系统的文件路径。</p>
                            <p><a href="docs/docs-java/api/java/nio/file/Path.html" target="_blank">Path</a> 由一系列由特殊分隔符或分隔符分隔的目录和文件名元素组成。 </p>
                            <p><a href="docs/docs-java/api/java/nio/file/Paths.html" target="_blank">Paths</a> 提供了创建 Path 的静态方法。</p>
                            <ol>
                                <li><p><code>static Path 	get(String first, String... more)</code> -- 从指定路径创建一个 Path 对象</p></li>
                                <li><p><code>static Path 	get(URI uri)</code> -- 从 URI 创建一个 Path 对象</p></li>
                            </ol>
                            <p><a href="docs/docs-java/api/java/nio/file/Path.html" target="_blank">Path</a> 可以和 <code>java.io.File</code> 相互转换: File 类有一个 <code>toPath()</code> 方法，Path 类有一个 <code>toFile()</code> 方法。</p>
                            <ol>
                                <li class="group"><p><code>Path 	toAbsolutePath()</code> -- 转换为绝对路径</p></li>
                                <li><p><code>boolean 	isAbsolute()</code> -- 是否为绝对路径</p></li>
                                <li><p><code>Path 	toRealPath(LinkOption... options)</code> -- 可以理解转换为绝对路径，如果存在 <code>LinkOption.NOFOLLOW_LINKS</code> 参数，则此方法不解析符号链接</p></li>
                                <li><p><code>File 	toFile()</code> -- 转换为文件</p></li>
                                <li><p><code>URI 	toUri()</code> -- 转换为 Uri 表示形式：<code>file:///tmp/</code></p></li>

                                <li class="group"><p><code>Iterator&lt;Path> 	iterator()</code> -- 每一级目录迭代器</p></li>
                                <li><p><code>int 	getNameCount()</code> -- 组成级别数，这个参数范围为: <code> >= 1</code></p></li>

                                <li class="group"><p><code>Path 	getName(int index)</code> -- 指定级别的文件名称，如果超出则抛出 <code>IllegalArgumentException</code></p></li>
                                <li><p><code>Path 	getFileName()</code> -- 获取文件名(如果最后一级的文件名称，可能是目录或文件，也可能为 <code>""</code>)</p></li>
                                <li><p><code>Path 	subpath(int beginIndex, int endIndex)</code> -- 指定索引范围的的目录</p></li>
                                <li><p><code>Path 	getParent()</code> -- 父目录</p></li>
                                <li><p><code>Path 	getRoot()</code> -- 根目录，如果是相对目录则返回 NULL</p></li>
                                <li><p><code>Path 	normalize()</code> -- 规范化</p></li>

                                <li class="group"><p><code>Path 	resolve(Path other)</code> -- 根据此路径解析给定路径</p></li>
                                <li><p><code>Path 	resolve(String other)</code> -- 同上:<code>"a/b".resolve("c/d") == "a/b/c/d"</code></p></li>
                                <li><p><code>Path 	relativize(Path other)</code> -- 在该路径和给定路径之间构造一个相对路径: <code>p.relativize(p.resolve(q)).equals(q) </code></p></li>
                                <li><p><code>Path 	resolveSibling(Path other)</code> -- 根据此路径的父路径解析给定路径(替换最后一级)</p></li>
                                <li><p><code>Path 	resolveSibling(String other)</code> -- 同上:<code>"a/b".resolve("c/d") == "a/c/d"</code></p></li>

                                <li class="group"><p><code>boolean 	startsWith(Path other)</code> -- 是否以指定路径开始</p></li>
                                <li><p><code>boolean 	startsWith(String other)</code> -- 是否以指定路径开始</p></li>
                                <li><p><code>boolean 	endsWith(Path other)</code> -- 是否以指定路径结束</p></li>
                                <li><p><code>boolean 	endsWith(String other)</code> -- 是否以指定路径结束</p></li>

                                <li class="group"><p><code>FileSystem 	getFileSystem()</code> -- 返回创建此对象的文件系统</p></li>

                                <li class="group"><p><code>WatchKey 	register(WatchService watcher, WatchEvent.Kind&lt;?>... events)</code> -- 向监视服务注册此路径下的文件</p></li>
                                <li><p><code>WatchKey 	register(WatchService watcher, WatchEvent.Kind&lt;?>[] events, WatchEvent.Modifier... modifiers)</code> -- 同上</p></li>

                                <li class="group"><p><code>String 	toString()</code> -- 转换为 String 表示形式</p></li>
                                <li><p><code>int 	compareTo(Path other)</code> -- 比较</p></li>
                                <li><p><code>boolean 	equals(Object other)</code> -- 相等</p></li>
                                <li><p><code>int 	hashCode()</code> -- 哈希值</p></li>
                            </ol>
                        </div>

                        <a class="offset" id="java-nio-file-Files-class"></a>
						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object
    java.nio.file.Files

public final class Files {
    private Files() {}
}
</pre>
							<p><a href="docs/docs-java/api/java/nio/file/Files.html" target="_blank">Files</a> 包含对文件、目录或其他类型的文件进行操作的静态方法。</p>
                            <p>在大多数情况下，这里定义的方法将委托给关联的文件系统提供程序来执行文件操作。</p>
                            <ol>
                                <li><p><code>static Path 	createDirectories(Path dir, FileAttribute&lt;?>... attrs)</code> -- 创建目录，包括不存在的父目录，目录存在返回目录</p></li>
                                <li><p><code>static Path 	createDirectory(Path dir, FileAttribute&lt;?>... attrs)</code> -- 创建目录，目录已存在抛出 <code>FileAlreadyExistsException</code>, 父目录不存在则抛出 <code>NoSuchFileException</code></p></li>
                                <li><p><code>static Path 	createFile(Path path, FileAttribute&lt;?>... attrs)</code> -- 创建空文件，异常同上</p></li>
                                <li><p><code>static Path 	createLink(Path link, Path existing)</code> -- 创建链接(硬链接，不能指向目录)，异常同上，若指向文件则抛出 <code>FileSystemException</code></p></li>
                                <li><p><code>static Path 	createSymbolicLink(Path link, Path target, FileAttribute&lt;?>... attrs)</code> -- 创建软链接(符号链接)，可以指向目录，异常同上</p></li>
                                <li><p><code>static Path 	createTempDirectory(Path dir, String prefix, FileAttribute&lt;?>... attrs)</code> -- 在 dir 下创建临时目录(目录名由 prefix + 系统自动生成串 组成)，异常同上</p></li>
                                <li><p><code>static Path 	createTempDirectory(String prefix, FileAttribute&lt;?>... attrs)</code> -- 同上，在临时目录下创建(Linux 为 /tmp)，异常同上</p></li>
                                <li><p><code>static Path 	createTempFile(Path dir, String prefix, String suffix, FileAttribute&lt;?>... attrs)</code> -- 在 dir 下创建临时文件(目录名由 prefix + 系统自动生成串 组成)，异常同上</p></li>
                                <li><p><code>static Path 	createTempFile(String prefix, String suffix, FileAttribute&lt;?>... attrs)</code> -- 同上，在临时目录下创建(Linux 为 /tmp)，异常同上</p>
                                    <pre class="brush: java;">
Set&lt;PosixFilePermission> permissions = new TreeSet<>();
// PosixFilePermission 枚举类型分别为: owner,group,others 的 rwx 权限
permissions.add(PosixFilePermission.OWNER_READ);
FileAttribute&lt;Set&lt;PosixFilePermission>> attrs = PosixFilePermissions.asFileAttribute(permissions);
try {
    Path dir = Paths.get("tmp", "files");
    Path file = dir.resolve("file");
    if(Files.notExists(dir)) {
        Files.createDirectories(dir);  // 创建目录，包括父目录
    }
    if(Files.notExists(file)) {
        Files.createFile(file, attrs); // 创建文件，指定创建者只读
    }
    Path link = dir.resolve("linkToFile");
    if(Files.notExists(link)) {
        Files.createLink(link, file);
    }
    Path softLink = dir.resolve("linkToDir");
    if(Files.notExists(softLink, LinkOption.NOFOLLOW_LINKS)) { // 指定包含符号链接
        Files.createSymbolicLink(softLink, dir);
    }
    log(Files.exists(link), Files.exists(softLink, LinkOption.NOFOLLOW_LINKS));
} catch (IOException e) {
    e.printStackTrace();
}
</pre>
                                </li>

                                <li class="group"><p><code>static boolean 	exists(Path path, LinkOption... options)</code> -- 存在返回 true, 否则 false，如果存在 LinkOption.NOFOLLOW_LINKS 参数，才计入符号链接</p></li>
                                <li><p><code>static boolean 	notExists(Path path, LinkOption... options)</code> -- 不存在返回 true, 否则 false，如果存在 LinkOption.NOFOLLOW_LINKS 参数，才计入符号链接</p>
                                    <pre class="brush: java;">
Path softLink = dir.resolve("linkToDir");
if(Files.notExists(softLink, LinkOption.NOFOLLOW_LINKS)) { // 指定包含符号链接
    Files.createSymbolicLink(softLink, dir);
}
log(Files.exists(softLink), Files.exists(softLink, LinkOption.NOFOLLOW_LINKS)); // false, true
</pre>
                                </li>

                                <li class="group"><p><code>static long 	copy(Path source, OutputStream out)</code> -- 复制，将 source 写入到指定输出流</p></li>
                                <li><p><code>static long 	copy(InputStream in, Path target, CopyOption... options)</code> -- 复制，将 in 写入到 target</p></li>
                                <li><p><code>static Path 	copy(Path source, Path target, CopyOption... options)</code> -- 复制，将 source 写入到 target</p></li>

                                <li class="group"><p><code>static Path 	move(Path source, Path target, CopyOption... options)</code> -- 移动/重命名文件</p></li>

                                <li class="group"><p><code>static void 	delete(Path path)</code> -- 删除文件</p></li>
                                <li><p><code>static boolean 	deleteIfExists(Path path)</code> -- 删除文件，不存在也不会抛出异常</p></li>



                                <li class="group"><p><code>static FileTime 	getLastModifiedTime(Path path, LinkOption... options)</code> -- 返回文件的上次修改时间</p></li>
                                <li><p><code>static Path 	setLastModifiedTime(Path path, FileTime time)</code> -- 更新文件上次修改的时间属性</p></li>
                                <li><p><code>static UserPrincipal 	getOwner(Path path, LinkOption... options)</code> -- 获取文件所有者</p></li>
                                <li><p><code>static Path 	setOwner(Path path, UserPrincipal owner)</code> -- 更新文件所有者</p></li>
                                <li><p><code>static Set&lt;PosixFilePermission> 	getPosixFilePermissions(Path path, LinkOption... options)</code> -- 获取权限列表</p></li>
                                <li><p><code>static Path 	setPosixFilePermissions(Path path, Set&lt;PosixFilePermission> perms)</code> -- 设置文件的POSIX权限</p></li>

                                <li class="group"><p><code>static Object 	getAttribute(Path path, String attribute, LinkOption... options)</code> -- 设置文件属性的值，不支持的属性报 <code>UnsupportedOperationException</code></p></li>
                                <li><p><code>static Path 	setAttribute(Path path, String attribute, Object value, LinkOption... options)</code> -- 获取文件属性的值，不支持的属性报 <code>UnsupportedOperationException</code></p>
                                    <pre class="brush: java;">
/* attribute 的格式如下：
 *    [view-name:]attribute-name
 * view-name 是视图名，默认为: basic, 其实对应的是 BasicFileAttributeView 的属性:
 *    "lastModifiedTime" 	FileTime
 *    "lastAccessTime" 	    FileTime
 *    "creationTime" 	    FileTime
 *    "size" 	            Long
 *    "isRegularFile" 	    Boolean
 *    "isDirectory" 	    Boolean
 *    "isSymbolicLink" 	    Boolean
 *    "isOther" 	        Boolean
 *    "fileKey" 	        Object
 *
 * 对于 Posix 和 Win 下有两个不同的子接口实现 PosixFileAttributeView 和 DosFileAttributeView
 * PosixFileAttributeView
 *    "permissions" 	    Set&lt;PosixFilePermission>
 *    "group" 	            GroupPrincipal
 *    "owner" 	            UserPrincipal

 * DosFileAttributeView
 *    "readonly" 	        Boolean
 *    "hidden"	            Boolean
 *    "system" 	            Boolean
 *    "archive" 	        Boolean
 */
log(Files.getAttribute(file, "size"));        // 文件大小
log(Files.getAttribute(file, "basic:size"));  // 同上

log(Files.getAttribute(file, "posix:group")); // 所属组，在 Posix 下才有效
log(Files.getAttribute(file, "dos:hidden"));  // 是否为隐藏文件，在 Win 下才有效
</pre>
                                </li>


                                <li><p><code>static Map&lt;String,Object> 	readAttributes(Path path, String attributes, LinkOption... options)</code> -- 属性名 attributes 支持以下写法</p>
                                    <pre class="brush: java;">
"*" 	                  -- 读取 BasicFileAttributeView 定义的所有属性
"size,lastModifiedTime"   -- 多个属性用 ',' 分割
"posix:*" 	              -- PosixFileAttributeView 的所有属性
"posix:permissions,size"  -- 多个属性用 ',' 分割
</pre>
                                </li>
                                <li class="group"><p><code>static &lt;A extends BasicFileAttributes> A 	readAttributes(Path path, Class&lt;A> type, LinkOption... options)</code> -- 读取文件属性</p>
                                    <pre class="brush: java;">
// 通用属性, 支持的方法参见 BasicFileAttributeView 的属性
BasicFileAttributes attrs = Files.readAttributes(file, BasicFileAttributes.class);
// Posix 系统
BasicFileAttributes posixAttrs = Files.readAttributes(file, PosixFileAttributes.class);
// Dos 系统
BasicFileAttributes dosAttrs = Files.readAttributes(file, DosFileAttributes.class);
</pre>
                                </li>
                                <li><p><code>static &lt;V extends FileAttributeView> V 	getFileAttributeView(Path path, Class&lt;V> type, LinkOption... options)</code> -- 返回给定类型的文件属性视图</p>
                                    <pre class="brush: java;">
try {
    log(Files.getFileAttributeView(file, BasicFileAttributeView.class).name());
    log(Files.getFileAttributeView(file, PosixFileAttributeView.class).name());
    log(Files.getFileAttributeView(file, DosFileAttributeView.class).name());

    Files.getFileAttributeView(file, DosFileAttributeView.class).setHidden(true);

    FileTime now = FileTime.fromMillis(System.currentTimeMillis());
    Files.getFileAttributeView(file, PosixFileAttributeView.class).setTimes(now, now, now);
} catch (IOException e) {
    e.printStackTrace();
}
</pre>
                                </li>

                                <li class="group"><p><code>static Stream&lt;Path> 	find(Path start, int maxDepth, BiPredicate&lt;Path,BasicFileAttributes> matcher, FileVisitOption... options)</code> -- 文件查找</p></li>
                                <li><p><code>static Path 	readSymbolicLink(Path link)</code> -- 读取链接的目标，如果文件不是符号链接，则会失败</p></li>

                                <li class="group"><p><code>static boolean 	isDirectory(Path path, LinkOption... options)</code> -- 是否为目录，参数类型了是否包含指向目录的符号链接</p></li>
                                <li><p><code>static boolean 	isRegularFile(Path path, LinkOption... options)</code> -- 是否为文件，参数类型了是否包含指向文件的符号链</p></li>
                                <li><p><code>static boolean 	isSymbolicLink(Path path)</code> -- 是否为符号链接</p></li>
                                <li><p><code>static boolean 	isSameFile(Path path, Path path2)</code> -- 是否指向同一个文件</p></li>
                                <li><p><code>static boolean 	isHidden(Path path)</code> -- 是否为隐藏文件</p></li>
                                <li><p><code>static boolean 	isReadable(Path path)</code> -- 是否可读</p></li>
                                <li><p><code>static boolean 	isWritable(Path path)</code> -- 是否可写</p></li>
                                <li><p><code>static boolean 	isExecutable(Path path)</code> -- 是否为可执行文件</p></li>

                                <li class="group"><p><code>static Stream&lt;String> 	lines(Path path)</code> -- 按行读取(Stream 是支持顺序和并行聚合操作的元素序列)</p></li>
                                <li><p><code>static Stream&lt;String> 	lines(Path path, Charset cs)</code> -- 指定编码按行读取</p></li>

                                <li class="group"><p><code>static byte[] 	readAllBytes(Path path)</code> -- 按字节读取所有字节</p></li>
                                <li><p><code>static List&lt;String> 	readAllLines(Path path)</code> -- 读取所有行</p></li>
                                <li><p><code>static List&lt;String> 	readAllLines(Path path, Charset cs)</code> -- 指定编码读取所有行</p></li>

                                <li class="group"><p><code>static Path 	write(Path path, byte[] bytes, OpenOption... options)</code> -- 写入字节，可以指定打开方式</p></li>
                                <li><p><code>static Path 	write(Path path, Iterable&lt;? extends CharSequence> lines, OpenOption... options)</code> -- 按行写入，可以指定打开方式</p></li>
                                <li><p><code>static Path 	write(Path path, Iterable&lt;? extends CharSequence> lines, Charset cs, OpenOption... options)</code> -- 指定编码按行写入，可以指定打开方式</p></li>

                                <li class="group"><p><code>static BufferedReader 	newBufferedReader(Path path)</code> -- 字符流读取</p></li>
                                <li><p><code>static BufferedReader 	newBufferedReader(Path path, Charset cs)</code> -- 指定编码字符流读取</p></li>
                                <li><p><code>static BufferedWriter 	newBufferedWriter(Path path, OpenOption... options)</code> -- 字符流写入，可以指定打开方式</p></li>
                                <li><p><code>static BufferedWriter 	newBufferedWriter(Path path, Charset cs, OpenOption... options)</code> -- 指定编码字符流写入，可以指定打开方式</p></li>

                                <li class="group"><p><code>static SeekableByteChannel 	newByteChannel(Path path, OpenOption... options)</code> -- 可读写/移动的字节数组，可以指定打开方式</p></li>
                                <li><p><code>static SeekableByteChannel 	newByteChannel(Path path, Set&lt;? extends OpenOption> options, FileAttribute&lt;?>... attrs)</code> -- 通上，可指定属性，可以指定打开方式</p></li>

                                <li class="group"><p><code>static Stream&lt;Path> 	list(Path dir)</code> -- 子目录/文件列表</p></li>
                                <li><p><code>static DirectoryStream&lt;Path> 	newDirectoryStream(Path dir)</code> -- 目录迭代器</p></li>
                                <li><p><code>static DirectoryStream&lt;Path> 	newDirectoryStream(Path dir, DirectoryStream.Filter&lt;? super Path> filter)</code> -- 可以指定过滤条件</p>
                                    <pre class="brush: java;">Files.newDirectoryStream(base, path -> Files.isRegularFile(path)).forEach(LogUtil::log);</pre>
                                </li>
                                <li><p><code>static DirectoryStream&lt;Path> 	newDirectoryStream(Path dir, String glob)</code> -- 过滤路径表示形式 <code>*.java</code></p></li>

                                <li class="group"><p><code>static InputStream 	newInputStream(Path path, OpenOption... options)</code> -- 读取字节流，可以指定打开方式</p></li>
                                <li><p><code>static OutputStream 	newOutputStream(Path path, OpenOption... options)</code> -- 写入字节流，可以指定打开方式</p></li>

                                <li class="group"><p><code>static long 	size(Path path)</code> -- 文件/目录大小</p></li>
                                <li><p><code>static String 	probeContentType(Path path)</code> -- 探测文件的内容类型</p></li>
                                <li><p><code>static FileStore 	getFileStore(Path path)</code> -- 文件存储的设备，分区，卷等信息</p></li>

                                <li class="group"><p><code>static Stream&lt;Path> 	walk(Path start, FileVisitOption... options)</code> -- 遍历文件树，包括子目录下目录/文件</p></li>
                                <li><p><code>static Stream&lt;Path> 	walk(Path start, int maxDepth, FileVisitOption... options)</code> -- 同上，指定最大深度</p></li>
                                <li><p><code>static Path 	walkFileTree(Path start, FileVisitor&lt;? super Path> visitor)</code> -- 过程可控遍历文件树，FileVisitor 是访问过程</p></li>
                                <li><p><code>static Path 	walkFileTree(Path start, Set&lt;FileVisitOption> options, int maxDepth, FileVisitor&lt;? super Path> visitor)</code> -- 同上，指定最大深度</p>
                                    <pre class="brush: java;">
// 文件访问者。该接口的实现 SimpleFileVisitor 用来访问文件树中的每个文件
public interface FileVisitor&lt;T> {
    // 在目录中的条目被访问之前调用一个目录
    FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException
    // 在目录中的条目之后调用目录，并且已经访问了所有的后代
    FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException;
    // 为目录中的文件调用
    FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException;
    // 为无法访问的文件调用
    FileVisitResult visitFileFailed(T file, IOException exc) throws IOException;
}

public enum FileVisitResult {
    CONTINUE,          // 继续
    TERMINATE,         // 终止
    SKIP_SUBTREE,      // 跳过此目录中的文件或目录
    SKIP_SIBLINGS;     // 跳过此文件或目录的兄弟节点
}
</pre>
                                </li>


                            </ol>
						</div>
                    </div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-net-URI"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">URI 和 URL</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object
	java.net.URI

public final class URI implements Comparable&lt;URI>, Serializable {
	public URI(String str) {...}
	public URI(String scheme, String ssp, String fragment) {...}
	public URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment) {...}
	public URI(String scheme, String host, String path, String fragment) {...}
	public URI(String scheme, String authority, String path, String query, String fragment){...}
}
</pre>
							<p><a href="docs/docs-java/api/java/net/URI.html" target="_blank">URI</a> 表示一个统一资源标识符。 </p>
							<p><a href="docs/docs-java/api/java/net/URL.html" target="_blank">URL</a> 是通用资源定位符。URI 是一种宽泛的含义更广的定义，而 URL 则是 URI 的一个子集。</p>
							<p><a href="docs/docs-java/api/java/net/URI.html" target="_blank">URI</a> 的组成: (Android 的 <code>android.net.Uri</code> 差不多)</p>
							<pre class="brush: java;">
&lt;scheme>://&lt;authority>&lt;path>?&lt;query>#&lt;fragment>

content://nate:123456@com.example.project:8080/folder/subfolder/etc?name=bqt&age=28#android
|------|  |---------||------------------||---||-------------------||--------------|-------|
 scheme       user           host         port         path              query     fragment
          |-----------------------------|
                 authority

/** 完整的 Uri 组成如下： */
&lt;scheme>://&lt;user>:&lt;password>@&lt;host>:&lt;port>/&lt;path>;&lt;params>?&lt;query>#&lt;fragment>
/** 一共由 9 个参数组成，
 * scheme -- 获取资源使用的协议，例如http、ftp等
 * user -- 用户名与密码，这个是一个特殊的存在，一般访问 ftp 时会用到
 * host -- 主机，访问那台主机
 * port -- 端口，访问主机时的端口
 * path -- 路径
 * params -- 这个很少见，主要作用就是向服务器提供额外的参数
 * query -- 查询参数，如通过 get 方式请求的参数
 * fragment -- 片段，比如 HTML 定义锚点
 */

String url = "content://nate:123456@lesson.com:8080/folder/subfolder/etc?name=bqt&age=28#android";

/** android.net.Uri 处理，类似的: java.net.URI */
Uri uri = Uri.parse(url);
uri.getScheme();        // -> content
uri.getUserInfo();      // -> nate:123456
uri.getHost();          // -> lesson.com
uri.getPort();          // -> 8080
uri.getPath();          // -> /folder/subfolder/etc
uri.getQuery();         // -> name=bqt&age=28
uri.getFragment();      // -> android

uri.getSchemeSpecificPart();    // -> nate:123456@lesson.com:8080/folder/subfolder/etc?name=bqt&age=28
uri.getAuthority();             // -> nate:123456@lesson.com:8080

/** java.net.URL 处理也差不多，但是支持的 Scheme 只有： http, https, ftp, file, jar */
</pre>
							<ol>
								<li><p><code>static URI create(String str)</code> -- 通过解析给定的字符串创建 URI</p>
									<pre class="brush: java;">
// content://nate:123456@lesson.com:8080/folder/etc?name=J&age=28&desc=%E5%B8%BD%E5%AD%90#android
String builder = "content" +                        // scheme
		"://" +
		"nate:123456" +                             // userInfo
		"@" +
		"lesson1234.com" +                          // host
		":" +
		"8080" +                                    // port
		"/folder/etc" +                             // path
		"?" +
		"name=J&age=28&desc=%E5%B8%BD%E5%AD%90" +   // query
		"#" +
		"android";                                  // fragment
URI uri = URI.create(builder);
</pre>
								</li>

								<li class="group"><p><code>String 	getScheme()</code> -- 返回此 URI 的 scheme 部分</p></li>
								<li><p><code>String 	getSchemeSpecificPart()</code> -- 如果 scheme 部分有 URLEncoder 编码，decode 后返回</p></li>
								<li><p><code>String 	getRawSchemeSpecificPart()</code> -- 以上值原始值</p></li>

								<li class="group"><p><code>String 	getUserInfo()</code> -- 如果 userInfo 部分有 URLEncoder 编码，decode 后返回</p></li>
								<li><p><code>String 	getRawUserInfo()</code> -- 以上值原始值</p></li>

								<li class="group"><p><code>String 	getHost()</code> -- 返回 host 部分</p></li>
								<li><p><code>int 	getPort()</code> -- 返回 port 部分</p></li>

								<li class="group"><p><code>String 	getAuthority()</code> -- 三部分组合 <code>${userInfo}@${host}:${port}</code> 有 URLEncoder 编码，decode 后返回</p></li>
								<li><p><code>String 	getRawAuthority()</code> -- 以上值原始值</p></li>

								<li class="group"><p><code>String 	getPath()</code> -- 返回 path 部分</p></li>
								<li><p><code>String 	getRawPath()</code> -- 以上值原始值</p></li>

								<li class="group"><p><code>String 	getQuery()</code> -- 返回 query 部分</p></li>
								<li><p><code>String 	getRawQuery()</code> -- 以上值原始值</p></li>

								<li class="group"><p><code>String 	getFragment()</code> -- 返回 fragment 部分</p></li>
								<li><p><code>String 	getRawFragment()</code> -- 以上值原始值</p></li>

								<li class="group"><p><code>boolean 	isAbsolute()</code> -- 判断此 URI 是否为绝对的(<code>scheme != null</code>)</p></li>
								<li><p><code>boolean 	isOpaque()</code> -- 判断此 URI 是否为不透明的(<code>path == null</code>)</p></li>

								<li class="group"><p><code>URL 	toURL()</code> -- 根据此 URI 构造一个 URL</p></li>

								<li class="group"><p><code>URI 	normalize()</code> -- 规范化此 URI 的路径(主要是对 path 部分的处理)</p></li>
								<li><p><code>URI 	parseServerAuthority()</code> -- 尝试将此 URI 的授权组成部分（如果已定义）解析为用户信息、主机和端口组成部分</p></li>
								<li><p><code>URI 	relativize(URI uri)</code> -- 根据此 URI 将给定 URI 相对化</p></li>
								<li><p><code>URI 	resolve(String str)</code> -- 解析给定的字符串，然后在此 URI 的基础上构造一个新的 URI</p></li>
								<li><p><code>URI 	resolve(URI uri)</code> -- 根据此 URI 解析给定的 URI</p></li>

								<li class="group"><p><code>String 	toString()</code> -- 以字符串形式返回此 URI 的内容</p></li>
								<li><p><code>String 	toASCIIString()</code> -- 中文等会被 URLEncode</p></li>
								<li><p><code>int 	compareTo(URI that)</code> -- 将此 URI 与另一个对象（也必须是 URI）进行比较</p></li>
								<li><p><code>boolean 	equals(Object ob)</code> -- 测试此 URI 与另一对象的相等性</p></li>
								<li><p><code>int 	hashCode()</code> -- 返回此 URI 的哈希码值</p></li>
							</ol>
						</div>

						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object
	java.net.URL

public final class URL implements Serializable {
	public URL(String spec) {...}
	public URL(String protocol, String host, int port, String file) {...}
	public URL(String protocol, String host, int port, String file, URLStreamHandler handler) {...}
	public URL(String protocol, String host, String file) {...}
	public URL(URL context, String spec) {...}
	public URL(URL context, String spec, URLStreamHandler handler) {...}
}
</pre>
							<p><a href="docs/docs-java/api/java/net/URL.html" target="_blank">URL</a> 代表一个统一资源定位符，它是指向互联网“资源”的指针。</p>
							<p><a href="docs/docs-java/api/java/net/URLStreamHandler.html" target="_blank">URLStreamHandler</a> 是所有流协议处理程序的通用超类。流协议处理程序知道如何为特定的协议类型进行连接。 </p>
							<p>在大多数情况下，URLStreamHandler 子类的实例都不是由应用程序直接创建的。而是在构造 URL 过程中第一次遇到协议名称时，自动加载适当的流协议处理程序。 </p>
							<p><a href="docs/docs-java/api/java/net/URL.html" target="_blank">URL</a> 支持的 <code>protocol</code> 由 <code>getURLStreamHandler</code> 方法决定(在没有 <code>setURLStreamHandlerFactory</code> 的情况下)</p>
							<pre class="brush: java;">
// URL 内部定义了这样的 Hashtable, 其中 Key 为 protocol
static Hashtable&lt;String,URLStreamHandler> handlers = new Hashtable<>();
// 第一次将会尝试反射加载 "sun.net.www.protocol." + ${protocol} + ".Handler" 类，如果加载到了就存入 handlers

/* URLStreamHandler 类的子类, 就是说 URL 支持: http, https, ftp, file, jar, mailto, netdoc */
sun.net.www.protocol.http.Handler a;
sun.net.www.protocol.https.Handler b;
sun.net.www.protocol.ftp.Handler c;
sun.net.www.protocol.file.Handler d;
sun.net.www.protocol.jar.Handler e;
sun.net.www.protocol.mailto.Handler f;
sun.net.www.protocol.netdoc.Handler g;
</pre>
							<ol>
								<li><p><code>static void setURLStreamHandlerFactory(URLStreamHandlerFactory fac)</code> -- 设置 URLStreamHandlerFactory, 相当于自定义 URL 的处理器。</p></li>

								<li class="group"><p><code>String 	getProtocol()</code> -- 获取此 URL 的协议名称</p></li>
								<li><p><code>String 	getUserInfo()</code> -- 获取此 URL 的 userInfo 部分</p></li>
								<li><p><code>String 	getHost()</code> -- 获取此 URL 的主机名（如果适用）</p></li>
								<li><p><code>int 	getPort()</code> -- 获取此 URL 的端口号</p></li>
								<li><p><code>String 	getAuthority()</code> -- 获取此 URL 的授权部分</p></li>
								<li><p><code>String 	getPath()</code> -- 获取此 URL 的路径部分</p></li>
								<li><p><code>String 	getQuery()</code> -- 获取此 URL 的查询部分</p></li>
								<li><p><code>String 	getFile()</code> -- 为 <code>$path + $file</code></p></li>
								<li><p><code>String 	getRef()</code> -- 获取此 URL 的锚点（也称为“引用”）</p></li>

								<li class="group"><p><code>int 	getDefaultPort()</code> -- 获取默认端口号，由 <code>protocol</code> 对应的 <code>URLStreamHandler</code> 返回</p></li>

								<li class="group"><p><code>URLConnection 	openConnection()</code> -- 返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接，由 <code>protocol</code> 对应的 <code>URLStreamHandler</code> 及子类实现</p></li>
								<li><p><code>URLConnection 	openConnection(Proxy proxy)</code> -- 与 openConnection() 类似，所不同是连接通过指定的代理建立；不支持代理方式的协议处理程序将忽略该代理参数并建立正常的连接，由 <code>URLStreamHandler</code> 及子类实现</p></li>
								<li><p><code>InputStream 	openStream()</code> -- 调用 <code>openConnection().getInputStream()</code></p></li>

								<li class="group"><p><code>Object 	getContent()</code> -- 调用 <code>openConnection().getContent()</code></p></li>
								<li><p><code>Object 	getContent(Class[] classes)</code> -- 调用 <code>openConnection().getContent(Class[])</code></p></li>

								<li class="group"><p><code>boolean 	sameFile(URL other)</code> -- 比较两个 URL，不包括片段部分</p></li>
								<li><p><code>String 	toExternalForm()</code> -- 构造此 URL 的字符串表示形式</p></li>

								<li class="group"><p><code>URI 	toURI()</code> -- 返回与此 URL 等效的 URI</p></li>

								<li class="group"><p><code>String 	toString()</code> -- 构造此 URL 的字符串表示形式</p></li>
								<li><p><code>int 	hashCode()</code> -- 创建一个适合哈希表索引的整数</p></li>
								<li><p><code>boolean 	equals(Object obj)</code> -- 比较此 URL 是否等于另一个对象</p></li>
							</ol>
						</div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-net-URLConnection"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">URLConnection 及子类</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object
	java.net.URLConnection
		java.net.HttpURLConnection
			sun.net.www.protocol.http.HttpURLConnection 		  // http 链接 URL 的 openConnection
			javax.net.ssl.HttpsURLConnection
				sun.net.www.protocol.https.HttpsURLConnectionImpl // https 链接 URL 的 openConnection

public abstract class URLConnection {}

/** 此类定义了 HTTP 状态码 */
public abstract class HttpURLConnection extends URLConnection {
    /** 成功 */
    public static final int HTTP_OK = 200;
    public static final int HTTP_CREATED = 201;
    public static final int HTTP_ACCEPTED = 202;
    public static final int HTTP_NOT_AUTHORITATIVE = 203;
    public static final int HTTP_NO_CONTENT = 204;
    public static final int HTTP_RESET = 205;
    public static final int HTTP_PARTIAL = 206;

    /** 重定向 */
    public static final int HTTP_MULT_CHOICE = 300;
    public static final int HTTP_MOVED_PERM = 301;
    public static final int HTTP_MOVED_TEMP = 302;
    public static final int HTTP_SEE_OTHER = 303;
    public static final int HTTP_NOT_MODIFIED = 304;
    public static final int HTTP_USE_PROXY = 305;

    /** 客户端错误，比如 不存在或未授权 */
    public static final int HTTP_BAD_REQUEST = 400;
    public static final int HTTP_UNAUTHORIZED = 401;
    public static final int HTTP_PAYMENT_REQUIRED = 402;
    public static final int HTTP_FORBIDDEN = 403;
    public static final int HTTP_NOT_FOUND = 404;
    public static final int HTTP_BAD_METHOD = 405;
    public static final int HTTP_NOT_ACCEPTABLE = 406;
    public static final int HTTP_PROXY_AUTH = 407;
    public static final int HTTP_CLIENT_TIMEOUT = 408;
    public static final int HTTP_CONFLICT = 409;
    public static final int HTTP_GONE = 410;
    public static final int HTTP_LENGTH_REQUIRED = 411;
    public static final int HTTP_PRECON_FAILED = 412;
    public static final int HTTP_ENTITY_TOO_LARGE = 413;
    public static final int HTTP_REQ_TOO_LONG = 414;
    public static final int HTTP_UNSUPPORTED_TYPE = 415;

    /** 服务器错误 */
    public static final int HTTP_INTERNAL_ERROR = 500;
    public static final int HTTP_NOT_IMPLEMENTED = 501;
    public static final int HTTP_BAD_GATEWAY = 502;
    public static final int HTTP_UNAVAILABLE = 503;
    public static final int HTTP_GATEWAY_TIMEOUT = 504;
    public static final int HTTP_VERSION = 505;

    static void setFollowRedirects(boolean set) {...}              // 重定向自动跟随, 默认不跟随
    static boolean 	getFollowRedirects() {...}

    void setInstanceFollowRedirects(boolean followRedirects) {...} // 重定向自动跟随, 默认不跟随
    boolean getInstanceFollowRedirects() {...}

    void setRequestMethod(String method) {...}  // 设置请求方法: GET POST HEAD OPTIONS PUT DELETE TRACE
    String 	getRequestMethod() {...}            // 获取请求方法
    int getResponseCode() {...}                 // 获取响应码

    ...
}
</pre>
							<p><a href="docs/docs-java/api/java/net/URLConnection.html" target="_blank">URLConnection</a> 代表应用程序和 URL 之间的通信链接。此类的实例可用于读取和写入此 URL 引用的资源。</p>
							<p><a href="docs/docs-java/api/java/net/HttpURLConnection.html" target="_blank">HttpURLConnection</a> 支持 HTTP 特定功能的 URLConnection。每个 HttpURLConnection 实例都可用于生成单个请求，但是其他实例可以透明地共享连接到 HTTP 服务器的基础网络。</p>
							<ol>
								<li><p><code>static void setDefaultAllowUserInteraction(boolean defaultallowuserinteraction)</code> -- 将未来的所有 URLConnection 对象的 allowUserInteraction 字段的默认值设置为指定的值</p></li>
								<li><p><code>static boolean getDefaultAllowUserInteraction()</code> -- 返回 allowUserInteraction 字段的默认值</p></li>
								<li><p><code>static void setFileNameMap(FileNameMap map)</code> -- 设置 FileNameMap</p></li>
								<li><p><code>static FileNameMap getFileNameMap()</code> -- 从数据文件加载文件名映射</p></li>
								<li><p><code>static void setContentHandlerFactory(ContentHandlerFactory fac)</code> -- 设置应用程序的 ContentHandlerFactory</p></li>
								<li><p><code>static String guessContentTypeFromName(String fname)</code> -- 根据 URL 的指定 "file" 部分尝试确定对象的内容类型</p></li>
								<li><p><code>static String guessContentTypeFromStream(InputStream is)</code> -- 根据输入流的开始字符尝试确定输入流的类型</p></li>

								<li class="group"><p><code>abstract void 	connect()</code> -- 打开到此 URL 引用的资源的通信链接(在 http 里面可以不需要)</p></li>

								<li class="group"><p><code>void 	addRequestProperty(String key, String value)</code> -- 添加由键值对指定的请求头(可有多个同名值)</p></li>
								<li><p><code>Map&lt;String,List&lt;String>> 	getRequestProperties()</code> -- 返回请求头</p></li>
								<li><p><code>void 	setRequestProperty(String key, String value)</code> -- 设置请求头属性值(键存在则修改)</p></li>
								<li><p><code>String 	getRequestProperty(String key)</code> --  返回请求头属性值</p></li>

								<li class="group"><p><code>void 	setConnectTimeout(int timeout)</code> -- 设置连接超时值</p></li>
								<li><p><code>int 	getConnectTimeout()</code> -- 返回连接超时设置</p></li>

								<li class="group"><p><code>void 	setReadTimeout(int timeout)</code> -- 将读超时设置为指定的超时值，以毫秒为单位</p></li>
								<li><p><code>int 	getReadTimeout()</code> -- 返回读入超时设置</p></li>

								<li class="group"><p><code>void 	setIfModifiedSince(long ifmodifiedsince)</code> -- 将 ifModifiedSince 字段的值设置为指定的值</p></li>
								<li><p><code>long 	getIfModifiedSince()</code> -- 返回 ifModifiedSince 字段的值</p></li>

								<li class="group"><p><code>void 	setUseCaches(boolean usecaches)</code> -- 将 useCaches 字段的值设置为指定的值</p></li>
								<li><p><code>boolean 	getUseCaches()</code> -- 返回 useCaches 字段的值</p></li>
								<li><p><code>void 	setDefaultUseCaches(boolean defaultusecaches)</code> -- 将 useCaches 字段的默认值设置为指定的值(区别是这个值是 <code>static</code> 成员)</p></li>
								<li><p><code>boolean 	getDefaultUseCaches()</code> -- 返回 useCaches 标志的默认值</p></li>

								<li class="group"><p><code>void 	setDoInput(boolean doinput)</code> -- 将 doInput 字段的值设置为指定的值, 默认 <code>true</code></p></li>
								<li><p><code>boolean 	getDoInput()</code> -- 返回 doInput 标志的值</p></li>
								<li><p><code>void 	setDoOutput(boolean dooutput)</code> -- 将 doOutput 字段的值设置为指定的值, 默认 <code>false</code></p></li>
								<li><p><code>boolean 	getDoOutput()</code> -- 返回 doOutput 标志的值</p></li>

								<li class="group"><p><code>void 	setAllowUserInteraction(boolean allowuserinteraction)</code> -- 设置 allowUserInteraction 字段的值</p></li>
								<li><p><code>boolean 	getAllowUserInteraction()</code> -- 返回 allowUserInteraction 字段的值</p></li>

								<li class="group"><p><code>Map&lt;String,List&lt;String>> 	getHeaderFields()</code> -- 返回响应头</p></li>
								<li><p><code>String 	getHeaderFieldKey(int n)</code> -- 返回第 n 个头字段的键</p></li>
								<li><p><code>String 	getHeaderField(int n)</code> -- 返回第 n 个头字段的值</p></li>
								<li><p><code>String 	getHeaderField(String name)</code> -- 返回指定的头字段的值</p></li>
								<li><p><code>int 	getHeaderFieldInt(String name, int Default)</code> -- 返回解析为数字的指定字段的值</p></li>
								<li><p><code>long 	getHeaderFieldLong(String name, long Default)</code> -- 返回解析为数字的指定字段的值</p></li>
								<li><p><code>long 	getHeaderFieldDate(String name, long Default)</code> -- 返回解析为日期的指定字段的值</p></li>

								<li class="group"><p><code>long 	getExpiration()</code> -- 返回 expires 头字段的值，调用 <code>getHeaderFieldDate("expires", 0)</code></p></li>
								<li><p><code>long 	getLastModified()</code> -- 返回 last-modified 头字段的值，调用 <code>getHeaderFieldDate("last-modified", 0)</code></p></li>
								<li><p><code>String 	getContentEncoding()</code> -- 返回 content-encoding 头字段的值，调用 <code>getHeaderField("content-encoding")</code></p></li>
								<li><p><code>long 	getContentLengthLong()</code> -- 返回 content-length 头字段的值，调用 <code>getHeaderFieldLong("content-length", -1)</code></p></li>
								<li><p><code>int 	getContentLength()</code> -- 调用<code>getContentLengthLong()</code> 如果超出 <code>if (l > Integer.MAX_VALUE) return -1;</code></p></li>
								<li><p><code>String 	getContentType()</code> -- 返回 content-type 头字段的值，调用 <code>getHeaderField("content-type")</code></p></li>
								<li><p><code>long 	getDate()</code> -- 返回 date 头字段的值，调用 <code>getHeaderFieldDate("date", 0)</code></p></li>

								<li class="group"><p><code>InputStream 	getInputStream()</code> -- 返回响应体的输入流</p></li>
								<li><p><code>OutputStream 	getOutputStream()</code> -- 返回写入到此连接的输出流(比如 Post 请求写数据)</p></li>

								<li class="group"><p><code>Object 	getContent()</code> -- 获取此 URL 连接的内容</p></li>
								<li><p><code>Object 	getContent(Class[] classes)</code> -- 获取此 URL 连接的内容</p></li>

								<li class="group"><p><code>URL 	getURL()</code> -- 返回此 URLConnection 的 URL 字段的值</p></li>
								<li><p><code>Permission 	getPermission()</code> -- 返回一个权限对象，其代表建立此对象表示的连接所需的权限</p></li>
								<li><p><code>String 	toString()</code> -- 返回此 URL 连接的 String 表示形式</p></li>
							</ol>
						</div>

						<div class="sub-item">
							<p><b>一个基于 URLConnection 的工具类</b></p>
							<pre class="brush: java;">
public class HttpClient {
	// https 支持(不验证证书)
    static {
        try {
            TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
                public X509Certificate[] getAcceptedIssuers() {
                    return null;
                }

                public void checkClientTrusted(X509Certificate[] certs, String authType) {
                }

                public void checkServerTrusted(X509Certificate[] certs, String authType) {
                }
            }};

            // Install the all-trusting trust manager
            SSLContext sc = SSLContext.getInstance("TLS");
            sc.init(null, trustAllCerts, new SecureRandom());

            // ip host verify
            HostnameVerifier hv = new HostnameVerifier() {
                public boolean verify(String urlHostName, SSLSession session) {
                    return urlHostName.equals(session.getPeerHost());
                }
            };

            // set ip host verify
            HttpsURLConnection.setDefaultHostnameVerifier(hv);
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    int connectTimeout;
    int readTimeout;
    Map&lt;String, List&lt;String>> headers;
    Map&lt;String, List&lt;String>> params;
    String method;
    String raw;
    HttpURLConnection connection = null;

    private HttpClient(Builder builder) {
        connectTimeout = builder.connectTimeout;
        readTimeout = builder.readTimeout;
        headers = builder.headers;
        method = builder.method;
        params = builder.params;
        raw = builder.raw;
    }

    public void execute(String url, Consumer&lt;Response> response, Consumer&lt;Error> error) {
        PrintWriter out = null;
        try {
            URL mUrl = new URL(url);

            String paramString = null;
            if (params != null && !params.isEmpty()) {
                StringBuffer buffer = new StringBuffer();
                params.forEach((key, values) -> {
                    values.forEach(value -> {
                        buffer.append(key).append("=")
                                .append(URLEncoder.encode(value))
                                .append("&");
                    });
                });
                paramString = buffer.deleteCharAt(buffer.length() - 1).toString();
            }


            if("GET".equalsIgnoreCase(method) && null != paramString) {
                if (mUrl.getQuery() != null) {
                    mUrl = new URL(url + "&" + paramString);
                } else {
                    mUrl = new URL(url + "?" + paramString);
                }
            }

            connection = (HttpURLConnection) mUrl.openConnection();
            connection.setConnectTimeout(connectTimeout);
            connection.setReadTimeout(readTimeout);
            connection.setInstanceFollowRedirects(true); // 重定向自动跟随

            headers.forEach((key, values) -> {
                values.forEach(value -> {
                    connection.addRequestProperty(key, value);
                });
            });

            if ("POST".equalsIgnoreCase(method)) {
                connection.setRequestMethod("POST");
                connection.setDoOutput(true);

                if(null != raw && !raw.isEmpty()) {
                    paramString = raw;
                }
                if(null != paramString) {
                    out = new PrintWriter(connection.getOutputStream());
                    out.print(paramString);
                    out.flush();
                }
            }

            if (HttpURLConnection.HTTP_OK == connection.getResponseCode()) {
                response.accept(new Response(connection, connection.getInputStream()));
            } else {
                error.accept(new Error(connection.getResponseCode(), connection.getResponseMessage()));
            }
        } catch (SSLException e) {
            error.accept(new Error(-1, "SSL 异常！"));
        } catch (UnknownHostException e) {
            error.accept(new Error(-2, "地址不存在或网络异常！"));
        } catch (ConnectException e) {
            error.accept(new Error(-3, "连接异常！"));
        } catch (SocketTimeoutException e) {
            error.accept(new Error(-4, "连接超时！"));
        } catch (IOException e) {
            error.accept(new Error(-5, e.getMessage()));
        } finally {
            if (out != null) {
                out.close();
            }
            if (null != connection) {
                connection.disconnect();
                connection = null;
            }
        }
    }

    public void execute(String url, Consumer&lt;Response> response) {
        execute(url, response, error -> {});
    }

    public static class Error {
        int code = -3;
        String message = "未知错误！";

        public Error() {}
        public Error(int code, String message) {
            this.code = code;
            this.message = message;
        }

        public int getCode() { return code; }
        public String getMessage() { return message; }
    }

    public static class Response {
        HttpURLConnection connection;
        InputStream inputStream;

        Response(HttpURLConnection connection, InputStream in) {
            this.connection = connection;
            inputStream = in;
        }

        public HttpURLConnection connection() { return connection; }

		// 读取为字符串
        public String string() {
            StringBuilder builder = new StringBuilder();
            BufferedReader br = null;
            try {
                br = new BufferedReader(new InputStreamReader(inputStream));
                String tmp;
                while ((tmp = br.readLine()) != null) {
                    builder.append(tmp).append("\n");
                }
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    if (null != br) {
                        br.close();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return builder.toString();
        }

		// 保存文件，可用于下载
        public boolean toFile(String pathname) {
            BufferedInputStream bis = null;
            OutputStream out = null;
            try {
                File file = new File(path);
                bis = new BufferedInputStream(inputStream);
                out = new FileOutputStream(file);
                int size = 0;
                int len = 0;
                byte[] buf = new byte[1024];
                long contentLength = connection.getContentLengthLong();
                while ((size = bis.read(buf)) != -1) {
                    len += size;
                    out.write(buf, 0, size);
                    System.out.println(String.format(Locale.getDefault(),
								"%.2f %%, %s Of %s", 100f * len / contentLength,  len, contentLength));
                }
                return true;
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    if(null != bis) {
                        bis.close();
                    }
                    if(null != out) {
                        out.close();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
            return false;
        }

        public InputStream stream() { return inputStream; }
    }

    public static final class Builder {
        int connectTimeout;
        int readTimeout;
        Map&lt;String, List&lt;String>> headers;
        Map&lt;String, List&lt;String>> params;
        String method;
        String raw;

        public Builder() {
            connectTimeout = 10_000;
            readTimeout = 10_000;
            method = "GET";
            headers = new HashMap<>();
        }

        public Builder connectTimeout(int millis) {
            connectTimeout = millis;
            return this;
        }

        public Builder readTimeout(int millis) {
            readTimeout = millis;
            return this;
        }

        public Builder headers(Map&lt;String, List&lt;String>> headers) {
            this.headers = headers;
            return this;
        }

        public Builder header(String key, String value) {
            if(headers == null) {
                headers = new HashMap<>();
            }
            List&lt;String> values = new ArrayList<>();
            if(headers.containsKey(key)) {
                values = headers.get(key);
            }
            values.add(value);
            headers.put(key, values);
            return this;
        }

        public Builder params(Map&lt;String, List&lt;String>> params) {
            this.params = params;
            return this;
        }

        public Builder param(String key, String value) {
            if(params == null) {
                params = new HashMap<>();
            }
            List&lt;String> values = new ArrayList<>();
            if(params.containsKey(key)) {
                values = params.get(key);
            }
            values.add(value);
            params.put(key, values);
            return this;
        }

        public Builder method(String method) {
            this.method = method;
            return this;
        }

        public Builder raw(String raw) {
            this.method = "POST";
            this.raw = raw;
            return this;
        }

        public HttpClient build() { return new HttpClient(this); }
    }
}
</pre>
						</div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-net-URLEncoder"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">URLEncoder 和 URLDecoder</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">
public class URLEncoder {
	public static String encode(String s, String enc) throws UnsupportedEncodingException {...}
}

public class URLDecoder {
	public static String decode(String s, String enc) throws UnsupportedEncodingException {...}
}
</pre>
						<p><a href="docs/docs-java/api/java/net/URLEncode.html" target="_blank">URLEncode</a> HTML 格式编码的实用工具类。该类包含了将 String 转换为 application/x-www-form-urlencoded MIME 格式的静态方法。</p>
						<p><a href="docs/docs-java/api/java/net/URLDecode.html" target="_blank">URLDecode</a> 该转换过程正好与 URLEncoder 类使用的过程相反。</p>
						<p><b>对 String 编码时，使用以下规则： </b></p>
						<ul>
							<li><p>字母数字字符 <code>[a-zA-Z0-9]</code> 保持不变；</p></li>
							<li><p>特殊字符 <code>"."</code>、<code>"-"</code>、<code>"*"</code> 和 <code>"_"</code> 保持不变；</p></li>
							<li><p>空格字符 <code>" "</code> 转换为一个加号 <code>"+"</code>；</p></li>
							<li><p>其它字符按指定编码将每个字节用一个包含 3 个字符的字符串 <code>"%xy"</code> 表示，其中 <code>xy</code> 为该字节的两位十六进制表示形式。</p></li>
						</ul>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-sql-DriverManager"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">DriverManager</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
	java.sql.DriverManager

public class DriverManager {}
</pre>
						<p><a href="docs/docs-java/api/java/sql/DriverManager.html" target="_blank">DriverManager</a> 是管理一组 JDBC 驱动程序的基本服务。</p>
						<p><a href="docs/docs-java/api/javax/sql/DataSource.html" target="_blank">DataSource</a> 接口是 JDBC 2.0 API 中的新增内容，它提供了连接到数据源的另一种方法。使用 DataSource 对象是连接到数据源的首选方法。 </p>
                        <pre class="brush: java;">
DataSource dataSource = new MysqlDataSource(); // MysqlDataSource 由 Mysql 的驱动提供的
try {
    Connection connection = dataSource.getConnection(user, password);
    connection.setCatalog("test"); // 设置数据库名
    ...
} catch (SQLException e) {
    e.printStackTrace();
}
</pre>
						<p>作为初始化的一部分，DriverManager 类会尝试加载在 "jdbc.drivers" 系统属性中引用的驱动程序类。这允许用户定制由他们的应用程序使用的 JDBC Driver</p>
						<p>riverManager 类的方法 getConnection 和 getDrivers 已经得到提高以支持 Java Standard Edition Service Provider 机制。 JDBC 4.0 Drivers 必须包括 META-INF/services/java.sql.Driver 文件。此文件包含 java.sql.Driver 的 JDBC 驱动程序实现的名称。</p>
						<p>应用程序不再需要使用 Class.forName() 显式地加载 JDBC 驱动程序。当前使用 Class.forName() 加载 JDBC 驱动程序的现有程序将在不作修改的情况下继续工作。 </p>
						<ol>
							<li><p><code>static Connection 	getConnection(String url)</code> -- 试图建立到给定数据库 URL 的连接</p></li>
							<li><p><code>static Connection 	getConnection(String url, Properties info)</code> -- 同上，数据库用户名和密码在 info 参数中</p></li>
							<li><p><code>static Connection 	getConnection(String url, String user, String password)</code> -- 同上，指名数据库用户名和密码</p>
								<pre class="brush: java;">
String url_01 = "jdbc:mysql:///test?user=root&password=ilesson1401&characterEncoding=utf-8";
String url_02 = "jdbc:mysql:///test";
String url_03 = "jdbc:mysql:///test?useUnicode=true&characterEncoding=utf-8";
String user = "root";
String password = "ilesson1401";

Properties info = new Properties();
try {
	/** db.config.properties 文件内容如下
	 # 数据库配置
	 * user=root
	 * password=ilesson1401
	 * useUnicode=true
	 * characterEncoding=utf-8
	 */
	info.load(new FileReader("./java-sdk/db.config.properties"));
} catch (IOException e) {
	e.printStackTrace();
}
Connection connection = DriverManager.getConnection(url_01); // 属性写在 url 中
Connection connection = DriverManager.getConnection(url_02, info); // 所有属性从 Properties 中读取
Connection connection = DriverManager.getConnection(url_03, user, password); // 部分属性从 url 中
</pre>
							</li>

							<li class="group"><p><code>static void 	registerDriver(Driver driver)</code> -- 向 DriverManager 注册给定驱动程序</p></li>
							<li><p><code>static void 	registerDriver(Driver driver, DriverAction da)</code> -- 同上，DriverAction 接口只有一个 <code>deregister()</code> 方法</p></li>
							<li><p><code>static void 	deregisterDriver(Driver driver)</code> -- 从 DriverManager 的列表中删除一个驱动程序</p></li>
							<li><p><code>static Driver 	getDriver(String url)</code> -- 试图查找能理解给定 URL 的驱动程序</p></li>
							<li><p><code>static Enumeration&lt;Driver> 	getDrivers()</code> -- 获取带有当前调用者可以访问的所有当前已加载 JDBC 驱动程序的</p></li>

							<li class="group"><p><code>static int 	getLoginTimeout()</code> -- 获取驱动程序试图登录到某一数据库时可以等待的最长时间(默认为 0, 不限时)，秒为单位</p></li>
							<li><p><code>static void 	setLoginTimeout(int seconds)</code> -- 设置超时时间</p></li>

							<li class="group"><p><code>static PrintWriter 	getLogWriter()</code> -- 获取日志 writer</p></li>
							<li><p><code>static void 	setLogWriter(PrintWriter out)</code> -- 设置所有驱动程序使用的日志/追踪 PrintWriter 对象</p></li>
							<li><p><code>static void 	println(String message)</code> --  将一条消息打印到当前 JDBC 日志流中</p></li>
						</ol>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-sql-Connection"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Connection</h3>
					</div>
					<div class="panel-body">
                        <pre class="brush: java;">
...
    java.sql.Connection

public interface Connection extends Wrapper, AutoCloseable {
    int TRANSACTION_NONE = 0; // 指示事务不受支持的常量
    int TRANSACTION_READ_COMMITTED = 1; // 指示不可以发生脏读的常量；不可重复读和虚读可以发生
    int TRANSACTION_READ_UNCOMMITTED = 2; // 指示可以发生脏读、不可重复读和虚读的常量
    int TRANSACTION_REPEATABLE_READ = 4; // 指示不可以发生脏读和不可重复读的常量；虚读可以发生
    int TRANSACTION_SERIALIZABLE = 8; // 指示不可以发生脏读、不可重复读和虚读的常量
}
</pre>
                        <p><a href="docs/docs-java/api/java/sql/Connection.html" target="_blank">Connection</a> 是与特定数据库的连接（会话）。在连接上下文中执行 SQL 语句并返回结果。 </p>
                        <p>Connection 对象的数据库能够提供描述其表、所支持的 SQL 语法、存储过程、此连接功能等等的信息。此信息是使用 getMetaData 方法获得的。</p>
                        <p><b>注意</b>：在配置 Connection 时，JDBC 应用程序应该使用适当的 Connection 方法，比如 setAutoCommit 或 setTransactionIsolation。在有可用的 JDBC 方法时，应用程序不能直接调用 SQL 命令更改连接的配置。默认情况下，Connection 对象处于自动提交模式下，这意味着它在执行每个语句后都会自动提交更改。如果禁用了自动提交模式，那么要提交更改就必须显式调用 commit 方法；否则无法保存数据库更改。 </p>
                        <ol>
                            <li><p><code>void 	abort(Executor executor)</code> -- 终止打开的连接，允许不立即关闭，在 <code>execute(Runable)</code> 方法中自己选择是否执行</p></li>
                            <li><p><code>void 	clearWarnings()</code> -- 清除为此 Connection 对象报告的所有警告</p></li>
                            <li><p><code>SQLWarning 	getWarnings()</code> -- 获取此 Connection 对象上的调用报告的第一个警告</p></li>
                            <li><p><code>boolean 	isClosed()</code> -- 查询此 Connection 对象是否已经被关闭</p></li>
                            <li><p><code>void 	close()</code> -- 立即释放此 Connection 对象的数据库和 JDBC 资源，而不是等待它们被自动释放</p></li>
                            <li><p><code>boolean 	isValid(int timeout)</code> -- 如果连接尚未关闭并且仍然有效，则返回 true</p></li>

                            <li><p><code>String 	nativeSQL(String sql)</code> -- 将给定的 SQL 语句转换成系统本机 SQL 语法</p></li>
                            <li><p><code><a href="#java-sql-DatabaseMetaData">DatabaseMetaData</a> 	getMetaData()</code> -- 获取一个 DatabaseMetaData 对象，该对象包含关于此 Connection 对象所连接的数据库的元数据</p></li>

                            <li class="group"><p><code>boolean 	isReadOnly()</code> -- 查询此 Connection 对象是否处于只读模式</p></li>
                            <li><p><code>void 	setReadOnly(boolean readOnly)</code> -- 将此连接设置为只读模式，作为驱动程序启用数据库优化的提示</p></li>
                            <li><p><code>int 	getNetworkTimeout()</code> -- 检索驱动程序等待数据库请求完成的毫秒数</p></li>
                            <li><p><code>void 	setNetworkTimeout(Executor executor, int milliseconds)</code> -- 设置最大时期连接或物体从连接创建将等待数据库回答任何一个请求</p></li>
                            <li><p><code>boolean 	getAutoCommit()</code> -- 获取此 Connection 对象的当前自动提交模式</p></li>
                            <li><p><code>void 	setAutoCommit(boolean autoCommit)</code> -- 将此连接的自动提交模式设置为给定状态</p></li>
                            <li><p><code>String 	getCatalog()</code> -- 数据库名称，获取此 Connection 对象的当前目录名称</p></li>
                            <li><p><code>void 	setCatalog(String catalog)</code> -- 设置给定目录名称，以便选择要在其中进行工作的此 Connection 对象数据库的子空间</p></li>
                            <li><p><code>String 	getSchema()</code> -- 获取 Schema</p></li>
                            <li><p><code>void 	setSchema(String schema)</code> -- 设置 Schema</p></li>
                            <li><p><code>int 	getHoldability()</code> -- 获取使用此 Connection 对象创建的 ResultSet 对象的当前可保存性</p></li>
                            <li><p><code>void 	setHoldability(int holdability)</code> -- 将使用此 Connection 对象创建的 ResultSet 对象的默认可保存性 (holdability) 更改为给定可保存性</p></li>
                            <li><p><code>Properties 	getClientInfo()</code> -- 返回一个列表，它包含驱动程序支持的每个客户端信息属性的名称和当前值</p></li>
                            <li><p><code>void 	setClientInfo(Properties properties)</code> -- 设置连接的客户端信息属性的值</p></li>
                            <li><p><code>String 	getClientInfo(String name)</code> -- 返回通过名称指定的客户端信息属性的值</p></li>
                            <li><p><code>void 	setClientInfo(String name, String value)</code> -- 将 name 指定的客户端信息属性的值设置为 value 指定的值</p></li>
                            <li><p><code>Map&lt;String,Class&lt;?>> 	getTypeMap()</code> -- 获取与此 Connection 对象关联的 Map 对象</p></li>
                            <li><p><code>void 	setTypeMap(Map&lt;String,Class&lt;?>> map)</code> -- 将给定的 TypeMap 对象安装为此 Connection 对象的类型映射</p></li>

                            <li class="group"><p><code>Array 	createArrayOf(String typeName, Object[] elements)</code> -- 创建 Array 对象的工厂方法</p></li>
                            <li><p><code>Blob 	createBlob()</code> -- 构造实现 Blob 接口的对象</p></li>
                            <li><p><code>Clob 	createClob()</code> -- 构造实现 Clob 接口的对象</p></li>
                            <li><p><code>NClob 	createNClob()</code> -- 构造实现 NClob 接口的对象</p></li>
                            <li><p><code>SQLXML 	createSQLXML()</code> -- 构造实现 SQLXML 接口的对象</p></li>
                            <li><p><code>Struct 	createStruct(String typeName, Object[] attributes)</code> -- </p></li>

                            <li class="group"><p><code>Statement 	createStatement()</code> -- 创建一个 Statement 对象来将 SQL 语句发送到数据库</p></li>
                            <li><p><code>Statement 	createStatement(int resultSetType, int resultSetConcurrency)</code> -- 创建一个 Statement 对象，该对象将生成具有给定类型和并发性的 ResultSet 对象</p></li>
                            <li><p><code>Statement 	createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)</code> -- 创建一个 Statement 对象，该对象将生成具有给定类型、并发性和可保存性的 ResultSet 对象</p></li>

                            <li class="group"><p><code>PreparedStatement 	prepareStatement(String sql)</code> -- 创建一个 PreparedStatement 对象来将参数化的 SQL 语句发送到数据库</p></li>
                            <li><p><code>PreparedStatement 	prepareStatement(String sql, int autoGeneratedKeys)</code> -- 创建一个默认 PreparedStatement 对象，该对象能获取自动生成的键</p></li>
                            <li><p><code>PreparedStatement 	prepareStatement(String sql, int[] columnIndexes)</code> -- 创建一个能返回由给定数组指定的自动生成键的默认 PreparedStatement 对象</p></li>
                            <li><p><code>PreparedStatement 	prepareStatement(String sql, int resultSetType, int resultSetConcurrency)</code> -- 创建一个 PreparedStatement 对象，该对象将生成具有给定类型和并发性的 ResultSet 对象</p></li>
                            <li><p><code>PreparedStatement 	prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability)</code> -- 创建一个 PreparedStatement 对象，该对象将生成具有给定类型、并发性和可保存性的 ResultSet 对象</p></li>
                            <li><p><code>PreparedStatement 	prepareStatement(String sql, String[] columnNames)</code> -- 创建一个能返回由给定数组指定的自动生成键的默认 PreparedStatement 对象</p></li>

                            <li class="group"><p><code>CallableStatement 	prepareCall(String sql)</code> -- 创建一个 CallableStatement 对象来调用数据库存储过程</p></li>
                            <li><p><code>CallableStatement 	prepareCall(String sql, int resultSetType, int resultSetConcurrency)</code> -- 创建一个 CallableStatement 对象，该对象将生成具有给定类型和并发性的 ResultSet 对象</p></li>
                            <li><p><code>CallableStatement 	prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability)</code> -- 创建一个 CallableStatement 对象，该对象将生成具有给定类型和并发性的 ResultSet 对象</p></li>

                            <li class="group"><p><code>Savepoint 	setSavepoint()</code> -- 在当前事务中创建一个未命名的保存点 (savepoint)，并返回表示它的新 Savepoint 对象</p></li>
                            <li><p><code>Savepoint 	setSavepoint(String name)</code> -- 在当前事务中创建一个具有给定名称的保存点，返回表示它的新 Savepoint 对象</p></li>
                            <li><p><code>void 	releaseSavepoint(Savepoint savepoint)</code> -- 从当前事务中移除指定的 Savepoint 和后续 Savepoint 对象</p></li>
                            <li><p><code>void 	rollback()</code> -- 取消在当前事务中进行的所有更改，并释放此 Connection 对象当前持有的所有数据库锁</p></li>
                            <li><p><code>void 	rollback(Savepoint savepoint)</code> -- 取消所有设置给定 Savepoint 对象之后进行的更改</p></li>
                            <li><p><code>void 	commit()</code> -- 使所有上一次提交/回滚后进行的更改成为持久更改，并释放此 Connection 对象当前持有的所有数据库锁</p></li>
                            <li><p><code>int 	getTransactionIsolation()</code> -- 获取此 Connection 对象的当前事务隔离级别</p></li>
                            <li><p><code>void 	setTransactionIsolation(int level)</code> -- 试图将此 Connection 对象的事务隔离级别更改为给定的级别</p></li>
                        </ol>
                    </div>
                </div>

                <!-- item start -->
                <a id="java-sql-DatabaseMetaData" class="offset"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">DatabaseMetaData</h3>
                    </div>
                    <div class="panel-body">
                        <pre class="brush: java;">
...
    java.sql.DatabaseMetaData

public interface DatabaseMetaData extends Wrapper {
    short attributeNoNulls = 0; // 指示可能不允许使用 NULL 值
    short attributeNullable = 1; // 指示明确允许使用 NULL 值
    short attributeNullableUnknown = 2; // 指示不知道是否允许使用 NULL 值

    int bestRowUnknown = 0; // 指示最佳行标识符可能是伪列 (pseudo column)，也可能不是
    int bestRowNotPseudo = 1; // 指示最佳行标识符“不”是伪列
    int bestRowPseudo = 2; // 指示最佳行标识符是伪列

    int bestRowTemporary = 0; // 指示最佳行标识符的作用域是临时的，仅在使用该行时可用
    int bestRowTransaction = 1; // 指示最佳行标识符的作用域是当前事务的剩余部分
    int bestRowSession = 2; // 指示最佳行标识符的作用域是当前会话的剩余部分

    int columnNoNulls = 0; // 指示列中可能不允许使用 NULL 值
    int columnNullable = 1; // 指示列中明确允许使用 NULL 值
    int columnNullableUnknown = 2; // 指示不知道列是否可为 null

    int functionColumnUnknown = 0; // 指示该类型的参数或列未知
    int functionColumnIn = 1; // 指示参数或列是一个 IN 参数
    int functionColumnInOut = 2; // 指示参数或列是一个 INOUT 参数
    int functionColumnOut = 3; // 指示参数或列是一个 OUT 参数
    int functionReturn = 4; // 指示参数或列是一个返回值
    int functionColumnResult = 5; // 指示参数或列是结果集中的一列

    int functionNoNulls = 0; // 指示不允许 NULL 值
    int functionNullable = 1; // 指示允许 NULL 值
    int functionNullableUnknown = 2; // 指示是否允许 NULL 值是未知的

    int functionResultUnknown = 0; // 指示不知道函数是返回一个结果还是一个表
    int functionNoTable = 1; // 指示函数不返回一个表
    int functionReturnsTable = 2; // 指示函数返回一个表

    int importedKeyCascade = 0; // 对于 UPDATE_RULE 列，指示在更新主键时，外键（导入的键）的更改要与之一致
    int importedKeyRestrict = 1; // 对于 UPDATE_RULE 列，指示如果主键已被另一个表作为外键导入，则可能不更新该主键
    int importedKeySetNull = 2; // 对于 UPDATE_RULE 和 DELETE_RULE 列，指示在更新或删除主键时，将外键（导入的键）更改为 NULL
    int importedKeyNoAction = 3; // 对于 UPDATE_RULE 和 DELETE_RULE 列，指示如果主键已导入，则无法更新或删除它
    int importedKeySetDefault = 4; // 对于 UPDATE_RULE 和 DELETE_RULE 列，指示如果更新或删除了主键，则将外键（导入的键）设置为默认值
    int importedKeyInitiallyDeferred = 5; // 指示可延迟性
    int importedKeyInitiallyImmediate = 6; // 指示可延迟性
    int importedKeyNotDeferrable = 7; // 指示可延迟性

    int procedureColumnUnknown = 0; //  指示列的类型为未知
    int procedureColumnIn = 1; // 指示列中存储了 IN 参数
    int procedureColumnInOut = 2; // 指示列中存储了 INOUT 参数
    int procedureColumnResult = 3; // 指示列中存储了结果
    int procedureColumnOut = 4; // 指示列中存储了 OUT 参数
    int procedureColumnReturn = 5; // 指示列中存储了返回值

    int procedureNoNulls = 0; // 指示不允许使用 NULL 值
    int procedureNullable = 1; // 指示允许使用 NULL 值
    int procedureNullableUnknown = 2; //  指示不知道是否允许使用 NULL 值

    int procedureResultUnknown = 0; // 指示不知道过程是否返回结果
    int procedureNoResult = 1; // 指示过程不返回结果
    int procedureReturnsResult = 2; // 指示过程返回结果

    int sqlStateXOpen = 1; // 用于指示 SQLException.getSQLState 返回的值是否是一个 X/Open（现在称为 Open Group）SQL CLI SQLSTATE 值
    int sqlStateSQL = 2; // 用于指示 SQLException.getSQLState 方法返回的值是否是一个 SQLSTATE 值
    int sqlStateSQL99 = sqlStateSQL; // 用于指示 SQLException.getSQLState 方法返回的值是否是一个 SQL99 SQLSTATE 值

    short tableIndexStatistic = 0; // 指示此列包含与表的索引描述一起返回的表统计信息
    short tableIndexClustered = 1; // 指示此表索引是一个集群索引 (clustered index)
    short tableIndexHashed = 2; // 指示此表索引是一个散列索引
    short tableIndexOther = 3; // 指示此表索引不是集群索引、散列索引或表统计信息，它是其他某种东西

    int typeNoNulls = 0; // 指示“不”允许对这种数据类型使用 NULL 值
    int typeNullable = 1; // 指示允许对这种数据类型使用 NULL 值
    int typeNullableUnknown = 2; // 指示不知道是否允许对这种数据类型使用 NULL 值

    int typePredNone = 0; // 指示不支持将 WHERE 搜索子句用于这种类型
    int typePredChar = 1; // 指示该数据类型只能用于使用 LIKE 谓词的 WHERE 搜索子句中
    int typePredBasic = 2; // 指示该数据类型只能用于不使用 LIKE 谓词的 WHERE 搜索子句中
    int typeSearchable = 3; // 指示在此类型上可以建立所有 WHERE 搜索子句

    int versionColumnUnknown = 0; // 指示这种版本的列可能是伪列，也可能不是
    int versionColumnNotPseudo = 1; // 指示这种版本的列“不”是伪列
    int versionColumnPseudo = 2; // 指示这种版本的列是伪列
}
</pre>

                        <ol>
                            <li><p><code>int 	getMaxBinaryLiteralLength()</code> -- 获取此数据库允许在内嵌二进制字面值中使用的最大十六进制字符数</p></li>
                            <li><p><code>int 	getMaxCatalogNameLength()</code> -- 获取此数据库允许用于类别名称的最大字符数</p></li>
                            <li><p><code>int 	getMaxCharLiteralLength()</code> -- 获取此数据库允许用于字符字面值的最大字符数</p></li>

                            <li class="group"><p><code>int 	getMaxColumnNameLength()</code> -- 获取此数据库允许用于列名称的最大字符数</p></li>
                            <li><p><code>int 	getMaxColumnsInGroupBy()</code> -- 获取此数据库允许在 GROUP BY 子句中使用的最大列数</p></li>
                            <li><p><code>int 	getMaxColumnsInIndex()</code> -- 获取此数据库允许在索引中使用的最大列数</p></li>
                            <li><p><code>int 	getMaxColumnsInOrderBy()</code> -- 获取此数据库允许在 ORDER BY 子句中使用的最大列数</p></li>
                            <li><p><code>int 	getMaxColumnsInSelect()</code> -- 获取此数据库允许在 SELECT 列表中使用的最大列数</p></li>
                            <li><p><code>int 	getMaxColumnsInTable()</code> -- 获取此数据库允许在表中使用的最大列数</p></li>

                            <li class="group"><p><code>int 	getMaxConnections()</code> -- 获取连接到此数据库的并发连接的可能最大数</p></li>
                            <li><p><code>int 	getMaxCursorNameLength()</code> -- 获取此数据库允许用于游标名称的最大字符数</p></li>
                            <li><p><code>int 	getMaxIndexLength()</code> -- 获取此数据库允许用于索引（包括索引的所有部分）的最大字节数</p></li>
                            <li><p><code>default long 	getMaxLogicalLobSize()</code> -- </p></li>
                            <li><p><code>int 	getMaxProcedureNameLength()</code> -- 获取此数据库允许用于过程名称的最大字符数</p></li>
                            <li><p><code>int 	getMaxRowSize()</code> -- 获取此数据库允许在单行中使用的最大字节数</p></li>
                            <li><p><code>int 	getMaxSchemaNameLength()</code> -- 获取此数据库允许在模式名称中使用的最大字符数</p></li>
                            <li><p><code>int 	getMaxStatementLength()</code> -- 获取此数据库允许在 SQL 语句中使用的最大字符数</p></li>
                            <li><p><code>int 	getMaxStatements()</code> -- 获取在此数据库中在同一时间内可处于开放状态的最大活动语句数</p></li>
                            <li><p><code>int 	getMaxTableNameLength()</code> -- 获取此数据库允许在表名称中使用的最大字符数</p></li>
                            <li><p><code>int 	getMaxTablesInSelect()</code> -- 获取此数据库允许在 SELECT 语句中使用的表的最大数量</p></li>
                            <li><p><code>int 	getMaxUserNameLength()</code> -- 获取此数据库允许在用户名称中使用的最大字符数</p></li>

                            <li class="group"><p><code>String 	getURL()</code> -- 获取此 DBMS 的 URL</p></li>
                            <li><p><code>String 	getUserName()</code> -- 获取此数据库的已知的用户名称</p></li>
                            <li><p><code>boolean 	isReadOnly()</code> -- 获取此数据库是否处于只读模式</p></li>

                            <li class="group"><p><code>int 	getDatabaseMajorVersion()</code> -- 获取底层数据库的主版本号</p></li>
                            <li><p><code>int 	getDatabaseMinorVersion()</code> -- 底层数据库的次版本号</p></li>
                            <li><p><code>String 	getDatabaseProductName()</code> -- 获取此数据库产品的名称</p></li>
                            <li><p><code>String 	getDatabaseProductVersion()</code> -- 获取此数据库产品的版本号</p></li>

                            <li class="group"><p><code>int 	getDriverMajorVersion()</code> -- 获取此 JDBC 驱动程序的主版本号</p></li>
                            <li><p><code>int 	getDriverMinorVersion()</code> -- 获取此 JDBC 驱动程序的次版本号</p></li>
                            <li><p><code>String 	getDriverName()</code> -- 获取此 JDBC 驱动程序的名称</p></li>
                            <li><p><code>String 	getDriverVersion()</code> -- 获取此 JDBC 驱动程序的 String 形式的版本号</p></li>

                            <li class="group"><p><code>int 	getJDBCMajorVersion()</code> -- 获取此驱动程序的主 JDBC 版本号</p></li>
                            <li><p><code>int 	getJDBCMinorVersion()</code> -- 获取此驱动程序的次 JDBC 版本号</p></li>

                            <li class="group"><p><code>boolean 	nullPlusNonNullIsNull()</code> -- 获取此数据库是否支持 NULL 值与等于 NULL 的非 NULL 值之间的连接</p></li>
                            <li><p><code>boolean 	nullsAreSortedAtEnd()</code> -- 获取 NULL 值是否始终排在末尾，不管排序顺序如何</p></li>
                            <li><p><code>boolean 	nullsAreSortedAtStart()</code> -- 获取 NULL 值是否始终排在开头，不管排序顺序如何</p></li>
                            <li><p><code>boolean 	nullsAreSortedHigh()</code> -- 获取 NULL 值是否被高排序</p></li>
                            <li><p><code>boolean 	nullsAreSortedLow()</code> -- 获取 NULL 值是否被低排序</p></li>

                            <li class="group"><p><code>boolean 	othersDeletesAreVisible(int type)</code> -- 获取由其他结果集类型进行的删除是否可见，参数为: <code>ResultSet.TYPE_FORWARD_ONLY</code>, <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code></p></li>
                            <li><p><code>boolean 	othersInsertsAreVisible(int type)</code> -- 获取由其他结果集类型进行的插入是否可见</p></li>
                            <li><p><code>boolean 	othersUpdatesAreVisible(int type)</code> -- 获取由其他结果集类型进行的更新是否可见</p></li>

                            <li class="group"><p><code>boolean 	ownDeletesAreVisible(int type)</code> -- 获取结果集自身的删除是否可见</p></li>
                            <li><p><code>boolean 	ownInsertsAreVisible(int type)</code> -- 获取结果集自身的插入是否可见</p></li>
                            <li><p><code>boolean 	ownUpdatesAreVisible(int type)</code> -- 获取对于给定类型的 ResultSet 对象，结果集自身的更新是否可见</p></li>

                            <li class="group"><p><code>boolean 	storesLowerCaseIdentifiers()</code> -- 获取此数据库是否将大小写混写的不带引号的 SQL 标识符作为不区分大小写的形式处理，并以小写形式存储它们</p></li>
                            <li><p><code>boolean 	storesLowerCaseQuotedIdentifiers()</code> -- 获取此数据库是否将大小写混写的带引号的 SQL 标识符作为不区分大小写的形式处理，并以小写形式存储它们</p></li>
                            <li><p><code>boolean 	storesMixedCaseIdentifiers()</code> -- 获取此数据库是否将大小写混写的不带引号的 SQL 标识符作为不区分大小写的形式处理，并以大小写混合形式存储它们</p></li>
                            <li><p><code>boolean 	storesMixedCaseQuotedIdentifiers()</code> -- 获取此数据库是否将大小写混写的带引号的 SQL 标识符作为不区分大小写的形式处理，并以大小写混合形式存储它们</p></li>
                            <li><p><code>boolean 	storesUpperCaseIdentifiers()</code> -- 获取此数据库是否将大小写混写的不带引号的 SQL 标识符作为不区分大小写的形式处理，并以大写形式存储它们</p></li>
                            <li><p><code>boolean 	storesUpperCaseQuotedIdentifiers()</code> -- 获取此数据库是否将大小写混写的带引号的 SQL 标识符作为不区分大小写的形式处理，并以大写形式存储它们</p></li>

                            <li class="group"><p><code>boolean 	supportsAlterTableWithAddColumn()</code> -- 获取此数据库是否支持带有 add 列的 ALTER TABLE</p></li>
                            <li><p><code>boolean 	supportsAlterTableWithDropColumn()</code> -- 获取此数据库是否支持带有 drop 列的 ALTER TABLE</p></li>
                            <li><p><code>boolean 	supportsANSI92EntryLevelSQL()</code> -- 获取此数据库是否支持 ANSI92 入门级 SQL 语法</p></li>
                            <li><p><code>boolean 	supportsANSI92FullSQL()</code> -- 获取此数据库是否支持受支持的 ANSI92 完全 SQL 语法</p></li>
                            <li><p><code>boolean 	supportsANSI92IntermediateSQL()</code> -- 获取此数据库是否支持受支持的 ANSI92 中间 SQL 语法</p></li>
                            <li><p><code>boolean 	supportsBatchUpdates()</code> -- 获取此数据库是否支持批量更新</p></li>
                            <li><p><code>boolean 	supportsCatalogsInDataManipulation()</code> -- 获取某个类别名称是否可以在数据操作语句中使用</p></li>
                            <li><p><code>boolean 	supportsCatalogsInIndexDefinitions()</code> -- 获取某个类别名称是否可以在获取定义语句中使用</p></li>
                            <li><p><code>boolean 	supportsCatalogsInPrivilegeDefinitions()</code> -- 获取某个类别名称是否可以在特权定义语句中使用</p></li>
                            <li><p><code>boolean 	supportsCatalogsInProcedureCalls()</code> -- 获取某个类别名称是否可以在过程调用语句中使用</p></li>
                            <li><p><code>boolean 	supportsCatalogsInTableDefinitions()</code> -- 获取某个类别名称是否可以在表定义语句中使用</p></li>
                            <li><p><code>boolean 	supportsColumnAliasing()</code> -- 获取此数据库是否支持为列提供别名</p></li>
                            <li><p><code>boolean 	supportsConvert()</code> -- 获取此数据库是否支持用于 JDBC 类型之间转换的 JDBC 标量函数 CONVERT</p></li>
                            <li><p><code>boolean 	supportsConvert(int fromType, int toType)</code> -- 获取此数据库是否支持用于 JDBC fromType 和 toType 类型之间转换的 JDBC 标量函数 CONVERT</p></li>
                            <li><p><code>boolean 	supportsCoreSQLGrammar()</code> -- 获取此数据库是否支持 ODBC Core SQL 语法</p></li>
                            <li><p><code>boolean 	supportsCorrelatedSubqueries()</code> -- 获取此数据库是否支持相关子查询</p></li>
                            <li><p><code>boolean 	supportsDataDefinitionAndDataManipulationTransactions()</code> -- 获取此数据库是否同时支持事务中的数据定义和数据操作语句</p></li>
                            <li><p><code>boolean 	supportsDataManipulationTransactionsOnly()</code> -- 获取此数据库是否仅支持事务中的数据操作语句</p></li>
                            <li><p><code>boolean 	supportsDifferentTableCorrelationNames()</code> -- 获取在表关联名称受支持时，是否要限制它们与表的名称不同</p></li>
                            <li><p><code>boolean 	supportsExpressionsInOrderBy()</code> -- 获取此数据库是否支持 ORDER BY 列表中的表达式</p></li>
                            <li><p><code>boolean 	supportsExtendedSQLGrammar()</code> -- 获取此数据库是否支持 ODBC Extended SQL 语法</p></li>
                            <li><p><code>boolean 	supportsFullOuterJoins()</code> -- 获取此数据库是否支持完全嵌套的外连接</p></li>
                            <li><p><code>boolean 	supportsGetGeneratedKeys()</code> -- 获取是否可以在执行语句后获取自动生成的键</p></li>
                            <li><p><code>boolean 	supportsGroupBy()</code> -- 获取此数据库是否支持某种形式的 GROUP BY 子句</p></li>
                            <li><p><code>boolean 	supportsGroupByBeyondSelect()</code> -- 获取此数据库是否支持使用不包含在 SELECT 语句中而包含在 GROUP BY 子句中的列，假设 SELECT 语句中的所有列都包含在 GROUP BY 子句中</p></li>
                            <li><p><code>boolean 	supportsGroupByUnrelated()</code> -- 获取此数据库是否支持使用不在 SELECT 语句中而在 GROUP BY 子句中的列</p></li>
                            <li><p><code>boolean 	supportsIntegrityEnhancementFacility()</code> -- 获取此数据库是否支持 SQL Integrity Enhancement Facility</p></li>
                            <li><p><code>boolean 	supportsLikeEscapeClause()</code> -- 获取此数据库是否支持指定 LIKE 转义子句</p></li>
                            <li><p><code>boolean 	supportsLimitedOuterJoins()</code> -- 获取此数据库是否为外连接提供受限制的支持</p></li>
                            <li><p><code>boolean 	supportsMinimumSQLGrammar()</code> -- 获取此数据库是否支持 ODBC Minimum SQL 语法</p></li>
                            <li><p><code>boolean 	supportsMixedCaseIdentifiers()</code> -- 获取此数据库是否将大小写混写的不带引号的 SQL 标识符作为区分大小写的形式处理，并且最后以大小写混合形式存储它们</p></li>
                            <li><p><code>boolean 	supportsMixedCaseQuotedIdentifiers()</code> -- 获取此数据库是否将大小写混写的带引号的 SQL 标识符作为区分大小写的形式处理，并且最后以大小写混合形式存储它们</p></li>
                            <li><p><code>boolean 	supportsMultipleOpenResults()</code> -- 获取是否可以同时拥有从 CallableStatement 对象中返回的多个 ResultSet 对象</p></li>
                            <li><p><code>boolean 	supportsMultipleResultSets()</code> -- 获取此数据库是否支持一次调用 execute 方法获得多个 ResultSet 对象</p></li>
                            <li><p><code>boolean 	supportsMultipleTransactions()</code> -- 获取此数据库是否允许一次打开多个事务</p></li>
                            <li><p><code>boolean 	supportsNamedParameters()</code> -- 获取此数据库是否支持可调用语句的指定参数</p></li>
                            <li><p><code>boolean 	supportsNonNullableColumns()</code> -- 获取是否可以将此数据库中的列定义为非 null</p></li>
                            <li><p><code>boolean 	supportsOpenCursorsAcrossCommit()</code> -- 获取此数据库是否支持在进行提交期间保持游标开放</p></li>
                            <li><p><code>boolean 	supportsOpenCursorsAcrossRollback()</code> -- 获取此数据库是否支持在回滚期间保持游标开放</p></li>
                            <li><p><code>boolean 	supportsOpenStatementsAcrossCommit()</code> -- 获取此数据库是否支持在进行提交期间保持语句开放</p></li>
                            <li><p><code>boolean 	supportsOpenStatementsAcrossRollback()</code> -- 获取此数据库是否支持在回滚期间保持语句开放</p></li>
                            <li><p><code>boolean 	supportsOrderByUnrelated()</code> -- 获取此数据库是否支持使用不在 SELECT 语句中而在 ORDER BY 子句中的列</p></li>
                            <li><p><code>boolean 	supportsOuterJoins()</code> -- 获取此数据库是否支持某种形式的外连接</p></li>
                            <li><p><code>boolean 	supportsPositionedDelete()</code> -- 获取此数据库是否支持位置的 DELETE 语句</p></li>
                            <li><p><code>boolean 	supportsPositionedUpdate()</code> -- 获取此数据库是否支持位置的 UPDATE 语句</p></li>
                            <li><p><code>default boolean 	supportsRefCursors()</code> -- </p></li>
                            <li><p><code>boolean 	supportsResultSetConcurrency(int type, int concurrency)</code> -- 获取此数据库是否支持与给定结果集类型结合在一起的给定并发性类型</p></li>
                            <li><p><code>boolean 	supportsResultSetHoldability(int holdability)</code> -- 获取此数据库是否支持给定结果集可保存性</p></li>
                            <li><p><code>boolean 	supportsResultSetType(int type)</code> -- 获取此数据库是否支持给定结果集类型</p></li>
                            <li><p><code>boolean 	supportsSavepoints()</code> -- 获取此数据库是否支持保存点 (savepoint)</p></li>
                            <li><p><code>boolean 	supportsSchemasInDataManipulation()</code> -- 获取某个模式名称是否可以数据操作语句中使用</p></li>
                            <li><p><code>boolean 	supportsSchemasInIndexDefinitions()</code> -- 获取某个模式名称是否可以在获取定义语句中使用</p></li>
                            <li><p><code>boolean 	supportsSchemasInPrivilegeDefinitions()</code> -- 获取某个模式名称是否可以在特权定义语句中使用</p></li>
                            <li><p><code>boolean 	supportsSchemasInProcedureCalls()</code> -- 获取某个模式名称是否可以在过程调用语句中使用</p></li>
                            <li><p><code>boolean 	supportsSchemasInTableDefinitions()</code> -- 获取某个模式名称是否可以在表定义语句中使用</p></li>
                            <li><p><code>boolean 	supportsSelectForUpdate()</code> -- 获取此数据库是否支持位置的 SELECT FOR UPDATE 语句</p></li>
                            <li><p><code>boolean 	supportsStatementPooling()</code> -- 获取此数据库是否支持语句合并 </p></li>
                            <li><p><code>boolean 	supportsStoredFunctionsUsingCallSyntax()</code> -- 获取此数据库是否支持使用存储过程转义语法调用用户定义的函数或供应商函数</p></li>
                            <li><p><code>boolean 	supportsStoredProcedures()</code> -- 获取此数据库是否支持使用存储过程转义语法的存储过程调用</p></li>
                            <li><p><code>boolean 	supportsSubqueriesInComparisons()</code> -- 获取此数据库是否支持比较表达式中的子查询</p></li>
                            <li><p><code>boolean 	supportsSubqueriesInExists()</code> -- 获取此数据库是否支持 EXISTS 表达式中的子查询</p></li>
                            <li><p><code>boolean 	supportsSubqueriesInIns()</code> -- 获取此数据库是否支持 IN 表达式中的子查询</p></li>
                            <li><p><code>boolean 	supportsSubqueriesInQuantifieds()</code> -- 获取此数据库是否支持量化表达式 (quantified expression) 中的子查询</p></li>
                            <li><p><code>boolean 	supportsTableCorrelationNames()</code> -- 获取此数据库是否支持表关联名称</p></li>
                            <li><p><code>boolean 	supportsTransactionIsolationLevel(int level)</code> -- 获取此数据库是否支持给定事务隔离级别</p></li>
                            <li><p><code>boolean 	supportsTransactions()</code> -- 获取此数据库是否支持事务</p></li>
                            <li><p><code>boolean 	supportsUnion()</code> -- 获取此数据库是否支持 SQL UNION</p></li>
                            <li><p><code>boolean 	supportsUnionAll()</code> -- 获取此数据库是否支持 SQL UNION ALL</p></li>

                            <li class="group"><p><code>boolean 	updatesAreDetected(int type)</code> -- 获取是否可以通过调用 ResultSet.rowUpdated 方法检测可见行的更新</p></li>
                            <li><p><code>boolean 	usesLocalFilePerTable()</code> -- 获取此数据库是否为每个表使用一个文件</p></li>
                            <li><p><code>boolean 	usesLocalFiles()</code> --  获取此数据库是否将表存储在本地文件中</p></li>

                            <li class="group"><p><code>int 	getDefaultTransactionIsolation()</code> -- 获取此数据库的默认事务隔离级别</p></li>
                            <li><p><code>ResultSet 	getExportedKeys(String catalog, String schema, String table)</code> -- 获取引用给定表的主键列（表导入的外键）的外键列的描述</p></li>
                            <li><p><code>String 	getExtraNameCharacters()</code> -- 获取可以在不带引号的标识符名称中使用的所有“额外”字符</p></li>
                            <li><p><code>ResultSet 	getFunctionColumns(String catalog, String schemaPattern, String functionNamePattern, String columnNamePattern)</code> -- 获取给定类别的系统或用户函数参数和返回类型的描述</p></li>
                            <li><p><code>ResultSet 	getFunctions(String catalog, String schemaPattern, String functionNamePattern)</code> -- 获取给定类别中可用的系统和用户函数的描述</p></li>
                            <li><p><code>String 	getIdentifierQuoteString()</code> -- 获取用于引用 SQL 标识符的字符串</p></li>
                            <li><p><code>ResultSet 	getImportedKeys(String catalog, String schema, String table)</code> -- 获取由给定表的外键列（表导入的主键）引用的主键列的描述</p></li>
                            <li><p><code>ResultSet 	getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate)</code> -- 获取给定表的索引和统计信息的描述</p></li>
                            <li><p><code>String 	getNumericFunctions()</code> -- 获取可用于此数据库的数学函数的逗号分隔列表</p></li>
                            <li><p><code>ResultSet 	getPrimaryKeys(String catalog, String schema, String table)</code> -- 获取对给定表的主键列的描述</p></li>
                            <li><p><code>ResultSet 	getProcedureColumns(String catalog, String schemaPattern, String procedureNamePattern, String columnNamePattern)</code> -- 获取给定类别的存储过程参数和结果列的描述</p></li>
                            <li><p><code>ResultSet 	getProcedures(String catalog, String schemaPattern, String procedureNamePattern)</code> -- 获取可在给定类别中使用的存储过程的描述</p></li>
                            <li><p><code>String 	getProcedureTerm()</code> -- 获取数据库供应商用于 "procedure" 的首选术语</p></li>
                            <li><p><code>ResultSet 	getPseudoColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)</code> -- </p></li>
                            <li><p><code>int 	getResultSetHoldability()</code> -- 针对 ResultSet 对象获取此数据库的默认可保存性</p></li>
                            <li><p><code>RowIdLifetime 	getRowIdLifetime()</code> -- 指示此数据源是否支持 SQL ROWID 类型，如果支持，则 RowId 对象在该类型的生存期内持续有效</p></li>
                            <li><p><code>ResultSet 	getSchemas()</code> -- 获取可在此数据库中使用的模式名称</p></li>
                            <li><p><code>ResultSet 	getSchemas(String catalog, String schemaPattern)</code> -- 获取此数据库中可用的模式名称</p></li>
                            <li><p><code>String 	getSchemaTerm()</code> -- 获取数据库供应商用于 "schema" 的首选术语</p></li>
                            <li><p><code>String 	getSearchStringEscape()</code> -- 获取可用于转义通配符的字符串</p></li>
                            <li><p><code>String 	getSQLKeywords()</code> -- 获取此数据库的还“不”是 SQL:2003 关键字的所有 SQL 关键字的逗号分隔列表</p></li>
                            <li><p><code>int 	getSQLStateType()</code> -- 指示由 SQLException.getSQLState 返回的 SQLSTATE 是 X/Open（现在称为 Open Group）SQL CLI 还是 SQL:2003</p></li>
                            <li><p><code>String 	getStringFunctions()</code> -- 获取可用于此数据库的字符串函数的逗号分隔列表</p></li>
                            <li><p><code>ResultSet 	getSuperTables(String catalog, String schemaPattern, String tableNamePattern)</code> -- 获取在此数据库的特定模式中定义的表分层结构的描述</p></li>
                            <li><p><code>ResultSet 	getSuperTypes(String catalog, String schemaPattern, String typeNamePattern)</code> -- 获取在此数据库的特定模式中定义的用户定义类型 (UDT) 分层结构的描述</p></li>
                            <li><p><code>String 	getSystemFunctions()</code> -- 获取可用于此数据库的系统函数的逗号分隔列表</p></li>
                            <li><p><code>ResultSet 	getTablePrivileges(String catalog, String schemaPattern, String tableNamePattern)</code> -- 获取可在类别中使用的每个表的访问权的描述</p></li>
                            <li><p><code>ResultSet 	getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types)</code> -- 获取可在给定类别中使用的表的描述</p></li>
                            <li><p><code>ResultSet 	getTableTypes()</code> -- 获取可在此数据库中使用的表类型</p></li>
                            <li><p><code>String 	getTimeDateFunctions()</code> -- 获取可用于此数据库的时间和日期函数的逗号分隔列表</p></li>
                            <li><p><code>ResultSet 	getTypeInfo()</code> -- 获取此数据库支持的所有数据类型的描述</p></li>
                            <li><p><code>ResultSet 	getUDTs(String catalog, String schemaPattern, String typeNamePattern, int[] types)</code> --  获取在特定模式中定义的用户定义类型 (UDT) 的描述</p></li>
                            <li><p><code>ResultSet 	getVersionColumns(String catalog, String schema, String table)</code> -- 获取在更新行中的任意值时自动更新的表列的描述</p></li>
                            <li><p><code>boolean 	insertsAreDetected(int type)</code> -- 获取是否可以通过调用 ResultSet.rowInserted 方法检测可见行的插入</p></li>
                            <li><p><code>boolean 	isCatalogAtStart()</code> -- 获取某个类别是否出现在完全限定表名的开头</p></li>
                            <li><p><code>boolean 	locatorsUpdateCopy()</code> -- 指示对 LOB 的更新是在副本上进行还是直接更新到 LOB</p></li>
                            <li><p><code>boolean 	allProceduresAreCallable()</code> -- 获取当前用户是否可以调用 getProcedures 方法返回的所有过程</p></li>
                            <li><p><code>boolean 	allTablesAreSelectable()</code> -- 获取当前用户是否可以使用 SELECT 语句中的 getTables 方法返回的所有表</p></li>
                            <li><p><code>boolean 	autoCommitFailureClosesAllResultSets()</code> -- 当 autoCommit 为 true 时，获取 SQLException 是否指示所有打开的 ResultSets 已关闭</p></li>
                            <li><p><code>boolean 	dataDefinitionCausesTransactionCommit()</code> -- 获取事务中的数据定义语句是否强迫该事务进行提交</p></li>
                            <li><p><code>boolean 	dataDefinitionIgnoredInTransactions()</code> -- 获取此数据库是否忽略事务中的数据定义语句</p></li>
                            <li><p><code>boolean 	deletesAreDetected(int type)</code> -- 获取是否可以通过调用 ResultSet.rowDeleted 方法检测可见行的删除</p></li>
                            <li><p><code>boolean 	doesMaxRowSizeIncludeBlobs()</code> -- 获取 getMaxRowSize 方法的返回值是否包括 SQL 数据类型 LONGVARCHAR 和 LONGVARBINARY</p></li>
                            <li><p><code>boolean 	generatedKeyAlwaysReturned()</code> -- </p></li>
                            <li><p><code>ResultSet 	getAttributes(String catalog, String schemaPattern, String typeNamePattern, String attributeNamePattern)</code> -- 获取可在给定模式和类别中使用的用户定义类型 (UDT) 的给定类型的给定属性的描述</p></li>
                            <li><p><code>ResultSet 	getBestRowIdentifier(String catalog, String schema, String table, int scope, boolean nullable)</code> -- 获取唯一标识行的表的最佳列集合的描述</p></li>
                            <li><p><code>ResultSet 	getCatalogs()</code> -- 获取可在此数据库中使用的类别名称</p></li>
                            <li><p><code>String 	getCatalogSeparator()</code> -- 获取此数据库用作类别和表名之间的分隔符的 String</p></li>
                            <li><p><code>String 	getCatalogTerm()</code> -- 获取数据库供应商用于 "catalog" 的首选术语</p></li>
                            <li><p><code>ResultSet 	getClientInfoProperties()</code> -- 获取驱动程序支持的客户端信息属性的列表</p></li>
                            <li><p><code>ResultSet 	getColumnPrivileges(String catalog, String schema, String table, String columnNamePattern)</code> -- 获取用于表列的访问权的描述</p></li>
                            <li><p><code>ResultSet 	getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)</code> -- 获取可在指定类别中使用的表列的描述</p></li>
                            <li><p><code>Connection 	getConnection()</code> -- 获取此元数据对象所产生的连接</p></li>
                            <li><p><code>ResultSet 	getCrossReference(String parentCatalog, String parentSchema, String parentTable, String foreignCatalog, String foreignSchema, String foreignTable)</code> -- 获取给定外键列表中外键列的描述，这些列引用主键或表示父表</p></li>
                        </ol>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-sql-Types"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Types 及内置类型</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
public class Types {
    public final static int NULL = 0; // SQL NULL
    public final static int BOOLEAN = 16; // 用 1 代表 TRUE, 0 代表 FALSE
    public final static int BIT = -7; // 代表一个位值，可为 0 或 1, boolean
    public final static int TINYINT = -6; // 代表一个 8 位无符号整数，byte
    public final static int SMALLINT = 5; // 代表一个 16 位的有符号整数，short
    public final static int INTEGER = 4; // 代表一个 32 位的有符号整数，int
    public final static int BIGINT = -5; // 代表一个 64 位的有符号整数，long
    public final static int REAL = 7; // 代表一个有 7 位尾数的“单精度”浮点数，float
    public final static int DOUBLE = 8; // 代表一个有 15 位尾数的“双精度”浮点数，double
    public final static int FLOAT = 6; // 建议使用 double
    public final static int NUMERIC = 2; // 表示固定精度的十进制值，BigDecimal
    public final static int DECIMAL = 3; // 表示固定精度的十进制值，BigDecimal

    /** CHAR、VARCHAR 和 LONGVARCHAR 可映射为 String 或 char[]，但 String 更适合于一般用法
     * CHAR -- 固定长度的小字符串,所有主要的数据库都支持长度达 254 个字符的 CHAR
     * VARCHAR -- 表示长度可变的小字符串,有主要数据库都至少支持长度达 254 个字符
     * LONGVARCHAR -- 目前并没有一致的 SQL 映射,所有主要数据库都支持某种类型的长度可变的大字符串
     */
    public final static int CHAR = 1;
    public final static int VARCHAR = 12;
    public final static int LONGVARCHAR = -1;

    /** NCHAR、NVARCHAR 和 LONGNVARCHAR 使用 Unicode 存储 */
    public static final int NCHAR = -15;
    public static final int NVARCHAR = -9;
    public static final int LONGNVARCHAR = -16;

    /** BINARY、VARBINARY 和 LONGVARBINARY 都可用同一 byte 数组来表示
     * BINARY -- 表示固定长度的小二进制值,通常，BINARY 值被限定在 254 个字节以内
     * VARBINARY -- 表示长度可变化的小二进制值,通常，BINARY 值被限定在 254 个字节以内
     * LONGVARBINARY -- 表示长度可变化的大二进制值, 目前还没有一致的 SQL 类型名称
     */
    public final static int BINARY = -2;
    public final static int VARBINARY = -3;
    public final static int LONGVARBINARY = -4;

    public final static int DATE = 91; // 年、月、日组成的日期，java.sql.Date
    public final static int TIME = 92; // 小时、分钟和秒组成的时间，java.sql.Time
    public final static int TIMESTAMP = 93; // DATE 加上 TIME，外加一个纳秒域，java.sql.TimeStamp
    public static final int TIME_WITH_TIMEZONE = 2013; //
    public static final int TIMESTAMP_WITH_TIMEZONE = 2014; //

    public final static int OTHER = 1111;
    public final static int DATALINK = 70;
    public static final int REF_CURSOR = 2012;
    public final static int JAVA_OBJECT = 2000;
    public final static int DISTINCT = 2001;
    public final static int STRUCT = 2002; // java.sql.Struct
    public final static int ARRAY = 2003; // java.sql.Array
    public final static int BLOB = 2004; // 大对象数据类型, java.sql.Blob
    public final static int CLOB = 2005; // java.sql.Clob
    public static final int NCLOB = 2011; // java.sql.NClob
    public final static int REF = 2006; // java.sql.Ref
    public final static int ROWID = -8; // java.sql.RowId
    public static final int SQLXML = 2009; // java.sql.SQLXML
}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/Types.html" target="_blank">Types</a> 定义用于标识一般 SQL 类型（称为 JDBC 类型）的常量的类。</p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public interface Array {}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/Array.html" target="_blank">Array</a> SQL 类型 ARRAY 在 Java 编程语言中的映射关系。默认情况下，Array 值是对 SQL ARRAY 值的事务处理期引用。默认情况下，Array 对象是使用 SQL LOCATOR(array) 内部实现的，这意味着 Array 对象包含一个指向 SQL ARRAY 值中数据的逻辑指针，而不是包含 ARRAY 值的数据。</p>
                            <p></p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public interface Blob {}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/Blob.html" target="_blank">Blob</a> SQL BLOB 是内置类型，它将二进制大对象 (Binary Large Object) 存储为数据库表某一行中的一个列值。默认情况下，驱动程序使用 SQL locator(BLOB) 实现 Blob，这意味着 Blob 对象包含一个指向 SQL BLOB 数据的逻辑指针而不是数据本身。Blob 对象在它被创建的事务处理期间有效。 </p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public interface Clob {}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/Clob.html" target="_blank">Clob</a> SQL CLOB 是内置类型，它将字符大对象 (Character Large Object) 存储为数据库表某一行中的一个列值。默认情况下，驱动程序使用 SQL locator(CLOB) 实现 Clob 对象，这意味着 CLOB 对象包含一个指向 SQL CLOB 数据的逻辑指针而不是数据本身。Clob 对象在它被创建的事务处理期间有效。 </p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public interface NClob exdents Clob {}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/NClob.html" target="_blank">NClob</a> SQL NCLOB 是内置类型，它将使用国家字符集（NATIONAL CHARACTER SET）的字符型大对象（Character Large Object）存储为数据库表某一行中的一个列值。 </p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public interface Ref {}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/Ref.html" target="_blank">Ref</a> SQL REF 值的映射关系，它是到数据库中的 SQL 结构类型值的引用。</p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public interface RowId {}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/RowId.html" target="_blank">RowId</a> SQL ROWID 值在 Java 编程语言中的表示形式（映射）。SQL ROWID 是一种内置类型，其值可视为它标识的行在数据库表中的一个地址。该地址是逻辑的还是物理的（在某些方面）取决于它的原始数据源。 </p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public interface SQLXML {}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/SQLXML.html" target="_blank">SQLXML</a> SQL XML 类型在 JavaTM 编程语言中的映射关系。XML 是内置类型，它将 XML 值存储为数据库表某一行中的一个列值。默认情况下，驱动程序将 SQLXML 对象实现为一个指向 XML 数据而不是数据本身的逻辑指针。SQLXML 对象在创建它的事务处理期间有效。 </p>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public interface Struct {}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/Struct.html" target="_blank">Struct</a> 用于 SQL 结构化类型的 Java 编程语言中的标准映射关系。Struct 对象为它所表示的 SQL 结构化类型的每个属性包含一个值。默认情况下，只要应用程序可以引用 Struct 实例，该实例就有效。 </p>
                        </div>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-sql-Statement"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Statement 及子接口</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
...
    java.sql.Statement

public interface Statement extends Wrapper, AutoCloseable {
    int CLOSE_CURRENT_RESULT = 1; // 该常量指示调用 getMoreResults 时应该关闭当前 ResultSet 对象
    int KEEP_CURRENT_RESULT = 2; // 该常量指示调用 getMoreResults 时应该关闭当前 ResultSet 对象
    int CLOSE_ALL_RESULTS = 3; // 该常量指示调用 getMoreResults 时应该关闭以前一直打开的所有 ResultSet 对象

    int SUCCESS_NO_INFO = -2; // 该常量指示批量语句执行成功但不存在受影响的可用行数计数
    int EXECUTE_FAILED = -3; // 该常量指示在执行批量语句时发生错误

    int RETURN_GENERATED_KEYS = 1; // 该常量指示生成的键应该可用于获取
    int NO_GENERATED_KEYS = 2; // 该常量指示生成的键应该不可用于获取
}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/Statement.html" target="_blank">Statement</a> 用于执行静态 SQL 语句并返回它所生成结果的对象。</p>
                            <p>在默认情况下，同一时间每个 Statement 对象在只能打开一个 ResultSet 对象。因此，如果读取一个 ResultSet 对象与读取另一个交叉，则这两个对象必须是由不同的 Statement 对象生成的。如果存在某个语句的打开的当前 ResultSet 对象，则 Statement 接口中的所有执行方法都会隐式关闭它。 </p>
                            <ol>
                                <li><p><code>void 	addBatch(String sql)</code> -- 将给定的 SQL 命令添加到此 Statement 对象的当前命令列表中</p></li>
                                <li><p><code>void 	clearBatch()</code> -- 清空此 Statement 对象的当前 SQL 命令列表</p></li>
                                <li><p><code>void 	cancel()</code> -- 如果 DBMS 和驱动程序都支持中止 SQL 语句，则取消此 Statement 对象</p></li>
                                <li><p><code>void 	clearWarnings()</code> -- 清除在此 Statement 对象上报告的所有警告</p></li>
                                <li><p><code>SQLWarning 	getWarnings()</code> -- 获取此 Statement 对象上的调用报告的第一个警告</p></li>
                                <li><p><code>void 	close()</code> -- 立即释放此 Statement 对象的数据库和 JDBC 资源，而不是等待该对象自动关闭时发生此操作</p></li>
                                <li><p><code>boolean 	isClosed()</code> -- 获取是否已关闭了此 Statement 对象</p></li>
                                <li><p><code>void 	closeOnCompletion()</code> -- 指定当所有依赖结果集被关闭时，此语句将被关闭</p></li>
                                <li><p><code>boolean 	isCloseOnCompletion()</code> -- 是否为结果集关闭自动关闭</p></li>

                                <li class="group"><p><code>ResultSet 	executeQuery(String sql)</code> -- 执行给定的 SQL 语句，该语句返回单个 ResultSet 对象</p></li>

                                <li class="group"><p><code>boolean 	execute(String sql)</code> -- 执行给定的 SQL 语句，该语句可能返回多个结果</p></li>
                                <li><p><code>boolean 	execute(String sql, int autoGeneratedKeys)</code> -- 参数参见常量，执行给定的 SQL 语句，并通知驱动程序所有自动生成的键都应该可用于获取</p></li>
                                <li><p><code>boolean 	execute(String sql, int[] columnIndexes)</code> -- 执行给定的 SQL 语句，并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取</p></li>
                                <li><p><code>boolean 	execute(String sql, String[] columnNames)</code> -- 执行给定的 SQL 语句，并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取</p></li>

                                <li class="group"><p><code>int 	executeUpdate(String sql)</code> -- 执行给定 SQL 语句，该语句可能为 INSERT、UPDATE 或 DELETE 语句，或者不返回任何内容的 SQL 语句</p></li>
                                <li><p><code>int 	executeUpdate(String sql, int autoGeneratedKeys)</code> -- 参数参见常量，执行给定的 SQL 语句，并用给定标志通知驱动程序由此 Statement 生成的自动生成键是否可用于获取</p></li>
                                <li><p><code>int 	executeUpdate(String sql, int[] columnIndexes)</code> -- 执行给定的 SQL 语句，并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取</p></li>
                                <li><p><code>int 	executeUpdate(String sql, String[] columnNames)</code> -- 执行给定的 SQL 语句，并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取</p></li>
                                <li><p><code>int 	getUpdateCount()</code> -- 以更新计数的形式获取当前结果；如果结果为 ResultSet 对象或没有更多结果，则返回 -1</p></li>

                                <li class="group"><p><code>int[] 	executeBatch()</code> -- 将一批命令提交给数据库来执行，如果全部命令执行成功，则返回更新计数组成的数组</p></li>
                                <li><p><code>default long[] 	executeLargeBatch()</code> -- 提交一批命令到数据库执行，如果所有命令都成功执行，返回一个更新计数数组</p></li>

                                <li class="group"><p><code>default long 	executeLargeUpdate(String sql)</code> -- 执行给定的SQL语句，该语句可以是插入、更新或删除语句或不返回任何语句的SQL语句</p></li>
                                <li><p><code>default long 	executeLargeUpdate(String sql, int autoGeneratedKeys)</code> -- 参数参见常量，执行给定的SQL语句，并用给定标志通知驱动程序由此 Statement 生成的自动生成键是否可用于获取</p></li>
                                <li><p><code>default long 	executeLargeUpdate(String sql, int[] columnIndexes)</code> -- 执行给定的SQL语句，并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取</p></li>
                                <li><p><code>default long 	executeLargeUpdate(String sql, String[] columnNames)</code> -- 执行给定的SQL语句，并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取</p></li>
                                <li><p><code>default long 	getLargeUpdateCount()</code> -- 检索当前结果作为更新计数；如果结果是ReultStor对象，或者没有更多的结果，则返回-1</p></li>

                                <li class="group"><p><code>int 	getMaxRows()</code> -- 获取由此 Statement 对象生成的 ResultSet 对象可以包含的最大行数</p></li>
                                <li><p><code>void 	setMaxRows(int max)</code> -- 将此 Statement 对象生成的所有 ResultSet 对象可以包含的最大行数限制设置为给定数</p></li>
                                <li><p><code>default long 	getLargeMaxRows()</code> -- 检索由该语句对象生成的 RESUTSET 对象所能包含的最大行数</p></li>
                                <li><p><code>default void 	setLargeMaxRows(long max)</code> -- 设置由该语句对象生成的 RESUTSET 对象所能包含的最大行数</p></li>

                                <li class="group"><p><code>int 	getFetchSize()</code> -- 获取结果集合的行数，该数是根据此 Statement 对象生成的 ResultSet 对象的默认获取大小</p></li>
                                <li><p><code>void 	setFetchSize(int rows)</code> -- 为 JDBC 驱动程序提供一个提示，它提示此 Statement 生成的 ResultSet 对象需要更多行时应该从数据库获取的行数</p></li>
                                <li><p><code>int 	getQueryTimeout()</code> -- 获取驱动程序等待 Statement 对象执行的秒数</p></li>
                                <li><p><code>void 	setQueryTimeout(int seconds)</code> -- 将驱动程序等待 Statement 对象执行的秒数设置为给定秒数</p></li>
                                <li><p><code>boolean 	isPoolable()</code> -- 返回指示 Statement 是否是可池化的值</p></li>
                                <li><p><code>void 	setPoolable(boolean poolable)</code> -- 请求将 Statement 池化或非池化</p></li>
                                <li><p><code>int 	getMaxFieldSize()</code> -- 获取可以为此 Statement 对象所生成 ResultSet 对象中的字符和二进制列值返回的最大字节数</p></li>
                                <li><p><code>void 	setMaxFieldSize(int max)</code> -- 设置此 Statement 对象生成的 ResultSet 对象中字符和二进制列值可以返回的最大字节数限制</p></li>
                                <li><p><code>int 	getFetchDirection()</code> -- 获取从数据库表获取行的方向，该方向是根据此 Statement 对象生成的结果集合的默认值</p></li>
                                <li><p><code>void 	setFetchDirection(int direction)</code> -- 向驱动程序提供关于方向的提示，在使用此 Statement 对象创建的 ResultSet 对象中将按该方向处理行，参数为：<code>ResultSet.FETCH_FORWARD</code>, <code>ResultSet.FETCH_REVERSE</code>, or <code>ResultSet.FETCH_UNKNOWN</code></p></li>

                                <li class="group"><p><code>boolean 	getMoreResults()</code> -- 移动到此 Statement 对象的下一个结果，如果其为 ResultSet 对象，则返回 true，并隐式关闭利用方法 getResultSet 获取的所有当前 ResultSet 对象</p></li>
                                <li><p><code>boolean 	getMoreResults(int current)</code> -- 参数参见常量，将此 Statement 对象移动到下一个结果，根据给定标志指定的指令处理所有当前 ResultSet 对象；如果下一个结果为 ResultSet 对象，则返回 true</p></li>
                                <li><p><code>ResultSet 	getResultSet()</code> -- 以 ResultSet 对象的形式获取当前结果</p></li>
                                <li><p><code>ResultSet 	getGeneratedKeys()</code> -- 获取由于执行此 Statement 对象而创建的所有自动生成的键</p></li>
                                <li><p><code>int 	getResultSetConcurrency()</code> -- 获取此 Statement 对象生成的 ResultSet 对象的结果集合并发性，返回值为：<code>ResultSet.CONCUR_READ_ONLY</code> 或 <code>ResultSet.CONCUR_UPDATABLE </code></p></li>
                                <li><p><code>int 	getResultSetHoldability()</code> -- 获取此 Statement 对象生成的 ResultSet 对象的结果集合可保存性，返回值为：<code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> 或 <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code></p></li>
                                <li><p><code>int 	getResultSetType()</code> -- 获取此 Statement 对象生成的 ResultSet 对象的结果集合类型，返回值为：<code>ResultSet.TYPE_FORWARD_ONLY</code>, <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code></p></li>

                                <li class="group"><p><code>Connection 	getConnection()</code> -- 获取生成此 Statement 对象的 Connection 对象</p></li>
                                <li><p><code>void 	setEscapeProcessing(boolean enable)</code> -- 将转义处理设置为开或关</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
...
    java.sql.Statement
        java.sql.PreparedStatement

public interface PreparedStatement extends Statement {}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/PreparedStatement.html" target="_blank">PreparedStatement</a> 是 Statement 的子接口，表示预编译的 SQL 语句的对象。 </p>
                            <p>SQL 语句被预编译并存储在 PreparedStatement 对象中。然后可以使用此对象多次高效地执行该语句。</p>
                            <p><b>注意</b>：用于设置 IN 参数值的设置方法（setShort、setString 等等）必须指定与输入参数的已定义 SQL 类型兼容的类型。例如，如果 IN 参数具有 SQL 类型 INTEGER，那么应该使用 setInt 方法。 </p>
                            <p>如果需要任意参数类型转换，使用 setObject 方法时应该将目标 SQL 类型作为其参数。 </p>
                            <ol>
                                <li><p><code>void 	addBatch()</code> -- 将一组参数添加到此 PreparedStatement 对象的批处理命令中</p></li>
                                <li><p><code>void 	clearParameters()</code> -- 立即清除当前参数值</p></li>
                                <li><p><code>boolean 	execute()</code> -- 在此 PreparedStatement 对象中执行 SQL 语句，该语句可以是任何种类的 SQL 语句</p></li>
                                <li><p><code>default long 	executeLargeUpdate()</code> -- </p></li>
                                <li><p><code>ResultSet 	executeQuery()</code> -- 在此 PreparedStatement 对象中执行 SQL 查询，并返回该查询生成的 ResultSet 对象</p></li>
                                <li><p><code>int 	executeUpdate()</code> -- 在此 PreparedStatement 对象中执行 SQL 语句，该语句必须是一个 SQL 数据操作语言语句，比如 INSERT、UPDATE 或 DELETE 语句；或者是无返回内容的 SQL 语句，比如 DDL 语句</p></li>
                                <li><p><code>ResultSetMetaData 	getMetaData()</code> -- 获取包含有关 ResultSet 对象列信息的 ResultSetMetaData 对象，ResultSet 对象将在执行此 PreparedStatement 对象时返回</p></li>
                                <li><p><code>ParameterMetaData 	getParameterMetaData()</code> -- 获取此 PreparedStatement 对象的参数的编号、类型和属性</p></li>

                                <li class="group"><p><code>void 	setBoolean(int parameterIndex, boolean x)</code> -- 将指定参数设置为给定 Java boolean 值</p></li>
                                <li><p><code>void 	setByte(int parameterIndex, byte x)</code> -- 将指定参数设置为给定 Java byte 值</p></li>
                                <li><p><code>void 	setShort(int parameterIndex, short x)</code> -- 将指定参数设置为给定 Java short 值</p></li>
                                <li><p><code>void 	setInt(int parameterIndex, int x)</code> -- 将指定参数设置为给定 Java int 值</p></li>
                                <li><p><code>void 	setLong(int parameterIndex, long x)</code> -- 将指定参数设置为给定 Java long 值</p></li>
                                <li><p><code>void 	setFloat(int parameterIndex, float x)</code> -- 将指定参数设置为给定 Java REAL 值</p></li>
                                <li><p><code>void 	setDouble(int parameterIndex, double x)</code> -- 将指定参数设置为给定 Java double 值</p></li>
                                <li><p><code>void 	setBigDecimal(int parameterIndex, BigDecimal x)</code> -- 将指定参数设置为给定 java.math.BigDecimal 值</p></li>
                                <li><p><code>void 	setString(int parameterIndex, String x)</code> -- 将指定参数设置为给定 Java String 值</p></li>
                                <li><p><code>void 	setNString(int parameterIndex, String value)</code> -- 将指定参数设置为给定 String 对象</p></li>

                                <li class="group"><p><code>void 	setBytes(int parameterIndex, byte[] x)</code> -- 将指定参数设置为给定 Java byte 数组</p></li>
                                <li><p><code>void 	setURL(int parameterIndex, URL x)</code> -- 将指定参数设置为给定 java.net.URL 值</p></li>
                                <li><p><code>void 	setArray(int parameterIndex, Array x)</code> -- 将指定参数设置为给定 java.sql.Array 对象</p></li>

                                <li class="group"><p><code>void 	setTime(int parameterIndex, Time x)</code> -- 将指定参数设置为给定 java.sql.Time 值</p></li>
                                <li><p><code>void 	setTime(int parameterIndex, Time x, Calendar cal)</code> -- 使用给定的 Calendar 对象将指定参数设置为给定 java.sql.Time 值</p></li>
                                <li><p><code>void 	setTimestamp(int parameterIndex, Timestamp x)</code> -- 将指定参数设置为给定 java.sql.Timestamp 值</p></li>
                                <li><p><code>void 	setTimestamp(int parameterIndex, Timestamp x, Calendar cal)</code> -- 使用给定的 Calendar 对象将指定参数设置为给定 java.sql.Timestamp 值</p></li>
                                <li><p><code>void 	setDate(int parameterIndex, Date x)</code> -- 使用运行应用程序的虚拟机的默认时区将指定参数设置为 java.sql.Date 值</p></li>
                                <li><p><code>void 	setDate(int parameterIndex, Date x, Calendar cal)</code> -- 使用给定的 Calendar 对象将指定参数设置为给定 java.sql.Date 值</p></li>

                                <li class="group"><p><code>void 	setAsciiStream(int parameterIndex, InputStream x)</code> -- 将指定参数设置为给定输入流</p></li>
                                <li><p><code>void 	setAsciiStream(int parameterIndex, InputStream x, int length)</code> -- 将指定参数设置为给定输入流，该输入流将具有给定字节数</p></li>
                                <li><p><code>void 	setAsciiStream(int parameterIndex, InputStream x, long length)</code> -- 将指定参数设置为给定输入流，该输入流将具有指定字节数</p></li>

                                <li class="group"><p><code>void 	setBinaryStream(int parameterIndex, InputStream x)</code> -- 将指定参数设置为给定输入流</p></li>
                                <li><p><code>void 	setBinaryStream(int parameterIndex, InputStream x, int length)</code> -- 将指定参数设置为给定输入流，该输入流将具有给定字节数</p></li>
                                <li><p><code>void 	setBinaryStream(int parameterIndex, InputStream x, long length)</code> -- 将指定参数设置为给定输入流，该输入流将具有指定字节数</p></li>

                                <li class="group"><p><code>void 	setBlob(int parameterIndex, Blob x)</code> -- 将指定参数设置为给定 java.sql.Blob 对象</p></li>
                                <li><p><code>void 	setBlob(int parameterIndex, InputStream inputStream)</code> -- 将指定参数设置为 InputStream 对象</p></li>
                                <li><p><code>void 	setBlob(int parameterIndex, InputStream inputStream, long length)</code> -- 将指定参数设置为 InputStream 对象</p></li>


                                <li class="group"><p><code>void 	setClob(int parameterIndex, Clob x)</code> -- 将指定参数设置为给定 java.sql.Clob 对象</p></li>
                                <li><p><code>void 	setClob(int parameterIndex, Reader reader)</code> -- 将指定参数设置为 Reader 对象</p></li>
                                <li><p><code>void 	setClob(int parameterIndex, Reader reader, long length)</code> -- 将指定参数设置为 Reader 对象</p></li>
                                <li><p><code>void 	setNClob(int parameterIndex, NClob value)</code> -- 将指定参数设置为 java.sql.NClob 对象</p></li>
                                <li><p><code>void 	setNClob(int parameterIndex, Reader reader)</code> -- 将指定参数设置为 Reader 对象</p></li>
                                <li><p><code>void 	setNClob(int parameterIndex, Reader reader, long length)</code> -- 将指定参数设置为 Reader 对象</p></li>

                                <li class="group"><p><code>void 	setCharacterStream(int parameterIndex, Reader reader)</code> -- 将指定参数设置为给定 Reader 对象</p></li>
                                <li><p><code>void 	setCharacterStream(int parameterIndex, Reader reader, int length)</code> -- 将给定参数设置为给定 Reader 对象，该对象具有给定字符数长度</p></li>
                                <li><p><code>void 	setCharacterStream(int parameterIndex, Reader reader, long length)</code> -- 将指定参数设置为给定 Reader 对象，该对象具有给定字符数长度</p></li>
                                <li><p><code>void 	setNCharacterStream(int parameterIndex, Reader value)</code> -- 将指定参数设置为 Reader 对象</p></li>
                                <li><p><code>void 	setNCharacterStream(int parameterIndex, Reader value, long length)</code> -- 将指定参数设置为 Reader 对象</p></li>

                                <li class="group"><p><code>void 	setNull(int parameterIndex, int sqlType)</code> -- 将指定参数设置为 SQL NULL</p></li>
                                <li><p><code>void 	setNull(int parameterIndex, int sqlType, String typeName)</code> -- 将指定参数设置为 SQL NULL</p></li>

                                <li class="group"><p><code>void 	setObject(int parameterIndex, Object x)</code> -- 使用给定对象设置指定参数的值</p></li>
                                <li><p><code>void 	setObject(int parameterIndex, Object x, int targetSqlType)</code> -- 使用给定对象设置指定参数的值</p></li>
                                <li><p><code>void 	setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength)</code> -- 使用给定对象设置参数的值</p></li>
                                <li><p><code>default void 	setObject(int parameterIndex, Object x, SQLType targetSqlType)</code> -- 使用给定对象设置指定参数的值</p></li>
                                <li><p><code>default void 	setObject(int parameterIndex, Object x, SQLType targetSqlType, int scaleOrLength)</code> -- 使用给定对象设置指定参数的值</p></li>

                                <li class="group"><p><code>void 	setRef(int parameterIndex, Ref x)</code> -- 将指定参数设置为给定 REF(&lt;structured-type>) 值</p></li>
                                <li><p><code>void 	setRowId(int parameterIndex, RowId x)</code> -- 将指定参数设置为给定 java.sql.RowId 对象</p></li>
                                <li><p><code>void 	setSQLXML(int parameterIndex, SQLXML xmlObject)</code> -- 将指定参数设置为给定 java.sql.SQLXML 对象</p></li>

                            </ol>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
...
    java.sql.Statement
        java.sql.PreparedStatement
            java.sql.CallableStatement

public interface PreparedStatement extends PreparedStatement {}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/CallableStatement.html" target="_blank">CallableStatement</a> 是 PreparedStatement 的子接口，用于执行 SQL 存储过程的接口。</p>
                            <p>JDBC API 提供了一个存储过程 SQL 转义语法，该语法允许对所有 RDBMS 使用标准方式调用存储过程。此转义语法有一个包含结果参数的形式和一个不包含结果参数的形式。如果使用结果参数，则必须将其注册为 OUT 参数。其他参数可用于输入、输出或同时用于二者。参数是根据编号按顺序引用的，第一个参数的编号是 1。 </p>
                            <p>IN 参数值是使用继承自 PreparedStatement 的 set 方法设置的。在执行存储过程之前，必须注册所有 OUT 参数的类型；它们的值是在执行后通过此类提供的 get 方法获取的。 </p>
                            <p>CallableStatement 可以返回一个 ResultSet 对象或多个 ResultSet 对象。多个 ResultSet 对象是使用继承自 Statement 的操作处理的。 </p>
                            <p>为了获得最大的可移植性，某一调用的 ResultSet 对象和更新计数应该在获得输出参数的值之前处理。</p>
                            <ol>
                                <li><p><code>boolean 	getBoolean(int parameterIndex)</code> -- 以 boolean 值的形式获取指定的 JDBC BIT 或 BOOLEAN 参数的值</p></li>
                                <li><p><code>boolean 	getBoolean(String parameterName)</code> -- 以 boolean 值的形式获取 JDBC BIT 或 BOOLEAN 参数的值</p></li>
                                <li><p><code>byte 	getByte(int parameterIndex)</code> -- 以 Java 编程语言中 byte 的形式获取指定的 JDBC TINYINT 参数的值</p></li>
                                <li><p><code>byte 	getByte(String parameterName)</code> -- 以 Java 编程语言中 byte 值的形式获取 JDBC TINYINT 参数的值</p></li>
                                <li><p><code>short 	getShort(int parameterIndex)</code> -- 以 Java 编程语言中 short 值的形式获取指定的 JDBC SMALLINT 参数的值</p></li>
                                <li><p><code>short 	getShort(String parameterName)</code> -- 以 Java 编程语言中 short 值的形式获取 JDBC SMALLINT 参数的值</p></li>
                                <li><p><code>int 	getInt(int parameterIndex)</code> -- 以 Java 编程语言中 int 值的形式获取指定的 JDBC INTEGER 参数的值</p></li>
                                <li><p><code>int 	getInt(String parameterName)</code> -- 以 Java 编程语言中 int 值的形式获取 JDBC INTEGER 参数的值</p></li>
                                <li><p><code>long 	getLong(int parameterIndex)</code> -- 以 Java 编程语言中 long 值的形式获取指定的 JDBC BIGINT 参数的值</p></li>
                                <li><p><code>long 	getLong(String parameterName)</code> -- 以 Java 编程语言中 long 值的形式获取 JDBC BIGINT 参数的值</p></li>
                                <li><p><code>float 	getFloat(int parameterIndex)</code> -- 以 Java 编程语言中 float 值的形式获取指定的 JDBC FLOAT 参数的值</p></li>
                                <li><p><code>float 	getFloat(String parameterName)</code> -- 以 Java 编程语言中 float 值的形式获取 JDBC FLOAT 参数的值</p></li>
                                <li><p><code>double 	getDouble(int parameterIndex)</code> -- 以 Java 编程语言中 double 值的形式获取指定的 JDBC DOUBLE 参数的值</p></li>
                                <li><p><code>double 	getDouble(String parameterName)</code> -- 以 Java 编程语言中 double 值的形式获取 JDBC DOUBLE 参数的值</p></li>
                                <li><p><code>BigDecimal 	getBigDecimal(int parameterIndex)</code> -- 以 java.math.BigDecimal 对象的形式获取指定 JDBC NUMERIC 参数的值，小数点右边的位数与该参数值所包含的位数相同</p></li>
                                <li><p><code>BigDecimal 	getBigDecimal(String parameterName)</code> -- 以 java.math.BigDecimal 对象的形式获取 JDBC NUMERIC 参数的值，小数点右边的位数与该参数值所包含的位数相同</p></li>
                                <li><p><code>String 	getString(int parameterIndex)</code> -- 以 Java 编程语言中 String 的形式获取指定的 JDBC CHAR、VARCHAR 或 LONGVARCHAR 参数的</p></li>
                                <li><p><code>String 	getString(String parameterName)</code> -- 以 Java 编程语言中 String 的形式获取 JDBC CHAR、VARCHAR 或 LONGVARCHAR 参数的值</p></li>
                                <li><p><code>String 	getNString(int parameterIndex)</code> -- 以 Java 编程语言中 String 的形式获取指定的 NCHAR、NVARCHAR 或 LONGNVARCHAR 参数的值</p></li>
                                <li><p><code>String 	getNString(String parameterName)</code> -- 以 Java 编程语言中 String 的形式获取指定的 NCHAR、NVARCHAR 或 LONGNVARCHAR 参数的值</p></li>

								<li class="group"><p><code>Time 	getTime(int parameterIndex)</code> -- 以 java.sql.Time 对象的形式获取指定 JDBC TIME 参数的值</p></li>
								<li><p><code>Time 	getTime(int parameterIndex, Calendar cal)</code> -- 以 java.sql.Time 对象的形式获取指定 JDBC TIME 参数的值，使用给定 Calendar 对象构造时间</p></li>
								<li><p><code>Time 	getTime(String parameterName)</code> -- 以 java.sql.Time 对象的形式获取 JDBC TIME 参数的值</p></li>
								<li><p><code>Time 	getTime(String parameterName, Calendar cal)</code> -- 以 java.sql.Time 对象的形式获取 JDBC TIME 参数的值，使用给定 Calendar 对象构造时间</p></li>

								<li class="group"><p><code>Timestamp 	getTimestamp(int parameterIndex)</code> -- 以 java.sql.Timestamp 对象的形式获取 JDBC TIMESTAMP 参数的值</p></li>
								<li><p><code>Timestamp 	getTimestamp(int parameterIndex, Calendar cal)</code> -- 以 java.sql.Timestamp 对象的形式获取指定 JDBC TIMESTAMP 参数的值，使用给定 Calendar 对象构造 Timestamp 对象</p></li>
								<li><p><code>Timestamp 	getTimestamp(String parameterName)</code> -- 以 java.sql.Timestamp 对象的形式获取 JDBC TIMESTAMP 参数的值</p></li>
								<li><p><code>Timestamp 	getTimestamp(String parameterName, Calendar cal)</code> -- 以 java.sql.Timestamp 对象的形式获取 JDBC TIMESTAMP 参数的值，使用给定 Calendar 对象构造 Timestamp 对象</p></li>

								<li class="group"><p><code>Date 	getDate(int parameterIndex)</code> -- 以 java.sql.Date 对象的形式获取指定 JDBC DATE 参数的值</p></li>
                                <li><p><code>Date 	getDate(int parameterIndex, Calendar cal)</code> -- 以 java.sql.Date 对象的形式获取指定 JDBC DATE 参数的值，使用给定 Calendar 对象构造日期</p></li>
                                <li><p><code>Date 	getDate(String parameterName)</code> -- 以 java.sql.Date 对象的形式获取 JDBC DATE 参数的值</p></li>
                                <li><p><code>Date 	getDate(String parameterName, Calendar cal)</code> -- 以 java.sql.Date 对象的形式获取 JDBC DATE 参数的值，使用给定 Calendar 对象构造日期</p></li>

								<li class="group"><p><code>byte[] 	getBytes(int parameterIndex)</code> -- 以 Java 编程语言中 byte 数组值的形式获取指定的 JDBC BINARY 或 VARBINARY 参数的值</p></li>
								<li><p><code>byte[] 	getBytes(String parameterName)</code> -- 以 Java 编程语言中 byte 数组值的形式获取 JDBC BINARY 或 VARBINARY 参数的值</p></li>
                                <li><p><code>Array 	getArray(int parameterIndex)</code> -- 以 Java 编程语言中 java.sql.Array 对象的形式获取指定的 JDBC ARRAY 参数的值</p></li>
                                <li><p><code>Array 	getArray(String parameterName)</code> -- 以 Java 编程语言中 java.sql.ARRAY 对象的形式获取 JDBC ARRAY 参数的值</p></li>

								<li class="group"><p><code>URL 	getURL(int parameterIndex)</code> -- 以 java.net.URL 对象的形式获取指定 JDBC DATALINK 参数的值</p></li>
								<li><p><code>URL 	getURL(String parameterName)</code> -- 以 java.net.URL 对象的形式获取 JDBC DATALINK 参数的值</p></li>

								<li class="group"><p><code>Clob 	getClob(int parameterIndex)</code> -- 以 Java 编程语言中 java.sql.Clob 对象的形式获取指定的 JDBC CLOB 参数的值</p></li>
								<li><p><code>Clob 	getClob(String parameterName)</code> -- 以 Java 编程语言中 java.sql.Clob 对象的形式获取 JDBC CLOB 参数的值</p></li>
								<li><p><code>NClob 	getNClob(int parameterIndex)</code> -- 以 java.sql.NClob 对象的形式获取指定的 JDBC NCLOB 参数的值</p></li>
								<li><p><code>NClob 	getNClob(String parameterName)</code> -- 以 java.sql.NClob 对象的形式获取 JDBC NCLOB 参数的值</p></li>
                                <li><p><code>Blob 	getBlob(int parameterIndex)</code> -- 以 Java 编程语言中 java.sql.Blob 对象的形式获取指定的 JDBC CLOB 参数的值</p></li>
                                <li><p><code>Blob 	getBlob(String parameterName)</code> -- 以 Java 编程语言中 java.sql.Blob 对象的形式获取 JDBC BLOB 参数的值</p></li>

                                <li class="group"><p><code>Reader 	getCharacterStream(int parameterIndex)</code> -- 以 Java 编程语言中 java.io.Reader 对象的形式获取指定参数的值</p></li>
                                <li><p><code>Reader 	getCharacterStream(String parameterName)</code> -- 以 Java 编程语言中 java.io.Reader 对象的形式获取指定参数的值</p></li>
                                <li><p><code>Reader 	getNCharacterStream(int parameterIndex)</code> -- 以 Java 编程语言中 java.io.Reader 对象的形式获取指定参数的值</p></li>
                                <li><p><code>Reader 	getNCharacterStream(String parameterName)</code> -- 以 Java 编程语言中 java.io.Reader 对象的形式获取指定参数的值</p></li>

                                <li class="group"><p><code>Object 	getObject(int parameterIndex)</code> -- 以 Java 编程语言中 Object 的形式获取指定参数的值</p></li>
                                <li><p><code>&lt;T> T 	getObject(int parameterIndex, Class&lt;T> type)</code> -- 指明类型</p></li>
                                <li><p><code>Object 	getObject(int parameterIndex, Map&lt;String,Class&lt;?>> map)</code> -- 返回一个表示 OUT 参数 parameterIndex 值的对象，并将 map 用于该参数值的自定义映射关系</p></li>
                                <li><p><code>Object 	getObject(String parameterName)</code> -- 以 Java 编程语言中 Object 的形式获取参数的值</p></li>
                                <li><p><code>&lt;T> T 	getObject(String parameterName, Class&lt;T> type)</code> -- 指明类型</p></li>
                                <li><p><code>Object 	getObject(String parameterName, Map&lt;String,Class&lt;?>> map)</code> -- 返回一个表示 OUT 参数 parameterName 值的对象，并将 map 用于该参数值的自定义映射关系</p></li>

                                <li class="group"><p><code>Ref 	getRef(int parameterIndex)</code> -- 以 Java 编程语言中 java.sql.Ref 对象的形式获取指定的 JDBC REF 参数的值</p></li>
                                <li><p><code>Ref 	getRef(String parameterName)</code> -- 以 Java 编程语言中 Ref 对象的形式获取 JDBC REF参数的值</p></li>

                                <li class="group"><p><code>RowId 	getRowId(int parameterIndex)</code> -- 以 java.sql.RowId 对象的形式获取指定 JDBC ROWID 参数的值</p></li>
                                <li><p><code>RowId 	getRowId(String parameterName)</code> -- 以 java.sql.RowId 对象的形式获取指定 JDBC ROWID 参数的值</p></li>

                                <li class="group"><p><code>SQLXML 	getSQLXML(int parameterIndex)</code> -- 以 java.sql.SQLXML 对象的形式获取指定的 SQL XML 参数的值</p></li>
                                <li><p><code>SQLXML 	getSQLXML(String parameterName)</code> -- 以 java.sql.SQLXML 对象的形式获取指定的 SQL XML 参数的值</p></li>


                                <li class="group"><p><code>void 	setBoolean(String parameterName, boolean x)</code> -- 将指定参数设置为给定 Java boolean 值</p></li>
                                <li><p><code>void 	setByte(String parameterName, byte x)</code> -- 将指定参数设置为给定 Java byte 值</p></li>
                                <li><p><code>void 	setShort(String parameterName, short x)</code> -- 将指定参数设置为给定 Java short 值</p></li>
                                <li><p><code>void 	setInt(String parameterName, int x)</code> -- 将指定参数设置为给定 Java int 值</p></li>
                                <li><p><code>void 	setLong(String parameterName, long x)</code> -- 将指定参数设置为给定 Java long 值</p></li>
                                <li><p><code>void 	setFloat(String parameterName, float x)</code> -- 将指定参数设置为给定 Java float 值</p></li>
                                <li><p><code>void 	setDouble(String parameterName, double x)</code> -- 将指定参数设置为给定 Java double 值</p></li>
                                <li><p><code>void 	setBigDecimal(String parameterName, BigDecimal x)</code> -- 将指定参数设置为给定 BigDecimal 值</p></li>
                                <li><p><code>void 	setString(String parameterName, String x)</code> -- 将指定参数设置为给定 String 值</p></li>
                                <li><p><code>void 	setNString(String parameterName, String value)</code> -- 将指定参数设置为给定 String 对象</p></li>

                                <li class="group"><p><code>void 	setTime(String parameterName, Time x)</code> -- 将指定参数设置为给定 java.sql.Time 值</p></li>
                                <li><p><code>void 	setTime(String parameterName, Time x, Calendar cal)</code> -- 使用给定的 Calendar 对象将指定参数设置为给定 java.sql.Time 值</p></li>
                                <li><p><code>void 	setTimestamp(String parameterName, Timestamp x)</code> -- 将指定参数设置为给定 java.sql.Timestamp 值</p></li>
                                <li><p><code>void 	setTimestamp(String parameterName, Timestamp x, Calendar cal)</code> -- 使用给定的 Calendar 对象将指定参数设置为给定 java.sql.Timestamp 值</p></li>
                                <li><p><code>void 	setDate(String parameterName, Date x)</code> -- 使用运行应用程序的虚拟机默认时区将参数设置为给定 java.sql.Date 值</p></li>
                                <li><p><code>void 	setDate(String parameterName, Date x, Calendar cal)</code> -- 使用给定的 Calendar 对象将指定参数设置为给定 java.sql.Date 值</p></li>

                                <li class="group"><p><code>void 	setBytes(String parameterName, byte[] x)</code> -- 将指定参数设置为给定 Java byte 数组</p></li>
                                <li><p><code>void 	setURL(String parameterName, URL val)</code> -- 将指定参数设置为给定 java.net.URL 对象</p></li>

                                <li class="group"><p><code>void 	setAsciiStream(String parameterName, InputStream x)</code> -- 将指定参数设置为给定输入流</p></li>
                                <li><p><code>void 	setAsciiStream(String parameterName, InputStream x, int length)</code> -- 将指定参数设置为给定输入流，该输入流将拥有指定的字节数</p></li>
                                <li><p><code>void 	setAsciiStream(String parameterName, InputStream x, long length)</code> -- 将指定参数设置为给定输入流，该输入流将拥有指定的字节数</p></li>

                                <li class="group"><p><code>void 	setBinaryStream(String parameterName, InputStream x)</code> -- 将指定参数设置为给定输入流</p></li>
                                <li><p><code>void 	setBinaryStream(String parameterName, InputStream x, int length)</code> -- 将指定参数设置为给定输入流，该输入流将拥有指定的字节数</p></li>
                                <li><p><code>void 	setBinaryStream(String parameterName, InputStream x, long length)</code> -- 将指定参数设置为给定输入流，该输入流将拥有指定字节数</p></li>

                                <li class="group"><p><code>void 	setBlob(String parameterName, Blob x)</code> -- 将指定参数设置为给定的 java.sql.Blob 对象</p></li>
                                <li><p><code>void 	setBlob(String parameterName, InputStream inputStream)</code> -- 将指定参数设置为 InputStream 对象</p></li>
                                <li><p><code>void 	setBlob(String parameterName, InputStream inputStream, long length)</code> -- 将指定参数设置为 InputStream 对象</p></li>

                                <li class="group"><p><code>void 	setCharacterStream(String parameterName, Reader reader)</code> --  将指定参数设置为给定 Reader 对象</p></li>
                                <li><p><code>void 	setCharacterStream(String parameterName, Reader reader, int length)</code> -- 将指定参数设置为给定 Reader 对象，该对象是给定的字符长度数</p></li>
                                <li><p><code>void 	setCharacterStream(String parameterName, Reader reader, long length)</code> -- 将指定参数设置为给定 Reader 对象，该对象具有给定字符数长度</p></li>
                                <li><p><code>void 	setNCharacterStream(String parameterName, Reader value)</code> -- 将指定参数设置为 Reader 对象</p></li>
                                <li><p><code>void 	setNCharacterStream(String parameterName, Reader value, long length)</code> -- 将指定参数设置为 Reader 对象</p></li>

                                <li class="group"><p><code>void 	setClob(String parameterName, Clob x)</code> -- 将指定参数设置为给定的 java.sql.Clob 对象</p></li>
                                <li><p><code>void 	setClob(String parameterName, Reader reader)</code> -- 将指定参数设置为 Reader 对象</p></li>
                                <li><p><code>void 	setClob(String parameterName, Reader reader, long length)</code> -- 将指定参数设置为 Reader 对象</p></li>
                                <li><p><code>void 	setNClob(String parameterName, NClob value)</code> -- 将指定参数设置为 java.sql.NClob 对象</p></li>
                                <li><p><code>void 	setNClob(String parameterName, Reader reader)</code> -- 将指定参数设置为 Reader 对象</p></li>
                                <li><p><code>void 	setNClob(String parameterName, Reader reader, long length)</code> -- 将指定参数设置为 Reader 对象</p></li>

                                <li class="group"><p><code>void 	setNull(String parameterName, int sqlType)</code> -- 将指定参数设置为 SQL NULL</p></li>
                                <li><p><code>void 	setNull(String parameterName, int sqlType, String typeName)</code> -- 将指定参数设置为 SQL NULL</p></li>

                                <li class="group"><p><code>void 	setObject(String parameterName, Object x)</code> -- 使用给定对象设置指定参数的值</p></li>
                                <li><p><code>void 	setObject(String parameterName, Object x, int targetSqlType)</code> -- 使用给定对象设置指定参数的值</p></li>
                                <li><p><code>void 	setObject(String parameterName, Object x, int targetSqlType, int scale)</code> -- 使用给定对象设置指定参数的值</p></li>
                                <li><p><code>default void 	setObject(String parameterName, Object x, SQLType targetSqlType)</code> -- SQLType 替代了 int 类型的 sqlType</p></li>
                                <li><p><code>default void 	setObject(String parameterName, Object x, SQLType targetSqlType, int scaleOrLength)</code> -- SQLType 替代了 int 类型的 sqlType</p></li>

                                <li class="group"><p><code>void 	setRowId(String parameterName, RowId x)</code> -- 将指定参数设置为给定 java.sql.RowId 对象</p></li>
                                <li><p><code>void 	setSQLXML(String parameterName, SQLXML xmlObject)</code> -- 将指定参数设置为给定 java.sql.SQLXML 对象</p></li>

                                <li class="group"><p><code>void 	registerOutParameter(int parameterIndex, int sqlType)</code> -- 按顺序位置 parameterIndex 将 OUT 参数注册为 JDBC 类型 sqlType</p></li>
                                <li><p><code>void 	registerOutParameter(int parameterIndex, int sqlType, int scale)</code> -- 按顺序位置 parameterIndex 将参数注册为 JDBC 类型 sqlType</p></li>
                                <li><p><code>void 	registerOutParameter(int parameterIndex, int sqlType, String typeName)</code> -- 注册指定的输出参数</p></li>
                                <li><p><code>default void 	registerOutParameter(int parameterIndex, SQLType sqlType)</code> -- SQLType 替代了 int 类型的 sqlType</p></li>
                                <li><p><code>default void 	registerOutParameter(int parameterIndex, SQLType sqlType, int scale)</code> -- SQLType 替代了 int 类型的 sqlType</p></li>
                                <li><p><code>default void 	registerOutParameter(int parameterIndex, SQLType sqlType, String typeName)</code> -- SQLType 替代了 int 类型的 sqlType</p></li>
                                <li><p><code>void 	registerOutParameter(String parameterName, int sqlType)</code> -- 将名为 parameterName 的 OUT 参数注册为 JDBC 类型 sqlType</p></li>
                                <li><p><code>void 	registerOutParameter(String parameterName, int sqlType, int scale)</code> -- 将名为 parameterName 的参数注册为 JDBC 类型 sqlType</p></li>
                                <li><p><code>void 	registerOutParameter(String parameterName, int sqlType, String typeName)</code> -- 注册指定的输出参数</p></li>
                                <li><p><code>default void 	registerOutParameter(String parameterName, SQLType sqlType)</code> -- SQLType 替代了 int 类型的 sqlType</p></li>
                                <li><p><code>default void 	registerOutParameter(String parameterName, SQLType sqlType, int scale)</code> -- SQLType 替代了 int 类型的 sqlType</p></li>
                                <li><p><code>default void 	registerOutParameter(String parameterName, SQLType sqlType, String typeName)</code> -- SQLType 替代了 int 类型的 sqlType</p></li>

                                <li class="group"><p><code>boolean 	wasNull()</code> -- 查询最后一个读取的 OUT 参数是否为 SQL NULL</p></li>
                            </ol>
                        </div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-sql-ResultSet"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">ResultSet 及子接口</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
                            <div class="split-item">
								<p><b>ResultSet 接口及相关类实例</b></p>
								<p><a href="#ResultSet">java.sql.ResultSet</a> -- 默认的结果集只能前向遍历,并且不能更新</p>
								<p><s10 />└─ <a href="#RowSet">RowSet</a> -- 支持适合于 JavaBeans 组件模型的 JDBC API</p>
								<p><s40 />├─ <a href="#JdbcRowSet">JdbcRowSet</a> -- 让 ResultSet 对象可滚动和可更新</p>
								<p><s40 />├─ <a href="#CachedRowSet">CachedRowSet</a> -- 内存缓存，提供了不用一直保持连接数据源而操作数据的能力</p>
								<p><s40 />├ <s20 />└─ <a href="#WebRowSet">WebRowSet</a> -- 输出到 XML 和使用有效的 XML 作为输入</p>
								<p><s40 />├ <s50 />├─ <a href="#FilteredRowSet">FilteredRowSet</a> -- 对其内容进行某种程度的过滤</p>
								<p><s40 />├ <s50 />└─ <a href="#JoinRowSet">JoinRowSet</a> -- 联合多个相关结果集</p>
								<p><s40 />└─ <a href="#SyncResolver">SyncResolver</a> -- 定义一个框架，当发生同步冲突时，它允许应用程序使用手工决策树来确定应该执行的操作</p>
								<p><a href="#Predicate">Predicate</a> -- FilteredRowSet 的过滤器</p>
								<p><a href="#Joinable">Joinable</a> -- 实现此接口的 ResultSet 可加入 JoinRowSet</p>
                            </div>

                            <div class="split-item">
                                <p>直接使用 ResultSet:</p>
                                <pre class="brush: java;">
// Statement 必须为可更新的，ResultSet 才能调用 update 相关方法
Statement statement = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
ResultSet rs = statement.executeQuery("select * from bonecp limit 10;");
while(rs.next()) {
    int id = rs.getInt(1);
    if(id == 5) {
        rs.updateString(2, "nate");
        rs.updateString(3, "http://d.lesson1234.com");
        rs.updateRow();
    }
    log(id, rs.getString(2), rs.getString(3));
}
</pre>
                            </div>

                            <div class="split-item">
                                <p>使用 RowSet 及子类:</p>
                                <pre class="brush: java;">
// 推荐使用先使用 RowSetProvider 构建 RowSetFactory， 再构建相应的 RowSet，实现类来自 com.sun.rowset 包
RowSetFactory factory = RowSetProvider.newFactory(); // 实现类: com.sun.rowset.RowSetFactoryImpl
JdbcRowSet jdbcRowSet = factory.createJdbcRowSet(); // 实现类: com.sun.rowset.JdbcRowSetImpl
CachedRowSet cachedRowSet = factory.createCachedRowSet(); // 实现类: com.sun.rowset.CachedRowSetImpl
WebRowSet webRowSet = factory.createWebRowSet(); // 实现类: com.sun.rowset.WebRowSetImpl
JoinRowSet joinRowSet = factory.createJoinRowSet(); // 实现类: com.sun.rowset.JoinRowSetImpl
FilteredRowSet filteredRowSet = factory.createFilteredRowSet(); // 实现类: com.sun.rowset.FilteredRowSetImpl

// javax.sql.rowset.spi.SyncResolver 类工厂未提供构建方法
SyncResolver syncResolver = new SyncResolverImpl();

// 使用实例 JdbcRowSet：
compile 'mysql:mysql-connector-java:8.0.11' // 1.要导入驱动包

RowSetFactory factory = RowSetProvider.newFactory(); // 2. 构建 RowSetFactory
JdbcRowSet jrs = factory.createJdbcRowSet(); // 3.构建 JdbcRowSet
jrs.setUrl(url); // 数据库连接 url
jrs.setUsername(user); // 数据库用户名
jrs.setPassword(password); // 数据库密码
jrs.setCommand("select * from bonecp limit 10;"); // sql 查询语句
jrs.execute(); // 执行 sql

while(jrs.next()) {
    log(jrs.getInt(1), jrs.getString(2), jrs.getString(3));
}
</pre>
                            </div>
                        </div>

                        <div class="sub-item">
                            <a id="ResultSet" class="offset"></a>
                            <pre class="brush: java;">
public interface ResultSet extends Wrapper, AutoCloseable {
    int FETCH_FORWARD = 1000; // 该常量指示将按正向（即从第一个到最后一个）处理结果集中的行
    int FETCH_REVERSE = 1001; // 该常量指示将按逆向（即从最后一个到第一个）处理结果集中的行处理
    int FETCH_UNKNOWN = 1002; // 该常量指示结果集中的行的处理顺序未知

    int TYPE_FORWARD_ONLY = 1003; // 该常量指示光标只能向前移动的 ResultSet 对象的类型
    int TYPE_SCROLL_INSENSITIVE = 1004; // 指示可滚动但通常不受 ResultSet 底层数据更改影响的 ResultSet 对象的类型
    int TYPE_SCROLL_SENSITIVE = 1005; // 指示可滚动并且通常受 ResultSet 底层数据更改影响的 ResultSet 对象的类型

    int CONCUR_READ_ONLY = 1007; // 该常量指示不可以更新的 ResultSet 对象的并发模式
    int CONCUR_UPDATABLE = 1008; // 该常量指示可以更新的 ResultSet 对象的并发模式

    int HOLD_CURSORS_OVER_COMMIT = 1; // 该常量指示提交当前事务时，具有此可保存性的打开的 ResultSet 对象将保持开放
    int CLOSE_CURSORS_AT_COMMIT = 2; // 该常量指示提交当前事务时，具有此可保存性的打开的 ResultSet 对象将被关闭
}
</pre>
                            <p><a href="docs/docs-java/api/java/sql/ResultSet.html" target="_blank">ResultSet</a> 表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。</p>
                            <p>ResultSet 对象具有指向其当前数据行的光标。最初，光标被置于第一行之前。next 方法将光标移动到下一行；因为该方法在 ResultSet 对象没有下一行时返回 false，所以可以在 while 循环中使用它来迭代结果集。 </p>
                            <p>默认的 ResultSet 对象不可更新，仅有一个向前移动的光标。因此，只能迭代它一次，并且只能按从第一行到最后一行的顺序进行。可以生成可滚动和/或可更新的 ResultSet 对象。如下代码：</p>
                            <pre class="brush: java;">
...
Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
ResultSet rs = stmt.executeQuery("SELECT * FROM table_x;");
...
</pre>
                            <p>ResultSet 接口提供用于从当前行获取列值的获取 方法（getBoolean、getLong 等）。可以使用列的索引编号或列的名称获取值。一般情况下，使用列索引较为高效。列从 1 开始编号。为了获得最大的可移植性，应该按从左到右的顺序读取每行中的结果集列，每列只能读取一次。</p>
                            <p>对于获取方法，JDBC 驱动程序尝试将底层数据转换为在获取方法中指定的 Java 类型，并返回适当的 Java 值。JDBC 规范有一个表，显示允许的从 SQL 类型到 ResultSet 获取方法所使用的 Java 类型的映射关系。 </p>
                            <p>用作获取方法的输入的列名称不区分大小写。用列名称调用获取方法时，如果多个列具有这一名称，则返回第一个匹配列的值。在生成结果集的 SQL 查询中使用列名称时，将使用列名称选项。对于没有在查询中显式指定的列，最好使用列编号。如果使用列名称，则程序员应该注意保证名称唯一引用预期的列，这可以使用 SQL AS 子句确定。 </p>
                            <p>当生成 ResultSet 对象的 Statement 对象关闭、重新执行或用来从多个结果的序列获取下一个结果时，ResultSet 对象将自动关闭。 </p>
                            <p>ResultSet 对象的列的编号、类型和属性由 ResultSet.getMetaData 方法返回的 ResulSetMetaData 对象提供。</p>
                            <ol>
                                <li><p><code>boolean 	next()</code> -- 将光标从当前位置向前移一行</p></li>
                                <li><p><code>boolean 	previous()</code> -- 将光标移动到此 ResultSet 对象的上一行</p></li>
                                <li><p><code>boolean 	first()</code> -- 将光标移动到此 ResultSet 对象的第一行</p></li>
                                <li><p><code>boolean 	isFirst()</code> --  获取光标是否位于此 ResultSet 对象的第一行</p></li>
                                <li><p><code>void 	beforeFirst()</code> -- 将光标移动到此 ResultSet 对象的开头，正好位于第一行之前</p></li>
                                <li><p><code>boolean 	isBeforeFirst()</code> -- 获取光标是否位于此 ResultSet 对象的第一行之</p></li>
                                <li><p><code>boolean 	last()</code> -- 将光标移动到此 ResultSet 对象的最后一行</p></li>
                                <li><p><code>boolean 	isLast()</code> -- 获取光标是否位于此 ResultSet 对象的最后一行</p></li>
                                <li><p><code>void 	afterLast()</code> -- 将光标移动到此 ResultSet 对象的末尾，正好位于最后一行之后</p></li>
                                <li><p><code>boolean 	isAfterLast()</code> -- 获取光标是否位于此 ResultSet 对象的最后一行之后</p></li>
                                <li><p><code>boolean 	absolute(int row)</code> -- 将光标移动到此 ResultSet 对象的给定行编号</p></li>
                                <li><p><code>boolean 	relative(int rows)</code> -- 按相对行数（或正或负）移动光标</p></li>
                                <li><p><code>int 	findColumn(String columnLabel)</code> -- 将给定的 ResultSet 列标签映射到其 ResultSet 列索引</p></li>

                                <li class="group"><p><code>boolean 	isClosed()</code> -- 获取此 ResultSet 对象是否已关闭</p></li>
                                <li><p><code>void 	close()</code> -- 立即释放此 ResultSet 对象的数据库和 JDBC 资源，而不是等待该对象自动关闭时发生此操作</p></li>

                                <li class="group"><p><code>void 	clearWarnings()</code> -- 清除在此 ResultSet 对象上报告的所有警</p></li>
                                <li><p><code>SQLWarning 	getWarnings()</code> -- 获取此 ResultSet 对象上的调用报告的第一个警告</p></li>
                                <li><p><code>int 	getType()</code> -- 获取此 ResultSet 对象的类型，返回值为：<code>TYPE_FORWARD_ONLY</code>、<code>TYPE_SCROLL_INSENSITIVE</code> or <code>TYPE_SCROLL_SENSITIVE</code></p></li>

                                <li class="group"><p><code>int 	getRow()</code> -- 获取当前行编号</p></li>
                                <li><p><code>void 	insertRow()</code> -- 将插入行的内容插入到此 ResultSet 对象和数据库中</p></li>
                                <li><p><code>void 	updateRow()</code> -- 用此 ResultSet 对象的当前行的新内容更新底层数据库</p></li>
                                <li><p><code>void 	deleteRow()</code> -- 从此 ResultSet 对象和底层数据库中删除当前行</p></li>
                                <li><p><code>void 	refreshRow()</code> -- 用数据库中的最近值刷新当前行</p></li>
                                <li><p><code>void 	cancelRowUpdates()</code> -- 取消对 ResultSet 对象中的当前行所作的更新</p></li>
                                <li><p><code>void 	moveToInsertRow()</code> -- 将光标移动到插入行</p></li>
                                <li><p><code>void 	moveToCurrentRow()</code> -- 将光标移动到记住的光标位置，通常为当前行</p></li>

                                <li class="group"><p><code>boolean 	rowDeleted()</code> -- 获取是否已删除某行</p></li>
                                <li><p><code>boolean 	rowInserted()</code> -- 获取当前行是否已有插入</p></li>
                                <li><p><code>boolean 	rowUpdated()</code> -- 获取是否已更新当前行</p></li>

                                <li class="group"><p><code>void 	setFetchDirection(int direction)</code> -- 设置此 ResultSet 对象中行的处理方向</p></li>
                                <li><p><code>int 	getFetchDirection()</code> -- 获取处理方向，返回值为：<code>FETCH_FORWARD</code>, <code>FETCH_REVERSE</code>, or <code>FETCH_UNKNOWN</code></p></li>
                                <li><p><code>int 	getFetchSize()</code> -- 获取此 ResultSet 对象的获取大小</p></li>
                                <li><p><code>void 	setFetchSize(int rows)</code> -- 设置此 ResultSet 对象的获取大小</p></li>

                                <li class="group"><p><code>boolean 	wasNull()</code> -- 报告最后一个读取的列是否具有值 SQL NULL</p></li>
                                <li><p><code>int 	getHoldability()</code> -- 获取可保存性，返回值为: <code>HOLD_CURSORS_OVER_COMMIT</code>  or <code>CLOSE_CURSORS_AT_COMMIT</code></p></li>
                                <li><p><code>int 	getConcurrency()</code> -- 获取此 ResultSet 对象的并发模式，返回值为: <code>CONCUR_READ_ONLY</code> or <code>CONCUR_UPDATABLE</code></p></li>
                                <li><p><code>String 	getCursorName()</code> -- 获取此 ResultSet 对象使用的 SQL 光标的名称</p></li>
                                <li><p><code>ResultSetMetaData 	getMetaData()</code> -- 获取此 ResultSet 对象的列的编号、类型和属性</p></li>
                                <li><p><code>Statement 	getStatement()</code> -- 获取生成此 ResultSet 对象的 Statement 对象</p></li>

                                <li class="group"><p><code>boolean 	getBoolean(int columnIndex)</code> -- 以 boolean 值的形式获取指定的 JDBC BIT 或 BOOLEAN 参数的值</p></li>
                                <li><p><code>boolean 	getBoolean(String columnLabel)</code> -- 以 boolean 值的形式获取 JDBC BIT 或 BOOLEAN 参数的值</p></li>
                                <li><p><code>byte 	getByte(int columnIndex)</code> -- 以 byte 的形式获取指定的 JDBC TINYINT 参数的值</p></li>
                                <li><p><code>byte 	getByte(String columnLabel)</code> -- 以 byte 的形式获取指定的 JDBC TINYINT 参数的值</p></li>
                                <li><p><code>short 	getShort(int columnIndex)</code> -- 以 short 值的形式获取指定的 JDBC SMALLINT 参数的值</p></li>
                                <li><p><code>short 	getShort(String columnLabel)</code> -- 以 short 值的形式获取指定的 JDBC SMALLINT 参数的值</p></li>
                                <li><p><code>int 	getInt(int columnIndex)</code> -- 以 int 值的形式获取指定的 JDBC INTEGER 参数的值</p></li>
                                <li><p><code>int 	getInt(String columnLabel)</code> -- 以 int 值的形式获取指定的 JDBC INTEGER 参数的值</p></li>
                                <li><p><code>long 	getLong(int columnIndex)</code> -- 以 long 值的形式获取指定的 JDBC BIGINT 参数的值</p></li>
                                <li><p><code>long 	getLong(String columnLabel)</code> -- 以 long 值的形式获取指定的 JDBC BIGINT 参数的值</p></li>
                                <li><p><code>float 	getFloat(int columnIndex)</code> -- 以 float 值的形式获取指定的 JDBC FLOAT 参数的值</p></li>
                                <li><p><code>float 	getFloat(String columnLabel)</code> -- 以 float 值的形式获取指定的 JDBC FLOAT 参数的值</p></li>
                                <li><p><code>double 	getDouble(int columnIndex)</code> -- 以 double 值的形式获取指定的 JDBC DOUBLE 参数的值</p></li>
                                <li><p><code>double 	getDouble(String columnLabel)</code> -- 以 double 值的形式获取指定的 JDBC DOUBLE 参数的值</p></li>
                                <li><p><code>BigDecimal 	getBigDecimal(int columnIndex)</code> -- 以 java.math.BigDecimal 对象的形式获取指定 JDBC NUMERIC 参数的值，小数点右边的位数与该参数值所包含的位数相同</p></li>
                                <li><p><code>BigDecimal 	getBigDecimal(String columnLabel)</code> -- 以 java.math.BigDecimal 对象的形式获取 JDBC NUMERIC 参数的值，小数点右边的位数与该参数值所包含的位数相同</p></li>
                                <li><p><code>String 	getString(int columnIndex)</code> -- 以 Java 编程语言中 String 的形式获取指定的 JDBC CHAR、VARCHAR 或 LONGVARCHAR 参数的</p></li>
                                <li><p><code>String 	getString(String columnLabel)</code> -- 以 Java 编程语言中 String 的形式获取指定的 JDBC CHAR、VARCHAR 或 LONGVARCHAR 参数的</p></li>
                                <li><p><code>String 	getNString(int columnIndex)</code> -- 以 Java 编程语言中 String 的形式获取指定的 NCHAR、NVARCHAR 或 LONGNVARCHAR 参数的值</p></li>
                                <li><p><code>String 	getNString(String columnLabel)</code> -- 以 Java 编程语言中 String 的形式获取指定的 NCHAR、NVARCHAR 或 LONGNVARCHAR 参数的值</p></li>

                                <li class="group"><p><code>Date 	getDate(int columnIndex)</code> -- 以 java.sql.Date 对象的形式获取指定 JDBC DATE 参数的值</p></li>
                                <li><p><code>Date 	getDate(int columnIndex, Calendar cal)</code> -- 以 java.sql.Date 对象的形式获取指定 JDBC DATE 参数的值，使用给定 Calendar 对象构造日期</p></li>
                                <li><p><code>Date 	getDate(String columnLabel)</code> -- 以 java.sql.Date 对象的形式获取 JDBC DATE 参数的值</p></li>
                                <li><p><code>Date 	getDate(String columnLabel, Calendar cal)</code> -- 以 java.sql.Date 对象的形式获取 JDBC DATE 参数的值，使用给定 Calendar 对象构造日期</p></li>

                                <li class="group"><p><code>Time 	getTime(int columnIndex)</code> -- 以 java.sql.Time 对象的形式获取指定 JDBC TIME 参数的值</p></li>
                                <li><p><code>Time 	getTime(int columnIndex, Calendar cal)</code> -- 以 java.sql.Time 对象的形式获取指定 JDBC TIME 参数的值，使用给定 Calendar 对象构造时间</p></li>
                                <li><p><code>Time 	getTime(String columnLabel)</code> -- 以 java.sql.Time 对象的形式获取 JDBC TIME 参数的值</p></li>
                                <li><p><code>Time 	getTime(String columnLabel, Calendar cal)</code> -- 以 java.sql.Time 对象的形式获取 JDBC TIME 参数的值，使用给定 Calendar 对象构造时间</p></li>

                                <li class="group"><p><code>Timestamp 	getTimestamp(int columnIndex)</code> -- 以 java.sql.Timestamp 对象的形式获取指定 JDBC TIMESTAMP 参数的值</p></li>
                                <li><p><code>Timestamp 	getTimestamp(int columnIndex, Calendar cal)</code> -- 以 java.sql.Timestamp 对象的形式获取指定 JDBC TIMESTAMP 参数的值，使用给定 Calendar 对象构造 Timestamp 对象</p></li>
                                <li><p><code>Timestamp 	getTimestamp(String columnLabel)</code> -- 以 java.sql.Timestamp 对象的形式获取 JDBC TIMESTAMP 参数的值</p></li>
                                <li><p><code>Timestamp 	getTimestamp(String columnLabel, Calendar cal)</code> -- 以 java.sql.Timestamp 对象的形式获取 JDBC TIMESTAMP 参数的值，使用给定 Calendar 对象构造 Timestamp 对象</p></li>

                                <li class="group"><p><code>byte[] 	getBytes(int columnIndex)</code> -- 以 byte 数组值的形式获取指定的 JDBC BINARY 或 VARBINARY 参数的值</p></li>
                                <li><p><code>byte[] 	getBytes(String columnLabel)</code> -- 以 byte 数组值的形式获取 JDBC BINARY 或 VARBINARY 参数的值</p></li>
                                <li><p><code>URL 	getURL(int columnIndex)</code> -- 以 java.net.URL 对象的形式获取指定 JDBC DATALINK 参数的值</p></li>
                                <li><p><code>URL 	getURL(String columnLabel)</code> -- 以 java.net.URL 对象的形式获取 JDBC DATALINK 参数的值</p></li>
                                <li><p><code>Array 	getArray(int columnIndex)</code> -- 以 Java 编程语言中 java.sql.Array 对象的形式获取指定的 JDBC ARRAY 参数的值</p></li>
                                <li><p><code>Array 	getArray(String columnLabel)</code> -- 以 Java 编程语言中 java.sql.ARRAY 对象的形式获取 JDBC ARRAY 参数的值</p></li>

                                <li class="group"><p><code>Blob 	getBlob(int columnIndex)</code> -- 以 Java 编程语言中 java.sql.Blob 对象的形式获取指定的 JDBC CLOB 参数的值</p></li>
                                <li><p><code>Blob 	getBlob(String columnLabel)</code> -- 以 Java 编程语言中 java.sql.Blob 对象的形式获取 JDBC BLOB 参数的值</p></li>
                                <li><p><code>Clob 	getClob(int columnIndex)</code> -- 以 Java 编程语言中 java.sql.Clob 对象的形式获取指定的 JDBC CLOB 参数的值</p></li>
                                <li><p><code>Clob 	getClob(String columnLabel)</code> -- 以 Java 编程语言中 java.sql.Clob 对象的形式获取 JDBC CLOB 参数的值</p></li>
                                <li><p><code>NClob 	getNClob(int columnIndex)</code> -- 以 Java 编程语言中 java.sql.NClob 对象的形式获取指定的 JDBC NCLOB 参数的值</p></li>
                                <li><p><code>NClob 	getNClob(String columnLabel)</code> -- 以 Java 编程语言中 java.sql.NClob 对象的形式获取 JDBC NCLOB 参数的值</p></li>

                                <li class="group"><p><code>Object 	getObject(int columnIndex)</code> -- 以 Java 编程语言中 Object 的形式获取指定参数的值</p></li>
                                <li><p><code>&lt;T> T 	getObject(int columnIndex, Class&lt;T> type)</code> -- 指明类型</p></li>
                                <li><p><code>Object 	getObject(int columnIndex, Map&lt;String,Class&lt;?>> map)</code> -- 返回一个表示 OUT 参数 parameterIndex 值的对象，并将 map 用于该参数值的自定义映射关系</p></li>
                                <li><p><code>Object 	getObject(String columnLabel)</code> -- 以 Java 编程语言中 Object 的形式获取参数的值</p></li>
                                <li><p><code>&lt;T> T 	getObject(String columnLabel, Class&lt;T> type)</code> -- 指明类型</p></li>
                                <li><p><code>Object 	getObject(String columnLabel, Map&lt;String,Class&lt;?>> map)</code> -- 返回一个表示 OUT 参数 parameterName 值的对象，并将 map 用于该参数值的自定义映射关系</p></li>

                                <li class="group"><p><code>Ref 	getRef(int columnIndex)</code> -- 以 Java 编程语言中 java.sql.Ref 对象的形式获取指定的 JDBC REF 参数的值</p></li>
                                <li><p><code>Ref 	getRef(String columnLabel)</code> -- 以 Java 编程语言中 Ref 对象的形式获取 JDBC REF参数的值</p></li>

                                <li class="group"><p><code>RowId 	getRowId(int columnIndex)</code> -- 以 java.sql.RowId 对象的形式获取指定 JDBC ROWID 参数的值</p></li>
                                <li><p><code>RowId 	getRowId(String columnLabel)</code> -- 以 java.sql.RowId 对象的形式获取指定 JDBC ROWID 参数的值</p></li>

                                <li class="group"><p><code>SQLXML 	getSQLXML(int columnIndex)</code> -- 以 Java 编程语言中 java.sql.SQLXML 对象的形式获取指定的 SQL XML 参数的值</p></li>
                                <li><p><code>SQLXML 	getSQLXML(String columnLabel)</code> -- 以 java.sql.SQLXML 对象的形式获取指定的 SQL XML 参数的值</p></li>

                                <li class="group"><p><code>InputStream 	getAsciiStream(int columnIndex)</code> -- 以 ASCII 字符流的形式获取此 ResultSet 对象的当前行中指定列的值</p></li>
                                <li><p><code>InputStream 	getAsciiStream(String columnLabel)</code> -- 以 ASCII 字符流的形式获取此 ResultSet 对象的当前行中指定列的值</p></li>
                                <li><p><code>InputStream 	getBinaryStream(int columnIndex)</code> -- 以未解释字节的流的形式获取此 ResultSet 对象的当前行中指定列的值</p></li>
                                <li><p><code>InputStream 	getBinaryStream(String columnLabel)</code> -- 以未解释的 byte 流的形式获取此 ResultSet 对象的当前行中指定列的值</p></li>
                                <li><p><code>Reader 	getCharacterStream(int columnIndex)</code> -- 以 Java 编程语言中 java.io.Reader 对象的形式获取指定参数的值</p></li>
                                <li><p><code>Reader 	getCharacterStream(String columnLabel)</code> -- 以 Java 编程语言中 java.io.Reader 对象的形式获取指定参数的值</p></li>
                                <li><p><code>Reader 	getNCharacterStream(int columnIndex)</code> -- 以 Java 编程语言中 java.io.Reader 对象的形式获取指定参数的值</p></li>
                                <li><p><code>Reader 	getNCharacterStream(String columnLabel)</code> -- 以 Java 编程语言中 java.io.Reader 对象的形式获取指定参数的值</p></li>

                                <li class="group"><p><code>void 	updateBoolean(int columnIndex, boolean x)</code> -- 用 boolean 值更新指定列</p></li>
                                <li><p><code>void 	updateBoolean(String columnLabel, boolean x)</code> -- 用 boolean 值更新指定列</p></li>
                                <li><p><code>void 	updateByte(int columnIndex, byte x)</code> -- 用 byte 值更新指定列</p></li>
                                <li><p><code>void 	updateByte(String columnLabel, byte x)</code> -- 用 byte 值更新指定列</p></li>
                                <li><p><code>void 	updateShort(int columnIndex, short x)</code> -- 用 short 值更新指定列</p></li>
                                <li><p><code>void 	updateShort(String columnLabel, short x)</code> -- 用 short 值更新指定列</p></li>
                                <li><p><code>void 	updateInt(int columnIndex, int x)</code> -- 用 int 值更新指定列</p></li>
                                <li><p><code>void 	updateInt(String columnLabel, int x)</code> -- 用 int 值更新指定列</p></li>
                                <li><p><code>void 	updateLong(int columnIndex, long x)</code> -- 用 long 值更新指定列</p></li>
                                <li><p><code>void 	updateLong(String columnLabel, long x)</code> -- 用 long 值更新指定列</p></li>
                                <li><p><code>void 	updateFloat(int columnIndex, float x)</code> -- 用 float 值更新指定列</p></li>
                                <li><p><code>void 	updateFloat(String columnLabel, float x)</code> -- 用 float 值更新指定列</p></li>
                                <li><p><code>void 	updateDouble(int columnIndex, double x)</code> -- 用 double 值更新指定列</p></li>
                                <li><p><code>void 	updateDouble(String columnLabel, double x)</code> -- 用 double 值更新指定列</p></li>
                                <li><p><code>void 	updateBigDecimal(int columnIndex, BigDecimal x)</code> -- 用 java.math.BigDecimal 值更新指定列</p></li>
                                <li><p><code>void 	updateBigDecimal(String columnLabel, BigDecimal x)</code> -- 用 java.math.BigDecimal 值更新指定列</p></li>
                                <li><p><code>void 	updateString(int columnIndex, String x)</code> -- 用 String 值更新指定的列</p></li>
                                <li><p><code>void 	updateString(String columnLabel, String x)</code> -- 用 String 值更新指定的列</p></li>
                                <li><p><code>void 	updateNString(int columnIndex, String nString)</code> -- 用 String 值更新指定的列</p></li>
                                <li><p><code>void 	updateNString(String columnLabel, String nString)</code> -- 用 String 值更新指定的列</p></li>
                                <li><p><code>void 	updateNull(int columnIndex)</code> -- 用 null 值更新指定列</p></li>
                                <li><p><code>void 	updateNull(String columnLabel)</code> -- 用 null 值更新指定列</p></li>

                                <li class="group"><p><code>void 	updateBytes(int columnIndex, byte[] x)</code> -- 用 byte 数组值更新指定列</p></li>
                                <li><p><code>void 	updateBytes(String columnLabel, byte[] x)</code> -- 用字节数组值更新指定列</p></li>
                                <li><p><code>void 	updateArray(int columnIndex, Array x)</code> -- 用 java.sql.Array 值更新指定列</p></li>
                                <li><p><code>void 	updateArray(String columnLabel, Array x)</code> -- 用 java.sql.Array 值更新指定列</p></li>

                                <li class="group"><p><code>void 	updateDate(int columnIndex, Date x)</code> -- 用 java.sql.Date 值更新指定列</p></li>
                                <li><p><code>void 	updateDate(String columnLabel, Date x)</code> -- 用 java.sql.Date 值更新指定列</p></li>
                                <li><p><code>void 	updateTime(int columnIndex, Time x)</code> -- 用 java.sql.Time 值更新指定列</p></li>
                                <li><p><code>void 	updateTime(String columnLabel, Time x)</code> -- 用 java.sql.Time 值更新指定列</p></li>
                                <li><p><code>void 	updateTimestamp(int columnIndex, Timestamp x)</code> -- 用 java.sql.Timestamp 值更新指定列</p></li>
                                <li><p><code>void 	updateTimestamp(String columnLabel, Timestamp x)</code> -- 用 java.sql.Timestamp 值更新指定列</p></li>

                                <li class="group"><p><code>void 	updateBlob(int columnIndex, Blob x)</code> -- 用 java.sql.Blob 值更新指定列</p></li>
                                <li><p><code>void 	updateBlob(int columnIndex, InputStream inputStream)</code> -- 使用给定输入流值更新指定列</p></li>
                                <li><p><code>void 	updateBlob(int columnIndex, InputStream inputStream, long length)</code> -- 使用给定输入流更新指定的列，该流将具有指定的字节数</p></li>
                                <li><p><code>void 	updateBlob(String columnLabel, Blob x)</code> -- 用 java.sql.Blob 值更新指定列</p></li>
                                <li><p><code>void 	updateBlob(String columnLabel, InputStream inputStream)</code> -- 使用给定输入流值更新指定列</p></li>
                                <li><p><code>void 	updateBlob(String columnLabel, InputStream inputStream, long length)</code> -- 使用给定输入流更新指定列，该流将具有指定的字节数</p></li>

                                <li class="group"><p><code>void 	updateClob(int columnIndex, Clob x)</code> -- 用 java.sql.Clob 值更新指定列</p></li>
                                <li><p><code>void 	updateClob(int columnIndex, Reader reader)</code> -- 使用给定的 Reader 对象更新指定列</p></li>
                                <li><p><code>void 	updateClob(int columnIndex, Reader reader, long length)</code> -- 使用给定的 Reader 对象更新指定列，该对象是给定的字符长度数目</p></li>
                                <li><p><code>void 	updateClob(String columnLabel, Clob x)</code> -- 用 java.sql.Clob 值更新指定列</p></li>
                                <li><p><code>void 	updateClob(String columnLabel, Reader reader)</code> -- 使用给定的 Reader 对象更新指定列</p></li>
                                <li><p><code>void 	updateClob(String columnLabel, Reader reader, long length)</code> -- 使用给定的 Reader 对象更新指定列，该对象是给定的字符长度数目</p></li>

                                <li class="group"><p><code>void 	updateNClob(int columnIndex, NClob nClob)</code> -- 用 java.sql.NClob 值更新指定的列</p></li>
                                <li><p><code>void 	updateNClob(int columnIndex, Reader reader)</code> -- 使用给定的 Reader 对象更新指定列</p></li>
                                <li><p><code>void 	updateNClob(int columnIndex, Reader reader, long length)</code> -- 使用给定的 Reader 对象更新指定的列，该对象是给定的字符长度数目</p></li>
                                <li><p><code>void 	updateNClob(String columnLabel, NClob nClob)</code> -- 用 java.sql.NClob 值更新指定的列</p></li>
                                <li><p><code>void 	updateNClob(String columnLabel, Reader reader)</code> -- 使用给定的 Reader 对象更新指定列</p></li>
                                <li><p><code>void 	updateNClob(String columnLabel, Reader reader, long length)</code> -- 使用给定的 Reader 对象更新指定的列，该对象是给定的字符长度数目</p></li>

                                <li class="group"><p><code>void 	updateRef(int columnIndex, Ref x)</code> -- 用 java.sql.Ref 值更新指定列</p></li>
                                <li><p><code>void 	updateRef(String columnLabel, Ref x)</code> -- 用 java.sql.Ref 值更新指定列</p></li>

                                <li class="group"><p><code>void 	updateRowId(int columnIndex, RowId x)</code> -- 用 RowId 值更新指定列</p></li>
                                <li><p><code>void 	updateRowId(String columnLabel, RowId x)</code> -- 用 RowId 值更新指定列</p></li>

                                <li class="group"><p><code>void 	updateSQLXML(int columnIndex, SQLXML xmlObject)</code> --  用 java.sql.SQLXML 值更新指定列</p></li>
                                <li><p><code>void 	updateSQLXML(String columnLabel, SQLXML xmlObject)</code> --  用 java.sql.SQLXML 值更新指定列</p></li>

                                <li class="group"><p><code>void 	updateObject(int columnIndex, Object x)</code> -- 用 Object 值更新指定列</p></li>
                                <li><p><code>void 	updateObject(int columnIndex, Object x, int scaleOrLength)</code> -- 用 Object 值更新指定列</p></li>
                                <li><p><code>default void 	updateObject(int columnIndex, Object x, SQLType targetSqlType)</code> -- 用 Object 值更新指定列</p></li>
                                <li><p><code>default void 	updateObject(int columnIndex, Object x, SQLType targetSqlType, int scaleOrLength)</code> -- 用 Object 值更新指定列</p></li>
                                <li><p><code>void 	updateObject(String columnLabel, Object x)</code> -- 用 Object 值更新指定列</p></li>
                                <li><p><code>void 	updateObject(String columnLabel, Object x, int scaleOrLength)</code> -- 用 Object 值更新指定列</p></li>
                                <li><p><code>default void 	updateObject(String columnLabel, Object x, SQLType targetSqlType)</code> -- 用 Object 值更新指定列</p></li>
                                <li><p><code>default void 	updateObject(String columnLabel, Object x, SQLType targetSqlType, int scaleOrLength)</code> -- 用 Object 值更新指定列</p></li>

                                <li class="group"><p><code>void 	updateCharacterStream(int columnIndex, Reader x)</code> -- 用字符流值更新指定的列</p></li>
                                <li><p><code>void 	updateCharacterStream(int columnIndex, Reader x, int length)</code> -- 用字符流值更新指定列，该列将具有指定字节数</p></li>
                                <li><p><code>void 	updateCharacterStream(int columnIndex, Reader x, long length)</code> -- 用字符流值更新指定的列，该值将具有指定的字节数</p></li>
                                <li><p><code>void 	updateCharacterStream(String columnLabel, Reader reader)</code> -- 用字符流值更新指定列</p></li>
                                <li><p><code>void 	updateCharacterStream(String columnLabel, Reader reader, int length)</code> -- 用字符流值更新指定列，该列具有指定的字节数</p></li>
                                <li><p><code>void 	updateCharacterStream(String columnLabel, Reader reader, long length)</code> -- 用字符流值更新指定的列，该值将具有指定的字节数</p></li>

                                <li class="group"><p><code>void 	updateNCharacterStream(int columnIndex, Reader x)</code> -- 用字符流值更新指定的列</p></li>
                                <li><p><code>void 	updateNCharacterStream(int columnIndex, Reader x, long length)</code> -- 用字符流值更新指定的列，该值将具有指定的字节数</p></li>
                                <li><p><code>void 	updateNCharacterStream(String columnLabel, Reader reader)</code> -- 用字符流值更新指定的列</p></li>
                                <li><p><code>void 	updateNCharacterStream(String columnLabel, Reader reader, long length)</code> -- 用字符流值更新指定的列，该值将具有指定的字节数</p></li>

                                <li class="group"><p><code>void 	updateAsciiStream(int columnIndex, InputStream x)</code> -- 用 ascii 流值更新指定的列</p></li>
                                <li><p><code>void 	updateAsciiStream(int columnIndex, InputStream x, int length)</code> -- 用 ascii 流值更新指定列，该列将具有指定字节数</p></li>
                                <li><p><code>void 	updateAsciiStream(int columnIndex, InputStream x, long length)</code> -- 用 ascii 流值更新指定的列，该值将具有指定的字节数</p></li>
                                <li><p><code>void 	updateAsciiStream(String columnLabel, InputStream x)</code> -- 用 ascii 流值更新指定列</p></li>
                                <li><p><code>void 	updateAsciiStream(String columnLabel, InputStream x, int length)</code> -- 用 ascii 流值更新指定列，该列具有指定的字节数</p></li>
                                <li><p><code>void 	updateAsciiStream(String columnLabel, InputStream x, long length)</code> -- 用 ascii 流值更新指定的列，该值将具有指定的字节数</p></li>

                                <li class="group"><p><code>void 	updateBinaryStream(int columnIndex, InputStream x)</code> -- 用二进制流值更新指定的列</p></li>
                                <li><p><code>void 	updateBinaryStream(int columnIndex, InputStream x, int length)</code> -- 用二进制流值更新指定列，该列将具有指定字节数</p></li>
                                <li><p><code>void 	updateBinaryStream(int columnIndex, InputStream x, long length)</code> -- 用二进制流值更新指定的列，该值将具有指定的字节数</p></li>
                                <li><p><code>void 	updateBinaryStream(String columnLabel, InputStream x)</code> -- 用二进制流值更新指定列</p></li>
                                <li><p><code>void 	updateBinaryStream(String columnLabel, InputStream x, int length)</code> -- 用二进制流值更新指定列，该列具有指定的字节数</p></li>
                                <li><p><code>void 	updateBinaryStream(String columnLabel, InputStream x, long length)</code> -- 用二进制流值更新指定的列，该值将具有指定的字节数</p></li>
                            </ol>
                        </div>

                        <a id="RowSet" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface RowSet extends ResultSet {}
</pre>
                            <p><a href="docs/docs-java/api/javax/sql/RowSet.html" target="_blank"><code>javax.sql.</code>RowSet</a> 接口添加了对 JavaBeans<sup>TM</sup> 组件模型的 JDBC API 支持。rowset 可用作可视化 Bean 开发环境中的 JavaBeans 组件，它可以在设计时创建和配置并在运行时执行。 </p>
                            <p>RowSet 接口提供一组 JavaBeans 属性，这些属性允许配置一个 RowSet 实例来连接 JDBC 数据源并从中读取某些数据。一组设置方法（setInt、setBytes、setString 等等）提供将输入参数传递到 rowset 命令属性的方式。在一般情况下，此命令是 rowset 从关系数据库获取其数据时所使用的 SQL 查询。 </p>
                            <p>RowSet 接口支持 JavaBeans 事件，允许应用程序中的其他组件在 rowset 发生事件时（如值的更改）得到通知。 </p>
                            <p>RowSet 接口是唯一的，因为需要使用其他 JDBC API 来实现它。换句话说，RowSet 实现是在 JDBC 驱动程序“顶部”执行的软件层。任何人都可以提供 RowSet 接口的实现，包括希望将 RowSet 实现作为其 JDBC 产品的一部分提供的 JDBC 驱动程序供应商。 </p>
                            <p>RowSet 对象可以建立一个与数据源的连接并在其整个生命周期中维持该连接，在此情况下，该对象被称为连接的 rowset。rowset 还可以建立一个与数据源的连接，从其获取数据，然后关闭它。这种 rowset 被称为非连接 rowset。非连接 rowset 可以在断开时更改其数据，然后将这些更改发送回原始数据源，不过它必须重新建立连接才能完成此操作。 </p>
                            <p>非连接 rowset 可以具有与之关联的 reader（RowSetReader 对象）和 writer（RowSetWriter 对象）。可以多种方式实现 reader 来使用数据填充 rowset，包括从非关系型数据源获取数据。也可以多种方式实现 writer 来将对 rowset 的数据所做的更改传回底层数据源。 </p>
                            <p>Rowset 易于使用。RowSet 接口扩展了标准 java.sql.ResultSet 接口。RowSetMetaData 接口扩展了 java.sql.ResultSetMetaData 接口。</p>
                            <ol>
                                <li class="group"><p><code>void 	addRowSetListener(RowSetListener listener)</code> -- 注册给定侦听器，以便此 RowSet 对象上发生事件时将得到通知</p></li>
                                <li><p><code>void 	removeRowSetListener(RowSetListener listener)</code> -- 移除指定的侦听器</p></li>

                                <li class="group"><p><code>void 	clearParameters()</code> -- 清除为此 RowSet 对象命令设置的参数</p></li>
                                <li><p><code>void 	execute()</code> -- 使用数据填充此 RowSet 对象</p></li>
                                <li><p><code>void 	setConcurrency(int concurrency)</code> -- 将此 RowSet 对象的并发性设置为给定的并发级别，参数为：<code>CONCUR_READ_ONLY</code> or <code>CONCUR_UPDATABLE</code></p></li>
                                <li><p><code>void 	setType(int type)</code> -- 将此 RowSet 对象的类型设置为给定的类型。此方法用于更改 rowset 的类型，默认情况下该类型为只读且不可滚动，参数为：<code>TYPE_FORWARD_ONLY</code>, <code>TYPE_SCROLL_INSENSITIVE</code> or <code>TYPE_SCROLL_SENSITIVE</code></p></li>

                                <li class="group"><p><code>String 	getUrl()</code> -- 如果 RowSet 对象使用 DriverManager 而非 DataSource 对象建立连接，则获取创建连接时的 url 属性</p></li>
                                <li><p><code>void 	setUrl(String url)</code> -- 设置 url</p></li>
                                <li><p><code>String 	getUsername()</code> -- 获取用于创建此 RowSet 对象的数据库连接的用户名</p></li>
                                <li><p><code>void 	setUsername(String name)</code> -- 设置 userName</p></li>
                                <li><p><code>String 	getPassword()</code> -- 获取用于创建数据库连接的密码</p></li>
                                <li><p><code>void 	setPassword(String password)</code> -- 设置 password</p></li>
                                <li><p><code>boolean 	isReadOnly()</code> -- 获取此 RowSet 对象是否是只读的</p></li>
                                <li><p><code>void 	setReadOnly(boolean value)</code> -- 设置是否是只读</p></li>
                                <li><p><code>String 	getCommand()</code> -- 获取此 RowSet 对象的命令属性</p></li>
                                <li><p><code>void 	setCommand(String cmd)</code> -- 设置此 RowSet 对象的命令属性</p></li>
                                <li><p><code>String 	getDataSourceName()</code> -- 获取标识此 RowSet 对象的数据源的逻辑名称</p></li>
                                <li><p><code>void 	setDataSourceName(String name)</code> -- 设置数据源的逻辑名称</p></li>
                                <li><p><code>int 	getQueryTimeout()</code> -- 获取驱动程序等待语句执行的最大秒数</p></li>
                                <li><p><code>void 	setQueryTimeout(int seconds)</code> --  设置驱动程序等待语句执行的最大秒数</p></li>
                                <li><p><code>int 	getMaxRows()</code> -- 获取此 RowSet 对象可以包含的最大行数</p></li>
                                <li><p><code>void 	setMaxRows(int max)</code> -- 设置此 RowSet 对象可以包含的最大行数</p></li>
                                <li><p><code>int 	getMaxFieldSize()</code> -- 获取可以对某些列值返回的最大字节数</p></li>
                                <li><p><code>void 	setMaxFieldSize(int max)</code> -- 设置可以对某些列值返回的最大字节数</p></li>
                                <li><p><code>boolean 	getEscapeProcessing()</code> -- 获取是否为此 RowSet 对象启用转义处理</p></li>
                                <li><p><code>void 	setEscapeProcessing(boolean enable)</code> -- 设置是否为此 RowSet 对象启用转义处理</p></li>
                                <li><p><code>int 	getTransactionIsolation()</code> -- 获取为此 RowSet 对象设置的事务隔离级别</p></li>
                                <li><p><code>void 	setTransactionIsolation(int level)</code> -- 设置为此 RowSet 对象设置的事务隔离级别，参数为 <a href="#java-sql-Connection">Connection</a> 对象的：<code>TRANSACTION_READ_UNCOMMITTED</code>、<code>TRANSACTION_READ_COMMITTED</code>、<code>TRANSACTION_REPEATABLE_READ</code> or <code>TRANSACTION_SERIALIZABLE</code></p></li>
                                <li><p><code>Map&lt;String,Class&lt;?>> 	getTypeMap()</code> -- 获取 RowSet 对象关联的 Map 对象，它指定 SQL 用户定义类型的自定义映射关系</p></li>
                                <li><p><code>void 	setTypeMap(Map&lt;String,Class&lt;?>> map)</code> -- 设置 RowSet 对象关联的 Map 对象</p></li>

                                <li class="group"><p><code>void 	setBoolean(int parameterIndex, boolean x)</code> -- 将指定参数设置为给定的 boolean 值</p></li>
                                <li><p><code>void 	setBoolean(String parameterName, boolean x)</code> -- 将指定参数设置为给定的 boolean 值</p></li>
                                <li><p><code>void 	setByte(int parameterIndex, byte x)</code> -- 将指定参数设置为给定的 byte 值</p></li>
                                <li><p><code>void 	setByte(String parameterName, byte x)</code> -- 将指定参数设置为给定的 byte 值</p></li>
                                <li><p><code>void 	setShort(int parameterIndex, short x)</code> -- 将指定参数设置为给定的 short 值</p></li>
                                <li><p><code>void 	setShort(String parameterName, short x)</code> -- 将指定参数设置为给定的 short 值</p></li>
                                <li><p><code>void 	setInt(int parameterIndex, int x)</code> -- 将指定参数设置为给定的 int 值</p></li>
                                <li><p><code>void 	setInt(String parameterName, int x)</code> -- 将指定参数设置为给定的 int 值</p></li>
                                <li><p><code>void 	setLong(int parameterIndex, long x)</code> -- 将指定参数设置为给定的 long 值</p></li>
                                <li><p><code>void 	setLong(String parameterName, long x)</code> -- 将指定参数设置为给定的 long 值</p></li>
                                <li><p><code>void 	setFloat(int parameterIndex, float x)</code> -- 将指定参数设置为给定的 float 值</p></li>
                                <li><p><code>void 	setFloat(String parameterName, float x)</code> -- 将指定参数设置为给定的 float 值</p></li>
                                <li><p><code>void 	setDouble(int parameterIndex, double x)</code> -- 将指定参数设置为给定的 double 值</p></li>
                                <li><p><code>void 	setDouble(String parameterName, double x)</code> -- 将指定参数设置为给定的 double 值</p></li>
                                <li><p><code>void 	setBigDecimal(int parameterIndex, BigDecimal x)</code> -- 将指定参数设置为给定的 java.math.BigDecimal 值</p></li>
                                <li><p><code>void 	setBigDecimal(String parameterName, BigDecimal x)</code> -- 将指定参数设置为给定的 java.math.BigDecimal 值</p></li>
                                <li><p><code>void 	setString(int parameterIndex, String x)</code> -- 将指定参数设置为给定的 String 值</p></li>
                                <li><p><code>void 	setString(String parameterName, String x)</code> -- 将指定参数设置为给定的 String 值</p></li>
                                <li><p><code>void 	setNString(int parameterIndex, String value)</code> -- 将指定参数设置为给定的 String 值</p></li>
                                <li><p><code>void 	setNString(String parameterName, String value)</code> -- 将指定参数设置为给定的 String 值</p></li>

                                <li class="group"><p><code>void 	setNull(int parameterIndex, int sqlType)</code> -- 设置为指定类型的 NULL, 参见: <a href="#java-sql-Types">Types</a></p></li>
                                <li><p><code>void 	setNull(int paramIndex, int sqlType, String typeName)</code> -- 设置为指定类型的 NULL, 参见: <a href="#java-sql-Types">Types</a></p></li>
                                <li><p><code>void 	setNull(String parameterName, int sqlType)</code> -- 设置为指定类型的 NULL, 参见: <a href="#java-sql-Types">Types</a></p></li>
                                <li><p><code>void 	setNull(String parameterName, int sqlType, String typeName)</code> -- 设置为指定类型的 NULL, 参见: <a href="#java-sql-Types">Types</a></p></li>

                                <li class="group"><p><code>void 	setTime(int parameterIndex, Time x)</code> -- 将指定参数设置为给定的 Time 值</p></li>
                                <li><p><code>void 	setTime(int parameterIndex, Time x, Calendar cal)</code> -- 将指定参数设置为给定的 Time 值</p></li>
                                <li><p><code>void 	setTime(String parameterName, Time x)</code> -- 将指定参数设置为给定的 Time 值</p></li>
                                <li><p><code>void 	setTime(String parameterName, Time x, Calendar cal)</code> -- 将指定参数设置为给定的 Time 值</p></li>

                                <li class="group"><p><code>void 	setTimestamp(int parameterIndex, Timestamp x)</code> -- 将指定参数设置为给定的 Timestamp 值</p></li>
                                <li><p><code>void 	setTimestamp(int parameterIndex, Timestamp x, Calendar cal)</code> -- 将指定参数设置为给定的 Timestamp 值</p></li>
                                <li><p><code>void 	setTimestamp(String parameterName, Timestamp x)</code> -- 将指定参数设置为给定的 Timestamp 值</p></li>
                                <li><p><code>void 	setTimestamp(String parameterName, Timestamp x, Calendar cal)</code> -- 将指定参数设置为给定的 Timestamp 值</p></li>

                                <li class="group"><p><code>void 	setDate(int parameterIndex, Date x)</code> -- 将指定参数设置为给定的 Date 值</p></li>
                                <li><p><code>void 	setDate(int parameterIndex, Date x, Calendar cal)</code> -- 将指定参数设置为给定的 Date 值</p></li>
                                <li><p><code>void 	setDate(String parameterName, Date x)</code> -- 将指定参数设置为给定的 Date 值</p></li>
                                <li><p><code>void 	setDate(String parameterName, Date x, Calendar cal)</code> -- 将指定参数设置为给定的 Date 值</p></li>

                                <li class="group"><p><code>void 	setBytes(int parameterIndex, byte[] x)</code> -- 将指定参数设置为给定的 byte[] 值</p></li>
                                <li><p><code>void 	setBytes(String parameterName, byte[] x)</code> -- 将指定参数设置为给定的 byte[] 值</p></li>
                                <li><p><code>void 	setArray(int i, Array x)</code> -- 使用给定 Array 值设置此 RowSet 对象命令中的指定参数</p></li>
                                <li><p><code>void 	setURL(int parameterIndex, URL x)</code> -- 将指定参数设置为给定的 URL 值</p></li>
                                <li><p><code>void 	setRef(int i, Ref x)</code> -- 将指定参数设置为给定的 Ref 值</p></li>

                                <li class="group"><p><code>void 	setObject(int parameterIndex, Object x)</code> -- 使用给定对象设置指定参数的值</p></li>
                                <li><p><code>void 	setObject(int parameterIndex, Object x, int targetSqlType)</code> -- 使用给定对象设置指定参数的值</p></li>
                                <li><p><code>void 	setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength)</code> -- 使用给定对象设置指定参数的值</p></li>
                                <li><p><code>void 	setObject(String parameterName, Object x)</code> -- 使用给定对象设置指定参数的值</p></li>
                                <li><p><code>void 	setObject(String parameterName, Object x, int targetSqlType)</code> -- 使用给定对象设置指定参数的值</p></li>
                                <li><p><code>void 	setObject(String parameterName, Object x, int targetSqlType, int scale)</code> -- 使用给定对象设置指定参数的值</p></li>

                                <li class="group"><p><code>void 	setRowId(int parameterIndex, RowId x)</code> -- 将指定参数设置为给定的 RowId 值</p></li>
                                <li><p><code>void 	setRowId(String parameterName, RowId x)</code> -- 将指定参数设置为给定的 RowId 值</p></li>

                                <li class="group"><p><code>void 	setSQLXML(int parameterIndex, SQLXML xmlObject)</code> -- 将指定参数设置为给定的 SQLXML 值</p></li>
                                <li><p><code>void 	setSQLXML(String parameterName, SQLXML xmlObject)</code> -- 将指定参数设置为给定的 SQLXML 值</p></li>

                                <li class="group"><p><code>void 	setBlob(int i, Blob x)</code> -- 使用给定 Blob 值设置此 RowSet 对象命令中的指定参数</p></li>
                                <li><p><code>void 	setBlob(int parameterIndex, InputStream inputStream)</code> -- 使用给定 Blob 值设置此 RowSet 对象命令中的指定参数</p></li>
                                <li><p><code>void 	setBlob(int parameterIndex, InputStream inputStream, long length)</code> -- 将指定参数设置为给定的 Blob 值</p></li>
                                <li><p><code>void 	setBlob(String parameterName, Blob x)</code> -- 将指定参数设置为给定的 Blob 值</p></li>
                                <li><p><code>void 	setBlob(String parameterName, InputStream inputStream)</code> -- 将指定参数设置为给定的 Blob 值</p></li>
                                <li><p><code>void 	setBlob(String parameterName, InputStream inputStream, long length)</code> -- 将指定参数设置为给定的 Blob 值</p></li>

                                <li class="group"><p><code>void 	setClob(int i, Clob x)</code> -- 使用给定 Clob 值设置此 RowSet 对象命令中的指定参数</p></li>
                                <li><p><code>void 	setClob(int parameterIndex, Reader reader)</code> -- 将指定参数设置为给定的 Clob 值</p></li>
                                <li><p><code>void 	setClob(int parameterIndex, Reader reader, long length)</code> -- 将指定参数设置为给定的 Clob 值</p></li>
                                <li><p><code>void 	setClob(String parameterName, Clob x)</code> -- 将指定参数设置为给定的 Clob 值</p></li>
                                <li><p><code>void 	setClob(String parameterName, Reader reader)</code> -- 将指定参数设置为给定的 Clob 值</p></li>
                                <li><p><code>void 	setClob(String parameterName, Reader reader, long length)</code> -- 将指定参数设置为给定的 Clob 值</p></li>

                                <li class="group"><p><code>void 	setNClob(int parameterIndex, NClob value)</code> -- 将指定参数设置为给定的 NClob 值</p></li>
                                <li><p><code>void 	setNClob(int parameterIndex, Reader reader)</code> -- 将指定参数设置为给定的 NClob 值</p></li>
                                <li><p><code>void 	setNClob(int parameterIndex, Reader reader, long length)</code> -- 将指定参数设置为给定的 NClob 值</p></li>
                                <li><p><code>void 	setNClob(String parameterName, NClob value)</code> -- 将指定参数设置为给定的 NClob 值</p></li>
                                <li><p><code>void 	setNClob(String parameterName, Reader reader)</code> -- 将指定参数设置为给定的 NClob 值</p></li>
                                <li><p><code>void 	setNClob(String parameterName, Reader reader, long length)</code> -- 将指定参数设置为给定的 NClob 值</p></li>

                                <li class="group"><p><code>void 	setAsciiStream(int parameterIndex, InputStream x)</code> -- 将此 RowSet 对象命令中的指定参数设置为给定输入流</p></li>
                                <li><p><code>void 	setAsciiStream(int parameterIndex, InputStream x, int length)</code> -- 将此 RowSet 对象命令中的指定参数设置为给定输入流，并指定长度</p></li>
                                <li><p><code>void 	setAsciiStream(String parameterName, InputStream x)</code> -- 将指定参数设置为给定输入流</p></li>
                                <li><p><code>void 	setAsciiStream(String parameterName, InputStream x, int length)</code> -- 将指定参数设置为给定输入流，并指定长度</p></li>

                                <li class="group"><p><code>void 	setBinaryStream(int parameterIndex, InputStream x)</code> -- 将指定参数设置为给定输入流</p></li>
                                <li><p><code>void 	setBinaryStream(int parameterIndex, InputStream x, int length)</code> -- 将指定参数设置为给定输入流</p></li>
                                <li><p><code>void 	setBinaryStream(String parameterName, InputStream x)</code> -- 将指定参数设置为给定输入流</p></li>
                                <li><p><code>void 	setBinaryStream(String parameterName, InputStream x, int length)</code> -- 将指定参数设置为给定输入流</p></li>

                                <li class="group"><p><code>void 	setCharacterStream(int parameterIndex, Reader reader)</code> -- 将指定参数设置为给定 Reader 对象</p></li>
                                <li><p><code>void 	setCharacterStream(int parameterIndex, Reader reader, int length)</code> -- 将指定参数设置为给定 Reader 对象</p></li>
                                <li><p><code>void 	setCharacterStream(String parameterName, Reader reader)</code> -- 将指定参数设置为给定 Reader 对象</p></li>
                                <li><p><code>void 	setCharacterStream(String parameterName, Reader reader, int length)</code> -- 将指定参数设置为给定 Reader 对象</p></li>

                                <li class="group"><p><code>void 	setNCharacterStream(int parameterIndex, Reader value)</code> -- 将指定参数设置为给定 Reader 对象</p></li>
                                <li><p><code>void 	setNCharacterStream(int parameterIndex, Reader value, long length)</code> -- 将指定参数设置为给定 Reader 对象</p></li>
                                <li><p><code>void 	setNCharacterStream(String parameterName, Reader value)</code> -- 将指定参数设置为给定 Reader 对象</p></li>
                                <li><p><code>void 	setNCharacterStream(String parameterName, Reader value, long length)</code> -- 将指定参数设置为给定 Reader 对象</p></li>
                            </ol>
                        </div>

                        <a id="JdbcRowSet" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface JdbcRowSet extends RowSet, Joinable {}
</pre>
                            <p><a href="docs/docs-java/api/javax/sql/rowset/JdbcRowSet.html" target="_blank"><code>javax.sql.rowset.</code>JdbcRowSet</a> 所有标准 JdbcRowSet 实现都必须实现的标准接口</p>
                            <p>ResultSet 对象的包装器使得将该结果集用作 JavaBeansTM 组件成为可能。因此，JdbcRowSet 对象可以是某个 Beans，是可用于组成应用程序的工具。因为 JdbcRowSet 是一个连接的 rowset，也就是说，它使用启用 JDBC 技术的驱动程序来维持它与数据库的连接，所以它也能有效地使驱动程序成为 JavaBeans 组件。 </p>
                            <p>因为它始终连接到其数据库，所以 JdbcRowSet 的实例可以简单地采用在其上进行调用的方法，并依次对其 ResultSet 对象调用这些方法。</p>
                            <p>JdbcRowSet 对象的另一个优点是可使用它让 ResultSet 对象可滚动和可更新。默认情况下，所有 RowSet 对象都是可滚动的和可更新的。如果使用的驱动程序和数据库不支持结果集的滚动和/或更新，则应用程序可以组装一个带 ResultSet 对象数据的 JdbcRowSet 对象，然后在该 JdbcRowSet 对象上操作，就好像它是 ResultSet 对象一样。 </p>
                            <ol>
                                <li><p><code>void 	commit()</code> -- 包装 Connection 提交方法，以允许灵活的自动提交或非自动提交事务控制支持</p></li>
                                <li><p><code>boolean 	getAutoCommit()</code> -- 包装 Connection 的 getAutoCommit 方法，以允许应用程序确定 JdbcRowSet 的事务行为</p></li>
                                <li><p><code>void 	setAutoCommit(boolean autoCommit)</code> -- 包装 Connection 的 getAutoCommit 方法，以允许应用程序设置 JdbcRowSet 的事务行为</p></li>
                                <li><p><code>void 	rollback()</code> -- 取消在当前事务中进行的所有更改，并释放此 Connection 对象当前保存的所有数据库锁定</p></li>
                                <li><p><code>void 	rollback(Savepoint s)</code> -- 取消在当前事务中进行的所有更改，一直到最后设置的保存点，并释放此 Connection 对象当前保存的所有数据库锁定</p></li>
                                <li><p><code>boolean 	getShowDeleted()</code> -- 获取一个 boolean 值，该值指示标记为删除的行是否会出现在当前行集合中</p></li>
                                <li><p><code>void 	setShowDeleted(boolean b)</code> -- 将属性 showDeleted 设置为给定的 boolean 值</p></li>
                                <li><p><code>RowSetWarning 	getRowSetWarnings()</code> -- 获取此 JdbcRowSet 对象上的调用报告的第一个警告</p></li>
                            </ol>
                        </div>

                        <a id="CachedRowSet" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface CachedRowSet extends RowSet, Joinable {}
</pre>
                            <p><a href="docs/docs-java/api/javax/sql/rowset/CachedRowSet.html" target="_blank"><code>javax.sql.rowset.</code>CachedRowSet</a> 对象是一个数据行的容器，可在内存中缓存其各行，这使得进行操作时无需总是连接到数据源。</p>
                            <p>此外，它还是一个 JavaBeans<sup>TM</sup> 组件，是可滚动、可更新、可序列化的。</p>
                            <p>CachedRowSet 对象通常包含结果集中的行，但它也可以包含任何具有表格式的文件（如电子表格）中的行。参考实现只支持从 ResultSet 对象中获取数据，但是开发人员可以扩展 SyncProvider 实现，以提供对其他表格数据源的访问。 </p>
                            <p>应用程序可以修改 CachedRowSet 对象中的数据，这些修改随后可以被传播回数据源。 </p>
                            <p>CachedRowSet 对象是一个非连接 rowset，这意味着它只会短暂地连接其数据源。连接数据源发生在读取数据以用各行填充自身，以及将更改传播回其底层数据源时。其余时间 CachedRowSet 对象是非连接的，包括修改它的数据时。非连接使 RowSet 对象更为简洁，因此更容易传递给另一个组件。</p>
                            <ol>
                                <li><p><code>void 	commit()</code> -- 包装 Connection 提交方法，以允许灵活的自动提交或非自动提交事务控制支持</p></li>
                                <li><p><code>void 	rollback()</code> -- 取消在当前事务中进行的所有更改，并释放此 Connection 对象当前保存的所有数据库锁定</p></li>
                                <li><p><code>void 	rollback(Savepoint s)</code> -- 取消在当前事务中进行的所有更改，一直到最后设置的保存点，并释放此 Connection 对象当前保存的所有数据库锁定</p></li>
                                <li><p><code>boolean 	getShowDeleted()</code> -- 获取一个 boolean 值，该值指示标记为删除的行是否会出现在当前行集合中</p></li>
                                <li><p><code>void 	setShowDeleted(boolean b)</code> -- 将属性 showDeleted 设置为给定的 boolean 值，它确定标记为删除的行是否会出现在当前行集合中</p></li>
                                <li><p><code>RowSetWarning 	getRowSetWarnings()</code> -- 获取此 RowSet 对象上的调用报告的第一个警告</p></li>
                                <li><p><code>void 	setMetaData(RowSetMetaData md)</code> -- 使用给定的 RowSetMetaData 对象设置此 CachedRowSet 对象的元数据</p></li>
                                <li><p><code>int 	size()</code> -- 返回此 CachedRowSet 对象中的行数</p></li>

                                <li class="group"><p><code>void 	acceptChanges()</code> -- 将对此 CachedRowSet 对象所做的行更新、插入以及删除更改传播到底层数据源</p></li>
                                <li><p><code>void 	acceptChanges(Connection con)</code> -- 将所有行更新、插入以及删除更改传播到支持此 CachedRowSet 对象的数据源，使用指定的 Connection 对象建立到数据源的连接</p></li>
                                <li><p><code>void 	execute(Connection conn)</code> -- 用数据填充此 CachedRowSet 对象，使用给定的连接来生成从中读取数据的结果集</p></li>
                                <li><p><code>void 	populate(ResultSet data)</code> -- 使用取自给定 ResultSet 对象的数据填充此 CachedRowSet 对象</p></li>
                                <li><p><code>void 	populate(ResultSet rs, int startRow)</code> -- 使用取自给定 ResultSet 对象的数据填充此 CachedRowSet 对象</p></li>

                                <li class="group"><p><code>boolean 	columnUpdated(int idx)</code> -- 指示此 CachedRowSet 对象当前行中的指定列是否已更新</p></li>
                                <li><p><code>boolean 	columnUpdated(String columnName)</code> -- 指示此 CachedRowSet 对象当前行中的指定列是否已更新</p></li>

                                <li class="group"><p><code>CachedRowSet 	createCopy()</code> -- 创建一个 RowSet 对象，它是此 CachedRowSet 对象中数据的深层副本</p></li>
                                <li><p><code>CachedRowSet 	createCopyNoConstraints()</code> -- 创建一个 CachedRowSet 对象，它是此 CachedRowSet 对象数据的深层副本，但是独立于此 CachedRowSet 对象</p></li>
                                <li><p><code>CachedRowSet 	createCopySchema()</code> -- 创建一个 CachedRowSet 对象，它是此 CachedRowSet 对象的空副本</p></li>
                                <li><p><code>RowSet 	createShared()</code> -- 返回一个新的 RowSet 对象，支持该对象的数据与此 CachedRowSet 对象的相同</p></li>

                                <li class="group"><p><code>String 	getTableName()</code> -- 返回创建此 CachedRowSet 对象时所用对象（表）的标识符</p></li>
                                <li><p><code>void 	setTableName(String tabName)</code> -- 将派生此 CachedRowSet 对象的表的标识符设置为给定的表名</p></li>
                                <li><p><code>ResultSet 	getOriginalRow()</code> -- 返回一个只包含此 CachedRowSet 对象当前行原始值的 ResultSet 对象</p></li>
                                <li><p><code>void 	setOriginalRow()</code> -- 将此 CachedRowSet 对象中的当前行设置为原始行</p></li>
                                <li><p><code>ResultSet 	getOriginal()</code> -- 返回一个包含此 CachedRowSet 对象原始值的 ResultSet 对象</p></li>
                                <li><p><code>void 	restoreOriginal()</code> -- 将此 CachedRowSet 对象还原成其原始值，即执行上一组更改前的值</p></li>
                                <li><p><code>int[] 	getKeyColumns()</code> -- 返回一个包含一个或多个列号的数组，这些列号指示了形成某个键的列，该键唯一地标识了此 CachedRowSet 对象中的某个行</p></li>
                                <li><p><code>void 	setKeyColumns(int[] keys)</code> -- 使用给定的列号数组设置此 CachedRowSet 对象的 keyCols 字段，它形成了唯一标识此 CachedRowSet 对象中某个行的键</p></li>
                                <li><p><code>SyncProvider 	getSyncProvider()</code> -- 获取此 CachedRowSet 对象的 SyncProvider 实现</p></li>
                                <li><p><code>void 	setSyncProvider(String provider)</code> -- 将此 CachedRowSet 对象的 SyncProvider 对象设置为指定的提供者</p></li>

                                <li class="group"><p><code>void 	undoDelete()</code> -- 取消删除当前行并通知侦听器已更改了某个行</p></li>
                                <li><p><code>void 	undoInsert()</code> -- 如果已经插入了当前行，则立即将它从此 CachedRowSet 对象移除，同样通知侦听器已更改了某个行</p></li>
                                <li><p><code>void 	undoUpdate()</code> -- 如果已经修改了行，则立即逆转上一次更新操作</p></li>
                                <li><p><code>void 	release()</code> -- 释放此 CachedRowSet 对象的当前内容并将 rowSetChanged 事件发送到所有已注册侦听器</p></li>
                                <li><p><code>void 	rowSetPopulated(RowSetEvent event, int numRows)</code> -- 通知已注册侦听器给定 RowSetEvent 对象中的某个 RowSet 对象已经填充了多个附加行</p></li>

                                <li class="group"><p><code>int 	getPageSize()</code> -- 返回 CachedRowSet 对象的页大小</p></li>
                                <li><p><code>void 	setPageSize(int size)</code> -- 设置 CachedRowSet 对象的页大小</p></li>
                                <li><p><code>boolean 	nextPage()</code> -- 逐个增加 CachedRowSet 的当前页</p></li>
                                <li><p><code>boolean 	previousPage()</code> -- 逐个减少 CachedRowSet 的当前页</p></li>

                                <li class="group"><p><code>Collection&lt;?> 	toCollection()</code> -- 将此 CachedRowSet 对象转换成一个 Collection 对象，它包含此 CachedRowSet 对象的所有数据</p></li>
                                <li><p><code>Collection&lt;?> 	toCollection(int column)</code> -- 将此 CachedRowSet 对象中的指定列转换成一个 Collection 对象</p></li>
                                <li><p><code>Collection&lt;?> 	toCollection(String column)</code> -- 将此 CachedRowSet 对象中的指定列转换成一个 Collection 对象</p></li>
                            </ol>
                        </div>

                        <a id="WebRowSet" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface WebRowSet extends CachedRowSet {
    String PUBLIC_XML_SCHEMA = "--//Oracle Corporation//XSD Schema//EN";
    String SCHEMA_SYSTEM_ID = "http://java.sun.com/xml/ns/jdbc/webrowset.xsd";
}
</pre>
                            <p><a href="docs/docs-java/api/javax/sql/rowset/WebRowSet.html" target="_blank"><code>javax.sql.rowset.</code>WebRowSet</a> 用于将结果集输出到 XML 和使用有效的 XML 作为结果集的输入。</p>
                            <p>准的 WebRowSet XML 模式定义位于以下 URI 中：<a href="http://java.sun.com/xml/ns/jdbc/webrowset.xsd" target="_blank">webrowset.xsd</a></p>
                            <p>它描述使用 XML 描述 RowSet 对象时所需的标准 XML 文档格式，所有 WebRowSet 接口的标准实现必须使用该文档格式以确保互操作性。此外，WebRowSet 模式使用特定的 SQL/XML 模式注释，从而确保较高的跨平台互操作性。</p>
                            <ol>
                                <li><p><code>void 	readXml(InputStream iStream)</code> -- 读取基于流的 XML 输入，以填充此 WebRowSet 对象</p></li>
                                <li><p><code>void 	readXml(Reader reader)</code> -- 从给定的 Reader 对象以其 XML 格式读取 WebRowSet 对象</p></li>
                                <li><p><code>void 	writeXml(OutputStream oStream)</code> -- 以 XML 格式将此 WebRowSet 对象的数据、属性和元数据写入给定的 OutputStream 对象</p></li>
                                <li><p><code>void 	writeXml(ResultSet rs, OutputStream oStream)</code> -- 使用给定 ResultSet 对象的内容填充此 WebRowSet 对象，并以 XML 格式将其数据、属性和元数据写入给定的 OutputStream 对象</p></li>
                                <li><p><code>void 	writeXml(ResultSet rs, Writer writer)</code> -- 使用给定 ResultSet 对象的内容填充此 WebRowSet 对象，并以 XML 格式将其数据、属性和元数据写入给定的 Writer 对象</p></li>
                                <li><p><code>void 	writeXml(Writer writer)</code> -- 以 XML 格式将此 WebRowSet 对象的数据、属性和元数据写入给定的 Writer 对象</p></li>
                            </ol>
                        </div>

                        <a id="FilteredRowSet" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface FilteredRowSet extends WebRowSet {
    Predicate getFilter(); // 获取此 FilteredRowSet 对象的活动过滤器
    void setFilter(Predicate p); // 将给定的 Predicate 对象应用到此 FilteredRowSet 对象
}

public interface Predicate {
    /** 向 FilteredRowSet 实例插入新行时，FilteredRowSet 对象将在内部使用此方法
     * 如果行值位于过滤器中，则返回 true；否则返回 false
     */
    boolean evaluate(Object value, int column);
    boolean evaluate(Object value, String columnName);

    /** 控制 RowSet 对象的指针从一行移动到下一行。此外，如果此内部方法将指针移动到一个已删除的行上，则其将继续移动指针，
     * 直到找到一个有效行为止，如果在过滤器中存在更多行，则返回 true；否则返回 false
     */
    boolean evaluate(RowSet rs);
}
</pre>
                            <p><a href="docs/docs-java/api/javax/sql/rowset/FilteredRowSet.html" target="_blank"><code>javax.sql.rowset.</code>FilteredRowSet</a> CachedRowSet 类提供了一组受保护的光标操纵方法，FilteredRowSet 实现可重写这些方法将来提供过滤支持。 </p>
                            <p>有时 RowSet 对象需要对其内容进行某种程度的过滤。一种可能的解决方案是为所有标准的 RowSet 实现提供一种查询语言；但是这对诸如非连接 RowSet 对象之类的轻量级组件而言是一种不切实际的方法。FilteredRowSet 接口寻求在不提供重量级查询语言和这种查询语言所需处理的情况下解决这一需求问题。 </p>
                            <p>在移除过滤器或应用新的过滤器之前，不能修改那些位于 FilteredRowSet 对象上设置的过滤器范围外的各行。 </p>
                            <p><a href="docs/docs-java/api/javax/sql/rowset/Predicate.html" target="_blank"><code>javax.sql.rowset.</code>Predicate</a> 是为所有 FilteredRowSet 对象提供框架以描述其过滤器的标准接口。</p>
                            <p>Predicate 接口是一个标准接口，应用程序可以实现它来定义希望应用于 FilteredRowSet 对象的过滤器。FilteredRowSet 对象使用此接口的实现并实施在 evaluate 方法的实现中定义的各种约束。FilteredRowSet 对象以双向方式实施过滤器约束：它只输出过滤器的约束中存在的行；反之，也只插入、修改或更新过滤器的约束中存在的行。 </p>
                            <p>如果使用父接口中继承的 createShared 方法共享了 FilteredRowSet 实现，则应所有 FilteredRowSet 实例副本应共享 Predicate 并不做任何修改。 </p>
                        </div>

                        <a id="Joinable" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface Joinable {}
</pre>
                            <p><a href="docs/docs-java/api/javax/sql/rowset/Joinable.html" target="_blank"><code>javax.sql.rowset.</code>Joinable</a> 接口提供了用于获取和设置匹配列的各种方法，匹配列是形成通过将 RowSet 对象添加到 JoinRowSet 对象所形成的 SQL JOIN 的基础。</p>
                            <p>任何标准 RowSet 实现都可以实现 Joinable 接口，以便能够被添加到 JoinRowSet 对象中。实现此接口使 RowSet 对象能够使用各种 Joinable 方法，这些方法可设置、检索和获取有关匹配列的信息。应用程序可以将尚未实现 Joinable 接口的 RowSet 对象添加到 JoinRowSet 对象中，但是这样做必须使用一个同时带有 RowSet 对象和匹配列（或者 RowSet 对象数组和匹配列数组）的 JoinRowSet.addRowSet 方法。</p>
                            <p>当应用程序向 JoinRowSet 对象添加两个或更多 RowSet 对象时，数组中索引的顺序特别重要。每个数组索引都直接映射到以前添加的 RowSet 对象的相应索引。如果出现重叠或间隙，则匹配列数据将被保留在添加了附加 Joinable RowSet 并需要关联匹配列数据的事件中。因此，应用程序可以以任意顺序设置多个匹配列，但是此顺序对 SQL JOIN 的结果有直接的影响。 </p>
                            <ol>
                                <li><p><code>int[] 	getMatchColumnIndexes()</code> -- 获取使用方法 setMatchColumn(int[] columnIdxes) 为此 RowSet 对象设置的匹配列的索引</p></li>
                                <li><p><code>String[] 	getMatchColumnNames()</code> -- 获取使用方法 setMatchColumn(String [] columnNames) 为此 RowSet 对象设置的匹配列的名称</p></li>
                                <li><p><code>void 	setMatchColumn(int columnIdx)</code> -- 将指定的列设置为此 RowSet 对象的匹配列</p></li>
                                <li><p><code>void 	setMatchColumn(int[] columnIdxes)</code> -- 将指定的列设置为此 RowSet 对象的匹配列</p></li>
                                <li><p><code>void 	setMatchColumn(String columnName)</code> -- 将指定的列设置为此 RowSet 对象的匹配列</p></li>
                                <li><p><code>void 	setMatchColumn(String[] columnNames)</code> -- 将指定的列设置为此 RowSet 对象的匹配列</p></li>
                                <li><p><code>void 	unsetMatchColumn(int columnIdx)</code> -- 取消将指定的列设置为此 RowSet 对象的匹配列</p></li>
                                <li><p><code>void 	unsetMatchColumn(int[] columnIdxes)</code> -- 取消将指定的列设置为此 RowSet 对象的匹配列</p></li>
                                <li><p><code>void 	unsetMatchColumn(String columnName)</code> -- 取消将指定的列设置为此 RowSet 对象的匹配列</p></li>
                                <li><p><code>void 	unsetMatchColumn(String[] columnName)</code> -- 取消将指定的列设置为此 RowSet 对象的匹配列</p></li>
                            </ol>
                        </div>

                        <a id="JoinRowSet" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface JoinRowSet extends WebRowSet {
    int CROSS_JOIN = 0; // ANSI 风格的 JOIN，提供两个表的交叉乘积
    int INNER_JOIN = 1; // 提供两个表之间的内联合 (inner join)
    int LEFT_OUTER_JOIN = 2; // 提供两个表之间的左外联合 (left outer join)
    int RIGHT_OUTER_JOIN = 3; // 提供两个表之间的右外联合 (right outer join)
    int FULL_JOIN = 4; // 提供一个完全 JOIN
}
</pre>
                            <p><a href="docs/docs-java/api/javax/sql/rowset/JoinRowSet.html" target="_blank"><code>javax.sql.rowset.</code>JoinRowSet</a> 接口提供了一种机制，用于将取自不同 RowSet 对象的相关数据组合到一个 JoinRowSet 对象中，该对象表示一个 SQL JOIN。换句话说，JoinRowSet 对象可作为一个数据容器，这些数据取自那些形成 SQL JOIN 关系的 RowSet 对象。 </p>
                            <p>Joinable 接口提供了一些用于设置、获取和取消设置匹配列的方法，匹配列建立 SQL JOIN 关系的基础。通过将匹配列提供给恰当形式的 JointRowSet 方法 addRowSet 也可设置匹配列。 </p>
                            <p>无连接的 RowSet 对象（CachedRowSet 对象和扩展 CachedRowSet 接口的实现）没有一种能在 RowSet 之间建立 SQL JOIN且无需重新连接数据源（该操作开销很大）的标准方式。JoinRowSet 接口是专门为解决这一需求而设计的。 </p>
                            <p>任何 RowSet 对象都可添加到 JoinRowSet 对象，以成为 SQL JOIN 关系的一部分。这意味着已连接和无连接的 RowSet 对象都可成为 JOIN 的一部分。鼓励在连接环境中运行的 RowSet 对象（JdbcRowSet 对象）使用它们已连接的数据库直接在表之间建立 SQL JOIN 关系。但必要时也可以将 JdbcRowSet 对象添加到 JoinRowSet 对象中。 </p>
                            <p>可将任意数目的 RowSet 对象添加到 JoinRowSet 的实例中，前提是只要这些对象可以在 SQL JOIN 中关联起来。根据定义，SQL JOIN 语句用于将两个或多个基于某个公共属性的关系数据库表中所包含的数据组合在一起。Joinable 接口提供了用于建立公共属性的方法，可通过设置匹配列 来建立。匹配列通常与主键相符，但是不要求匹配列与主键相同。通过建立然后强制执行匹配列，JoinRowSet 对象可在 RowSet 对象之间建立 JOIN 关系，无需可用关系型数据库的协助。 </p>
                            <p>注意，如果未设置类型，则 JOIN 将自动为 INNER_JOIN。JoinRowSet 接口中各字段的注释说明了这些 JOIN 类型，它们都是标准的 SQL JOIN 类型。</p>
                            <ol>
                                <li><p><code>void 	addRowSet(Joinable rowset)</code> -- 将给定的 RowSet 对象添加到此 JoinRowSet 对象</p></li>
                                <li><p><code>void 	addRowSet(RowSet[] rowset, int[] columnIdx)</code> -- 将给定 RowSet 对象数组中包含的一个或多个 RowSet 对象添加到此 JoinRowSet 对象，并且将每个 RowSet 对象的匹配列设置为给定列索引数组中的匹配列</p></li>
                                <li><p><code>void 	addRowSet(RowSet[] rowset, String[] columnName)</code> -- 将给定 RowSet 对象数组中包含的一个或多个 RowSet 对象添加到此 JoinRowSet 对象，并且将每个 RowSet 对象的匹配列设置为给定列名数组中的匹配列</p></li>
                                <li><p><code>void 	addRowSet(RowSet rowset, int columnIdx)</code> -- 将给定的 RowSet 对象添加到此 JoinRowSet 对象，并将指定的列设置为 RowSet 对象的匹配列</p></li>
                                <li><p><code>void 	addRowSet(RowSet rowset, String columnName)</code> -- 将 rowset 添加到此 JoinRowSet 对象，并将指定的列设置为匹配列</p></li>

                                <li class="group"><p><code>int 	getJoinType()</code> -- 返回一个 int 值，它描述控制此 JoinRowSet 实例的已设置 SQL JOIN 类型</p></li>
                                <li><p><code>void 	setJoinType(int joinType)</code> -- 允许应用程序调整在 JoinRowSet 对象实例包含的表上强制应用的 JOIN 类型</p></li>
                                <li><p><code>String[] 	getRowSetNames()</code> -- 返回一个 String 数组，包含添加到此 JoinRowSet 对象的 RowSet 对象的名称</p></li>
                                <li><p><code>Collection&lt;?> 	getRowSets()</code> -- 返回一个 Collection 对象，包含已经添加到此 JoinRowSet 对象的 RowSet 对象</p></li>
                                <li><p><code>String 	getWhereClause()</code> -- 返回在 JoinRowSet 对象中使用的 WHERE 子句的类似 SQL 的描述</p></li>
                                <li><p><code>CachedRowSet 	toCachedRowSet()</code> -- 创建一个包含此 JoinRowSet 对象中数据的新 CachedRowSet 对象，可以使用 CachedRowSet 对象的 SyncProvider 对象将此 JoinRowSet 对象保存到数据源</p></li>

                                <li class="group"><p><code>boolean 	supportsCrossJoin()</code> -- 指示 JoinRowSet 实现是否支持 CROSS_JOIN</p></li>
                                <li><p><code>boolean 	supportsFullJoin()</code> -- 指示 JoinRowSet 实现是否支持 FULL_JOIN</p></li>
                                <li><p><code>boolean 	supportsInnerJoin()</code> -- 指示 JoinRowSet 实现是否支持 INNER_JOIN</p></li>
                                <li><p><code>boolean 	supportsLeftOuterJoin()</code> -- 指示 JoinRowSet 实现是否支持 LEFT_OUTER_JOIN</p></li>
                                <li><p><code>boolean 	supportsRightOuterJoin()</code> -- 指示 JoinRowSet 实现是否支持 RIGHT_OUTER_JOIN</p></li>
                            </ol>
                        </div>

                        <a id="SyncResolver" class="offset"></a>
                        <div class="sub-item">
                            <pre class="brush: java;">
public interface SyncResolver extends RowSet {
    int UPDATE_ROW_CONFLICT = 0; // 指示在 RowSet 对象试图更新数据源中的行时发生冲突
    int DELETE_ROW_CONFLICT = 1; // 指示在 RowSet 对象试图删除数据源中的行时发生冲突
    int INSERT_ROW_CONFLICT = 2; // 指示在 RowSet 对象试图将行插入数据源中时发生冲突
    int NO_ROW_CONFLICT = 3; // 指示在 RowSet 对象试图更新、删除或插入数据源中的行时不发生任何冲突
}
</pre>
                            <p><a href="docs/docs-java/api/javax/sql/rowset/spi/SyncResolver.html" target="_blank"><code>javax.sql.rowset.spi.</code>SyncResolver</a> 定义一个框架，当发生同步冲突时，它允许应用程序使用手工决策树来确定应该执行的操作。虽然应用程序手工解决同步冲突并不是委托过程，但此框架还是提供了一些发生冲突时委托应用程序的方法。 </p>
                            <p>注意，冲突是指 RowSet 对象的原始行值与数据源中的值不匹配的情况，它指示自最后一次同步以来数据源行已被修改。还要注意，RowSet 对象的原始值就是最后一次同步之前的值，不必是其初始值。 </p>
                            <ol>
                                <li><p><code>Object 	getConflictValue(int index)</code> -- 获取此 SyncResolver 对象的当前行中指定列的值，它是数据源中导致冲突的值</p></li>
                                <li><p><code>Object 	getConflictValue(String columnName)</code> -- 获取此 SyncResolver 对象的当前行中指定列的值，它是数据源中导致冲突的值</p></li>
                                <li><p><code>int 	getStatus()</code> -- 获取此 SyncResolver 的当前行的冲突状态，它指示在发生冲突时 RowSet 对象正尝试的操作</p></li>
                                <li><p><code>boolean 	nextConflict()</code> -- 将指针从其当前位置移动到下一个包含冲突值的行</p></li>
                                <li><p><code>boolean 	previousConflict()</code> -- 将指针从其当前位置移动到此 SyncResolver 对象中上一个冲突行</p></li>
                                <li><p><code>void 	setResolvedValue(int index, Object obj)</code> -- 将 obj 设置为将同步的 RowSet 对象当前行中第 index 列的值</p></li>
                                <li><p><code>void 	setResolvedValue(String columnName, Object obj)</code> -- 将 obj 设置为将同步的 RowSet 对象当前行中列 columnName 的值</p></li>
                            </ol>
                        </div>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-beans-Beans"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Beans</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
                            <p><b>java.beans 包概述</b></p>
                            <p><code>java.beans</code> 包包含与开发 beans 有关的类，即基于 JavaBeans<sup>TM</sup> 架构的组件。</p>
                            <p>少数类可由 bean 使用，也能以应用程序的形式运行。</p>
                            <p>结构良好的对象就叫做 JavaBeans，简称Beans。定义Beans的类称为 JavaBeans 组件或 Bean 组件，或者简称为组件。这些类通过下列条件组织为 JavaBeans 组件模型：</p>
                            <ol>
                                <li><p>Bean 必须是 public 类；</p></li>
                                <li><p>尽管 Bean 可能有其他构造方法，但是必须有一个公用的无参构造方法；</p></li>
                                <li><p>Bean 必须实现接口 java.io.Serializeable,并确保其持续性；</p></li>
                                <li><p>Bean 的属性通常带有构造恰当的共用访问器方法（get 方法）和修改器方法（set 方法），可以使开发工具能够看到并使用 Bean 属性；</p></li>
                                <li><p>Bean 事件可能带有构造恰当的，共用的注册方法和注销方法，使用这些方法可以添加或删除监听器。如果 Bean 是事件源，它必须提供注册监听器的注册方法。</p></li>
                            </ol>
                            <p>Bean 必须满足前三个条件，因此，这三个条件称为 JavanBeans 组件的最低要求。是否满足后两个条件依赖于具体实现，可能编写的Bean没有 get/set 方法或者没有事件注册/注销方法。</p>
                            <p>为了最大限度地减少 bean 使用的资源，只在要编辑 bean 时加载 bean 编辑器使用的类。当 bean 以应用程序的形式运行时，不需要这些类，所以不用加载它们。</p>
                            <p>除非显式声明，否则 null 值或空 String 对于此包中的方法是无效参数。如果使用这些参数，可能将引发异常。 </p>
                            <p>从 v1.4 开始，java.beans 包提供了对长期持久性 的支持，即以其属性值的文本表示形式读取或写入 bean。这些属性值被视为 bean，它们被递归地读取或写入，以捕获其公共可用状态。此方法适用于长期存储，因为它只依赖于公共 API 而不是很可能发生更改的私有实现。 </p>
                            <p><b>注意</b>： 持久性方案无法自动实例化自定义内部类，比如用于事件处理程序。通过使用 EventHandler 类而不是自定义事件处理程序的内部类，可以避免此问题。 </p>
                            <p>如果需要（或选择）为 bean 提供持久委托，则可以通过使用 DefaultPersistenceDelegate 实例或通过创建自己的 PersistenceDelegate 子类来实现。如果 bean 需要持久委托的唯一原因是因为用户想调用 bean 使用属性值作为参数的构造方法，则可以使用单参数的 DefaultPersistenceDelegate 构造方法创建 bean 的持久委托。否则，用户需要实现自己的持久委托，对此，可能需要以下类：</p>
                            <ul>
                                <li><p><a href="#java-beans-PersistenceDelegate">PersistenceDelegate</a> -- 是一个抽象类，所有持久委托都是从它遗传的。子类应该使用它所知的 bean 类型信息来提供创建 bean 和恢复其状态所需的任何 Statement 和 Expression。</p></li>
                                <li><p><a href="#java-beans-Statement">Statement</a> -- 表示某一对象上的单个方法的调用。包括该方法的参数集合。</p></li>
                                <li><p><a href="#java-beans-Expression">Expression</a> -- 用于返回一个值的那些方法的 Statement 的子类。</p></li>
                            </ul>
                            <p>一旦创建了一个持久委托，就可以使用 XMLEncoder 的 setPersistenceDelegate 方法注册它。</p>
                        </div>
						<pre class="brush: java;">
public class Beans {}
</pre>
                        <p><a href="docs/docs-java/api/java/beans/Beans.html" target="_blank">Beans</a> 类提供一些通用的 bean 控制方法。 </p>
                        <ol>
                            <li><p><code>static Object 	instantiate(ClassLoader cls, String beanName)</code> -- 实例化 JavaBean</p></li>
                            <li><p><code>static Object 	instantiate(ClassLoader cls, String beanName, BeanContext beanContext)</code> -- 实例化 JavaBean</p></li>
                            <li><p><code>static Object 	instantiate(ClassLoader cls, String beanName, BeanContext beanContext, AppletInitializer initializer)</code> -- 实例化 bean</p></li>

                            <li class="group"><p><code>static Object 	getInstanceOf(Object bean, Class&lt;?> targetType)</code> -- 从 bean 中获得表示源对象的指定类型视图的对象</p></li>
                            <li><p><code>static boolean 	isInstanceOf(Object bean, Class&lt;?> targetType)</code> -- 检查是否可以将 bean 视为给定目标类型</p></li>

                            <li class="group"><p><code>static boolean 	isDesignTime()</code> -- 测试是否正处于设计模式</p></li>
                            <li><p><code>static void 	setDesignTime(boolean isDesignTime)</code> -- 用于指示是否正运行在应用程序生成器环境中</p></li>

                            <li class="group"><p><code>static boolean 	isGuiAvailable()</code> -- 确定 bean 是否可以假定某个 GUI 是可用的</p></li>
                            <li><p><code>static void 	setGuiAvailable(boolean isGuiAvailable)</code> -- 用于指示是否正运行在可进行 GUI 交互的环境中</p></li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-beans-Encoder"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Encoder 及相关类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.beans.Encoder

public class Encoder {}
</pre>
                            <p><a href="docs/docs-java/api/java/beans/Encoder.html" target="_blank">Encoder</a> 是这样的类，它可用于创建根据其公共 API 对 JavaBeans 集合状态进行编码的文件或流。Encoder 结合其持久委托，负责将对象图形拆分成一系列可用于创建它的 Statements 和 Expression。子类通常使用某种可读形式（比如 Java 源代码或 XML）提供这些表达式的语法。 </p>
                            <ol>
                                <li><p><code>Object 	get(Object oldInstance)</code> -- 在由此流创建的环境中返回 oldInstance 的一个实验值</p></li>
                                <li><p><code>Object 	remove(Object oldInstance)</code> -- 移除此实例的条目，返回旧条目</p></li>

                                <li class="group"><p><code>protected  void 	writeObject(Object o)</code> -- 将指定对象写入输出流中</p></li>
                                <li><p><code>void 	writeStatement(Statement oldStm)</code> -- 将语句 oldStm 写入流中</p></li>
                                <li><p><code>void 	writeExpression(Expression oldExp)</code> -- 该实现首先查看使用此值的表达式是否已经被写入</p></li>

                                <li class="group"><p><code>ExceptionListener 	getExceptionListener()</code> -- 获得此流的异常处理程序</p></li>
                                <li><p><code>void 	setExceptionListener(ExceptionListener exceptionListener)</code> -- 将此流的异常处理程序设置为 exceptionListener</p></li>

                                <li class="group"><p><code>PersistenceDelegate 	getPersistenceDelegate(Class&lt;?> type)</code> -- 返回给定类型的持久委托</p></li>
                                <li><p><code>void 	setPersistenceDelegate(Class&lt;?> type, PersistenceDelegate persistenceDelegate)</code> -- 将与此 type 相关联的持久委托设置为 persistenceDelegate</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.beans.Encoder
        java.beans.XMLEncoder

public class XMLEncoder extends Encoder implements AutoCloseable {
    public XMLEncoder(OutputStream out) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/beans/XMLEncoder.html" target="_blank">XMLEncoder</a> 是 ObjectOutputStream 的互补替换，可用于生成 JavaBean 的文本表示形式，所使用方式与用 ObjectOutputStream 创建 Serializable 对象的二进制表示形式的方式相同。</p>
                            <p>尽管两者的 API 类似，但 XMLEncoder 类仅设计用于将 JavaBean 的图形归档为其公共属性的文本表示形式。与 Java 源文件类似，以这种方式写入的文档在所涉及类的实现中可自然免除更改。在进程间通信和通用序列化中继续推荐使用 ObjectOutputStream。 </p>
                            <p>XMLEncoder 类提供 JavaBean 的默认指示，其中它们被表示为符合 1.0 版的 XML 规范和 Unicode/ISO 10646 字符集 UTF-8 字符编码的 XML 文档。由 XMLEncoder 类生成的 XML 文档如下： </p>
                            <ul>
                                <li><p>轻便且版本灵活：它们不依赖于任何类的私有实现，因此，与 Java 源文件类似，可以在某些不同版本的类之间或不同的供应商的 VM 之间交换它们。</p></li>
                                <li><p>结构紧凑：XMLEncoder 类在内部使用删减冗余 (redundancy elimination) 算法，因此 Bean 属性的默认值不会被写入流中。</p></li>
                                <li><p>容错性：文件中的非结构性错误（由于文件的破坏或在归档文件中对类进行的 API 更改导致）仍然保持本地化，因此 reader 可以报告错误，并继续加载不受错误影响的那部分文档。</p></li>
                            </ul>
                            <ol>
                                <li><p><code>void 	close()</code> -- 此方法调用 flush，写入结束后文，然后关闭与此流有关的输出流</p></li>
                                <li><p><code>void 	flush()</code> -- 如果还没有写出导言，那么此方法将写出与 XML 编码有关的导言，并随后写出从最后一次调用 flush 以来写入流中的所有值</p></li>
                                <li><p><code>Object 	getOwner()</code> -- 获得此编码器的所有者</p></li>
                                <li><p><code>void 	setOwner(Object owner)</code> -- 将此编码器的所有者设置为 owner</p></li>
                                <li><p><code>void 	writeExpression(Expression oldExp)</code> -- 记录 Expression，以便 Encoder 在刷新流的缓存时产生实际输出</p></li>
                                <li><p><code>void 	writeObject(Object o)</code> -- 将指定对象的 XML 表示形式写入输出中</p></li>
                                <li><p><code>void 	writeStatement(Statement oldStm)</code> -- 记录 Statement，以便 Encoder 在刷新流的缓存时产生实际输出</p></li>
                            </ol>
                            <p>将对象生成 XML 文件：</p>
                            <pre class="brush: java;">
List&lt;Book> books = new ArrayList<>();
books.add(new Book(1001, "Think In Java", 30.00f));
books.add(new Book(1001, "Linux Kernel", 60.00f));
try {
    OutputStream out = new FileOutputStream("./books.xml");
    XMLEncoder xmlEncoder = new XMLEncoder(out);
    xmlEncoder.writeObject(books);
    xmlEncoder.close();
} catch (FileNotFoundException e) {
    e.printStackTrace();
}
</pre>
                            <p>生成的 XML 文件如下：</p>
                            <pre class="brush: xml;">
&lt;?xml version="1.0" encoding="UTF-8"?>
<java version="1.8.0_65" class="java.beans.XMLDecoder">
 <object class="java.util.ArrayList">
  <void method="add">
   <object class="io.github.my.bean.Book">
    <void property="id">
     <int>1001</int>
    </void>
    <void property="name">
     <string>Think In Java</string>
    </void>
    <void property="price">
     <float>30.0</float>
    </void>
   </object>
  </void>
  <void method="add">
   <object class="io.github.my.bean.Book">
    <void property="id">
     <int>1001</int>
    </void>
    <void property="name">
     <string>Linux Kernel</string>
    </void>
    <void property="price">
     <float>60.0</float>
    </void>
   </object>
  </void>
 </object>
</java>
</pre>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.beans.XMLDecoder

public class XMLDecoder implements AutoCloseable {
    public XMLDecoder(InputSource is) {}
    public XMLDecoder(InputStream in) {}
    public XMLDecoder(InputStream in, Object owner) {}
    public XMLDecoder(InputStream in, Object owner, ExceptionListener exceptionListener) {}
    public XMLDecoder(InputStream in, Object owner, ExceptionListener exceptionListener, ClassLoader cl) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/beans/XMLDecoder.html" target="_blank">XMLDecoder</a> 类用于读取使用 XMLEncoder 创建的 XML 文档，用途类似于 ObjectInputStream。</p>
                            <ol>
                                <li><p><code>static DefaultHandler 	createHandler(Object owner, ExceptionListener el, ClassLoader cl)</code> -- 为 SAX 解析器创建一个新的处理程序</p></li>

                                <li class="group"><p><code>Object 	readObject()</code> -- 从基础输入流中读取下一个对象</p></li>
                                <li><p><code>void 	close()</code> -- 关闭与此流相关联的输入流</p></li>
                                <li><p><code>Object 	getOwner()</code> -- 获取此解码器的所有者</p></li>
                                <li><p><code>void 	setOwner(Object owner)</code> -- 设置将此解码器的所有者</p></li>

                                <li class="group"><p><code>void 	setExceptionListener(ExceptionListener exceptionListener)</code> -- 设置异常处理程序</p></li>
                                <li><p><code>ExceptionListener 	getExceptionListener()</code> -- 获得此流的异常处理程序</p></li>
                            </ol>
                            <p>从 XML 加载对象:(前面 XMLEncoder 生成的 xml 文件)</p>
                            <pre class="brush: java;">
try {
    InputStream in = new FileInputStream("./books.xml");
    XMLDecoder xmlDecoder = new XMLDecoder(in);
    List&lt;Book> bookList = (List&lt;Book>) xmlDecoder.readObject();
    bookList.forEach(book -> {
        log(book);
    });
} catch (FileNotFoundException e) {
    e.printStackTrace();
}
</pre>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-beans-FeatureDescriptor"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">FeatureDescriptor 及子类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.beans.FeatureDescriptor

public class FeatureDescriptor {}
</pre>
                            <p><a href="docs/docs-java/api/java/beans/FeatureDescriptor.html" target="_blank">FeatureDescriptor</a> 类是 PropertyDescriptor、EventSetDescriptor 和 MethodDescriptor 等的公共基类。</p>
                            <p>它支持一些可以设置和检索任意的内省描述符的公共信息。 </p>
                            <p>此外，它还提供了一种扩展机制，从而任意属性/值对都可以与设计特性相关联。 </p>
                            <ol>
                                <li><p><code>void 	setName(String name)</code> -- 设置此特性的编程名称</p></li>
                                <li><p><code>String 	getName()</code> -- 获得此特性的编程名称</p></li>
                                <li><p><code>void 	setDisplayName(String displayName)</code> -- 获得此特性的本地化显示名称</p></li>
                                <li><p><code>String 	getDisplayName()</code> -- 设置此特性的本地化显示名称</p></li>
                                <li><p><code>void 	setShortDescription(String text)</code> -- 可以将简短描述性字符串与某一特性相关联</p></li>
                                <li><p><code>String 	getShortDescription()</code> -- 获得此特性的简短描述</p></li>

                                <li class="group"><p><code>Object 	getValue(String attributeName)</code> -- 利用此特性检索指定属性</p></li>
                                <li><p><code>void 	setValue(String attributeName, Object value)</code> -- 将某一指定属性与此特性相关联</p></li>
                                <li><p><code>Enumeration&lt;String> 	attributeNames()</code> -- 获得与语言环境无关的此特性名称的枚举</p></li>

                                <li class="group"><p><code>boolean 	isExpert()</code> -- "expert" 标志用于区分那些打算供高级用户使用的特性与那些打算供普通用户使用的特性</p></li>
                                <li><p><code>void 	setExpert(boolean expert)</code> -- 设置 expert 标志</p></li>
                                <li><p><code>boolean 	isHidden()</code> -- "hidden" 标志用于标识只打算供工具使用、不应对人类开放的特性</p></li>
                                <li><p><code>void 	setHidden(boolean hidden)</code> -- 设置 hidden 标志</p></li>
                                <li><p><code>boolean 	isPreferred()</code> -- "preferred" 标志用于标识呈现给用户的特别重要的特性</p></li>
                                <li><p><code>void 	setPreferred(boolean preferred)</code> -- 设置 preferred 标志</p></li>

                                <li class="group"><p><code>void toString()</code> -- 所有属性</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.beans.FeatureDescriptor
        java.beans.BeanDescriptor

public class BeanDescriptor extends FeatureDescriptor {
    public BeanDescriptor(Class&lt;?> beanClass) {}
    public BeanDescriptor(Class&lt;?> beanClass, Class&lt;?> customizerClass) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/beans/BeanDescriptor.html" target="_blank">BeanDescriptor</a> 提供有关 "bean" 的全局信息，其中包括其 Java 类、其 displayName 等等</p>
                            <p>这是由 BeanInfo 对象返回的描述符种类之一，该对象还返回属性、方法和事件的描述符。</p>
                            <ol>
                                <li><p><code>Class&lt;?> 	getBeanClass()</code> -- 获得 bean 的 Class 对象</p></li>
                                <li><p><code>Class&lt;?> 	getCustomizerClass()</code> -- 获得 bean 的 customizer 的 Class 对象</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.beans.FeatureDescriptor
        java.beans.EventSetDescriptor

public class EventSetDescriptor extends FeatureDescriptor {
    public EventSetDescriptor(Class&lt;?> sourceClass, String eventSetName, Class&lt;?> listenerType,
        String listenerMethodName) {}
    public EventSetDescriptor(Class&lt;?> sourceClass, String eventSetName, Class&lt;?> listenerType,
        String[] listenerMethodNames, String addListenerMethodName, String removeListenerMethodName) {}
    public EventSetDescriptor(Class&lt;?> sourceClass, String eventSetName, Class&lt;?> listenerType,
        String[] listenerMethodNames, String addListenerMethodName, String removeListenerMethodName,
        String getListenerMethodName) {}
    public EventSetDescriptor(String eventSetName, Class&lt;?> listenerType, Method[] listenerMethods,
        Method addListenerMethod, Method removeListenerMethod) {}
    public EventSetDescriptor(String eventSetName, Class&lt;?> listenerType, Method[] listenerMethods,
        Method addListenerMethod, Method removeListenerMethod, Method getListenerMethod) {}
    public EventSetDescriptor(String eventSetName, Class&lt;?> listenerType, MethodDescriptor[]
        listenerMethodDescriptors, Method addListenerMethod, Method removeListenerMethod) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/beans/EventSetDescriptor.html" target="_blank">EventSetDescriptor</a> 描述给定 Java bean 激发的一组事件的 EventSetDescriptor。 </p>
                            <p>给定的事件组都是作为方法调用在单个事件侦听器接口上传递的，事件侦听器对象可以通过调用事件源提供的注册方法进行注册。</p>
							<ol>
                                <li><p><code>Method 	getAddListenerMethod()</code> -- 获得用来添加事件侦听器的方法</p></li>
                                <li><p><code>Method 	getRemoveListenerMethod()</code> -- 获得用来移除事件侦听器的方法</p></li>
                                <li><p><code>Method 	getGetListenerMethod()</code> -- 获得用来访问已注册事件侦听器的方法</p></li>

                                <li class="group"><p><code>Method[] 	getListenerMethods()</code> -- 获得目标侦听器接口的方法</p></li>
                                <li><p><code>MethodDescriptor[] 	getListenerMethodDescriptors()</code> -- 获得目标侦听器接口的 MethodDescriptor</p></li>
                                <li><p><code>Class&lt;?> 	getListenerType()</code> -- 获得目标接口的 Class 对象</p></li>

                                <li class="group"><p><code>boolean 	isInDefaultEventSet()</code> -- 报告事件集是否在“默认”集合中</p></li>
                                <li><p><code>void 	setInDefaultEventSet(boolean inDefaultEventSet)</code> -- 将事件集标记为“默认”集合（或非默认集合）</p></li>
                                <li><p><code>boolean 	isUnicast()</code> -- 通常事件源是多播的</p></li>
                                <li><p><code>void 	setUnicast(boolean unicast)</code> -- 将事件集标记为单播（或非单播）</p></li>
							</ol>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.beans.FeatureDescriptor
        java.beans.MethodDescriptor

public class MethodDescriptor extends FeatureDescriptor {
    public MethodDescriptor(Method method) {}
    public MethodDescriptor(Method method, ParameterDescriptor[] parameterDescriptors) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/beans/MethodDescriptor.html" target="_blank">MethodDescriptor</a> 描述了一种特殊方法，即 Java Bean 支持从其他组件对其进行外部访问。</p>
                            <ol>
                                <li><p><code>Method 	getMethod()</code> -- 获得此 MethodDescriptor 封装的方法</p></li>
                                <li><p><code>ParameterDescriptor[] 	getParameterDescriptors()</code> -- 获得此 MethodDescriptor 每个方法参数的 ParameterDescriptor</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.beans.FeatureDescriptor
        java.beans.ParameterDescriptor

public class ParameterDescriptor extends FeatureDescriptor {}
</pre>
                            <p><a href="docs/docs-java/api/java/beans/ParameterDescriptor.html" target="_blank">ParameterDescriptor</a> 类允许 bean 实现者提供除 java.lang.reflect.Method 类提供的低级别信息之外的关于其每个参数的额外信息。 </p>
                            <p>当前所有状态都来自 FeatureDescriptor 基类。</p>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.beans.FeatureDescriptor
        java.beans.PropertyDescriptor

public class PropertyDescriptor extends FeatureDescriptor {
    public PropertyDescriptor(String propertyName, Class&lt;?> beanClass) {}
    public PropertyDescriptor(String propertyName, Class&lt;?> beanClass, String readMethodName,
                              String writeMethodName) {}
    public PropertyDescriptor(String propertyName, Method readMethod, Method writeMethod) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/beans/PropertyDescriptor.html" target="_blank">PropertyDescriptor</a> 描述 Java Bean 通过一对存储器方法导出的一个属性。 </p>
                            <ol>
                                <li><p><code>PropertyEditor 	createPropertyEditor(Object bean)</code> -- 使用当前属性编辑器类构造一个属性编辑器实例</p></li>
                                <li><p><code>Class&lt;?> 	getPropertyEditorClass()</code> -- 获得已为此属性注册的任何显式 PropertyEditor Class</p></li>
                                <li><p><code>void 	setPropertyEditorClass(Class&lt;?> propertyEditorClass)</code> -- 通常此 class  是使用 PropertyEditorManager 找到的</p></li>

                                <li class="group"><p><code>Class&lt;?> 	getPropertyType()</code> -- 获得属性的 Class 对象</p></li>

                                <li class="group"><p><code>boolean 	isBound()</code> -- 更新 "bound" 属性将导致更改该属性时激发 "PropertyChange" 事件</p></li>
                                <li><p><code>void 	setBound(boolean bound)</code> -- 更新 "bound" 属性将导致更改该属性时激发 "PropertyChange" 事件</p></li>
                                <li><p><code>boolean 	isConstrained()</code> -- 试图更新 "Constrained" 属性将导致更改该属性时激发 "VetoableChange" 事件</p></li>
                                <li><p><code>void 	setConstrained(boolean constrained)</code> -- 更新 "Constrained" 属性将导致更改该属性时激发 "VetoableChange" 事件</p></li>

                                <li class="group"><p><code>Method 	getReadMethod()</code> -- 获得应该用于读取属性值的方法</p></li>
                                <li><p><code>void 	setReadMethod(Method readMethod)</code> -- 设置应该用于读取属性值的方法</p></li>
                                <li><p><code>void 	setWriteMethod(Method writeMethod)</code> -- 设置应该用于写入属性值的方法</p></li>
                                <li><p><code>Method 	getWriteMethod()</code> -- 获得应该用于写入属性值的方法</p></li>

                                <li class="group"><p><code>int 	hashCode()</code> -- 返回对象的哈希码</p></li>
                                <li><p><code>boolean 	equals(Object obj)</code> -- 将此 PropertyDescriptor 与指定对象进行比较</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.beans.FeatureDescriptor
        java.beans.PropertyDescriptor
            java.beans.IndexedPropertyDescriptor

public class IndexedPropertyDescriptor extends PropertyDescriptor {
    public IndexedPropertyDescriptor(String propertyName, Class&lt;?> beanClass) {}
    public IndexedPropertyDescriptor(String propertyName, Class&lt;?> beanClass, String readMethodName,
        String writeMethodName, String indexedReadMethodName, String indexedWriteMethodName) {}
    public IndexedPropertyDescriptor(String propertyName, Method readMethod, Method writeMethod,
        Method indexedReadMethod, Method indexedWriteMethod) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/beans/IndexedPropertyDescriptor.html" target="_blank">IndexedPropertyDescriptor</a> 描述了类似数组行为的属性，且有一种访问数组特定元素的索引读和/或索引写方法。 </p>
                            <p>索引 (indexed) 属性还可以提供简单的非索引读和写方法。如果存在这些方法，它们可读取和写入索引读方法所返回类型的读写数组。</p>
                            <ol>
                                <li><p><code>Class&lt;?> 	getIndexedPropertyType()</code> -- 获得索引属性类型的 Class 对象</p></li>

                                <li class="group"><p><code>Method 	getIndexedReadMethod()</code> -- 获得应该用于读取索引属性值的方法</p></li>
                                <li><p><code>void 	setIndexedReadMethod(Method readMethod)</code> -- 设置应该用于读取索引属性值的方法</p></li>
                                <li><p><code>Method 	getIndexedWriteMethod()</code> -- 获得应该用于写入索引属性值的方法</p></li>
                                <li><p><code>void 	setIndexedWriteMethod(Method writeMethod)</code> -- 设置应该用于写入索引属性值的方法</p></li>

                                <li class="group"><p><code>boolean 	equals(Object obj)</code> -- 将此 PropertyDescriptor 与指定对象比较</p></li>
                                <li><p><code>int 	hashCode()</code> -- 返回对象的哈希码值</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-text-Format"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Format 及其子类</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
Format
 ├─ DateFormat
 │   └─ SimpleDateFormat
 ├─ NumberFormat
 │   ├─ DecimalFormat
 │   └─ ChoiceFormat
 └─ MessageFormat

java.lang.Object
    java.text.Format

public abstract class Format implements Serializable, Cloneable {
    public static class Field extends AttributedCharacterIterator.Attribute {
        protected Field(String name) {}
    }

    protected Format() {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/text/Format.html" target="_blank">Format</a>  是一个用于格式化语言环境敏感的信息（如日期、消息和数字）的抽象基类。 </p>
                            <p>Format 定义了编程接口，用于将语言环境敏感的对象格式化为 String（使用 format 方法）和将 String 重新解析为对象（使用 parseObject 方法）。</p>
                            <p>通常，一个 format 的 parseObject 方法必须能解析任何由其 format 方法格式化的字符串。不过，也可能存在不能解析的异常情况。例如，format 方法可能创建中间无分隔符的两个相邻整数，在这种情况下，parseObject 无法判断哪个数字属于哪个数。 </p>
                            <ol>
                                <li><p><code>String 	format(Object obj)</code> -- 格式化一个对象以生成一个字符串</p></li>
                                <li><p><code>abstract  StringBuffer 	format(Object obj, StringBuffer toAppendTo, FieldPosition pos)</code> -- 格式化一个对象，并将得到的文本添加到给定的字符缓冲区</p></li>
                                <li><p><code>AttributedCharacterIterator 	formatToCharacterIterator(Object obj)</code> -- 格式化一个对象，生成一个 AttributedCharacterIterator</p></li>

                                <li class="group"><p><code>Object 	parseObject(String source)</code> -- 从给定字符串的开始处解析文本以生成一个对象</p></li>
                                <li><p><code>abstract  Object 	parseObject(String source, ParsePosition pos)</code> -- 解析字符串文本，生成一个对象</p></li>

                                <li class="group"><p><code>Object 	clone()</code> -- 创建并返回此对象的一个副本</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <div class="split-item">
						        <pre class="brush: java;">
public abstract class DateFormat extends Format {
    public static class Field extends Format.Field {}

    /** 格式化样式，包括日期和时间的样式都能使用 */
    public static final int FULL = 0;   // Friday, 24 August 2018 17:17:40 o'clock CST
    public static final int LONG = 1;   // 24 August 2018 17:18:21 CST
    public static final int MEDIUM = 2; // 24-Aug-2018 17:19:19
    public static final int SHORT = 3;  // 24/08/18 17:18
    public static final int DEFAULT = MEDIUM;

    public final static int ERA_FIELD = 0;
    public final static int YEAR_FIELD = 1;
    public final static int MONTH_FIELD = 2;
    public final static int DATE_FIELD = 3;
    public final static int HOUR_OF_DAY1_FIELD = 4;
    public final static int HOUR_OF_DAY0_FIELD = 5;
    public final static int MINUTE_FIELD = 6;
    public final static int SECOND_FIELD = 7;
    public final static int MILLISECOND_FIELD = 8;
    public final static int DAY_OF_WEEK_FIELD = 9;
    public final static int DAY_OF_YEAR_FIELD = 10;
    public final static int DAY_OF_WEEK_IN_MONTH_FIELD = 11;
    public final static int WEEK_OF_YEAR_FIELD = 12;
    public final static int WEEK_OF_MONTH_FIELD = 13;
    public final static int AM_PM_FIELD = 14;
    public final static int HOUR1_FIELD = 15;
    public final static int HOUR0_FIELD = 16;
    public final static int TIMEZONE_FIELD = 17;
}
</pre>
                                <p><a href="docs/docs-java/api/java/text/DateFormat.html" target="_blank">DateFormat</a> 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。</p>
                                <p>DateFormat 提供了很多类方法，以获得基于默认或给定语言环境和多种格式化风格的默认日期/时间 Formatter。格式化风格包括 FULL、LONG、MEDIUM 和 SHORT。</p>
                                <p>DateFormat 可帮助进行格式化并解析任何语言环境的日期。对于月、星期，甚至日历格式（阴历和阳历），其代码可完全与语言环境的约定无关。</p>
                                <ol>
                                    <li><p><code>static DateFormat 	getInstance()</code> -- 调用的是 <code>getDateTimeInstance(SHORT, SHORT)</code> 方法</p></li>

                                    <li class="group"><p><code>static DateFormat 	getDateInstance()</code> -- 同 <code>getDateInstance(DEFAULT)</code></p></li>
                                    <li><p><code>static DateFormat 	getDateInstance(int style)</code> -- 获取指定格式的日期格式器，参见格式化样式常量</p></li>
                                    <li><p><code>static DateFormat 	getDateInstance(int style, Locale aLocale)</code> -- 获取指定语言环境的指定格式的日期格式器</p>
                                        <pre class="brush: java;">
log(DateFormat.getDateInstance().format(new Date()));                 // 24-Aug-2018
log(DateFormat.getDateInstance(DateFormat.SHORT).format(new Date())); // 24/08/18
</pre>
                                    </li>

                                    <li class="group"><p><code>static DateFormat 	getTimeInstance()</code> -- 同 <code>getTimeInstance(DEFAULT)</code></p></li>
                                    <li><p><code>static DateFormat 	getTimeInstance(int style)</code> -- 获取指定格式的时间格式器，参见格式化样式常量</p></li>
                                    <li><p><code>static DateFormat 	getTimeInstance(int style, Locale aLocale)</code> -- 获取指定语言环境的指定格式的时间格式器</p>
                                        <pre class="brush: java;">
log(DateFormat.getTimeInstance().format(new Date()));                 // 17:44:45
log(DateFormat.getTimeInstance(DateFormat.SHORT).format(new Date())); // 17:44
</pre>
                                    </li>

                                    <li class="group"><p><code>static DateFormat 	getDateTimeInstance()</code> -- 合并 <code>getDateInstance(DEFAULT)</code> 和 <code>getTimeInstance(DEFAULT)</code></p></li>
                                    <li><p><code>static DateFormat 	getDateTimeInstance(int dateStyle, int timeStyle)</code> -- 获取指定格式的时间和时间格式器</p></li>
                                    <li><p><code>static DateFormat 	getDateTimeInstance(int dateStyle, int timeStyle, Locale aLocale)</code> -- 指定语言环境</p>
                                        <pre class="brush: java;">
// 24-Aug-2018 17:44
log(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.SHORT).format(new Date()));
</pre>
                                    </li>

                                    <li class="group"><p><code>static Locale[] 	getAvailableLocales()</code> -- 返回所有语言环境的数组</p></li>

                                    <li class="group"><p><code>String 	format(Date date)</code> -- 用当前的时间/时间格式器将 date 格式为字符串</p></li>
                                    <li><p><code>abstract StringBuffer 	format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)</code> -- 参见子类实现</p></li>
                                    <li><p><code>StringBuffer 	format(Object obj, StringBuffer toAppendTo, FieldPosition fieldPosition)</code> -- 相当于重写 format</p></li>

                                    <li class="group"><p><code>Date 	parse(String source)</code> -- 从给定字符串的开始解析文本以生成一个日期，参见子类 SimpleDateFormat</p></li>
                                    <li><p><code>abstract Date 	parse(String source, ParsePosition pos)</code> -- 参见子类 SimpleDateFormat 实现</p></li>
                                    <li><p><code>Object 	parseObject(String source, ParsePosition pos)</code> -- 相当于重写 parse</p></li>

                                    <li class="group"><p><code>NumberFormat 	getNumberFormat()</code> -- 获取数字格式器</p></li>
                                    <li><p><code>void 	setNumberFormat(NumberFormat newNumberFormat)</code> -- 允许用户设置数字格式器</p></li>
                                    <li><p><code>TimeZone 	getTimeZone()</code> -- 获取时区，参见: <a href="#java-util-Date">TimeZone</a></p></li>
                                    <li><p><code>void 	setTimeZone(TimeZone zone)</code> -- 为此 DateFormat 对象的日历设置时区</p></li>
                                    <li><p><code>boolean 	isLenient()</code> -- 判断日期/时间解析是否为不严格的</p></li>
                                    <li><p><code>void 	setLenient(boolean lenient)</code> -- 指定日期/时间解析是否不严格</p></li>
                                    <li><p><code>Calendar 	getCalendar()</code> -- 获取使用的日历</p></li>
                                    <li><p><code>void 	setCalendar(Calendar newCalendar)</code> -- 设置此日期格式所使用的日历</p></li>
                                </ol>
                            </div>
                            <div class="split-item">
						        <pre class="brush: java;">
public class SimpleDateFormat extends DateFormat {
    /** 前三个构造方法最然是公共的，但是推荐使用 DateFormat 的 getTimeInstance(...) 方法构建 */
    public SimpleDateFormat() {}
    public SimpleDateFormat(String pattern) {}
    public SimpleDateFormat(String pattern, DateFormatSymbols formatSymbols) {}

	/** 此方法唯一适合 SimpleDateFormat 的构造 */
    public SimpleDateFormat(String pattern, Locale locale) {}
}
</pre>
                                <p><a href="docs/docs-java/api/java/text/SimpleDateFormat.html" target="_blank">SimpleDateFormat</a> 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -> 文本）、解析（文本 -> 日期）和规范化。 </p>
                                <p>SimpleDateFormat 使得可以选择任何用户定义的日期-时间格式的模式。但是，仍然建议通过 DateFormat 中的 getTimeInstance、getDateInstance 或 getDateTimeInstance 来创建日期-时间格式器。每一个这样的类方法都能够返回一个以默认格式模式初始化的日期/时间格式器。可以根据需要使用 applyPattern 方法来修改格式模式。</p>
                                <ol>

                                    <li><p><code>StringBuffer 	format(Date date, StringBuffer toAppendTo, FieldPosition pos)</code> -- 将给定的 Date 格式化为日期/时间字符串，并将结果添加到给定的 StringBuffer</p></li>
                                    <li><p><code>AttributedCharacterIterator 	formatToCharacterIterator(Object obj)</code> -- 格式化生成 AttributedCharacterIterator 的对象</p></li>
                                    <li><p><code>Date 	parse(String text, ParsePosition pos)</code> -- 解析字符串的文本，生成 Date</p></li>

                                    <li class="group"><p><code>void 	applyLocalizedPattern(String pattern)</code> -- 将给定的本地化模式字符串应用于此日期格式</p></li>
                                    <li><p><code>void 	applyPattern(String pattern)</code> -- 将给定模式字符串应用于此日期格式</p></li>
                                    <li><p><code>String 	toLocalizedPattern()</code> -- 返回描述此日期格式的本地化模式字符串</p></li>
                                    <li><p><code>String 	toPattern()</code> -- 返回描述此日期格式的模式字符串</p></li>

                                    <li class="group"><p><code>Date 	get2DigitYearStart()</code> -- 返回在 100 年周期内被解释的两位数字年份的开始日期</p></li>
                                    <li><p><code>void 	set2DigitYearStart(Date startDate)</code> -- 设置 100 年周期的两位数年份，该年份将被解释为从用户指定的日期开始</p></li>
                                    <li><p><code>DateFormatSymbols 	getDateFormatSymbols()</code> -- 获取此日期格式的日期和时间格式符号的一个副本</p></li>
                                    <li><p><code>void 	setDateFormatSymbols(DateFormatSymbols newFormatSymbols)</code> -- 设置此日期格式的日期和时间格式符号</p></li>

                                    <li class="group"><p><code>Object 	clone()</code> -- 创建此 SimpleDateFormat 的一个副本</p></li>
                                    <li><p><code>boolean 	equals(Object obj)</code> -- 比较给定对象与此 SimpleDateFormat 的相等性</p></li>
                                    <li><p><code>int 	hashCode()</code> -- 返回此 SimpleDateFormat 对象的哈希码值</p></li>
                                </ol>
								<p>日期和时间的模式:</p>
								<pre class="brush: java;">
/**
 * y 	年 	Year 	1996; 96
 * M 	年中的月份 	Month 	July; Jul; 07
 * d 	月份中的天数 	Number 	10
 * H 	一天中的小时数（0-23） 	Number 	0
 * h 	am/pm 中的小时数（1-12） 	Number 	12
 * m 	小时中的分钟数 	Number 	30
 * s 	分钟中的秒数 	 	55
 * S 	毫秒数 	Number 	978
 * a 	Am/pm 标记 	Text 	PM
 * E 	星期中的天数 	Text 	Tuesday; Tue
 * G 	Era 标志符 	Text 	AD
 * w 	年中的周数 	Number 	27
 * W 	月份中的周数 	Number 	2
 * D 	年中的天数 	Number 	189
 * F 	月份中的星期 	Number 	2
 * k 	一天中的小时数（1-24） 	Number 	24
 * K 	am/pm 中的小时数（0-11） 	Number 	0
 * z 	时区 	General time zone 	Pacific Standard Time; PST; GMT-08:00
 * Z 	时区 	RFC 822 time zone 	-0800
 */
SimpleDateFormat format = new SimpleDateFormat("dd/MM/YYYY E hh:mm:ss", Locale.CHINA);
log(format.format(new Date())); // 27/08/2018 星期一 09:01:19
format.applyPattern("YYYY 年 MM 月 dd 日 E hh 时 mm 分 ss 秒");
log(format.format(new Date())); // 2018 年 08 月 27 日 星期一 09 时 01 分 19 秒
</pre>
                            </div>
                        </div>

                        <div class="sub-item">
                            <div class="split-item">
						        <pre class="brush: java;">
public abstract class NumberFormat extends Format {
    public static class Field extends Format.Field {}

    protected NumberFormat() {}

    /** 用于构造 FieldPosition 对象的字段常量 */
    public static final int INTEGER_FIELD = 0;  // 表示必须返回格式化数值整数部分的位置
    public static final int FRACTION_FIELD = 1; // 表示必须返回格式化数值小数部分的位置
}
</pre>
                                <p><a href="docs/docs-java/api/java/text/NumberFormat.html" target="_blank">NumberFormat</a> 是所有数值格式的抽象基类。此类提供格式化和解析数值的接口。NumberFormat 还提供了一些方法来确定哪些语言环境具有数值格式，以及它们的名称是什么。 </p>
                                <p>NumberFormat 可用于格式化和解析任何语言环境的数值。使代码能够完全独立于小数点、千位分隔符甚至所用特定小数位数的语言环境约定，并与数值格式是否为偶小数无关。 </p>
                                <ol>
                                    <li><p><code>static NumberFormat 	getInstance()</code> -- 返回当前默认语言环境的通用数值格式</p></li>
                                    <li><p><code>static NumberFormat 	getNumberInstance()</code> -- 同上</p></li>
                                    <li><p><code>static NumberFormat 	getInstance(Locale inLocale)</code> -- 返回指定语言环境的通用数值格式</p></li>
                                    <li><p><code>static NumberFormat 	getNumberInstance(Locale inLocale)</code> -- 同上</p>
                                        <pre class="brush: java;">
/** 去除左右无效位(0),float 和 double 默认保留三位小数(第三位为四舍五入)，
 可通过 setMaximumFractionDigits(int) 更改浮点数有效位数 */
NumberFormat format = NumberFormat.getInstance();
log(format.format(100), format.format(0100.23456789f)); // 100, 100.235
format = NumberFormat.getNumberInstance();
log(format.format(100), format.format(0100.234567890)); // 100, 100.235
</pre>
                                    </li>

                                    <li class="group"><p><code>static NumberFormat 	getIntegerInstance()</code> -- 返回当前默认语言环境的整数格式(小数位直接丢弃)</p></li>
                                    <li><p><code>static NumberFormat 	getIntegerInstance(Locale inLocale)</code> -- 返回指定语言环境的整数格式</p></li>
                                    <li><p><code>static NumberFormat 	getPercentInstance()</code> -- 返回当前默认语言环境的百分比格式</p></li>
                                    <li><p><code>static NumberFormat 	getPercentInstance(Locale inLocale)</code> -- 返回指定语言环境的百分比格式</p>
                                        <pre class="brush: java;">log(NumberFormat.getPercentInstance().format(88.8)); // 8,880%</pre>
                                    </li>
                                    <li><p><code>static NumberFormat 	getCurrencyInstance()</code> -- 返回当前默认语言环境的货币格式(格式化时加货币符号)</p></li>
                                    <li><p><code>static NumberFormat 	getCurrencyInstance(Locale inLocale)</code> -- 返回指定语言环境的货币格式</p>
                                        <pre class="brush: java;">log(NumberFormat.getCurrencyInstance(Locale.CHINA).format(100)); // ￥100.00</pre>
                                    </li>

                                    <li class="group"><p><code>static Locale[] 	getAvailableLocales()</code> -- 返回所有语言环境的数组</p></li>

                                    <li class="group"><p><code>String 	format(long number)</code> -- 使用当前的数字格式器格式化 long 类型</p></li>
                                    <li><p><code>String 	format(double number)</code> -- 使用当前的数字格式器格式化 double 类型</p></li>
                                    <li><p><code>abstract StringBuffer 	format(long number, StringBuffer toAppendTo, FieldPosition pos)</code> -- 相当于重写</p></li>
                                    <li><p><code>abstract StringBuffer 	format(double number, StringBuffer toAppendTo, FieldPosition pos)</code> -- 相当于重写</p></li>
                                    <li><p><code>StringBuffer 	format(Object number, StringBuffer toAppendTo, FieldPosition pos)</code> -- 如何格式化 Object 类型</p></li>

                                    <li class="group"><p><code>Number 	parse(String source)</code> -- 解析给定字符串开头的文本，生成一个数值</p></li>
                                    <li><p><code>abstract Number 	parse(String source, ParsePosition parsePosition)</code> -- 参见子类实现</p></li>
                                    <li><p><code>Object 	parseObject(String source, ParsePosition pos)</code> -- 解析字符串中的文本，以生成一个 Number</p></li>

                                    <li class="group"><p><code>int 	getMaximumFractionDigits()</code> -- 获取数的小数部分所允许的最大位数</p></li>
                                    <li><p><code>void 	setMaximumFractionDigits(int newValue)</code> -- 设置数的小数部分所允许的最大位数(四舍五入)</p></li>
                                    <li><p><code>int 	getMinimumFractionDigits()</code> -- 获取数的小数部分所允许的最小位数</p></li>
                                    <li><p><code>void 	setMinimumFractionDigits(int newValue)</code> -- 设置数的小数部分所允许的最小位数(右侧填充 0)</p></li>
                                    <li><p><code>int 	getMaximumIntegerDigits()</code> -- 获取数的整数部分所允许的最大位数</p></li>
                                    <li><p><code>void 	setMaximumIntegerDigits(int newValue)</code> -- 设置数的整数部分所允许的最大位数(丢弃高位)</p></li>
                                    <li><p><code>int 	getMinimumIntegerDigits()</code> -- 获取数的整数部分所允许的最小位数</p></li>
                                    <li><p><code>void 	setMinimumIntegerDigits(int newValue)</code> -- 设置数的整数部分所允许的最小位数(左侧填充 0)</p></li>

                                    <li class="group"><p><code>Currency 	getCurrency()</code> -- 获取格式化货币值时此数值格式使用的货币单位</p></li>
                                    <li><p><code>void 	setCurrency(Currency currency)</code> -- 设置格式化货币值时此数值格式使用的货币</p></li>
                                    <li><p><code>boolean 	isGroupingUsed()</code> -- 格式中是否使用了分组</p></li>
                                    <li><p><code>void 	setGroupingUsed(boolean newValue)</code> -- 设置此格式中是否使用分组</p></li>
                                    <li><p><code>boolean 	isParseIntegerOnly()</code> -- 格式是否只将数作为整数解析</p></li>
                                    <li><p><code>void 	setParseIntegerOnly(boolean value)</code> -- 设置数是否应该仅作为整数进行解析</p></li>
                                    <li><p><code>RoundingMode 	getRoundingMode()</code> -- 获取舍入模式，参见: <a href="#java-math-RoundingMode">RoundingMode 和 BigDecimal</a></p></li>
                                    <li><p><code>void 	setRoundingMode(RoundingMode roundingMode)</code> -- 设置舍入模式</p></li>
                                </ol>
                            </div>

                            <div class="split-item">
						        <pre class="brush: java;">
public class DecimalFormat extends NumberFormat {
    public DecimalFormat() {} // 默认的模式为: #,##0.###
    public DecimalFormat(String pattern) {}
    public DecimalFormat(String pattern, DecimalFormatSymbols symbols) {}
}

/** 模式实例和解析: #,##0.###;(-#,##0.###)
 * #,##0.### -- 默认的模式，分组为 3 位，小数后保留 3 位，如果整数个位没有值，则用 0 填充
 *  eg: format(1234) = 1,234, format(1234.5678) = 1,234.568, format(0.2) = 0.2
 * #,###0.00#### -- 分组 4 位，小数后保留 6 位，如果整数个位和小数前两位没有值，则用 0 填充
 *  eg: format(1234) = 1234.00, format(1234.5678) = 1234.5678, format(0.2) = 0.20
 * #,##0.###% -- % 号在前或者在后，都要将值乘以 100,然后在按上面的格式格式化
 *  eg: format(0.5678) = 56.78%
 * #,##0.###‰ -- ‰(\u2030) 号在前或者在后，都要将值乘以 1000,然后在按上面的格式格式化
 *  eg: format(0.5678) = 567.8‰
 * ¤#,##0.### -- ¤(\u00A4) 货币记号，由货币符号替换，如果两个同时出现，则用国际货币符号替换
 *  eg: format(0.5678) = £0.568
 * '#,#'#0.### -- ' 号为特殊字符，其包裹的内容原样输出
 *  eg: format("'#,#'#0.###") = #,#0.568
 * #.######E0 -- 科学计数法，E0 写在后缀，有效位同前面实例
 *  eg: format("#.######E0") = 1.234568E3
 */
</pre>
                                <p><a href="docs/docs-java/api/java/text/DecimalFormat.html" target="_blank">DecimalFormat</a> 是 NumberFormat 的一个具体子类，用于格式化十进制数字。该类设计有各种功能，使其能够解析和格式化任意语言环境中的数，包括对西方语言、阿拉伯语和印度语数字的支持。它还支持不同类型的数，包括整数 (123)、定点数 (123.4)、科学记数法表示的数 (1.23E4)、百分数 (12%) 和金额 ($123)。所有这些内容都可以本地化。</p>
                                <ol>
                                    <li class="group"><p><code>void 	applyLocalizedPattern(String pattern)</code> -- 应用一个本地化的模式</p></li>
                                    <li><p><code>String 	toPattern()</code> -- 合成一个表示此 Format 对象当前状态的模式字符串</p></li>
                                    <li><p><code>String 	toLocalizedPattern()</code> -- 合成一个表示此 Format 对象当前状态的、已本地化的模式字符串</p></li>
                                    <li><p><code>void 	applyPattern(String pattern)</code> -- 应用模式</p></li>

                                    <li class="group"><p><code>StringBuffer 	format(double number, StringBuffer result, FieldPosition fieldPosition)</code> -- 格式化一个 double 值，以生成一个字符串</p></li>
                                    <li><p><code>StringBuffer 	format(long number, StringBuffer result, FieldPosition fieldPosition)</code> -- 格式化一个 long 值，以生成一个字符串</p></li>
                                    <li><p><code>StringBuffer 	format(Object number, StringBuffer toAppendTo, FieldPosition pos)</code> -- 格式化一个数，并将所得文本追加到给定的字符串缓冲区</p></li>
                                    <li><p><code>AttributedCharacterIterator 	formatToCharacterIterator(Object obj)</code> -- 格式化 obj 生成 AttributedCharacterIterator</p></li>

                                    <li class="group"><p><code>Number 	parse(String text, ParsePosition pos)</code> -- 解析字符串中的文本，以生成一个 Number</p></li>

                                    <li class="group"><p><code>RoundingMode 	getRoundingMode()</code> -- 获取舍入模式</p></li>
                                    <li><p><code>void 	setRoundingMode(RoundingMode roundingMode)</code> -- 设置舍入模式</p></li>
                                    <li><p><code>Currency 	getCurrency()</code> -- 获取格式化货币值时此数值格式使用的货币单位</p></li>
                                    <li><p><code>void 	setCurrency(Currency currency)</code> -- 设置格式化货币值时此数值格式使用的货币</p></li>

                                    <li class="group"><p><code>int 	getMultiplier()</code> -- 获取百分数、千分数和类似格式中使用的乘数(应用模式可能会改变此值)</p></li>
                                    <li><p><code>void 	setMultiplier(int newValue)</code> -- 设置百分数、千分数和类似格式中使用的乘数</p></li>
                                    <li><p><code>int 	getGroupingSize()</code> -- 返回分组大小(应用模式可能会改变此值)</p></li>
                                    <li><p><code>void 	setGroupingSize(int newValue)</code> -- 设置分组大小(默认为 3)</p></li>
                                    <li><p><code>void 	setGroupingUsed(boolean newValue)</code> -- 格式中是否使用分组(应用模式可能会改变此值)</p>
                                        <pre class="brush: java;">
DecimalFormat format = new DecimalFormat(); //  默认模式: #,##0.###
log(format.isGroupingUsed(), format.getGroupingSize(), format.getMultiplier()); // true, 3, 1
format.applyPattern("#0.###%");
log(format.isGroupingUsed(), format.getGroupingSize(), format.getMultiplier()); // false, 0, 100
</pre>
                                    </li>

                                    <li class="group"><p><code>boolean 	isDecimalSeparatorAlwaysShown()</code> -- 是否允许获取整数中小数分隔符的行为</p></li>
                                    <li><p><code>void 	setDecimalSeparatorAlwaysShown(boolean newValue)</code> -- 设置是否允许设置整数中小数分隔符的行为</p></li>
                                    <li><p><code>DecimalFormatSymbols 	getDecimalFormatSymbols()</code> -- 获取设置小数格式符号</p></li>
                                    <li><p><code>void 	setDecimalFormatSymbols(DecimalFormatSymbols newSymbols)</code> -- 设置小数格式符号，通常程序员或用户不改变此符号</p></li>
                                    <li><p><code>boolean 	isParseBigDecimal()</code> -- 是否解析的为 BigDecimal</p></li>
                                    <li><p><code>void 	setParseBigDecimal(boolean newValue)</code> -- 设置 <code>parse(String, ParsePosition)</code> 方法是否返回 BigDecimal</p></li>

                                    <li class="group"><p><code>int 	getMaximumFractionDigits()</code> -- 获取数的小数部分所允许的最大位数</p></li>
                                    <li><p><code>void 	setMaximumFractionDigits(int newValue)</code> -- 设置数的小数部分所允许的最大位数(四舍五入)</p></li>
                                    <li><p><code>int 	getMinimumFractionDigits()</code> -- 获取数的小数部分所允许的最小位数</p></li>
                                    <li><p><code>void 	setMinimumFractionDigits(int newValue)</code> -- 设置数的小数部分所允许的最小位数(右侧填充 0)</p></li>
                                    <li><p><code>int 	getMaximumIntegerDigits()</code> -- 获取数的整数部分所允许的最大位数</p></li>
                                    <li><p><code>void 	setMaximumIntegerDigits(int newValue)</code> -- 设置数的整数部分所允许的最大位数(丢弃高位)</p></li>
                                    <li><p><code>int 	getMinimumIntegerDigits()</code> -- 获取数的整数部分所允许的最小位数</p></li>
                                    <li><p><code>void 	setMinimumIntegerDigits(int newValue)</code> -- 设置数的整数部分所允许的最小位数(左侧填充 0)</p></li>

                                    <li class="group"><p><code>String 	getNegativePrefix()</code> -- 获取负数前缀(默认"-")</p></li>
                                    <li><p><code>void 	setNegativePrefix(String newValue)</code> -- 设置负数前缀</p></li>
                                    <li><p><code>String 	getNegativeSuffix()</code> -- 获取负数后缀(默认无)</p></li>
                                    <li><p><code>void 	setNegativeSuffix(String newValue)</code> -- 设置负数后缀</p></li>
                                    <li><p><code>String 	getPositivePrefix()</code> -- 获取正数前缀(默认无)</p></li>
                                    <li><p><code>void 	setPositivePrefix(String newValue)</code> -- 设置正数前缀</p></li>
                                    <li><p><code>String 	getPositiveSuffix()</code> -- 获取正数后缀(默认无)</p></li>
                                    <li><p><code>void 	setPositiveSuffix(String newValue)</code> -- 设置正数后缀</p></li>

                                </ol>
                            </div>

                            <div class="split-item">
						        <pre class="brush: java;">
public class ChoiceFormat extends NumberFormat {
    public ChoiceFormat(double[] limits, String[] formats) {}
    public ChoiceFormat(String newPattern) {}
}
</pre>
                                <p><a href="docs/docs-java/api/java/text/ChoiceFormat.html" target="_blank">ChoiceFormat</a> 允许将格式应用到某个范围的数。它通常用于在 MessageFormat 中处理复数。</p>
                                <p><b>注意</b>：ChoiceFormat 不同于其他 Format 类，因为 ChoiceFormat 对象是通过构造方法创建的（而不是通过 getInstance 样式工厂方法）。工厂方法不是必需的，因为 ChoiceFormat 不要求针对给定语言环境进行任何复杂的设置。事实上，ChoiceFormat 并不实现任何特定于语言环境的行为。 </p>
                                <p>关于 ChoiceFormat 的使用直接看实例：</p>
                                <pre class="brush: java;">
double[] limits = {1, 2, 3, 4, 5, 6, 7};
String[] dayOfWeekNames = {"星期一", "星期二", "星期三", "星期四", "星期五", "星期六", "星期天"};

ChoiceFormat format = new ChoiceFormat(limits, dayOfWeekNames); // 数组长度必须相等
// 星期一, 星期一, 星期一
log(format.format(0.5), format.format(1), format.format(1.5));
// 星期二, 星期天, 星期天
log(format.format(2), format.format(7), format.format(8));
</pre>
                                <ol>
                                    <li><p><code>static double 	nextDouble(double d)</code> -- 下一个计算机可表示的 double</p></li>
                                    <li><p><code>static double 	previousDouble(double d)</code> -- 上一个计算机可表示的 double</p></li>
                                    <li><p><code>static double 	nextDouble(double d, boolean positive)</code> -- positive 为 true / false, 分别表示上面的两个方法</p></li>

                                    <li class="group"><p><code>void 	setChoices(double[] limits, String[] formats)</code> -- 设置要在格式化中使用的 choice</p></li>
                                    <li><p><code>Object[] 	getFormats()</code> -- 获取 formats</p></li>
                                    <li><p><code>double[] 	getLimits()</code> -- 获取 limits</p></li>

                                    <li class="group"><p><code>void 	applyPattern(String newPattern)</code> -- 应用模式</p></li>
                                    <li><p><code>String 	toPattern()</code> -- 获取模式的 String 表示</p></li>

                                    <li class="group"><p><code>StringBuffer 	format(double number, StringBuffer toAppendTo, FieldPosition status)</code> -- 带已格式化 double 的模式</p></li>
                                    <li><p><code>StringBuffer 	format(long number, StringBuffer toAppendTo, FieldPosition status)</code> -- 返回带已格式化 long 的模式</p></li>

                                    <li class="group"><p><code>Number 	parse(String text, ParsePosition status)</code> -- format 逆向操作</p></li>
                                </ol>
                            </div>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
public class MessageFormat extends Format {
    public static class Field extends Format.Field {}

    public MessageFormat(String pattern) {}
    public MessageFormat(String pattern, Locale locale) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/text/MessageFormat.html" target="_blank">MessageFormat</a> 提供了以与语言无关方式生成连接消息的方式。使用此方法构造向终端用户显示的消息。</p>
                            <p>MessageFormat 获取一组对象，格式化这些对象，然后将格式化后的字符串插入到模式中的适当位置。 </p>
                            <p>注：MessageFormat 不同于其他 Format 类，因为 MessageFormat 对象是用其构造方法之一创建的（而不是使用 getInstance 样式的工厂方法创建的）。工厂方法不是必需的，因为 MessageFormat 本身不实现特定于语言环境的行为。特定于语言环境的行为是由所提供的模式和用于已插入参数的子格式来定义的。 </p>
                            <ol>
                                <li><p><code>static String 	format(String pattern, Object... arguments)</code> -- 创建具有给定模式的 MessageFormat，并用它来格式化给定的参数</p>
                                    <pre class="brush: java;">
/** 模式可以为以下类型:
 * { ArgumentIndex } -- 只索引值，那么值就是指定 arguments[ArgumentIndex]
 *  eg: format("今天是星期{0}", "一", "二") == 今天是星期一
 * { ArgumentIndex, FormatType } -- 格式化类型类: number, date, time 或 choice
 *  eg: log(MessageFormat.format("日期：{0, date}", new Date()));
 * { ArgumentIndex , FormatType , FormatStyle } -- 不同的 FormatType 可以使用的 FormatStyle 如下表：
 *	eg: log(MessageFormat.format("日期：{0, date, yyyy 年 MM 月 dd 日}", new Date()));
 * SubformatPattern 为模式字符串，比如 date 类型可以为: "YYYY/MM/dd HH:mm:ss"
 *  FormatType |  FormatStyle     | 	使用的格式(默认调用下面的方法来格式化)
 *    number   |   (none) 	      | NumberFormat.getInstance(getLocale())
 *    		   |   integer 	      | NumberFormat.getIntegerInstance(getLocale())
 *    		   |  currency 	      | NumberFormat.getCurrencyInstance(getLocale())
 *    		   |   percent 	      | NumberFormat.getPercentInstance(getLocale())
 *    		   | SubformatPattern |	new DecimalFormat(String, DecimalFormatSymbols)
 *    date 	   |   (none)     	  | DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
 *    		   |    short 	      | DateFormat.getDateInstance(DateFormat.SHORT, getLocale())
 *    		   |    medium 	      | DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())
 *    		   |    long 	      | DateFormat.getDateInstance(DateFormat.LONG, getLocale())
 *    		   |    full 	      | DateFormat.getDateInstance(DateFormat.FULL, getLocale())
 *    		   | SubformatPattern |	new SimpleDateFormat(subformatPattern, getLocale())
 *    time 	   |   (none) 	      | DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
 *    		   |    short 	      | DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())
 *    		   |    medium 	      | DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())
 *    		   |    long 	      | DateFormat.getTimeInstance(DateFormat.LONG, getLocale())
 *    		   |    full 	      | DateFormat.getTimeInstance(DateFormat.FULL, getLocale())
 *    		   | SubformatPattern |	new SimpleDateFormat(subformatPattern, getLocale())
 *    choice   | SubformatPattern | new ChoiceFormat(subformatPattern)
 */
</pre>
                                </li>

                                <li class="group"><p><code>void 	applyPattern(String pattern)</code> -- 设置此消息格式所使用的模式</p></li>
                                <li><p><code>String 	toPattern()</code> -- 返回表示消息格式当前状态的模式</p></li>
                                <li><p><code>Locale 	getLocale()</code> -- 获取创建或比较子格式时所使用的语言环境</p></li>
                                <li><p><code>void 	setLocale(Locale locale)</code> -- 设置创建或比较子格式时要使用的语言环境</p></li>

                                <li class="group"><p><code>StringBuffer 	format(Object[] arguments, StringBuffer result, FieldPosition pos)</code> -- 格式化一个对象数组，并将 MessageFormat 的模式添加到所提供的 StringBuffer，用格式化后的对象替换格式元素</p></li>
                                <li><p><code>StringBuffer 	format(Object arguments, StringBuffer result, FieldPosition pos)</code> -- 格式化一个对象，并将 MessageFormat 的模式添加到所提供的 StringBuffer，用格式化后的对象替换格式元素</p></li>
                                <li><p><code>AttributedCharacterIterator 	formatToCharacterIterator(Object arguments)</code> --  格式化生成 AttributedCharacterIterator</p></li>

                                <li class="group"><p><code>Format[] 	getFormats()</code> -- 获取用于以前所设置的模式字符串中格式元素的格式</p></li>
                                <li><p><code>void 	setFormats(Format[] newFormats)</code> -- 设置用于以前所设置的模式字符串中格式元素的格式</p></li>
                                <li><p><code>Format[] 	getFormatsByArgumentIndex()</code> -- 获取传递给 format 方法或从 parse 方法返回的值的格式</p></li>
                                <li><p><code>void 	setFormatsByArgumentIndex(Format[] newFormats)</code> -- 设置传递给 format 方法或从 parse 方法返回的值使用的格式</p></li>
                                <li><p><code>void 	setFormat(int formatElementIndex, Format newFormat)</code> -- 使用在以前设置的模式字符串中给定的格式元素索引来设置格式元素使用的格式</p></li>
                                <li><p><code>void 	setFormatByArgumentIndex(int argumentIndex, Format newFormat)</code> -- 设置用于以前所设置的模式字符串中格式元素的格式，其中以前的模式字符串是用给定的参数索引设置的</p></li>

                                <li class="group"><p><code>Object[] 	parse(String source)</code> -- 从给定字符串的开始位置解析文本，以生成一个对象数组</p></li>
                                <li><p><code>Object[] 	parse(String source, ParsePosition pos)</code> -- 自定义解析为一个对象数组</p></li>
                                <li><p><code>Object 	parseObject(String source, ParsePosition pos)</code> -- 自定义解析为一个对象</p></li>
                            </ol>
                        </div>
                    </div>


                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-text-CharacterIterator"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">CharacterIterator 及实现类</h3>
                    </div>
                    <div class="panel-body">
						<div class="sub-item">
							<pre class="brush: java;">
public interface CharacterIterator extends Cloneable {
    public static final char DONE = '\uFFFF';
}
</pre>
                        	<p><a href="docs/docs-java/api/java/text/CharacterIterator.html" target="_blank">CharacterIterator</a> 接口定义了对文本进行双向迭代的协议。</p>
                            <p>迭代器对有界字符序列进行迭代。这些字符使用从 getBeginIndex() 返回的值开始，一直到 getEndIndex()-1 返回的值结束之间的值进行索引。 </p>
                            <p>迭代器维护当前的字符索引，索引值的有效范围是从 getBeginIndex() 到 getEndIndex()；出于历史原因，包括了值 getEndIndex() 以允许处理零长度的文本范围。可以通过调用 getIndex() 获取当前索引，还可以通过调用 setIndex()、first() 和 last() 直接设置当前索引。 </p>
                            <ol>
                                <li><p><code>char 	first()</code> -- 将位置设置为 getBeginIndex()，并返回该位置的字符</p></li>
                                <li><p><code>char 	last()</code> -- 将位置设置为 getEndIndex()-1（如果文本为空，则为 getEndIndex()），并返回该位置的字符</p></li>
                                <li><p><code>char 	previous()</code> -- 将迭代器的索引减一，并返回新索引处的字符</p></li>
                                <li><p><code>char 	next()</code> -- 将迭代器的索引加一，并返回新索引处的字符</p></li>
                                <li><p><code>char 	current()</code> -- 获取当前位置（由 getIndex() 返回）的字符</p>
                                    <pre class="brush: java;">
CharacterIterator iterator = new StringCharacterIterator("abcdefg你好0123456789");
while (iterator.current() != CharacterIterator.DONE) {
    log(iterator.current());
    iterator.next();
}
</pre>
                                </li>

                                <li class="group"><p><code>int 	getBeginIndex()</code> -- 返回文本的起始索引</p></li>
                                <li><p><code>int 	getEndIndex()</code> -- 返回文本的结束索引</p></li>
                                <li><p><code>int 	getIndex()</code> -- 返回当前索引</p></li>
                                <li><p><code>char 	setIndex(int position)</code> -- 将位置设置为文本中的指定位置，并返回该字符</p></li>

                                <li class="group"><p><code>Object 	clone()</code> -- 创建此迭代器的一个副本</p></li>
                            </ol>
                        </div>

						<div class="sub-item">
							<pre class="brush: java;">
public interface AttributedCharacterIterator extends CharacterIterator {
    /** 内部有一个 Map&lt;String, Attribute> */
    public static class Attribute implements Serializable {}
}
</pre>
							<p><a href="docs/docs-java/api/java/text/AttributedCharacterIterator.html" target="_blank">AttributedCharacterIterator</a> 允许对文本和相关属性信息的迭代。</p>
                            <p>属性是一个由键来标识的键/值对。在一个给定字符上的两个属性不能有相同的键。</p>
                            <p>一个属性的值是不可变的，或者不能由客户端或存储来改变。其始终按引用而不是复制来传递。</p>
                            <p>对于以下情况，关于属性的运行是一个最大的文本范围：</p>
                            <ul>
                                <li><p>在整个范围中属性没有定义或为 null。</p></li>
                                <li><p>定义了属性值并且在整个范围中具有同样的非 null 值。</p></li>
                            </ul>
                            <p>对于每个成员属性都满足此条件的关于属性集合的运行 是一个最大的文本范围。</p>
                            <p><a href="#java-text-Format">Format</a> 接口有一个 <code>formatToCharacterIterator(Object obj)</code> 方法返回此对象的实例，另外， <a href="#java-text-Format">Format</a> 的内部类 <code>Field</code> 继承自 <code>AttributedCharacterIterator.Attribute</code>。</p>
                            <ol>
                                <li><p><code>Set&lt;AttributedCharacterIterator.Attribute> 	getAllAttributeKeys()</code> -- 返回定义于迭代器文本范围上的所有属性的键</p></li>
                                <li><p><code>Object 	getAttribute(AttributedCharacterIterator.Attribute attribute)</code> -- 返回当前字符的命名属性的值</p></li>
                                <li><p><code>Map&lt;AttributedCharacterIterator.Attribute,Object> 	getAttributes()</code> -- 返回具有定义于当前字符上的多个属性的映射</p></li>

                                <li class="group"><p><code>int 	getRunLimit()</code> -- 返回关于包含当前字符的所有属性的运行之后的第一个字符的索引</p></li>
                                <li><p><code>int 	getRunLimit(AttributedCharacterIterator.Attribute attribute)</code> -- 返回关于包含当前字符的给定属性的运行之后的第一个字符的索引</p></li>
                                <li><p><code>int 	getRunLimit(Set&lt;? extends AttributedCharacterIterator.Attribute> attributes)</code> -- 返回关于包含当前字符的给定多个属性的运行之后的第一个字符的索引</p></li>

                                <li class="group"><p><code>int 	getRunStart()</code> -- 返回关于包含当前字符的所有属性的运行的第一个字符的索引</p></li>
                                <li><p><code>int 	getRunStart(AttributedCharacterIterator.Attribute attribute)</code> -- 返回关于包含当前字符的给定属性的运行的第一个字符的索引</p></li>
                                <li><p><code>int 	getRunStart(Set&lt;? extends AttributedCharacterIterator.Attribute> attributes)</code> -- 返回关于包含当前字符的给定多个属性的运行的第一个字符的索引</p></li>
                            </ol>
                        </div>

						<div class="sub-item">
							<pre class="brush: java;">
public final class StringCharacterIterator implements CharacterIterator {
    public StringCharacterIterator(String text) {}
    public StringCharacterIterator(String text, int pos) {}
    public StringCharacterIterator(String text, int begin, int end, int pos) {}
}
</pre>
							<p><a href="docs/docs-java/api/java/text/StringCharacterIterator.html" target="_blank">StringCharacterIterator</a> 为 String 实现 CharacterIterater 协议。StringCharacterIterator 类对整个 String 进行迭代。</p>
                            <ol>
                                <li><p><code>char 	first()</code> -- 将位置设置为 getBeginIndex()，并返回该位置的字符</p></li>
                                <li><p><code>char 	last()</code> -- 将位置设置为 getEndIndex()-1（如果文本为空，则为 getEndIndex()），并返回该位置的字符</p></li>
                                <li><p><code>char 	previous()</code> -- 将迭代器的索引减一，并返回新索引处的字符</p></li>
                                <li><p><code>char 	next()</code> -- 将迭代器的索引加一，并返回新索引处的字符</p></li>
                                <li><p><code>char 	current()</code> -- 获取当前位置（由 getIndex() 返回）的字符</p>
                                    <pre class="brush: java;">
StringCharacterIterator iterator = new StringCharacterIterator("abcdefg0123456789");
while (iterator.current() != CharacterIterator.DONE) {
    log(iterator.current());
    iterator.next();
}
</pre>
                                </li>

                                <li class="group"><p><code>int 	getBeginIndex()</code> -- 返回文本的起始索引</p></li>
                                <li><p><code>int 	getEndIndex()</code> -- 返回文本的结束索引</p></li>
                                <li><p><code>int 	getIndex()</code> -- 返回当前索引</p></li>
                                <li><p><code>char 	setIndex(int position)</code> -- 将位置设置为文本中的指定位置，并返回该字符</p></li>

                                <li class="group"><p><code>Object 	clone()</code> -- 创建此迭代器的一个副本</p></li>
                                <li><p><code>int 	hashCode()</code> -- 计算此迭代器的哈希码</p></li>
                                <li><p><code>boolean 	equals(Object obj)</code> -- 比较两个 StringCharacterIterator 对象的相等性</p></li>
                            </ol>
						</div>

                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-text-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">...</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">

</pre>
						<p><a href="docs/docs-java/api/" target="_blank"></a></p>
					</div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
		<a target="_blank" href="./docs/docs-java/api-zh/index.html"
			type="button" class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> DOCS-6 </a>
		<a target="_blank" href="./docs/docs-java/api/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-8 </a>
		<a target="_blank" href="./docs/jdk-8-zh-google/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-8-ZH </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushXml.js"></script>
    <script src="../support/syntaxhighlighter/scripts/shBrushBash.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
