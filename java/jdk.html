<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--JDK</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1" >
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->

	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">JDK</h3>
					</div>
					<div class="list-group">
						<a href="#jdk-intro" class="list-group-item">简介</a>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#java-lang" aria-expanded="true">
							<code>java.lang</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-lang" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#java-lang-Object" class="list-group-item">Object</a>
							<a href="#java-lang-Class" class="list-group-item">Class 及相关类</a>
                            <a href="#java-lang-ClassLoader" class="list-group-item">ClassLoader</a>
                            <a href="#java-lang-Enum" class="list-group-item">Enum</a>
							<a href="#java-lang-Package" class="list-group-item">Package</a>
							<a href="#java-lang-System" class="list-group-item">System</a>
							<a href="#java-lang-Runtime" class="list-group-item">Runtime / Process</a>
                            <a href="#java-lang-Thread" class="list-group-item">Thread 与 ThreadGroup</a>
                            <a href="#java-lang-String" class="list-group-item">String 及相关类</a>
                            <a href="#java-lang-Math" class="list-group-item">Math</a>
                            <a href="#java-lang-Number" class="list-group-item">Number 及子类</a>
                            <a href="#java-lang-Exception" class="list-group-item">Exception 和 Error</a>
						</div>


						<a class="list-group-item active drop" data-toggle="collapse"
						   data-parent="#accordion" href="#java-util" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							<code>java.util</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-util" class="panel-collapse collapse"
							 role="tabpanel">
							<a href="#java-util-Date" class="list-group-item">Date, TimeZone, Calendar</a>
                            <a href="#java-util-Timer" class="list-group-item">Timer 和 TimerTask</a>
                            <a href="#java-util-List" class="list-group-item">List, Map, Set, Collections...</a>
                            <a href="#java-util-Formatter" class="list-group-item">Formatter, Formattable</a>
                            <a href="#java-util-Observable" class="list-group-item">Observer, Observable</a>
                            <a href="#java-util-UUID" class="list-group-item">UUID</a>
                            <a href="#java-util-concurrent-Executor" class="list-group-item">Executor 及实现类</a>
                            <a href="#java-util-concurrent-Future" class="list-group-item">Future 及实现类</a>
						</div>

                        <a class="list-group-item active drop" data-toggle="collapse"
                           data-parent="#accordion" href="#java-io" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
                            <code>java.io</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="java-io" class="panel-collapse collapse"
                             role="tabpanel">
                            <a href="#java-io-File" class="list-group-item">File</a>
                            <a href="#java-io-" class="list-group-item">...</a>
                        </div>

                        <a class="list-group-item active drop" data-toggle="collapse"
                           data-parent="#accordion" href="#java-text" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
                            <code>java.text</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="java-text" class="panel-collapse collapse"
                             role="tabpanel">
                            <a href="#java-text-Format" class="list-group-item">Format 及子类</a>
                            <a href="#java-text-" class="list-group-item">...</a>
                        </div>

                        <a class="list-group-item active drop" data-toggle="collapse"
                           data-parent="#accordion" href="#java-xxx" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
                            <code>java...</code><span class="caret pull-right" style="margin-top: 5px;"></span>
                        </a>
                        <div id="java-xxx" class="panel-collapse collapse"
                             role="tabpanel">
                            <a href="#java-" class="list-group-item"></a>
                        </div>

						<a href="#java-" class="list-group-item">...</a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<a class="offset" id="jdk-intro"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<p>JDK 是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的 java 应用程序。JDK 是整个
							java 开发的核心，它包含了 JAVA 的运行环境（JVM + Java 系统类库）和 JAVA 工具。</p>
						<p>
							<b>以下是各版本的名称及发布日期：</b>
						</p>
						<table class="table table-bordered table-responsive">
							<tbody>
								<tr>
									<td><div>版本</div></td>
									<td><div>名称</div></td>
									<td><div>发行日期</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.4</div></td>
									<td><div>Sparkler（宝石）</div></td>
									<td><div>1997-09-12</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.5</div></td>
									<td><div>Pumpkin（南瓜）</div></td>
									<td><div>1997-12-13</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.6</div></td>
									<td><div>Abigail（阿比盖尔–女子名）</div></td>
									<td><div>1998-04-24</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.7</div></td>
									<td><div>Brutus（布鲁图–古罗马政治家和将军）</div></td>
									<td><div>1998-09-28</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.8</div></td>
									<td><div>Chelsea（切尔西–城市名）</div></td>
									<td><div>1999-04-08</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.2</div></td>
									<td><div>Playground（运动场）</div></td>
									<td><div>1998-12-04</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.2.1</div></td>
									<td><div>none（无）</div></td>
									<td><div>1999-03-30</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.2.2</div></td>
									<td><div>Cricket（蟋蟀）</div></td>
									<td><div>1999-07-08</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.3</div></td>
									<td><div>Kestrel（美洲红隼）</div></td>
									<td><div>2000-05-08</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.3.1</div></td>
									<td><div>Ladybird（瓢虫）</div></td>
									<td><div>2001-05-17</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.4.0</div></td>
									<td><div>Merlin（灰背隼）</div></td>
									<td><div>2002-02-13</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.4.1</div></td>
									<td><div>grasshopper（蚱蜢）</div></td>
									<td><div>2002-09-16</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.4.2</div></td>
									<td><div>Mantis（螳螂）</div></td>
									<td><div>2003-06-26</div></td>
								</tr>
								<tr>
									<td><div>Java SE 5.0 (1.5.0)</div></td>
									<td><div>Tiger（老虎）</div></td>
									<td><div>2004-09-30</div></td>
								</tr>
								<tr>
									<td><div>Java SE 6.0 (1.6.0)</div></td>
									<td><div>Mustang（野马）</div></td>
									<td><div>2006-04</div></td>
								</tr>
								<tr>
									<td><div>Java SE 7.0 (1.7.0)</div></td>
									<td><div>Dolphin（海豚）</div></td>
									<td><div>2011-07-28</div></td>
								</tr>
								<tr>
									<td><div>Java SE 8.0 (1.8.0)</div></td>
									<td>Spider（蜘蛛）</td>
									<td><div>2014-03-18</div></td>
								</tr>
								<tr>
									<td colspan="1" rowspan="1">Java SE 9</td>
									<td colspan="1" rowspan="1"></td>
									<td colspan="1" rowspan="1">2017-09-21</td>
								</tr>
							</tbody>
						</table>
						<p>
							<b>JDK 各版本新增的主要特性</b>
						</p>
						<p>
							<b>JDK 5 新特性：</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. 自动装箱与拆箱：</p>
							<p>2. 枚举</p>
							<p>
								3. 静态导入，如：
								<code>import staticjava.lang.System.out</code>
							</p>
							<p>4. 可变参数（Varargs）</p>
							<p>5. 内省（Introspector），主要用于操作 JavaBean 中的属性，通过
								getXxx/setXxx。一般的做法是通过类 Introspector 来获取某个对象的 BeanInfo 信息，然后通过
								BeanInfo 来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的
								getter/setter 方法，然后我们就可以通过反射机制来调用这些方法。</p>
							<p>6. 泛型(Generic)（包括通配类型/边界类型等）</p>
							<p>7. For-Each 循环</p>
							<p>8. 注解</p>
							<p>9. 协变返回类型：实际返回类型可以是要求的返回类型的一个子类型</p>
						</div>
						<p>
							<b>JDK 6 新特性：</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. AWT 新增加了两个类: Desktop 和
								SystemTray，其中前者用来通过系统默认程序来执行一个操作，如使用默认浏览器浏览指定的URL,用默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以
								txt 为后缀名的文件),用系统默认的打印机打印文档等。后者可以用来在系统托盘区创建一个托盘程序</p>
							<p>2. 使用 JAXB2 来实现对象与 XML 之间的映射，可以将一个 Java 对象转变成为 XML 格式，反之亦然</p>
							<p>3. StAX，一种利用拉模式解析(pull-parsing)XML 文档的API。类似于
								SAX，也基于事件驱动模型。之所以将 StAX 加入到 JAXP 家族，是因为 JDK6 中的 JAXB2 和 JAX-WS
								2.0 中都会用 StAX。</p>
							<p>4.使用 Compiler API，动态编译 Java 源文件，如 JSP
								编译引擎就是动态的，所以修改后无需重启服务器。</p>
							<p>5. 轻量级 Http Server API，据此可以构建自己的嵌入式 HttpServer,它支持 Http 和
								Https 协议。</p>
							<p>6. 插入式注解处理 API(PluggableAnnotation Processing API)</p>
							<p>7. 提供了 Console 类用以开发控制台程序，位于 java.io 包中。据此可方便与 Windows 下的
								cmd 或 Linux 下的 Terminal 等交互。</p>
							<p>8. 对脚本语言的支持如: ruby, groovy, javascript</p>
							<p>9. Common Annotations，原是 J2EE 5.0 规范的一部分，现在把它的一部分放到了 J2SE
								6.0 中</p>
							<p>10. 嵌入式数据库 Derby</p>
						</div>
						<p>
							<b>JDK 7 新特性</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. 对 Java 集合（Collections）的增强支持，可直接采用 []、{} 的形式存入对象，采用 []
								的形式按照索引、键值来获取集合中的对象。如：
							<pre class="brush: java;">
List&lt;String&gt; list = [“item1”, ”item2”]; // 存
String item = list[0]; // 直接取
Set&lt;String&gt; set = {“item1”, ”item2”, ”item3”}; // 存
Map&lt;String, Integer&gt; map = {“key1”:1, ”key2”:2}; // 存
Int value = map[“key1”]; // 取
</pre>
							<p>2. 在 Switch 中可用 String</p>
							<p>3. 数值可加下划线用作分隔符（编译时自动被忽略）</p>
							<p>
								4. 支持二进制数字，如：
								<code>int binary = 0b1001_1001;</code>
							</p>
							<p>5. 简化了可变参数方法的调用</p>
							<p>6. 调用泛型类的构造方法时，可以省去泛型参数，编译器会自动判断。</p>
							<p>7. Boolean 类型反转，空指针安全,参与位运算</p>
							<p>
								8. char 类型的 equals 方法:
								<code>booleanCharacter.equalsIgnoreCase(char ch1, char
									ch2)</code>
							</p>
							<p>9. 安全的加减乘除:
							<pre class="brush: java;">
Math.safeToInt(longv); 
Math.safeNegate(int v);
Math.safeSubtract(long v1, int v2);
Math.safeMultiply(int v1, int v2);
......
</pre>
							<p>
								10. Map 集合支持并发请求，注 HashTable 是线程安全的，Map
								是非线程安全的。但此处更新使得其也支持并发。另外，Map 对象可这样定义：
								<code>Map map = {name:"xxx",age:18};</code>
							</p>
						</div>
						<p>
							<b>JDK 8 新特性</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1.
								接口的默认方法：即接口中可以声明一个非抽象的方法做为默认的实现，但只能声明一个，且在方法的返回类型前要加上“default”关键字。
							</p>
							<p>2. Lambda 表达式：是对匿名比较器的简化，如：</p>
							<pre class="brush: java;">
Collections.sort(names,(String a, String b) -&gt; {
	returnb.compareTo(a);
});
</pre>
							<p>对于函数体只有一行代码的，你可以去掉大括号 {} 以及 return 关键字。如：</p>
							<pre class="brush: java;">
Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));
// 或
Collections.sort(names, (a, b) -&gt; b.compareTo(a));
</pre>
							<p>3. 函数式接口：是指仅仅只包含一个抽象方法的接口，要加 @FunctionalInterface 注解</p>
							<p>4. 使用 :: 关键字来传递方法或者构造函数引用</p>
							<p>5. 多重注解</p>
							<p>6. 还增加了很多与函数式接口类似的接口以及与Map相关的API等……</p>
						</div>
						<p>
							<b>JDK 9 新特性 </b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. Jigsaw 项目：模块化 JDK 源码。</p>
							<p>2. 简化了的进程 API。</p>
							<p>3. 轻量级的 JSON API。</p>
							<p>4. 钱和货币的相关 API。</p>
							<p>5. 改善锁争用机制。</p>
							<p>6. 代码分段缓存。</p>
							<p>7. 智能 Java 编译工具。</p>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Object"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">java.lang.Object</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p>
								<code>java.lang</code>
								包在使用的时候无需显示导入，编译时由编译器自动导入。
							</p>
						</div>

						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object

public class Object {}
</pre>

							<p><a href="docs/docs-java/api/java/lang/Object.html" target="_blank">Object</a> 类是类层次结构的根，Java中所有的类从根本上都继承自这个类。</p>
							<p>Object 类是 Java 中唯一没有父类的类。Java 中的每个类都具有定义在 Object 类中的这些方法。</p>
							<ol>
								<li><p><code>protected native Object clone()</code> -- 对象复制(浅层复制)。1.要实现 Cloneable; 2.覆写此方法要修改为 public
										修饰,才能让类外部的代码调用。</p>
									<p>
										<strong>浅层复制：&nbsp;</strong>被复制的对象的所有成员属性都有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅层复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
									<p>
										<strong>深层复制：</strong>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不是原有的那些被引用的对象。换言之，深层复制要复制的对象引用的对象都复制一遍。</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-clone" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-clone" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
/**
 * 要实现 Cloneable
 */
public class Person implements Cloneable {
	private String name;
	private Student student;
	
	public Person() {
	}

	public Person(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	/**
	 * 覆写此方法修改为 public, 才能让类外部的代码调用
	 */
	@Override
	public Object clone() throws CloneNotSupportedException {
		// TODO Auto-generated method stub
		return super.clone();
	}
	
	private void testClone() throws CloneNotSupportedException {
		Person p1 = new Person();
		p1.setName("aaa");
		Person p2 = (Person) p1.clone();	// p2 也有 name=aaa属性
		p1.setName("bbb");
		System.out.println(p1.getName() + "==" + p2.getName());
		
		Student s1 = new Student();
		p1.setStudent(s1);
		
		Person p3 = (Person) p1.clone();
		Student s2 = p3.getStudent();
		System.out.println(s1 == s2);		// s1==s2, 说明p1和p3引用了同一个Student对象
	}
}
</pre>
										</div>
									</div>

									<p>
										<b>使用序列化实现深层复制:</b></p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-deepClone" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-deepClone" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
public class DeepClone {
	public static void main(String[] args) throws Exception {
		Teacher t = new Teacher();
		t.setName("Teacher Wang");
		t.setAge(50);

		Student s1 = new Student();
		s1.setAge(20);
		s1.setName("ZhangSan");
		s1.setTeacher(t);

		Student s2 = (Student) s1.deepClone();

		System.out.println("拷贝得到的信息:");
		System.out.println(s2.getName());
		System.out.println(s2.getAge());
		System.out.println(s2.getTeacher().getName());
		System.out.println(s2.getTeacher().getAge());
		System.out.println("---------------------------");

		// 将复制后的对象的老师信息修改一下：
		s2.getTeacher().setName("New Teacher Wang");
		s2.getTeacher().setAge(28);

		System.out.println("修改了拷贝对象的教师后：");
		System.out.println("拷贝对象的教师：");
		System.out.println(s2.getTeacher().getName());
		System.out.println(s2.getTeacher().getAge());
		System.out.println("原来对象的教师：");
		System.out.println(s1.getTeacher().getName());
		System.out.println(s1.getTeacher().getAge());

		// 由此证明序列化的方式实现了对象的深拷贝
	}

}

class Teacher implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;
	private int age;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}

class Student implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;
	private int age;
	private Teacher teacher;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public Teacher getTeacher() {
		return teacher;
	}

	public void setTeacher(Teacher teacher) {
		this.teacher = teacher;
	}

	/**
	 * 使用序列化实现深层复制
	 */ 
	public Object deepClone() throws Exception {
		// 序列化
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		ObjectOutputStream oos = new ObjectOutputStream(bos);

		oos.writeObject(this);

		// 反序列化
		ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
		ObjectInputStream ois = new ObjectInputStream(bis);

		return ois.readObject();
	}

}
</pre>
										</div>
									</div>
								</li>
								<li><p><code>public boolean equals(Object obj)</code> -- 两个对象是否相等。如果不覆写此方法，使用
										<code>return (this == obj);</code>
										,就是说同一个对象才返回 true。并且覆写equals()方法时，应该同时覆写hashCode()方法，反之亦然。</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-equals" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-equals" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
/**
 * 两个对象的 name 属性相等，返回　true
 */
@Override
public boolean equals(Object obj) {
	return this.name.equals(((Person) obj).getName());
}

public void testEquals() {
	Person p1 = new Person("aa");
	Person p2 = new Person("aa");
	System.out.println(p1.equals(p2));
}
</pre>
										</div>
									</div>
								</li>
								<li><p><code>public native int hashCode()</code>
										--
										Object 类的 hashCode() 方法为不同的对象返回不同的值，Object 类的 hashCode 值表示的是对象的地址。两个不相等的对象产生两个不同的 hashCode 可以改善哈希表的性能。</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-hashCode" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-hashCode" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
/**
 * 直接使用 name 的 hashCode 返回
 */
@Override
public int hashCode() {
	return this.name.hashCode();
}

public void testHashCode(){
	Person p1 = new Person("aa");
	Person p2 = new Person("aa");
	System.out.println(p1.hashCode() + "==" + p2.hashCode());
}
</pre>
										</div>
									</div>
								</li>
								<li><p><code>public String toString()</code> -- Object 的 toString 方法返回 className 和 hashCode 的十六进制值</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-toString" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-toString" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
// Object 的 toString 方法
return getClass().getName() + "@" + Integer.toHexString(hashCode());

@Override
public String toString() {
	return "Person [name=" + name + "]";
}
</pre>
										</div>
									</div>
								</li>
								<li><p><code>public final native Class&lt;?> getClass()</code> -- 返回该对象的运行时类的 Java.lang.Class 对象</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-getClass" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-getClass" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
public class ObjectDemo {
	class Person {
		Person() {
			// 注意如果是实例化了子类的调用，这里打印的是运行时类的类名, 是 Student
			System.out.println("Person:" + getClass().getName());
		}
	}
	
	class Student extends Person {
		Student(){
			System.out.println("Student:" + getClass().getName());
		}
	}
	
	public static void main(String[] args) {
		/** 输出:
		 * Person:cm.nate.lang.ObjectDemo$Student
		 * Student:cm.nate.lang.ObjectDemo$Student
		 */
		new ObjectDemo().new Student();
	}
}
</pre>
										</div>
									</div>
								</li>
								<li><p><code>protected void finalize()</code> -- 用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p></li>
								<li><p><code>notity</code>,<code>wait</code>,<code>notityAll</code>方法参见:<a href="index.html#java-thread">Java 多线程</a></p></li>
							</ol>
						</div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Class"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">java.lang.Class</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">Class 类</h5>
							<pre class="brush: java;">
java.lang.Object
	java.lang.Class&lt;T>

public final class Class&lt;T> implements Serializable, GenericDeclaration, Type, AnnotatedElement {}

/** 序列化标识 */
public interface Serializable {}

/** 表示目前正在此 VM 中运行的程序的一个已注释元素 */
public interface AnnotatedElement {
	// 如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。
	&lt;T extends Annotation> T	getAnnotation(Class&lt;T> annotationClass)
	// 返回此元素上存在的所有注释。
	Annotation[] getAnnotations();
	// 返回直接存在于此元素上的所有注释。
	Annotation[] getDeclaredAnnotations();
	// 返回直接存在于此元素上的指定类型的注释
	default &lt;T extends Annotation> T getDeclaredAnnotation(Class&lt;T> annotationClass);
	// 返回直接存在于此元素上的指定类型所有注释
	default &lt;T extends Annotation> T[] getDeclaredAnnotationsByType(Class&lt;T> annotationClass);
	// 如果指定类型的注释存在于此元素上，则返回 true，否则返回 false。
	boolean isAnnotationPresent(Class&lt;? extends Annotation> annotationClass);
}

public interface GenericDeclaration extends AnnotatedElement {
	TypeVariable&lt;?>[] getTypeParameters();
}

/** 类型 */
public interface Type {
    default String getTypeName() {
        return toString();
    }
}
</pre>
							<p><a href="docs/docs-java/api/java/lang/Class.html" target="_blank">Class</a> 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。</p>
							<p><a href="docs/docs-java/api/java/lang/Class.html" target="_blank">Class</a> 类没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。</p>
							<pre class="brush: java;">
/** 1.反射方式第一次会触发静态代码块
 *  2.类名直接访问不会触发静态代码块
 *  3.通过 getClass 方法，因为要小得到实例，所以第一次触发静态代码块，每个实例触发普通代码块
 */
Class clas = Class.forName("cm.nate.lang.ClassDemo"); // 反射得到类
Class&lt;MyClass> clazz = MyClass.class; // 类名直接访问
Class cls = obj.getClass(); // Object 的 getClass() 方法
</pre>
							<p><b>类的加载:</b></p>
							<ol>
								<li>
									<code>Class.forName</code>
									方式加载 -- 静态代码块 -> 如果调用 newInstance 方法 -> 非静态代码块 -> 构造方法
								</li>
								<li>
									<code>直接 new</code>
									-- 静态代码块 -> [如果加载过了 class -> 非静态代码块 -> 构造方法 | 没加载过 class ->
									静态代码块 -> 非静态代码块 -> 构造方法]
								</li>
							</ol>
							<div class="panel panel-default">
								<div class="panel-heading">
									<a data-toggle="collapse" data-parent="#accordion"
										href="#jdk-Class-load" aria-expanded="true"
										class="code-header">
										<span class="glyphicon glyphicon-plus"></span> View Code
									</a>
								</div>
								<div id="jdk-Class-load" class="panel-collapse collapse"
									style="" aria-expanded="true">
									<pre class="brush: java;">
public class ClassDemo {
	static {
		System.out.println("===静态代码块===");
	}
	
	{
		System.out.println("===非静态代码块===");
	}
	
	public ClassDemo() {
		System.out.println("===构造方法===");
	}
	
	// Class.forName 方式加载
	public static void testForName(){
		try {
			Class testTypeForName = Class.forName("cm.nate.lang.ClassDemo");
			testTypeForName.newInstance();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) {
		testForName();
		
		// 前面加载过class了,这里不会调用静态代码块 
		new ClassDemo();
	}
}
</pre>
								</div>
							</div>
                            <p><b>Class 类的常用方法:</b></p>
							<ol>
								<li><p><code>static Class&lt;?> forName(String className)</code> -- 动态加载类。调用了 native 方法加载类</p></li>
                                <li>
                                    <p><code>static Class&lt;?> 	forName(String name, boolean initialize, ClassLoader loader)</code> -- 使用给定的类加载器</p></li>
                                <li class="group">
                                    <p><code>native boolean isInterface()</code> -- 是否是接口</p>
                                </li>
                                <li>
                                    <p><code>native boolean isPrimitive()</code> -- 是否是基础类</p>
                                </li>
                                <li>
                                    <p><code>boolean isEnum()</code> -- 是否是枚举</p>
                                </li>
                                <li>
                                    <p><code>boolean isAnnotation()</code> -- 是否为注解类</p>
                                </li>
                                <li>
                                    <p><code>native boolean isArray()</code> -- 是否是数组</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isAnonymousClass()</code> -- 是否为匿名类</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isMemberClass()</code> -- 是否为成员类</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isSynthetic()</code> -- 是否为复合类(编译器生成的特殊类)</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isAssignableFrom(Class&lt;?> cls)</code> -- 此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isInstance(Object obj)</code> -- 对象是否为 class 的实例</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isLocalClass()</code> -- 是否为局部类(在方法体中的类)</p>
                                </li>

                                <li class="group">
                                    <p><code>ClassLoader getClassLoader()</code> -- 获得类的类加载器</p>
                                </li>
                                <li>
                                    <p><code>Package getPackage()</code> -- 获得 package，参见相关类</p>
                                </li>
                                <li class="group">
                                    <p><code>Class&lt;?>[] getInterfaces()</code> -- 获得直接实现的接口列表</p>
                                </li>
                                <li>
                                    <p><code>Type[] getGenericInterfaces()</code> -- 直接实现接口的类型，参见相关类</p>
                                </li>
                                <li>
                                    <p><code>native Class&lt;? super T> getSuperclass()</code> -- 获取类的直接父类，继承了父类则返回父类，否则返回 Object</p>
                                </li>
                                <li>
                                    <p><code>Type 	getGenericSuperclass()</code> -- 直接继承类的类型，只有 Object 返回空，参见相关类</p>
                                </li>
                                <li class="group">
                                    <p><code>native int getModifiers()</code> -- 获得整数表示的修饰符，由 <a href="docs/docs-java/api/java/lang/reflect/Modifier.html" target="_blank">Modifier</a> 定义</p>
                                    <pre class="brush: java;">
/** Modifier 类定义以下常量，并且定义了相关 is 方法。
 * 因为修饰符有多个叠加，返回值需要计算：比如 public static 为 9
 */
public static final int PUBLIC           = 0x00000001;
public static final int PRIVATE          = 0x00000002;
public static final int PROTECTED        = 0x00000004;
public static final int STATIC           = 0x00000008;
public static final int FINAL            = 0x00000010;
public static final int SYNCHRONIZED     = 0x00000020;
public static final int VOLATILE         = 0x00000040;
public static final int TRANSIENT        = 0x00000080;
public static final int NATIVE           = 0x00000100;
public static final int INTERFACE        = 0x00000200;
public static final int ABSTRACT         = 0x00000400;
public static final int STRICT           = 0x00000800;
                                    </pre>
                                </li>
                                <li>
                                    <p><code>String getName()</code> -- 获取类或接口的名字，包括包名</p>
                                </li>
                                <li>
                                    <p><code>String getSimpleName()</code> -- 获得类名</p>
                                </li>
                                <li>
                                    <p><code>String 	getCanonicalName()</code> -- 同 getName(), 内部类的 <code>$</code> 变成 <code>.</code></p>
                                </li>
                                <li>
                                    <p><code>String getTypeName()</code> -- 如果是数组，获得数组数据类型名，否则返回类名</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?> 	getComponentType()</code> -- 返回表示数组组件类型的 Class</p>
                                </li>
                                <li>
                                    <p><code>TypeVariable&lt;Class&lt;T>>[] 	getTypeParameters()</code> -- 声明顺序返回类型变量对象的数组，就是下面的 <code>T, M</code></p>
                                    <pre class="brush: java;">
public class Test&lt;T, M> {}
                                    </pre>
                                </li>

                                <li class="group">
                                    <p><code>Constructor&lt;?>[] getConstructors()</code> -- 获得所有的构造函数</p>
                                </li>
                                <li>
                                    <p><code>Constructor&lt;T> getConstructor(Class&lt;?>... parameterTypes)</code> -- 获得指定参数类型的构造函数</p>
                                </li>
                                <li>
                                    <p><code>Constructor&lt;?>[] 	getDeclaredConstructors()</code> -- 自己的构造方法</p>
                                </li>
                                <li>
                                    <p><code>Constructor&lt;T> 	getDeclaredConstructor(Class&lt;?>... parameterTypes)</code> -- 指定参数类型的自己的构造方法</p>
                                </li>

                                <li class="group">
                                    <p><code>Field[] getFields()</code> -- 获得字段数组(public 修饰的，包括继承的)</p>
                                </li>
                                <li>
                                    <p><code>Field 	getField(String name)</code> -- 获取指定名字字段(public 修饰的，包括继承的)</p>
                                </li>
                                <li>
                                    <p><code>Field[] 	getDeclaredFields()</code> -- 自己的所有字段列表，不包括父类</p>
                                </li>
                                <li>
                                    <p><code>Field 	getDeclaredField(String name)</code> -- 指定名字的自己的字段</p>
                                </li>
                                <li>
                                    <p><code>T[] getEnumConstants()</code> -- 获取枚举常量数组</p>
                                </li>

                                <li class="group">
                                    <p><code>Method[] 	getDeclaredMethods()</code> -- 自己的所有方法列表，不包括父类</p>
                                </li>
                                <li>
                                    <p><code>Method 	getDeclaredMethod(String name, Class&lt;?>... parameterTypes)</code> -- 指定名字和参数类型的自己的方法</p>
                                </li>
                                <li>
                                    <p><code>Method[] getMethods()</code> -- 获得 public 方法(包括继承的)</p>
                                </li>
                                <li>
                                    <p><code>Method 	getMethod(String name, Class&lt;?>... parameterTypes)</code> -- 指定名字和参数类型的 public 方法(包括继承的)</p>
                                </li>

                                <li class="group">
                                    <p><code>Class&lt;?>[] 	getClasses()</code> -- public 的成员类</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?>[] 	getDeclaredClasses()</code> -- 所有成员类/接口/枚举</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?> 	getDeclaringClass()</code> -- 如果是成员类，则返回其包裹类</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?> 	getEnclosingClass()</code> -- 返回其包裹类(上一级的类)</p>
                                </li>
                                <li>
                                    <p><code>Constructor&lt;?> 	getEnclosingConstructor()</code> -- 如果局部类定义在构造方法中，返回局部类所在的构造方法</p>
                                </li>
                                <li>
                                    <p><code>Method 	getEnclosingMethod()</code> -- 如果局部类定义在普通方法中，返回局部类所在的方法</p>
                                </li>

                                <li class="group">
									<p><code>T newInstance()</code> -- 根据对象的 class 新建一个对象，用于反射。</p></li>

								<li><p><code>java.net.URL getResource(String name)</code> -- 返回文件的却对路径(file:/home/nate/....)</p></li>
                                <li>
                                    <p><code>InputStream 	getResourceAsStream(String name)</code> -- 指定文件读取为流</p>
                                </li>
                                <li class="group">
                                    <p><code>&lt;A extends Annotation> A getAnnotation(Class&lt;A> annotationClass)</code> -- 如果存在指定类型的注释，则返回这些注释</p>
                                </li>
                                <li>
                                    <p><code>Annotation[] getAnnotations</code> -- 返回此元素上存在的所有注释</p>
                                </li>
                                <li>
                                    <p><code>&lt;A extends Annotation> A[] 	getAnnotationsByType(Class&lt;A> annotationClass)</code> -- 获取指定类型注解列表</p>
                                </li>
                                <li>
                                    <p><code>&lt;A extends Annotation> A[] getDeclaredAnnotationsByType(Class&lt;A> annotationClass)</code> -- 获取指定类型注解列表</p>
                                </li>
                                <li>
                                    <p><code>&lt;A extends Annotation> A getDeclaredAnnotation(Class&lt;A> annotationClass)</code> -- 获取指定类型注解</p>
                                </li>
                                <li>
                                    <p><code>Annotation[] getDeclaredAnnotations()</code> -- 直接存在于此元素上的所有注释</p>
                                </li>
                                <li>
                                    <p><code>boolean isAnnotationPresent(Class&lt;? extends Annotation> annotationClass)</code> -- 是否有指定注解存在此元素上</p>
                                </li>


                                <li class="group">
                                    <p><code>&lt;U> Class&lt;? extends U> 	asSubclass(Class&lt;U> clazz)</code> -- 强制转换为 <code>clazz</code> 的子类</p>
                                </li>
                                <li>
                                    <p><code>T 	cast(Object obj)</code> -- 强制类型转换</p>
                                </li>
                                <li>
                                    <p><code>boolean 	desiredAssertionStatus()</code> -- 如果要在调用此方法时将要初始化该类，则返回将分配给该类的断言状态</p>
                                </li>

                                <li class="group">
                                    <p><code>AnnotatedType[] 	getAnnotatedInterfaces()</code> -- 获取直接继承/实现带注解的接口列表</p>
                                </li>
                                <li>
                                    <p><code>AnnotatedType 	getAnnotatedSuperclass()</code> -- 获取直接继承带注解的类</p>
                                </li>



                                <li class="group">
                                    <p><code>ProtectionDomain 	getProtectionDomain()</code> -- 返回该类的 ProtectionDomain，参见相关类</p>
                                </li>
                                <li>
                                    <p><code>Object[] 	getSigners()</code> -- 获取类的签名，一般为 NULL</p>
                                </li>

                                <li>
                                    <p><code>String 	toGenericString()</code> -- 返回形式：<code>修饰符 + class/interface/enum + getName()</code></p>
                                </li>
                                <li>
                                    <p><code>String 	toString()</code> -- 返回形式：<code>interface / class + getName()</code></p>
                                </li>

							</ol>
							<div class="panel panel-default">
								<div class="panel-heading">
									<a data-toggle="collapse" data-parent="#accordion"
										href="#jdk-Class-clazz" aria-expanded="true"
										class="code-header">
										<span class="glyphicon glyphicon-plus"></span> View Code
									</a>
								</div>
								<div id="jdk-Class-clazz" class="panel-collapse collapse"
									style="" aria-expanded="true">
									<pre class="brush: java;">
public class MyReflect {
	public static void main(String[] args) {
		/** 类型 */
		System.out.println(Serializable.class.isInterface());
		System.out.println(ElementType.class.isEnum());
		System.out.println(Target.class.isAnnotation());
		String[] array = {};
		System.out.println(array.getClass().isArray());
	
		MyReflect testReflect = new MyReflect();
		Class&lt;?> clazz = testReflect.getClass();
		
		System.out.println("完整类名: " + clazz.getName());
		System.out.println("类名: " + clazz.getSimpleName());
		System.out.println("类型名: " + clazz.getTypeName());
		System.out.println("ClassLoader名: "
				+ clazz.getClassLoader().getClass().getName());
		System.out.println("父类: " + clazz.getSuperclass().getName());
		
		/** 实例化一个对象，并操作这个对象 */
		try {
			// 第一种方法，实例化默认构造方法，调用set赋值
			Class&lt;?> myClass = Class.forName("cm.nate.reflect.MyReflect");
			MyReflect mr = (MyReflect) myClass.newInstance();
			mr.setName("hello");
			System.out.println(mr.getName());
			
			// 取得指定的构造函数 使用构造函数赋值
			@SuppressWarnings("unchecked")
			Constructor&lt;MyReflect> constructor = 
				(Constructor&lt;MyReflect>) myClass.getConstructor(String.class);
			MyReflect mr2 = constructor.newInstance("jiwanger");
			System.out.println(mr2.getName());
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		/** 取得本类的全部属性 */
		Field[] field = clazz.getDeclaredFields();
        for (int i = 0; i &lt; field.length; i++) {
            // 权限修饰符
            int mo = field[i].getModifiers();
            String priv = Modifier.toString(mo);
            // 属性类型
            Class&lt;?> type = field[i].getType();
            System.out.println(priv + " " + type.getName() + " " + field[i].getName() + ";");
        }
        
        /** 获取某个类的全部方法 */
        Method method[] = clazz.getMethods();
        for (int i = 0; i &lt; method.length; ++i) {
            Class&lt;?> returnType = method[i].getReturnType();
            Class&lt;?> para[] = method[i].getParameterTypes();
            int temp = method[i].getModifiers();
            System.out.print(Modifier.toString(temp) + " ");
            System.out.print(returnType.getName() + "  ");
            System.out.print(method[i].getName() + " ");
            System.out.print("(");
            for (int j = 0; j &lt; para.length; ++j) {
                System.out.print(para[j].getName() + " " + "arg" + j);
                if (j &lt; para.length - 1) {
                    System.out.print(",");
                }
            }
            Class&lt;?> exce[] = method[i].getExceptionTypes();
            if (exce.length > 0) {
                System.out.print(") throws ");
                for (int k = 0; k &lt; exce.length; ++k) {
                    System.out.print(exce[k].getName() + " ");
                    if (k &lt; exce.length - 1) {
                        System.out.print(",");
                    }
                }
            } else {
                System.out.print(")");
            }
            System.out.println();
        }
        
        /** 反射机制调用某个类的方法 */
        try {
			Class&lt;?> myClass = Class.forName("cm.nate.reflect.MyReflect");
			// 调用TestReflect类中的reflect1方法
			
			// Java 反射机制 - 调用某个类的方法1.
			// 调用TestReflect的reflect2方法
			MyReflect mr3 = (MyReflect) myClass.newInstance();
			Method method2 = myClass.getMethod("setName", String.class);
			method2.invoke(mr3, "张三");
			
			Method method3 = myClass.getMethod("getName");
			String name = (String) method3.invoke(mr3);
			System.out.println(name);
			
		}  catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public MyReflect(){}
	
	public MyReflect(String name){
		this.name = name;
	}

	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

}
</pre>
								</div>
							</div>
						</div>

						<div class="sub-item">
                            <p><b><code>Class</code> 相关类：</b></p>
                            <p><a href="docs/docs-java/api/java/lang/annotation/Annotation.html" target="_blank">Annotation</a> -- 所有 annotation 类型都要扩展的公共接口。注意，手动扩展该公共接口的接口不 定义 annotation 类型。还要注意此接口本身不定义 annotation 类型。</p>
                            <pre class="brush: java;">
Class&lt;? extends Annotation> annotationType() -- 返回此 annotation 的注释类型。
boolean equals(Object obj); // 如果指定的对象表示在逻辑上等效于此接口的注释，则返回 true。
int hashCode(); // 返回此 annotation 的哈希码，
String toString(); // 返回此 annotation 的字符串表示形式
                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Constructor.html" target="_blank">Constructor</a> -- 提供关于类的单个构造方法的信息以及对它的访问权限。</p>
							<p><code>Constructor</code> 允许在将实参与带有底层构造方法的形参的 <code>newInstance()</code> 匹配时进行扩展转换，但是如果发生收缩转换，则抛出 <code>IllegalArgumentException</code>。 </p>
                            <pre class="brush: java;">
public final class Constructor&lt;T> extends Executable {
	// 主要是这个方法，用于使用指定的参数构造对象实例
	T newInstance(Object... initargs);
}

public abstract class Executable extends AccessibleObject implements Member, GenericDeclaration {}

/** 可访问性控制 */
public class AccessibleObject implements AnnotatedElement {
	// 值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查
	void setAccessible(boolean flag);
	// 获取此对象的 accessible 标志的值
	boolean isAccessible();
    ...
}

public interface Member {
    public static final int PUBLIC = 0; // 标识类或接口的所有已声明成员的集合
    public static final int DECLARED = 1; // 标识类或接口的所有公共成员（包括继承成员）的集合

    public Class&lt;?> getDeclaringClass(); // 返回表示声明由此 Member 表示的成员或构造方法的类或接口的 Class 对象
    public String getName(); // 作为整数返回由此 Member 所表示的成员或构造方法的 Java 语言修饰符
    int getModifiers(); // 返回此 Member 表示的底层成员或构造方法的简单名称
    boolean isSynthetic(); //  如果此成员是编译器引入的，则返回 true；否则，返回 false。
}
                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Field.html" target="_blank">Field</a> -- 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p>
							<p>Array 允许在执行 <code>get</code> 或 <code>set</code> 访问操作期间进行扩展转换，但如果将发生收缩转换，则抛出一个 <code>IllegalArgumentException。</code> </p>
                            <pre class="brush: java;">
public final class Field extends AccessibleObject implements Member {
	String getName(); // 返回此 Field 对象表示的字段的名称
	Class&lt;?> getType(); // 返回标识了此 Field 对象所表示字段的声明类型
	Object get(Object obj); // 获取指定对象实例上该字段的值
	void set(Object obj, Object value); // 设置指定对象实例上该字段的值
	int getInt(Object obj); // 获取指定对象实例上 int 字段的值
	void setInt(Object obj, int i); // 设置指定对象实例上 int 字段的值
	boolean getBoolean(Object obj); // 获取指定对象实例上 boolean 字段的值
	void setBoolean(Object obj, boolean z); // 设置指定对象实例上 boolean 字段的值
	...
}
                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Method.html" target="_blank">Method</a> -- 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法）。 </p>
							<p><code>Method</code> 允许在匹配要调用的实参与底层方法的形参时进行扩展转换；但如果要进行收缩转换，则会抛出 <code>IllegalArgumentException</code>。</p>
                            <pre class="brush: java;">
public final class Method extends Executable {
	String getName(); // 方法名
	Class&lt;?> getReturnType(); // 返回返回值类型
	Class&lt;?>[] getParameterTypes(); // 按照声明顺序返回参数类型的 Class 对象的数组
	Object invoke(Object obj, Object... args); // 调用指定对象的方法
	boolean isVarArgs(); // 是否有可变数量的参数类型
}
                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Type.html" target="_blank">Type</a> -- 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。有以下子类：</p>
							<ul>
								<li><p><a href="docs/docs-java/api/java/lang/reflect/TypeVariable.html" target="_blank">TypeVariable</a> -- 是各种类型变量的公共高级接口。类型变量在反射方法首次需要时创建。如果类型变量 t 由类型（即类、接口或注释类型）T 引用，而且 T 由 T 的第 n 个封闭类声明（请参见 JLS 8.1.2），那么创建 t 需要解析（请参见 JVMS 5）T 的第 i 个封闭类，其中 i = 0 到 n（包含）。创建某个类型变量决不能导致创建其边界。重复创建类型变量没有效果。 </p>
									<p>可以在运行时将多个对象实例化，以表示一个给定的类型变量。尽管类型变量仅创建一次，这并不意味着任何缓存实例的要求都表示类型变量。不过，表示类型变量的所有实例彼此必须相等 (equal())。因此，使用类型变量的用户决不能依靠实现此接口的类实例的身份。 </p>
								<pre class="brush: java;">
public interface TypeVariable&lt;D extends GenericDeclaration> extends Type, AnnotatedElement {
	Type[] getBounds(); // 返回表示此类型变量上边界的 Type 对象的数组。
	D getGenericDeclaration(); // 返回 GenericDeclaration 对象，该对象表示声明此类型变量的一般声明。
	String getName(); // 返回此类型变量的名称，它出现在源代码中。
}

public interface GenericDeclaration extends AnnotatedElement {
	// 返回声明顺序的 TypeVariable 对象的数组，由此 GenericDeclaration 对象表示的一般声明声明的类型变量
	TypeVariable&lt;?>[] getTypeParameters();
}
								</pre>
								</li>
								<li><p><a href="docs/docs-java/api/java/lang/reflect/ParameterizedType.html" target="_blank">ParameterizedType</a> -- 表示参数化类型，如 <code>Collection&lt;String></code>。</p>
									<p>参数化类型在反射方法首次需要时创建（在此包中指定）。当创建参数化类型 p 时，p 实例化的一般类型声明会被解析，并且按递归方式创建 p 的所有类型参数。有关类型变量创建过程的详细信息，请参阅 TypeVariable。重复创建的参数化类型无效。</p>
										<p>实现此接口的类的实例必须实现 <code>equals()</code> 方法，该方法用于比较两个共享相同一般类型声明和具有相同类型参数的任何实例。 </p>
									<pre class="brush: java;">
public interface ParameterizedType extends Type {
	Type[] getActualTypeArguments(); // 返回表示此类型实际类型参数的 Type 对象的数组。
	Type getOwnerType(); // 返回 Type 对象，表示此类型是其成员之一的类型。
	Type getRawType(); // 返回 Type 对象，表示声明此类型的类或接口
}
									</pre>
								</li>
								<li><p><a href="docs/docs-java/api/java/lang/reflect/WildcardType.html" target="_blank">WildcardType</a> -- 表示一个通配符类型表达式，如 <code>?</code>、<code>? extends Number</code> 或 <code>? super Integer</code>。</p>
									<pre class="brush: java;">
public interface WildcardType extends Type {
	Type[] getLowerBounds(); // 返回表示此类型变量下边界的 Type 对象的数组。
	Type[] getUpperBounds(); // 返回表示此类型变量上边界的 Type 对象的数组。
}
									</pre>
								</li>
								<li><p><a href="docs/docs-java/api/java/lang/reflect/GenericArrayType.html" target="_blank">GenericArrayType</a> -- 表示一种数组类型，其组件类型为参数化类型或类型变量。</p>
									<pre class="brush: java;">
public interface GenericArrayType extends Type {
	Type getGenericComponentType(); // 返回表示此数组的组件类型的 Type 对象
}
									</pre>
								</li>
							</ul>
                            <p><a href="docs/docs-java/api/java/security/ProtectionDomain.html" target="_blank">ProtectionDomain</a> -- 封装域的特征，域中包装一个类集合，在代表给定的主体集合执行这些类的实例时会授予它们一个权限集合。</p>
							<p>在构造 ProtectionDomain 时可以对它绑定一个静态的权限集合；不管 Policy 是否有效，都会将这些权限授予域。但是，为了支持动态安全策略，也可以构造 ProtectionDomain，使得只要检查权限时就能通过当前 Policy 将其动态地映射到一个权限集合。 </p>
                            <pre class="brush: java;">
public class ProtectionDomain {
	public ProtectionDomain(CodeSource codesource, PermissionCollection permissions) {}
	public ProtectionDomain(CodeSource codesource, PermissionCollection permissions,
								ClassLoader classloader, Principal[] principals) {}

	ClassLoader getClassLoader(); // 返回此域的 ClassLoader。
	CodeSource getCodeSource(); // 返回此域的 CodeSource。
	PermissionCollection getPermissions(); // 返回授予此域的静态权限。
	Principal[] getPrincipals(); // 返回此域的 principals 数组。
	boolean implies(Permission permission); //  查看此 ProtectionDomain 是否暗含了 Permission 对象中表示的权限。
}
                            </pre>

						</div>
				    </div>
			    </div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-ClassLoader"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">ClassLoader</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
public abstract class ClassLoader {
    protected 	ClassLoader() {}
    protected 	ClassLoader(ClassLoader parent) {}
}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/ClassLoader.html" target="_blank">ClassLoader</a> -- 是一个抽象类，负责加载类的对象。如果给定类的二进制名称，那么类加载器会试图查找或生成构成类定义的数据。一般策略是将名称转换为某个文件名，然后从文件系统读取该名称的“类文件”。 </p>
                        <p>每个 Class 对象都包含一个对定义它的 ClassLoader 的引用。 </p>
                        <p>数组类的 Class 对象不是由类加载器创建的，而是由 Java 运行时根据需要自动创建。数组类的类加载器由 <code>Class.getClassLoader()</code> 返回，该加载器与其元素类型的类加载器是相同的；如果该元素类型是基本类型，则该数组类没有类加载器。 </p>
                        <p>类加载器通常由安全管理器使用，用于指示安全域。</p>
                        <p>ClassLoader 类使用委托模型来搜索类和资源。每个 ClassLoader 实例都有一个相关的父类加载器。需要查找类或资源时，ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。虚拟机的内置类加载器（称为 "bootstrap class loader"）本身没有父类加载器，但是可以将它用作 ClassLoader 实例的父类加载器。</p>
                        <p>通常情况下，Java 虚拟机以与平台有关的方式，从本地文件系统中加载类。例如，在 UNIX 系统中，虚拟机从 CLASSPATH 环境变量定义的目录中加载类。</p>
                        <p><b>类加载过程：</b></p>
                        <ul>
                            <li><p><b>加载</b>：类加载过程的一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个 Class 对象;</p></li>
                            <li><p><b>验证</b>：目的在于确保 Class 文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证;                            </p></li>
                            <li><p><b>准备</b>：为类变量(即 static 修饰的字段变量)分配内存并且设置该类变量的初始值即0(如 static int i = 5;这里只将 i 初始化为 0，至于 5 的值将在初始化时赋值)，这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中;                            </p></li>
                            <li><p><b>解析</b>：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析(这里涉及到字节码变量的引用，如需更详细了解，可参考《深入 Java 虚拟机》);                            </p></li>
                            <li><p><b>初始化</b>：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的 static 变量将会在这个阶段赋值，成员变量也将被初始化)。                            </p></li>
                        </ul>

                        <p><a href="docs/docs-java/api/java/lang/ClassLoader.html" target="_blank">ClassLoader</a> 的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，<b>引导（Bootstrap）类加载器</b>、<b>扩展（Extension）类加载器</b>、<b>系统（System）类加载器（也称应用类加载器）</b></p>
                        <p><b>启动类加载器</b> -- 启动类加载器主要加载的是 JVM 自身需要的类，这个类加载使用 C++ 语言实现的，是虚拟机自身的一部分，它负责将 <code>$JAVA_HOME/lib</code> 路径下的核心类库或 <code>-Xbootclasspath</code> 参数指定的路径下的 jar 包加载到内存中，注意必由于虚拟机是按照文件名识别加载 jar 包的，如 rt.jar，如果文件名不被虚拟机识别，即使把 jar 包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启 动类加载器只加载包名为 java、javax、sun 等开头的类)。</p>
                        <p><b>扩展类加载器</b> -- 扩展类加载器是指 Sun 公司(已被 Oracle 收购)实现的 sun.misc.Launcher$ExtClassLoader 类，由 Java 语言实现的，是Launcher的静态内部类，它负责加载 <code>$JAVA_HOME/lib/ext</code> 目录下或者由系统变量 <code>-Djava.ext.dir</code> 指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</p>
                        <p><b>系统类加载器</b> -- 也称应用程序加载器是指 Sun 公司实现的 sun.misc.Launcher$AppClassLoader。它负责加载系统类路径 <code>java -classpath</code> 或 <code>-D java.class.path</code> 指定路径下的类库，也就是我们经常用到的 classpath 路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过 <code>ClassLoader.getSystemClassLoader()</code> 方法可以获取到该类加载器。 </p>

                        <p><b>双亲委派模式</b> -- 要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
                        <p>采用双亲委派模式的是好处是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次。其次是考虑到安全因素，java 核心 api 中定义类型不会被随意替换。</p>
                        <ol>
                            <li><p><code>static ClassLoader 	getSystemClassLoader()</code> -- 返回委托的系统类加载器</p></li>
                            <li><p><code>static URL 	getSystemResource(String name)</code> -- 从用来加载类的搜索路径中查找具有指定名称的资源</p></li>
                            <li><p><code>static InputStream 	getSystemResourceAsStream(String name)</code> -- 以流的形式读取该资源</p></li>
                            <li><p><code>static Enumeration&lt;URL> 	getSystemResources(String name)</code> -- 从用来加载类的搜索路径中查找所有具有指定名称的资源</p></li>

                            <li class="group"><p><code>Class&lt;?> 	loadClass(String name)</code> -- 使用指定的二进制名称来加载类</p></li>
                            <li><p><code>protected Class&lt;?> 	loadClass(String name, boolean resolve)</code> -- 使用指定的二进制名称来加载类</p></li>

                            <li class="group"><p><code>protected Class&lt;?> 	findClass(String name)</code> -- 使用指定的二进制名称查找类</p></li>
                            <li><p><code>protected String 	findLibrary(String libname)</code> -- 返回本机库的绝对路径名</p></li>
                            <li><p><code>protected Class&lt;?> 	findLoadedClass(String name)</code> -- 如果 JVM 已将此加载器记录为具有给定二进制名称的某个类的启动加载器，则返回该二进制名称的类</p></li>
                            <li><p><code>protected URL 	findResource(String name)</code> -- 查找具有给定名称的资源</p></li>
                            <li><p><code>protected Enumeration&lt;URL> 	findResources(String name)</code> -- 返回表示所有具有给定名称的资源的 URL 对象的枚举</p></li>
                            <li><p><code>protected Class&lt;?> 	findSystemClass(String name)</code> --  查找具有指定的二进制名称的类，必要时加载它</p></li>


                            <li class="group"><p><code>protected Class&lt;?> 	defineClass(String name, byte[] b, int off, int len)</code> -- 将一个 byte 数组转换为 Class 类的实例</p></li>
                            <li><p><code>protected Class&lt;?> 	defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)</code> -- 使用可选的 ProtectionDomain 将一个 byte 数组转换为 Class 类的实例</p></li>
                            <li><p><code>protected Class<?> 	defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)</code> -- 使用可选的 ProtectionDomain 将 ByteBuffer 转换为 Class 类的实例</p></li>
                            <li><p><code>protected Package 	definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)</code> -- 根据 name 在此 ClassLoader 中定义包</p></li>

                            <li class="group"><p><code>protected Object 	getClassLoadingLock(String className)</code> -- 返回类加载操作的锁定对象</p></li>
                            <li><p><code>protected Package 	getPackage(String name)</code> --  返回由此类加载器或其任何祖先所定义的 Package</p></li>
                            <li><p><code>protected Package[] 	getPackages()</code> -- 返回此类加载器及其祖先所定义的所有 Package</p></li>
                            <li><p><code>ClassLoader 	getParent()</code> -- 返回委托的父类加载器</p></li>
                            <li><p><code>URL 	getResource(String name)</code> -- 查找具有给定名称的资源</p></li>
                            <li><p><code>InputStream 	getResourceAsStream(String name)</code> -- 返回读取指定资源的输入流</p></li>
                            <li><p><code>Enumeration&lt;URL> 	getResources(String name)</code> -- 查找所有给定名称的资源</p></li>

                            <li class="group"><p><code>protected static boolean 	registerAsParallelCapable()</code> -- 注册为并行</p></li>
                            <li><p><code>protected void 	resolveClass(Class&lt;?> c)</code> -- 链接指定的类</p></li>
                            <li><p><code>protected void 	setSigners(Class&lt;?> c, Object[] signers)</code> -- 设置类的签署者</p></li>
                            <li><p><code>void 	setPackageAssertionStatus(String packageName, boolean enabled)</code> -- 为指定包设置默认断言状态</p></li>
                            <li><p><code>void 	setDefaultAssertionStatus(boolean enabled)</code> -- 设置此类加载器的默认断言状态</p></li>
                            <li><p><code>void 	setClassAssertionStatus(String className, boolean enabled)</code> -- 设置在此类加载器及其包含的嵌套类中指定的最高层类所需的断言状态</p></li>
                            <li><p><code>void 	clearAssertionStatus()</code> -- 将此类加载器的默认断言状态设置为 false，并放弃与此类加载器关联的所有默认包或类断言状态设置</p></li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-Enum"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">java.lang.Enum</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.Enum&lt;E>

public abstract class Enum&lt;E extends Enum&lt;E>> implements Comparable&lt;E>, Serializable {
    protected Enum(String name, int ordinal) {}
}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/Enum.html" target="_blank">Enum</a> -- 特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。</p>
                        <p><a href="docs/docs-java/api/java/lang/Enum.html" target="_blank">Enum</a> 还有专属的 <code>Map(<a href="docs/docs-java/api/java/util/EnumMap.html" target="_blank">EnumMap</a>)</code> 和 <code>Set(<a href="docs/docs-java/api/java/util/EnumSet.html" target="_blank">EnumSet</a>)</code></p>

                        <ul>
                            <li><p><a href="docs/docs-java/api/java/util/EnumMap.html" target="_blank">EnumMap</a> -- 与枚举类型键一起使用的专用 Map 实现。枚举映射中所有键都必须来自单个枚举类型，该枚举类型在创建映射时显式或隐式地指定。枚举映射在内部表示为数组。此表示形式非常紧凑且高效。 </p></li>
                            <li><p><a href="docs/docs-java/api/java/util/EnumSet.html" target="_blank">EnumSet</a> -- 与枚举类型一起使用的专用 Set 实现。枚举 set 中所有键都必须来自单个枚举类型，该枚举类型在创建 set 时显式或隐式地指定。枚举 set 在内部表示为位向量。此表示形式非常紧凑且高效。此类的空间和时间性能应该很好，足以用作传统上基于 int 的“位标志”的替换形式，具有高品质、类型安全的优势。如果其参数也是一个枚举 set，则批量操作（如 containsAll 和 retainAll）也应运行得非常快。 </p></li>
                        </ul>


                        <pre class="brush: java;">
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

/** 编译器编译后的 class 文件: */
public final class Day extends Enum {
	// 前面定义的 7 种枚举实例
    public static final Day MONDAY;
    public static final Day TUESDAY;
    public static final Day WEDNESDAY;
    public static final Day THURSDAY;
    public static final Day FRIDAY;
    public static final Day SATURDAY;
    public static final Day SUNDAY;
    private static final Day $VALUES[];

    static {
        // 实例化枚举实例
        MONDAY = new Day("MONDAY", 0);
        TUESDAY = new Day("TUESDAY", 1);
        WEDNESDAY = new Day("WEDNESDAY", 2);
        THURSDAY = new Day("THURSDAY", 3);
        FRIDAY = new Day("FRIDAY", 4);
        SATURDAY = new Day("SATURDAY", 5);
        SUNDAY = new Day("SUNDAY", 6);
        $VALUES = (new Day[] {
            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
        });
    }

	// 私有构造函数
    private Day(String s, int i) {
        super(s, i);
    }

    // 编译器为我们添加的静态的values()方法
    public static Day[] values() {
        return (Day[])$VALUES.clone();
    }

    // 编译器为我们添加的静态的 valueOf() 方法，注意间接调用了 Enum 也类的 valueOf 方法
    public static Day valueOf(String s) {
        return (Day)Enum.valueOf(com/zejian/enumdemo/Day, s);
    }
}
</pre>
						<p><b>Enum API:</b></p>
						<ol>
							<li><p><code>static &lt;T extends Enum&lt;T>> T 	valueOf(Class&lt;T> enumType, String name)</code> -- 返回带指定名称的指定枚举类型的枚举常量</p></li>
							<li class="group"><p><code>String 	name()</code> -- 返回此枚举常量的名称</p></li>
							<li><p><code>int 	ordinal()</code> -- 返回枚举常量的序数</p></li>
							<li><p><code>int 	compareTo(E o)</code> -- 比较此枚举与指定对象的顺序</p></li>
							<li><p><code>Class&lt;E> 	getDeclaringClass()</code> -- 返回与此枚举常量的枚举类型相对应的 Class 对象</p></li>
							<li class="group"><p><code>boolean 	equals(Object other)</code> -- 当指定对象等于此枚举常量时，返回 true</p></li>
							<li><p><code>int 	hashCode()</code> -- 返回枚举常量的哈希码</p></li>
							<li><p><code>protected void 	finalize()</code> -- 枚举类不能有 finalize 方法</p></li>
							<li><p><code>String 	toString()</code> -- 返回枚举常量的名称</p></li>
							<li><p><code>protected Object 	clone()</code> -- 枚举类不能 clone，抛出异常</p></li>
							<li class="group"><p><code>static &lt;T extends Enum&lt;T>> T valueOf(String name)</code> -- 编译器自动生成的方法</p></li>
							<li><p><code>static &lt;T extends Enum&lt;T>>[] T values()</code> -- 编译器自动生成的方法</p></li>
						</ol>

                        <p><b>添加方法与自定义构造函数</b></p>
                        <pre class="brush: java;">
public enum Day {
    MONDAY("星期一"), TUESDAY("星期二"), WEDNESDAY("星期三"), THURSDAY("星期四"),
    FRIDAY("星期五"), SATURDAY("星期六"), SUNDAY("星期日"); // 最后一个分号不能少

    private String desc; // 中文描述

    private Day(String desc) { // 私有构造,防止被外部调用
        this.desc = desc;
    }

    public String getDesc(){ // 常规类的定义没区别
        return desc;
    }
}
</pre>

                        <p><b>定义抽象方法，每个枚举实例都实现该方法，以便产生不同的行为方式</b></p>
                        <pre class="brush: java;">
public enum Day {
    MONDAY {
        @Override
        public String getInfo() {
            return null;
        }
    }, FRIDAY {
        @Override
        public String getInfo() {
            return null;
        }
    };

    public abstract String getInfo();
}
                        </pre>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Package"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Class</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">Package 类</h5>
							<pre class="brush: java;">
public class Package implements AnnotatedElement {}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/Package.html" target="_blank">Package</a> 对象包含有关 Java 包的实现和规范的版本信息。通过用于加载类的 ClassLoader
								实例，可以获取并获得此版本信息。通常，此信息存储在与类一起分发的清单中。</p>
							<p>组成包的类集可以实现一个特定规范，如此一来，就可以通过规范标题、版本号和供应商字符串来标识该规范。应用程序可以询问包是否与特定版本兼容，有关详细信息，请参阅
								isCompatibleWith 方法。</p>
                            <p>在每一个 ClassLoader 实例中，<b>相同 java 包中的所有类都有相同的 Package 对象</b>。静态方法允许通过名称或当前类加载器已知的所有包的集合来找到包。 </p>
                            <ol>
                                <li><p><code>static Package 	getPackage(String name)</code> -- 如果 ClassLoader 加载了此包，则返回 Package；否则返回空</p>
                                <pre class="brush: java;">
/** 已知一个 App 源码结构如下：
 *  io.github.jiwanger.App.java
 *  io.github.jiwanger.helper.Log.java
 *  io.github.jiwanger.io.MyFile.java
 *  io.github.jiwanger.lang.MyPackage.java
 */
/** 代码总只使用了 MyPackage, App, Log, 那么以下输出为： */
Package.getPackage("io.github"); // null
Package.getPackage("io.github.jiwanger"); // 不为空
Package.getPackage("io.github.jiwanger.helper"); // null
Package.getPackage("io.github.jiwanger.lang"); // 不为空
                                </pre>
                                </li>
                                <li><p><code>static Package[] 	getPackages()</code> -- ClassLoader 实例当前已知的所有包</p></li>

                                <li class="group"><p><code>String 	getImplementationTitle()</code> -- 实现标题</p></li>
                                <li><p><code>String 	getSpecificationTitle()</code> -- 规范标题</p></li>
                                <li><p><code>String 	getImplementationVendor()</code> -- 实现供应商</p></li>
                                <li><p><code>String 	getSpecificationVendor()</code> -- 规范供应商</p></li>
                                <li><p><code>String 	getImplementationVersion()</code> -- 实现版本</p></li>
                                <li><p><code>String 	getSpecificationVersion()</code> -- 规范版本</p></li>

                                <li class="group"><p><code>&lt;A extends Annotation> A 	getAnnotation(Class&lt;A> annotationClass)</code> -- 存在该元素的指定类型的注释</p></li>
                                <li><p><code>Annotation[] 	getAnnotations()</code> -- 返回此元素上存在的所有注释</p></li>
                                <li><p><code>&lt;A extends Annotation> A 	getDeclaredAnnotation(Class&lt;A> annotationClass)</code> -- 返回直接存在于此元素上的指定注释</p></li>
                                <li><p><code>Annotation[] 	getDeclaredAnnotations()</code> -- 返回直接存在于此元素上的所有注释</p></li>
                                <li><p><code>&lt;A extends Annotation> A[] 	getAnnotationsByType(Class&lt;A> annotationClass)</code> -- 此元素上的指定类型注释</p></li>
                                <li><p><code>&lt;A extends Annotation> A[] 	getDeclaredAnnotationsByType(Class&lt;A> annotationClass)</code> -- 直接存在于此元素上的指定类型注释</p></li>
                                <li><p><code>boolean 	isAnnotationPresent(Class&lt;? extends Annotation> annotationClass)</code> -- 如果指定类型的注释存在于此元素上，则返回 true，否则返回 false</p></li>

                                <li class="group"><p><code>String 	getName()</code> -- 包的名称</p></li>
                                <li><p><code>boolean 	isSealed()</code> -- 是否密封</p></li>
                                <li><p><code>boolean 	isSealed(URL url)</code> -- 对于指定的代码源 url 是密封的</p></li>
                                <li><p><code>boolean 	isCompatibleWith(String desired)</code> -- 比较此包的规范版本和所需版本</p></li>
                            </ol>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-System"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">System</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.lang.System

public final class System {
    public final static InputStream in = null; // “标准”输入流
    public final static PrintStream out = null; // “标准”输出流
    public final static PrintStream err = null; // “标准”错误输出流
}
                            </pre>
							<p><a href="docs/docs-java/api/java/lang/System.html" target="_blank">System</a> 类代表系统，系统级的很多属性和控制方法都放置在该类的内部。</p>
							<p>System类内部包含 <code>in</code>、<code>out</code> 和 <code>err</code> 三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</p>
							<ol>
								<li><p><code>static void setIn(InputStream in)</code> -- 改变标准输入流</p></li>
                                <li><p><code>static void setOut(PrintStream out)</code> -- 改变标准输出流</p></li>
                                <li><p><code>static void setError(PrintStream out)</code> -- 改变标准错误流</p></li>

                                <li class="group"><p><code>static void setProperty(String key, String value)</code> -- 设置系统属性</p></li>
                                <li><p><code>static String getProperty(String key)</code> -- 获得系统属性</p></li>
                                <li><p><code>static StringgetProperty(String key, String def)</code> -- 获得系统属性，如果为空则返回默认值</p></li>
                                <li><p><code>static String clearProperty(String key)</code> -- 清除属性</p></li>
                                <li><p><code>static void 	setProperties(Properties props)</code> -- 将系统属性设置为 Properties 参数</p></li>
                                <li><p><code>static Properties getProperties()</code> -- 获得所有系统属性</p>
									<pre class="brush: java;">
//  所有的 property
Properties properties = System.getProperties();
Iterator it = properties.keySet().iterator();
while(it.hasNext()) {
	String key = (String) it.next();
	System.out.println(key + ":" + properties.get(key));
}

// 指定的 property
System.out.println(System.getProperty("os.name"));
// 如果没有指定的 property, 返回指定的 default
System.out.println(System.getProperty("os.name2", "default"));

// 自己定义属性
System.setProperty("property.define", "myProperty");
</pre>
								</li>

                                <li class="group"><p><code>static String getenv(String name)</code> -- 获得环境变量</p></li>
                                <li><p><code>static String getenv()</code> -- 获得所有环境变量</p>
									<pre class="brush: java;">
//  所有的 env
Map&lt;String, String> env = System.getenv();
Iterator&lt;String> it = env.keySet().iterator();
while(it.hasNext()) {
	String key = it.next();
	System.out.println(key + ":" + env.get(key));
}

// 指定 env
System.out.println(System.getenv("PATH"));
</pre>
								</li>

                                <li class="group"><p><code>static native long currentTimeMillis()</code> -- 自 1970 年 1 月 1 日 0 时起的毫秒数</p></li>
                                <li><p><code>static long 	nanoTime()</code> -- 返回最准确的可用系统计时器的当前值，以纳秒秒为单位</p>
                                <pre class="brush: java;">
/** currentTimeMillis() -- 自 1970 年 1 月 1 日 0 时起的毫秒数
 * nanoTime() -- 返回的时间点是随机的，不是 1970 年..., 但是对于同一个JVM里，不同地方使用到的基点时间是一样的
 */
long start = System.nanoTime();
...
long time = System.nanoTime() - start;

Date date = new Data(System.currentTimeMillis());
                                </pre>
                                </li>

                                <li class="group"><p><code>static void exit(int status)</code> -- 退出程序(调用 Runtime 的 exit) </p>
                                <li><p><code>static void gc()</code> -- 请求系统进行垃圾回收</p></li>
                                <li><p><code>static Console 	console()</code> -- 返回与当前 Java 虚拟机关联的唯一 Console 对象(JVM 在命令行中被调用，并且输入/输出未被重定向)</p></li>
                                <li><p><code>static void 	runFinalization()</code> -- 运行处于挂起终止状态的所有对象的终止方法</p></li>
                                <li><p><code>static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code> -- 该方法的作用是数组拷贝。比使用循环更高效。</p>
                                    <pre class="brush: java;">
int[] a = { 1, 2, 3, 4 };
int[] b = new int[5];

// 将数组a中，从下标为1开始，复制到数组b从下标3开始的位置，总共复制2个。b -> 0 0 0 2 3
System.arraycopy(a, 1, b, 3, 2);
</pre>
                                </li>

                                <li class="group"><p><code>static void load(String filename)</code> -- 主要用来加载动态链接库</p></li>
                                <li><p><code>static String 	mapLibraryName(String libname)</code> -- 将一个库名称映射到特定于平台的、表示本机库的字符串中</p></li>
                                <li><p><code>static void loadLibrary(String libname)</code> -- 主要用来加载动态链接库, JNI 中使用, 实例参见:
                                    <a href="index.html#java-jni">Java 本地编程 - JNI</a></p></li>

                                <li class="group"><p><code>static void setSecurityManager(final SecurityManager s)</code> -- 设置安全管理器</p></li>
                                <li><p><code>static getSecurityManager()</code> -- 获得安全管理器</p></li>
                                <li><p><code>static int 	identityHashCode(Object x)</code> -- 返回给定对象的哈希码，该代码与默认的方法 hashCode() 返回的代码一样，无论给定对象的类是否重写 hashCode()。</p></li>
                                <li><p><code>static Channel 	inheritedChannel()</code> -- 返回从创建此 Java 虚拟机的实体中继承的信道。</p></li>

							</ol>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Runtime"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Runtime / Process</h3>
					</div>
					<div class="panel-body">

						<div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.lang.Runtime

public class Runtime {
     private Runtime() {}
}
</pre>

                            <p>每个 Java 应用程序都有一个 <a href="docs/docs-java/api/java/lang/Runtime.html" target="_blank">Runtime</a> 类实例，使应用程序能够与其运行的环境相连接。可以通过
								getRuntime 方法获取当前运行时。 应用程序不能创建自己的 Runtime 类实例。</p>

                            <ol>
                                <li><p><code>static Runtime 	getRuntime()</code> -- 返回与当前 Java 应用程序相关的运行时对象。</p></li>

                                <li class="group"><p><code>int 	availableProcessors()</code> -- 向 Java 虚拟机返回可用处理器的数目。</p></li>
                                <li><p><code>long 	maxMemory()</code> --  JVM 能从系统分配到的最大内存总量，字节为单位</p></li>
                                <li><p><code>long 	totalMemory()</code> -- JVM 已经分配到的内存总量，字节为单位，<code>-Xms</code> 参数会影响此值</p></li>
                                <li><p><code>long 	freeMemory()</code> -- 已经分配到但是空闲的内存量，字节为单位</p></li>

                                <li class="group"><p><code>Process 	exec(String command)</code> -- 在单独的进程中执行指定的字符串命令。</p></li>
                                <li><p><code>Process 	exec(String command, String[] envp)</code> -- 在指定环境的单独进程中执行指定的字符串命令。</p></li>
                                <li><p><code>Process 	exec(String command, String[] envp, File dir)</code> -- 在有指定环境和工作目录的独立进程中执行指定的字符串命令。</p></li>
                                <li><p><code>Process 	exec(String[] cmdarray)</code> -- 在单独的进程中执行指定命令和变量。</p></li>
                                <li><p><code>Process 	exec(String[] cmdarray, String[] envp)</code> -- 在指定环境的独立进程中执行指定命令和变量。</p></li>
                                <li><p><code>Process 	exec(String[] cmdarray, String[] envp, File dir)</code> -- 在指定环境和工作目录的独立进程中执行指定的命令和变量。</p>
                                <pre class="brush: java;">
Runtime r = Runtime.getRuntime();
Process process = r.exec("ls");
InputStream in = process.getInputStream();
...

/** 当 exec 使用管道符和重定向时候，最好使用以下方法： */
Process process = r.exec(new String[]{"/bin/bash", "-c", "ls >> log.log"});
...
</pre>
                                </li>

                                <li class="group"><p><code>void 	addShutdownHook(Thread hook)</code> -- 注册新的虚拟机来关闭钩子。</p></li>
                                <li><p><code>boolean 	removeShutdownHook(Thread hook)</code> -- 取消注册某个先前已注册的虚拟机关闭钩子。</p></li>

                                <li class="group"><p><code>void 	exit(int status)</code> -- 通过启动虚拟机的关闭序列，终止当前正在运行的 Java 虚拟机。</p></li>
                                <li><p><code>void 	halt(int status)</code> -- 强行终止目前正在运行的 Java 虚拟机(不会运行关闭回调)。</p></li>
                                <li><p><code>void 	gc()</code> -- 运行垃圾回收器。</p></li>
                                <li><p><code>void 	load(String filename)</code> -- 加载作为动态库的指定文件名。</p></li>
                                <li><p><code>void 	loadLibrary(String libname)</code> -- 加载具有指定库名的动态库。</p></li>
                                <li><p><code>void 	runFinalization()</code> -- 运行挂起 finalization 的所有对象的终止方法。</p></li>

                                <li class="group"><p><code>void 	traceInstructions(boolean on)</code> -- 启用／禁用指令跟踪。</p></li>
                                <li><p><code>void 	traceMethodCalls(boolean on)</code> -- 启用／禁用方法调用跟踪。</p></li>


                            </ol>

						</div>

                        <div class="sub-item">
                            <p><b>Process</b></p>
                            <p>ProcessBuilder.start() 和 Runtime.exec 方法创建一个本机进程，并返回
                                Process 子类的一个实例，该实例可用来控制进程并获得相关信息。Process
                                类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程的方法。</p>
                            <p>创建进程的方法可能无法针对某些本机平台上的特定进程很好地工作，比如，本机窗口进程，守护进程，Microsoft
                                Windows 上的 Win16/DOS 进程，或者 shell 脚本。创建的子进程没有自己的终端或控制台。它的所有标准
                                io（即 stdin、stdout 和 stderr）操作都将通过三个流
                                (getOutputStream()、getInputStream() 和 getErrorStream())
                                重定向到父进程。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。因为有些本机平台仅针对标准输入和输出流提供有限的缓冲区大小，如果读写子进程的输出流或输入流迅速出现失败，则可能导致子进程阻塞，甚至产生死锁。
                            </p>
                            <p>当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。</p>
                            <p>对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</p>

							<ol>

								<li><p><code>abstract  void 	destroy()</code> -- 杀掉子进程。</p></li>
								<li><p><code>abstract  int 	exitValue()</code> -- 返回子进程的出口值。</p></li>
								<li><p><code>abstract  InputStream 	getErrorStream()</code> -- 获取子进程的错误流。</p></li>
								<li><p><code>abstract  InputStream 	getInputStream()</code> -- 获取子进程的输入流。</p></li>
								<li><p><code>abstract  OutputStream 	getOutputStream()</code> -- 获取子进程的输出流。</p></li>
								<li><p><code>abstract  int 	waitFor()</code> -- 导致当前线程等待，如有必要，一直要等到由该 Process 对象表示的进程已经终止。</p></li>
							</ol>
                        </div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Thread"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Thread 与 ThreadGroup</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.lang.Thread

public class Thread implements Runnable {
    /** 线程状态 */
    public enum State {
        NEW, // 至今尚未启动的线程处于这种状态。
        RUNNABLE, // 正在 Java 虚拟机中执行的线程处于这种状态。
        BLOCKED, // 受阻塞并等待某个监视器锁的线程处于这种状态。
        WAITING, // 无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。
        TIMED_WAITING, // 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。
        TERMINATED, // 已退出的线程处于这种状态。
    }

    /** 未捕获的异常回调接口 */
    public interface UncaughtExceptionHandler {
        void uncaughtException(Thread t, Throwable e);
    }

    public static int MAX_PRIORITY; // 线程可以具有的最高优先级。
    public static int 	MIN_PRIORITY; // 线程可以具有的最低优先级。
    public static int 	NORM_PRIORITY; // 分配给线程的默认优先级。

    public Thread() {}
    public Thread(String name) {}
    public Thread(Runnable target) {}
    public Thread(Runnable target, String name) {}
    public Thread(ThreadGroup group, String name) {}
    public Thread(ThreadGroup group, Runnable target) {}
    public Thread(ThreadGroup group, Runnable target, String name) {}
    public Thread(ThreadGroup group, Runnable target, String name, long stackSize) {}
}

/** 为非 Thread 子类的类提供了一种激活方式 */
public interface Runnable {
    void run();
}
                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/Thread.html" target="_blank">Thread</a> 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。 </p>
                            <p>每个线程都有一个标识名，多个线程可以同名。如果线程创建时没有指定标识名，就会为其生成一个新名称。</p>
                            <p>每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。每个线程都可以或不可以标记为一个守护程序。当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护程序。
                            </p>
                            <p>当 Java 虚拟机启动时，通常都会有单个非守护线程（它通常会调用某个指定类的 main 方法）。Java 虚拟机会继续执行线程，直到下列任一情况出现时为止：
                            </p>
                            <ul>
                                <li><p>调用了 Runtime 类的 exit 方法，并且安全管理器允许退出操作发生。</p></li>
                                <li><p>非守护线程的所有线程都已停止运行，无论是通过从对 run 方法的调用中返回，还是通过抛出一个传播到 run 方法之外的异常。</p></li>
                            </ul>

                            <ol>
                                <li><p><code>static void 	setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code> -- 设置未捕获到异常而突然终止时调用的默认处理程序</p></li>
                                <li><p><code>static Thread.UncaughtExceptionHandler 	getDefaultUncaughtExceptionHandler()</code> -- 获取未捕获到异常而突然终止时调用的默认处理程序</p></li>

                                <li class="group"><p><code>static boolean 	interrupted()</code> -- 测试当前线程是否已经中断</p></li>
                                <li><p><code>static void 	sleep(long millis)</code> -- 当前线程休眠指定毫秒数</p></li>
                                <li><p><code>static void 	sleep(long millis, int nanos)</code> -- 当前线程休眠指定毫秒数+纳秒数目</p></li>
                                <li><p><code>static void 	yield()</code> -- 暂停当前正在执行的线程对象，并执行其他线程</p></li>

                                <li class="group"><p><code>static int 	activeCount()</code> -- 当前线程的线程组中活动线程的数目</p></li>
                                <li><p><code>static int 	enumerate(Thread[] tarray)</code> -- 将当前线程的线程组及其子组中的每一个活动线程复制到指定的数组中</p></li>
                                <li><p><code>static void 	dumpStack()</code> -- 将当前线程的堆栈跟踪打印至标准错误流</p></li>
                                <li><p><code>static Map&lt;Thread, StackTraceElement[]> 	getAllStackTraces()</code> -- 返回所有活动线程的堆栈跟踪的一个映射</p></li>
                                <li><p><code>static Thread 	currentThread()</code> -- 当前线程</p></li>
                                <li><p><code>static boolean 	holdsLock(Object obj)</code> -- 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true</p></li>

                                <li class="group"><p><code>void 	setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code> -- 设置该线程由于未捕获到异常而突然终止时调用的处理程序</p></li>
                                <li><p><code>Thread.UncaughtExceptionHandler 	getUncaughtExceptionHandler()</code> -- 获取该线程由于未捕获到异常而突然终止时调用的处理程序</p></li>

                                <li class="group"><p><code>void 	setPriority(int newPriority)</code> -- 更改线程的优先级</p></li>
                                <li><p><code>int 	getPriority()</code> -- 获取线程优先级</p></li>
                                <li><p><code>void 	setName(String name)</code> -- 更改线程的名字</p></li>
                                <li><p><code>String 	getName()</code> -- 获取线程名字</p></li>
                                <li><p><code>long 	getId()</code> -- 获取线程 ID</p></li>
                                <li><p><code>void 	setDaemon(boolean on)</code> --  将该线程标记为守护线程或用户线程</p></li>
                                <li><p><code>boolean 	isDaemon()</code> -- 是否为守护线程</p></li>

                                <li class="group"><p><code>void 	start()</code> --  使该线程开始执行；Java 虚拟机调用该线程的 run 方法</p></li>
                                <li><p><code>void 	run()</code> -- 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回</p></li>
                                <li><p><code>void 	interrupt()</code> -- 中断线程</p></li>
                                <li><p><code>boolean 	isInterrupted()</code> -- 是否已经中断</p></li>
                                <li><p><code>boolean 	isAlive()</code> -- 测试线程是否处于活动状态</p></li>
                                <li><p><code>Thread.State 	getState()</code> -- 返回该线程的状态</p></li>
                                <li><p><code>void 	checkAccess()</code> -- 判定当前运行的线程是否有权修改该线程</p></li>
                                <li><p><code>void 	join()</code> -- 等待该线程终止</p></li>
                                <li><p><code>void 	join(long millis)</code> -- 等待该线程终止的时间最长为 millis 毫秒</p></li>
                                <li><p><code>void 	join(long millis, int nanos)</code> -- 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</p></li>

                                <li class="group"><p><code>ThreadGroup 	getThreadGroup()</code> -- 返回该线程所属的线程组</p></li>
                                <li><p><code>StackTraceElement[] 	getStackTrace()</code> -- 返回一个表示该线程堆栈转储的堆栈跟踪元素数组</p></li>
                                <li><p><code>ClassLoader 	getContextClassLoader()</code> -- 返回该线程的上下文 ClassLoader</p></li>
                                <li><p><code>void 	setContextClassLoader(ClassLoader cl)</code> -- 设置该线程的上下文 ClassLoader</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
public class ThreadGroup implements Thread.UncaughtExceptionHandler {
    public ThreadGroup(String name) {}
    public ThreadGroup(ThreadGroup parent, String name) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/ThreadGroup.html" target="_blank">ThreadGroup</a> 表示一个线程的集合。此外，线程组也可以包含其他线程组。线程组构成一棵树，在树中，除了初始线程组外，每个线程组都有一个父线程组。 </p>
                            <p>允许线程访问有关自己的线程组的信息，但是不允许它访问有关其线程组的父线程组或其他任何线程组的信息。 </p>
                            <ol>

                                <li><p><code>int 	activeCount()</code> -- 返回此线程组中活动线程的估计数。</p></li>
                                <li><p><code>int 	activeGroupCount()</code> -- 返回此线程组中活动线程组的估计数。</p></li>

                                <li class="group"><p><code>int 	enumerate(Thread[] list)</code> -- 把此线程组及其子组中的所有活动线程复制到指定数组中。</p></li>
                                <li><p><code>int 	enumerate(Thread[] list, boolean recurse)</code> -- 把此线程组中的所有活动线程复制到指定数组中。</p></li>
                                <li><p><code>int 	enumerate(ThreadGroup[] list)</code> -- 把对此线程组中的所有活动子组的引用复制到指定数组中。</p></li>
                                <li><p><code>int 	enumerate(ThreadGroup[] list, boolean recurse)</code> -- 把对此线程组中的所有活动子组的引用复制到指定数组中。</p></li>

                                <li class="group"><p><code>int 	getMaxPriority()</code> -- 返回此线程组的最高优先级。</p></li>
                                <li><p><code>void 	setMaxPriority(int pri)</code> -- 设置线程组的最高优先级。</p></li>
                                <li><p><code>String 	getName()</code> -- 返回此线程组的名称。</p></li>
                                <li><p><code>ThreadGroup 	getParent()</code> -- 返回此线程组的父线程组。</p></li>
                                <li><p><code>void 	setDaemon(boolean daemon)</code> -- 更改此线程组的后台程序状态。</p></li>
                                <li><p><code>boolean 	isDaemon()</code> -- 测试此线程组是否为一个后台程序线程组。</p></li>
                                <li><p><code>void 	interrupt()</code> -- 中断此线程组中的所有线程。</p></li>
                                <li><p><code>void 	destroy()</code> -- 销毁此线程组及其所有子组。</p></li>
                                <li><p><code>boolean 	isDestroyed()</code> -- 测试此线程组是否已经被销毁。</p></li>
                                <li><p><code>void 	checkAccess()</code> -- 确定当前运行的线程是否有权修改此线程组。</p></li>

                                <li class="group"><p><code>void 	list()</code> -- 将有关此线程组的信息打印到标准输出。</p></li>
                                <li><p><code>boolean 	parentOf(ThreadGroup g)</code> -- 测试此线程组是否为线程组参数或其祖先线程组之一。</p></li>
                                <li><p><code>String 	toString()</code> -- 返回此线程组的字符串表示形式。</p></li>
                                <li><p><code>void 	uncaughtException(Thread t, Throwable e)</code> -- 当此线程组中的线程因为一个未捕获的异常而停止，并且线程没有安装特定 Thread.UncaughtExceptionHandler 时，由 Java Virtual Machine 调用此方法。</p></li>
                            </ol>
                        </div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-String"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">String 相关类</h3>
					</div>
					<div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.lang.String

public final class String implements Serializable, Comparable&lt;String>, CharSequence {
    public String() {}
    public String(String original) {}
    public String(StringBuffer buffer) {}
    public String(StringBuilder builder)

    public String(byte[] bytes) {}
    public String(byte[] bytes, Charset charset) {}
    public String(byte[] bytes, int offset, int length) {}
    public String(byte[] bytes, int offset, int length, Charset charset) {}
    public String(byte[] bytes, int offset, int length, String charsetName) {}
    public String(byte[] bytes, String charsetName) {}

    public String(char[] value) {}
    public String(char[] value, int offset, int count) {}

    public String(int[] codePoints, int offset, int count) {}
}

/** CharSequence 是 char 值的一个可读序列。此接口对许多不同种类的 char 序列提供统一的只读访问。
 *      char 值表示 Unicode 的 Basic Multilingual Plane (BMP字符平面) 或代理项中的一个字符。
 * 此接口不修改 equals 和 hashCode 方法的常规协定。因此，通常未定义比较实现 CharSequence 的两个对象的结果。
 *      每个对象都可以通过一个不同的类实现，而且不能保证每个类能够测试其实例与其他类的实例的相等性。
 *      因此，使用任意 CharSequence 实例作为集合中的元素或映射中的键是不合适的。
 */
public interface CharSequence {
    char charAt(int index); // 返回指定索引的 char 值。
    int length(); // 返回此字符序列的长度。
    CharSequence subSequence(int start, int end); // 返回一个新的 CharSequence，它是此序列的子序列。
    String toString(); // 返回一个包含此序列中字符的字符串，该字符串与此序列的顺序相同。
}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/String.html" target="_blank">String</a> 类代表字符串。Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。</p>
                            <p><a href="docs/docs-java/api/java/lang/String.html" target="_blank">String</a> 在创建之后不能更改。字符串缓冲区支持可变的字符串。</p>
                            <p><a href="docs/docs-java/api/java/lang/String.html" target="_blank">String</a> 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。大小写映射基于 Character 类指定的 Unicode 标准版。 </p>
                            <p>Java 语言提供对字符串串联符号（"+"）以及将其他对象转换为字符串的特殊支持。字符串串联是通过 StringBuilder（或 StringBuffer）类及其 append 方法实现的。字符串转换是通过 toString 方法实现的，该方法由 Object 类定义，并可被 Java 中的所有类继承。</p>
                            <ol>

                                <li class="group"><p><code>static String 	copyValueOf(char[] data)</code> -- 返回指定数组中表示该字符序列的 String。</p></li>
                                <li><p><code>static String 	copyValueOf(char[] data, int offset, int count)</code> -- 返回指定数组中表示该字符序列的 String。</p></li>

                                <li class="group"><p><code>static String 	format(String format, Object... args)</code> -- 格式化字符串，参见: <a href="#java-util-Formatter">Formatter</a></p></li>
                                <li><p><code>static String 	format(Locale l, String format, Object... args)</code> -- 用指定的语言环境格式化字符串，参见: <a href="#java-util-Formatter">Formatter</a></p>
                                    <pre class="brush: java;">
/** 两个格式化方法都是使用 java.util.Formatter 来进行操作的: */
public static String format(String format, Object... args) {
    return new Formatter().format(format, args).toString();
}
</pre>
                                </li>

                                <li class="group"><p><code>static String 	valueOf(boolean b)</code> -- 返回 boolean 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(char c)</code> -- 返回 char 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(char[] data)</code> -- 返回 char 数组参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(char[] data, int offset, int count)</code> -- 返回 char 数组参数的特定子数组的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(double d)</code> -- 返回 double 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(float f)</code> -- 返回 float 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(int i)</code> -- 返回 int 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(long l)</code> -- 返回 long 参数的字符串表示形式。</p></li>
                                <li><p><code>static String 	valueOf(Object obj)</code> -- 返回 Object 参数的字符串表示形式。</p></li>

                                <li class="group"><p><code>static String join(CharSequence delimiter, CharSequence... elements)</code> -- 在 elements 间插入 delimiter，连接成一个 String, JAVA8 添加</p></li>
                                <li><p><code>static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence> elements)</code> -- 同上，JAVA8 添加</p>
                                    <pre class="brush: java;">
String jo = String.join("-", "abc", "def", "hi");
// jo == "abc-def-hi";
</pre>
                                </li>

                                <li class="group"><p><code>int 	length()</code> -- 返回此字符串的长度</p></li>
                                <li><p><code>boolean 	isEmpty()</code> -- 当且仅当 length() 为 0 时返回 true</p></li>
                                <li><p><code>int 	indexOf(int ch)</code> -- 返回指定字符在此字符串中第一次出现处的索引</p></li>
                                <li><p><code>int 	indexOf(int ch, int fromIndex)</code> -- 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索</p></li>
                                <li><p><code>int 	indexOf(String str)</code> -- 返回指定子字符串在此字符串中第一次出现处的索引</p></li>
                                <li><p><code>int 	indexOf(String str, int fromIndex)</code> -- 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</p></li>
                                <li><p><code>int 	lastIndexOf(int ch)</code> -- 返回指定字符在此字符串中最后一次出现处的索引</p></li>
                                <li><p><code>int 	lastIndexOf(int ch, int fromIndex)</code> -- 指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始</p></li>
                                <li><p><code>int 	lastIndexOf(String str)</code> -- 返回指定子字符串在此字符串中最右边出现处的索引</p></li>
                                <li><p><code>int 	lastIndexOf(String str, int fromIndex)</code> -- 指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始</p></li>

                                <li class="group"><p><code>char 	charAt(int index)</code> -- 指定索引处的 char 值</p></li>
                                <li><p><code>int 	codePointAt(int index)</code> -- 返回指定索引处的字符 Unicode 编码, <a href="https://zh.wikibooks.org/wiki/Unicode" target="_blank">Unicode 编码查询</a></p>
                                <pre class="brush: java;">
/** 可从 Unicode 编码查询到以下结果：
 * "陈".codePointAt(0) -- 结果为 38472, 十六进制为 9648
 * "茂".codePointAt(0) -- 结果为 33538, 十六进制为 8302
 */
</pre>
                                </li>
                                <li><p><code>int 	codePointBefore(int index)</code> -- 基本等同于 <code>codePointAt(index - 1)</code></p></li>
                                <li><p><code>int 	offsetByCodePoints(int index, int codePointOffset)</code> -- 返回此 String 中从给定的 index 处偏移 codePointOffset 个代码点的索引</p></li>
                                <li><p><code>int 	codePointCount(int beginIndex, int endIndex)</code> -- 在求 Unicode 非 BMP(<a href="../tips/charset.html">Unicode</a>) 平面字符数目时候使用</p>
                                <pre class="brush: java;">
/** 常用的 UniCode 字符使用一个代码单元就可以表示，但有些辅助字符需要一对代码单元表示
 * 比如整数集合的数学符号 '𝕫', 不是字母 'z', Unicode 代码点是 U+1D56B, 但它的代理单元是 U+D835 和 U+DD6B
 * 如果令字符串 str = "\u1D56B", 而是一个代码点 '\u1D56' 和字符 'B', 它的代码点数是 2，代码单元数也是 2;
 * 但如果令字符 str = "\uD835\uDD6B", str.lenght == 2, str.codePointCount(0, 2) == 1.
 */

// 字面为：“陈茂𝕫”, 是整数集合的数学符号 '𝕫', 不是字母 'z'
String s1 = "\u9648\u8302\uD835\uDD6B";
String s2 = "陈茂𝕫";
log(s1.equals(s2)); // true
log(s1, s2); // 陈茂𝕫
log(s1.codePointCount(0, 4), s2.codePointCount(0, 4)); // 长度为 3
log(s1.length(), s2.length()); // 长度为 4
                                </pre>
                                </li>

                                <li class="group"><p><code>int 	compareTo(String anotherString)</code> --   按字典顺序比较两个字符串</p></li>
                                <li><p><code>int 	compareToIgnoreCase(String str)</code> -- 按字典顺序比较两个字符串，不考虑大小写</p></li>
                                <li><p><code>boolean 	contains(CharSequence s)</code> -- 当且仅当此字符串包含指定的 char 值序列时</p></li>
                                <li><p><code>boolean 	endsWith(String suffix)</code> -- 测试此字符串是否以指定的后缀结束</p></li>
                                <li><p><code>boolean 	startsWith(String prefix)</code> -- 测试此字符串是否以指定的前缀开始</p></li>
                                <li><p><code>boolean 	startsWith(String prefix, int toffset)</code> -- 测试此字符串从指定索引开始的子字符串是否以指定前缀开始</p></li>
                                <li><p><code>boolean 	equals(Object anObject)</code> -- 将此字符串与指定的对象比较</p></li>
                                <li><p><code>boolean 	equalsIgnoreCase(String anotherString)</code> -- 将此 String 与另一个 String 比较，不考虑大小写</p></li>
                                <li><p><code>boolean 	matches(String regex)</code> -- 告知此字符串是否匹配给定的正则表达式,参见： <a href="../regex/regexp-java.html">Regex In Java</a></p></li>
                                <li><p><code>boolean 	regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</code> -- 测试两个字符串区域是否相等</p></li>
                                <li><p><code>boolean 	regionMatches(int toffset, String other, int ooffset, int len)</code> -- 测试两个字符串区域是否相等</p></li>
                                <li><p><code>boolean 	contentEquals(CharSequence cs)</code> -- 将此字符串与指定的 CharSequence 比较</p></li>
                                <li><p><code>boolean 	contentEquals(StringBuffer sb)</code> -- 将此字符串与指定的 StringBuffer 比较</p></li>

                                <li class="group"><p><code>byte[] 	getBytes()</code> --  使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中</p></li>
                                <li><p><code>byte[] 	getBytes(Charset charset)</code> -- 使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组</p></li>
                                <li><p><code>byte[] 	getBytes(String charsetName)</code> -- 使用指定的字符集将此 String 编码为 byte 序列，并存储到一个新的 byte 数组中</p>
                                    <pre class="brush: java;">
/** 可用于将字符串转码，将 iso8895-1 转换为 utf-8 */
String keyword = request.getParameter("key");
keyword = new String(keyword.getBytes("iso8859-1"), "utf-8");
</pre>
                                </li>


                                <li class="group"><p><code>String 	replace(char oldChar, char newChar)</code> -- 用 newChar 替换所有 oldChar，并返回一个新的字符串</p></li>
                                <li><p><code>String 	replace(CharSequence target, CharSequence replacement)</code> -- 用 replacement 替换所有 target，返回新的字符串</p></li>
                                <li><p><code>String 	replaceAll(String regex, String replacement)</code> -- 用 replacement 替换所有匹配给定的正则表达式的子字符串</p></li>
                                <li><p><code>String 	replaceFirst(String regex, String replacement)</code> --  用 replacement 替换匹配给定的正则表达式的第一个子串</p></li>

                                <li class="group"><p><code>String 	toLowerCase()</code> -- 使用默认语言环境的规则将此 String 中的所有字符都转换为小写</p></li>
                                <li><p><code>String 	toLowerCase(Locale locale)</code> -- 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写</p></li>
                                <li><p><code>String 	toUpperCase()</code> -- 使用默认语言环境的规则将此 String 中的所有字符都转换为大写</p></li>
                                <li><p><code>String 	toUpperCase(Locale locale)</code> -- 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写</p></li>

                                <li class="group"><p><code>String[] 	split(String regex)</code> -- 根据给定正则表达式的匹配拆分此字符串</p></li>
                                <li><p><code>String[] 	split(String regex, int limit)</code> -- 同上，但是最多分为 limit 组</p>
                                    <pre class="brush: java;">
String s = "Hello Everyone! Today is Monday!";
for (String s1 : s.split(" ")) {
    log(s1); // {"Hello", "Everyone!", "Today", "is", "Monday!"}
}
for (String s1 : s.split(" ", 2)) {
    log(s1); // {"Hello", "Everyone! Today is Monday!"}
}

// 如果使用正则表达式的特殊字符 .$|()[{^?*+\ 分割，则必须做如下处理，如：
for (String s1 : "One|Two|Three".split("\\|")) {
    log(s1);
}
</pre>
                                </li>

                                <li class="group"><p><code>String 	substring(int beginIndex)</code> -- 返回从 beginIndex 到结尾的新的子串</p></li>
                                <li><p><code>String 	substring(int beginIndex, int endIndex)</code> -- 返回从 beginIndex 到 endIndex 的新的子串</p></li>
                                <li><p><code>CharSequence 	subSequence(int beginIndex, int endIndex)</code> -- 返回从 beginIndex 到 endIndex 的新的子串</p></li>

                                <li class="group"><p><code>String 	intern()</code> -- 类 String 私有地维护一个初始为空的字符串池， 当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。</p>
                                    <pre class="brush: java;">
/** str1.intern() 发现常量池中不存在 “SEUCalvin”，因此指向了 str1。
 *  "SEUCalvin" 在常量池中创建时，也就直接指向了 str1 了。两个都返回 true 就理所当然啦。
 */
String str1 = new String("SEU") + new String("Calvin");
log(str1.intern() == str1, str1 == "SEUCalvin"); // false, false

/** s2 先在常量池中创建了 “MyCalvin”，那么 s3.intern() 当然就直接指向了 s2，你可以去验证它们两个是返回的 true。
 * 后面的 "MyCalvin" 也一样指向 s2。所以谁都不搭理在堆空间中的 s3 了，所以都返回了 false。
 */
String s2 = "MyCalvin"; // 新加的一行代码，其余不变
String s3 = new String("My") + new String("Calvin");
log(s3.intern() == s3, s3 == "SEUCalvin"); // true, true
</pre>
                                </li>
                                <li><p><code>String 	concat(String str)</code> -- 将指定字符串连接到此字符串的结尾，并返回一个新的字符串</p></li>
                                <li><p><code>String 	trim()</code> -- 截去字符串开头和末尾的空白</p></li>
                                <li><p><code>void 	getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code> -- 将字符从此字符串复制到目标字符数组</p></li>
                                <li><p><code>char[] 	toCharArray()</code> -- 将此字符串转换为一个新的字符数组</p></li>
                                <li><p><code>int 	hashCode()</code> -- 返回此字符串的哈希码</p></li>
                                <li><p><code>String 	toString()</code> -- 返回此对象本身</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <pre class="brush: java;">
java.lang.Object
    java.lang.AbstractStringBuilder
        java.lang.StringBuffer
        java.lang.StringBuilder

public final class StringBuffer  extends AbstractStringBuilder implements Serializable, CharSequence {
    public StringBuffer() {} // 构造一个其中不带字符的字符串生成器，初始容量为 16 个字符。
    public StringBuffer(CharSequence seq) {} // 构造一个字符串生成器，包含与指定的 CharSequence 相同的字符。
    public StringBuffer(int capacity) {} //  构造一个其中不带字符的字符串生成器，初始容量由 capacity 参数指定。
    public StringBuffer(String str) {} // 构造一个字符串生成器，并初始化为指定的字符串内容
}

public final class StringBuffer extends AbstractStringBuilder
                                implements java.io.Serializable, CharSequence {
    public StringBuilder() {} // 构造一个其中不带字符的字符串生成器，初始容量为 16 个字符。
    public StringBuilder(CharSequence seq) {} // 构造一个字符串生成器，包含与指定的 CharSequence 相同的字符。
    public StringBuilder(int capacity) {} //  构造一个其中不带字符的字符串生成器，初始容量由 capacity 参数指定。
    public StringBuilder(String str) {} // 构造一个字符串生成器，并初始化为指定的字符串内容
}
</pre>
                            <p><a href="docs/docs-java/api/java/lang/StringBuffer.html" target="_blank">StringBuffer</a> 是线程安全的可变字符序列。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 </p>
                            <p>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。 </p>
                            <p>每个字符串缓冲区都有一定的容量。只要字符串缓冲区所包含的字符序列的长度没有超出此容量，就无需分配新的内部缓冲区数组。如果内部缓冲区溢出，则此容量自动增大。从 JDK 5 开始，为该类补充了一个单个线程使用的等价类，即 StringBuilder。与该类相比，通常应该优先使用 StringBuilder 类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。</p>

                            <p><a href="docs/docs-java/api/java/lang/StringBuilder.html" target="_blank">StringBuilder</a> 提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。 </p>

                            <p>在 StringBuilder 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。append 方法始终将这些字符添加到生成器的末端；而 insert 方法则在指定的点添加字符。 </p>
                            <p>将 StringBuilder 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用 StringBuffer。 </p>

                            <p><a href="docs/docs-java/api/java/lang/StringBuilder.html" target="_blank">StringBuilder</a> 和 <a href="docs/docs-java/api/java/lang/StringBuffer.html" target="_blank">StringBuffer</a> 除了构造方法，其他方法都是来自 AbstractStringBuilder 类，但是二者都简单覆写了: 调用父类处理，并返回自身，如下：</p>
                            <pre class="brush: java;">
/** StringBuffer 都有 synchronized 修饰符，线程安全的 */
@Override
public synchronized StringBuffer append(boolean b) {
    toStringCache = null;
    super.append(b);
    return this;
}

/** StringBuidler 无 synchronized 修饰符，单线程操作，速度较快 */
@Override
public StringBuffer append(boolean b) {
    toStringCache = null;
    super.append(b);
    return this;
}

...
</pre>
                            <ol>

                                <li><p><code>StringBuffer / StringBuilder 	append(boolean/char/char[]/CharSequence/double/float/int/long/Object/String/StringBuffer b)</code> -- 添加各种类型到该序列</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	append(char[] str, int offset, int len)</code> -- 偏移 offset 长度为 len 添加到该序列</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	append(CharSequence s, int start, int end)</code> -- 指定 start 和 end 到该序列</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	appendCodePoint(int codePoint)</code> -- 添加 Unicode 代码点表示的字符到该序列</p></li>

                                <li class="group"><p><code>StringBuffer / StringBuilder 	insert(int offset, boolean/char/char[]/CharSequence/double/float/int/long/Object/String b)</code> -- 从指定位置插入到此序列</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	insert(int index, char[] str, int offset, int len)</code> -- 从指定位置插入到此序列</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	insert(int dstOffset, CharSequence s, int start, int end)</code> -- 从指定位置插入到此序列</p></li>

                                <li class="group"><p><code>StringBuffer / StringBuilder 	delete(int start, int end)</code> -- 删除指定索引 start 到 end 的串</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	deleteCharAt(int index)</code> -- 删除指定索引字符</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	replace(int start, int end, String str)</code> -- 替换指定索引 start 到 end 的为 str</p></li>
                                <li><p><code>StringBuffer / StringBuilder 	reverse()</code> -- 反转字符串</p></li>


                                <li class="group"><p><code>String 	substring(int start)</code> -- 指定 start 到结尾的子串</p></li>
                                <li><p><code>String 	substring(int start, int end)</code> -- 指定 start 到 end 的子串</p></li>
                                <li><p><code>CharSequence 	subSequence(int start, int end)</code> -- 指定索引 start 到 end 子序列</p></li>
                                <li><p><code>String 	toString()</code> -- 转为 String</p></li>

                                <li class="group"><p><code>int 	indexOf(String str)</code> -- 子串位置</p></li>
                                <li><p><code>int 	indexOf(String str, int fromIndex)</code> -- 从指定的索引开始，子串位置</p></li>
                                <li><p><code>int 	lastIndexOf(String str)</code> -- 返回指定字符在此字符串中最后一次出现处的索引</p></li>
                                <li><p><code>int 	lastIndexOf(String str, int fromIndex)</code> -- 从指定的索引开始，最后一次出现处的索引</p></li>
                                <li><p><code>int 	length()</code> -- 返回此字符串的长度</p></li>

                                <li class="group"><p><code>int 	capacity()</code> -- 返回容量大小，容量大小会根据使用的量动态添加</p></li>
                                <li><p><code>void 	ensureCapacity(int minimumCapacity)</code> -- 设置容量至少等于指定的最小值</p></li>
                                <li><p><code>char 	charAt(int index)</code> -- 指定索引出字符</p></li>
                                <li><p><code>void 	setCharAt(int index, char ch)</code> -- 更改指定索引出字符</p></li>
                                <li><p><code>void 	setLength(int newLength)</code> -- 使用 '\0' 填充其空的容量</p></li>
                                <li><p><code>void 	trimToSize()</code> -- 将未使用的容量去除(不是去除空白，调用此方法后，<code>capacity() == length()</code>)</p></li>
                                <li><p><code>void 	getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code> -- 复制到 dst 中</p></li>

                                <li class="group"><p><code>int 	codePointAt(int index)</code> -- 同 String 同名方法</p></li>
                                <li><p><code>int 	codePointBefore(int index)</code> -- 同 String 同名方法</p></li>
                                <li><p><code>int 	codePointCount(int beginIndex, int endIndex)</code> -- 同 String 同名方法</p></li>
                                <li><p><code>int 	offsetByCodePoints(int index, int codePointOffset)</code> -- 同 String 同名方法</p></li>
                            </ol>


                        </div>


					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-lang-Math"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Math</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
public final class Math {
    // 比任何其他值都更接近 e（即自然对数的底数）的 double 值, e 的值为 n 接近无穷大时： e = Math.pow(1 + 1 / n, n)
    public static final double E = 2.7182818284590452354;
    // 比任何其他值都更接近 pi（即圆的周长与直径之比）的 double 值
    public static final double PI = 3.14159265358979323846;
}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/Math.html" target="_blank">Math</a> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p>
                        <p>默认情况下，很多 Math 方法仅调用 StrictMath 中的等价方法来完成它们的实现，而这些函数方法在 StrictMath 里面的形式是调用本地的非 Java 代码的接口。建议代码生成器使用特定于平台的本机库或者微处理器指令（可用时）来提供 Math 方法更高性能的实现。这种更高性能的实现仍然必须遵守 Math 的规范。 </p>
                        <ol>
                            <li><p><code>static double 	max(double a, double b)</code> -- 返回两个 double 值中较大的一个。</p></li>
                            <li><p><code>static float 	max(float a, float b)</code> -- 返回两个 float 值中较大的一个。</p></li>
                            <li><p><code>static int 	max(int a, int b)</code> -- 返回两个 int 值中较大的一个。</p></li>
                            <li><p><code>static long 	max(long a, long b)</code> -- 返回两个 long 值中较大的一个。</p></li>
                            <li><p><code>static double 	min(double a, double b)</code> -- 返回两个 double 值中较小的一个。</p></li>
                            <li><p><code>static float 	min(float a, float b)</code> -- 返回两个 float 值中较小的一个。</p></li>
                            <li><p><code>static int 	min(int a, int b)</code> -- 返回两个 int 值中较小的一个。</p></li>
                            <li><p><code>static long 	min(long a, long b)</code> -- 返回两个 long 值中较小的一个。</p></li>

                            <li class="group"><p><code>static double 	abs(double a)</code> -- 返回 double 值的绝对值。</p></li>
                            <li><p><code>static float 	abs(float a)</code> -- 返回 float 值的绝对值。</p></li>
                            <li><p><code>static int 	abs(int a)</code> -- 返回 int 值的绝对值。</p></li>
                            <li><p><code>static long 	abs(long a)</code> -- 返回 long 值的绝对值。</p></li>

                            <li class="group"><p><code>static double 	signum(double d)</code> -- 返回参数的符号函数；如果参数为 0，则返回 0；如果参数大于 0，则返回 1.0；如果参数小于 0，则返回 -1.0。</p></li>
                            <li><p><code>static float 	signum(float f)</code> -- 返回参数的符号函数；如果参数为 0，则返回 0；如果参数大于 0，则返回 1.0；如果参数小于 0，则返回 -1.0。</p></li>

                            <li class="group"><p><code>static double 	floor(double a)</code> -- 返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。</p></li>
                            <li><p><code>static double 	ceil(double a)</code> -- 返回最小的（最接近负无穷大）double 值，该值大于等于参数，并等于某个整数。</p></li>
                            <li><p><code>static double 	rint(double a)</code> -- 返回最接近参数并等于某一整数的 double 值。</p></li>
                            <li><p><code>static long 	round(double a)</code> -- 返回最接近参数的 long。</p></li>
                            <li><p><code>static int 	round(float a)</code> -- 返回最接近参数的 int。</p>
                                <pre class="brush: java;">
/** floor -- 总是往负无穷大方向舍取，如: floor(3.9) = 3.0, floor(-3.1) = -4.0
 * ceil -- 和 floor 相反，总是往正无穷大方向舍取，如: ceil(3.9) = 4.0, ceil(-3.1) = -3.0
 * rint -- 四舍五入，如：rint(3.1) = 3.0, rint(3.5) = 4.0, rint(-3.1) = 3.0, rint(-3.5) = -4.0
 * round -- 舍入同 rint 函数，返回 int 或 long，如： round(3.1) = 3, round(-3.1) = 3
 */
</pre>
                            </li>

                            <li class="group"><p><code>static double 	pow(double a, double b)</code> -- 返回第一个参数的第二个参数次幂的值。</p></li>
                            <li><p><code>static double 	sqrt(double a)</code> -- 返回正确舍入的 double 值的正平方根。</p></li>
                            <li><p><code>static double 	cbrt(double a)</code> -- 返回 double 值的立方根。</p></li>
                            <li><p><code>static double 	hypot(double x, double y)</code> -- 返回 sqrt(x2 +y2)，没有中间溢出或下溢。</p></li>

                            <li class="group"><p><code>static double 	toDegrees(double angrad)</code> -- 将用弧度表示的角转换为近似相等的用角度表示的角。</p></li>
                            <li><p><code>static double 	toRadians(double angdeg)</code> -- 将用角度表示的角转换为近似相等的用弧度表示的角。</p>
                                <pre class="brush: java;">
Math.toDegrees(Math.PI * 30 / 180) ~= 30;
Math.toDegrees(Math.PI * 45 / 180) ~= 45;

Math.toRadians(30) ~= Math.PI * 30 / 180;
Math.toRadians(45) ~= Math.PI * 45 / 180;
</pre>
                            </li>

                            <li><p><code>static double 	sin(double a)</code> -- 返回角的三角正弦。</p></li>
                            <li><p><code>static double 	cos(double a)</code> -- 返回角的三角余弦。</p></li>
                            <li><p><code>static double 	tan(double a)</code> -- 返回角的三角正切。</p>
                                <pre class="brush: java;">
sin(30°) == Math.sin(Math.PI * 30 / 180) ~= 1 / 2
sin(45°) == Math.sin(Math.PI * 45 / 180) ~= 1 / sqrt(2)
cos(60°) == Math.cos(Math.PI * 60 / 180) ~= 1 / 2
cos(45°) == Math.cos(Math.PI * 45 / 180) ~= 1 / sqrt(2)
tan(30°) == Math.tan(Math.PI * 30 / 180) ~= 1 / sqrt(3)
tan(45°) == Math.tan(Math.PI * 45 / 180) ~= 1
</pre>
                            </li>

                            <li><p><code>static double 	asin(double a)</code> -- 返回一个值的反正弦；返回的角度范围在 -pi/2 到 pi/2 之间。</p></li>
                            <li><p><code>static double 	acos(double a)</code> -- 返回一个值的反余弦；返回的角度范围在 0.0 到 pi 之间。</p></li>
                            <li><p><code>static double 	atan2(double y, double x)</code> -- 同 atan(double), 参数为 y 边长 和 x 边长</p></li>
                            <li><p><code>static double 	atan(double a)</code> -- 返回一个值的反正切；返回的角度范围在 -pi/2 到 pi/2 之间。</p>
                                <pre class="brush: java;">
asin(30°) ~= Math.PI * 30 / 180, sin(30°) == Math.sin(Math.PI * 30 / 180)
acos(60°) ~= Math.PI * 60 / 180, cos(60°) == Math.cos(Math.PI * 60 / 180)
atan(30°) ~= atan2(1, Math.sqrt(3)) ~= Math.PI * 30 / 180, tan(30°) == Math.tan(Math.PI * 30 / 180)
</pre>
                            </li>

                            <li><p><code>static double 	sinh(double x)</code> -- 返回 x 值的双曲线正弦，x 的双曲正弦被定义为 <code>(e<sup>x</sup> - e<sup>-x</sup>) / 2</code>, e 为自然对数</p></li>
                            <li><p><code>static double 	cosh(double x)</code> -- 返回 x 值的双曲线余弦，x 的双曲余弦被定义为 <code>(e<sup>x</sup> + e<sup>-x</sup>) / 2</code>, e 为自然对数</p></li>
                            <li><p><code>static double 	tanh(double x)</code> -- 返回 x 值的双曲线正切，x 的双曲正切被定义为 <code>(e<sup>x</sup> - e<sup>-x</sup>) / (e<sup>x</sup> + e<sup>-x</sup>)</code>, e 为自然对数</p>
                                <pre class="brush: java;">
sinh(x) == (Math.pow(Math.E, x) - Math.pow(Math.E, -x)) / 2
cosh(x) == (Math.pow(Math.E, x) + Math.pow(Math.E, -x)) / 2
tanh(x) == (Math.pow(Math.E, x) - Math.pow(Math.E, -x)) / (Math.pow(Math.E, x) + Math.pow(Math.E, -x))
</pre>
                            </li>


                            <li class="group"><p><code>static double 	exp(double x)</code> -- 返回 e^x</p></li>
                            <li><p><code>static double 	expm1(double x)</code> -- 返回 e^x - 1</p></li>
                            <li><p><code>static double 	log(double a)</code> -- 返回 a 值的自然对数（底数是 e）。</p></li>
                            <li><p><code>static double 	log10(double a)</code> -- 返回 a 值的底数为 10 的对数。</p></li>
                            <li><p><code>static double 	log1p(double x)</code> -- 返回参数与 1 之和的自然对数。</p></li>
                            <li><p><code>static int 	getExponent(double d)</code> -- 返回 d 表示形式中使用的无偏差指数(d 是 2 的 x 次方，不管符号，余数和小数)</p></li>
                            <li><p><code>static int 	getExponent(float f)</code> -- 返回 f 表示形式中使用的无偏差指数(d 是 2 的 x 次方，不管符号，余数和小数)</p>
                                <pre class="brush: java;">
Math.getExponent(8) == 3
Math.getExponent(-8) == 3
Math.getExponent(9) == 3

double m = Math.pow(Math.E, 3);
Math.log(m) == Math.log1p(m - 1) == 3.0
</pre>
                            </li>

                            <li class="group"><p><code>static double 	nextUp(double d)</code> -- 返回 d 和正无穷大之间与 d 相邻的浮点值。</p></li>
                            <li><p><code>static float 	nextUp(float f)</code> -- 返回 f 和正无穷大之间与 f 相邻的浮点值。</p></li>
                            <li><p><code>static double 	nextDown(double d)</code> -- 返回 d 和负无穷大之间与 d 相邻的浮点值。</p></li>
                            <li><p><code>static float 	nextDown(float f)</code> -- 返回 f 和负无穷大之间与 f 相邻的浮点值。</p></li>
                            <li><p><code>static double 	nextAfter(double start, double direction)</code> -- 返回 start 和 direction 间与第一个参数相邻的浮点数。</p></li>
                            <li><p><code>static float 	nextAfter(float start, double direction)</code> -- 返回 start 和 direction 间与第一个参数相邻的浮点数。</p>
                                <pre class="brush: java;">
float f = 3.14f;
double d = 3.14;
Math.nextUp(f) == 3.1400003; // 比 f 稍大但是接近 f 的浮点值
Math.nextUp(d) == 3.1400000000000006; // 比 d 稍大但是接近 d 的 double 值
Math.nextDown(f) == 3.1399999; // 比 f 稍小但是接近 f 的浮点值
Math.nextDown(d) == 3.1399999999999997; // 比 d 稍小但是接近 d 的 double 值

/* 如果 direction > start, 则相当于 nextUp;
 * 如果 direction < start, 则相当于 nextDown;
 */
nextAfter(double start, double direction);
</pre>
                            </li>


                            <li class="group"><p><code>static double 	random()</code> -- 返回随机正的 double 值，该值大于等于 0.0 且小于 1.0。</p></li>
                            <li><p><code>static double 	IEEEremainder(double f1, double f2)</code> -- 按照 IEEE 754 标准的规定，对两个参数进行余数运算，返回为 <code>f1 - f2 * Math.rint(f1 / f2)</code></p></li>
                            <li><p><code>static double 	copySign(double magnitude, double sign)</code> -- 返回带有第二个浮点参数符号的第一个浮点参数。</p></li>
                            <li><p><code>static float 	copySign(float magnitude, float sign)</code> -- 返回带有第二个浮点参数符号的第一个浮点参数。</p></li>

                            <li><p><code>static double 	scalb(double d, int scaleFactor)</code> -- 返回 <code>d × 2^scaleFactor</code>，其舍入方式如同将一个正确舍入的浮点值乘以 double 值集合中的一个值。</p></li>
                            <li><p><code>static float 	scalb(float f, int scaleFactor)</code> -- 返回 <code>f × 2^scaleFactor</code>，其舍入方式如同将一个正确舍入的浮点值乘以 float 值集合中的一个值。</p></li>

                            <li><p><code>static double 	ulp(double d)</code> -- 返回一个数字和距其最近的数字之间的距离</p></li>
                            <li><p><code>static float 	ulp(float f)</code> -- 返回一个数字和距其最近的数字之间的距离</p>
                                <pre class="brush: java;">
在计算机中，float(32 位) 和 double(64 位) 都是固定长度的，一个数字和另外一个数字间，所有的数字是有限的。
比如： 1.0001f 和 1.00012f 间，假设计算机能表示的数字为 10232332(乱写的)，那么，ulp = 1.0 / 10232332.
                                </pre>
                            </li>
                        </ol>
                    </div>
                </div>
                <!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Number"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Number 及子类</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.lang.Number

public abstract class Number implements java.io.Serializable {
    byte byteValue() {
        return (byte)intValue();
    }

    short shortValue() {
        return (short)intValue();
    }
    abstract int intValue();
    abstract long longValue();
    abstract float floatValue();
    abstract double doubleValue();
}
						</pre>
                        <p>抽象类 <a href="docs/docs-java/api/java/lang/Number.html" target="_blank">Number</a> 是 BigDecimal、BigInteger、Byte、Double、Float、Integer、Long 和 Short 类的超类。 </p>
                        <p><a href="docs/docs-java/api/java/lang/Number.html" target="_blank">Number</a> 的子类必须提供将表示的数值转换为 byte、double、float、int、long 和 short 的方法。 </p>

                        <ul>
                            <li><p><a href="docs/docs-java/api/java/lang/Byte.html" target="_blank">Byte</a> 类将基本类型 byte 的值包装在一个对象中。一个 Byte 类型的对象只包含一个类型为 byte 的字段。</p>
                                <p>此外，该类还为 byte 和 String 的相互转换提供了几种方法，并提供了处理 byte 时非常有用的其他一些常量和方法。 </p>
                                <pre class="brush: java;">
public final class Byte extends Number implements Comparable&lt;Byte> {
    public static byte MAX_VALUE = 127; // 保存 byte 类型可取的最大值，即 2^7 - 1
    public static byte MIN_VALUE = -128; // 保存 byte 类型可取的最小值，即 -2^7
    public static int 	SIZE = 8; // byte 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

    static byte parseByte(String s) {} // 默认 10 进制转换
    /** radix 为指定进制:
     * log(Byte.parseByte("100"), Byte.parseByte("100", 2), Byte.parseByte("1A", 16));
     * 输出为: 100, 4, 26
     */
    static byte parseByte(String s, int radix) {}

	/** decode 接受 10 进制 16 进制， 8 进制数据
	 * log(Byte.decode("100"), Byte.decode("0x1A"), Byte.decode("#1A"), Byte.decode("010"));
	 * 输出为: 100, 26, 26, 8
	 */
    static Byte decode(String nm) {}

	/** 调用 parseByte 方法 */
    static Byte valueOf(byte b) {}
    static Byte valueOf(String s) {}
    static Byte valueOf(String s, int radix) {}

	static int compare(byte x, byte y) {} // reurn x - y;
	static int toUnsignedInt(byte x) {} // 转为无符号整型
	static long toUnsignedLong(byte x) {} // 转为无符号长整型
}
</pre>
                            </li>
                            <li><p><a href="docs/docs-java/api/java/lang/Short.html" target="_blank">Short</a> 类在对象中包装基本类型 short 的值。一个 Short 类型的对象只包含一个 short 类型的字段。 </p>
								<pre class="brush: java;">
public final class Short extends Number implements Comparable&lt;Short> {
    public static final short MAX_VALUE = 32767; // 最大值的常量，最大值为 2^15 - 1
	public static final short MIN_VALUE = -32768; // 最小值的常量，最小值为 -2^15
	public static final int SIZE = 16; // short 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

	// 低字节和高字节二进制互换位置
	static byte reverseBytes(byte i) {}

	// 以下方法同 Byte 类似
	static int compare(short x, short y) {}
	static int toUnsignedInt(short x)
	static long toUnsignedLong(short x)
	static Short decode(String nm) {}
	static short parseShort(String s) {}
	static short parseShort(String s, int radix) {}
	static Short valueOf(short s) {}
	static Short valueOf(String s) {}
	static Short valueOf(String s, int radix) {}
}
</pre>
							</li>
                            <li><p><a href="docs/docs-java/api/java/lang/Integer.html" target="_blank">Integer</a> 类在对象中包装了一个基本类型 int 的值。Integer 类型的对象包含一个 int 类型的字段。 </p>
								<pre class="brush: java;">
public final class Short extends Number implements Comparable&lt;Short> {
    public static final int MAX_VALUE = 0x7fffffff; // 最大值的常量，最大值为 2^31 - 1, 即： 2147483647
	public static final int MIN_VALUE = 0x80000000; // 最小值的常量，最小值为 -2^31，即： -2147483648
	public static final int SIZE = 32; // int 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

	static int 	compareUnsigned(int x, int y) {} // 无符号 x - y
	static int 	divideUnsigned(int x, int y) {} // 无符号 x / y
	static int remainderUnsigned(int x, int y) {} // 无符号 x % y
	static int 	max(int a, int b) {} // 返回较大值
	static int 	min(int a, int b) {} // 返回较小值
	static int 	sum(int a, int b) {} // 返回 a + b

	static Integer getInteger(String nm) {} // 获取系统属性的 int 值
	static Integer getInteger(String nm, int val) {} // 获取系统属性的 int 值, 为空则返回 val
	static Integer getInteger(String nm, Integer val) {} // 获取系统属性的 int 值, 为空则返回 val

	static int bitCount(int i) {} // 二进制形式表示后 '1' 的数量，和数大小无关
	static int highestOneBit(int i) {} // 二进制形式最高为为 '1' 表示的整数，highestOneBit(0x60) == 64
	static int lowestOneBit(int i) {} // 二进制形式最低为为 '1' 表示的整数，lowestOneBit(0x60) == 32
	static int numberOfLeadingZeros(int i) {} // 二进制形式从左往右有多少个连续的 '0'
	static int numberOfTrailingZeros(int i) {} // 二进制形式从右往左有多少个连续的 '0'

	static int reverse(int i) {} // 同 reverseBytes 区别为此方法二进制从右往左的值，按位不是按字节
	static int rotateLeft(int i, int b) {} // 二进制左移 b 位，左边会移动到右边，若 b 为 32 倍数，值将不变
	static int rotateRight(int i, int b) {} // 二进制右移 b 位，右边会移动到左边，若 b 为 32 倍数，值将不变
	static int signum(int i) {} // 返回 1 为正， -1 为负

	static String toBinaryString(int i) {} // 二进制形式
	static String toHexString(int i) {} // 八进制形式
	static String toOctalString(int i) {} // 十六进制形式

	static int parseUnsignedInt(String s) {} // 同 paseInt(String), 无符号整型
	static int parseUnsignedInt(String s, int radix) {} // 同 paseInt(String, int), 无符号整型


	// 其它方法同 Short 类似
	...
}
</pre>
							</li>
                            <li><p><a href="docs/docs-java/api/java/lang/Long.html" target="_blank">Long</a> 类在对象中包装了基本类型 long 的值。每个 Long 类型的对象都包含一个 long 类型的字段。 </p>
								<pre class="brush: java;">
/** long 类型在数字后加 'L' 表示， 如： 100L */
public final class Long extends Number implements Comparable&lt;Long> {
	public static final int MAX_VALUE = 0x7fffffffffffffffL; // 最大值的常量，最大值为 2^63 - 1
	public static final int MIN_VALUE = 0x8000000000000000L; // 最小值的常量，最小值为 -2^63
	public static final int SIZE = 64; // int 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

	/** Long 的方法和 Integer 都是类似的 */
}
</pre>
							</li>
                            <li><p><a href="docs/docs-java/api/java/lang/Float.html" target="_blank">Float</a> 类在对象中包装一个基本类型 float 的值，在不超出范围情况下，<b>其精度只有小数点后面 6 位，第 7 位可能为舍入的</b>。Float 类型的对象包含一个 float 类型的字段。 </p>
								<p><b>一个浮点数有 2 部分组成：底数 和 指数</b></p>
								<ul>
									<li><p>底数 -- 使用二进制数来表示此浮点数的实际值，但是最高位始终为 1，所以，最高位省去不存储，在存储中占 23 bit</p></li>
									<li><p>指数 -- 占用 8 bit 的二进制数，可表示数值范围为 0-255。</p></li>
								</ul>
								<p><b>float 类型在内存中的表示：</b></p>
								<pre class="brush: java;">
SEEEEEEE EMMMMMMM MMMMMMMM MMMMMMMM
S: 符号位
E: 指数位，实际指数加上 127(2^7-1) 后的值后得二进制数据
M: 底数位，IEEE 794 规定最高位始终为 1，所以，最高位省去不存储

实例： 17.625 在内存中的表示形式
1.整数部分直接换算程二进制： 10001
2.小数部分使用乘 2 取整法：
	2.1 首先给小数部分乘 2，得到的数，如果小数点前为 1，则计 1；为 0，则计 0；
	2.2 再对剩下的小数部分乘 2，再计出 1 或 0；
	2.3 重复以上步骤，直至达到需要的精度。
		0.625 x 2 = 1.25   	--- 计为 1
		0.25 x 2 = 0.5      --- 计为 0
        0.5 x 2 = 1.0       --- 计为 1
		... 如果还有尾数，算到需要的精度为止(最多只有23 bit)
3.得到的形式为: 10001.101
4.再将 10001.101 右移，直到小数点前只剩 1 位(IEEE 794 规定)，最终移动了 4 位： 1.0001101 * 2^4
5.此时，得到了底数和指数：
	5.1 指数部分要加上 127，即 4 + 127 = 131，二进制表示为： 1000 0011
	5.2 底数部分为： 1.0001101
6.符号为正，底数最高位不存储(IEEE 794 规定)，因此表示如下：
	SEEEEEEE EMMMMMMM MMMMMMMM MMMMMMMM
	01000001 10001101 00000000 00000000
</pre>
								<pre class="brush: java;">
/** float 类型在数字后加 'f' 表示， 如： 1.0f */
public final class Float extends Number implements Comparable&lt;Float> {
	public static final int SIZE = 32; // int 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

	public static final float NaN = 0.0f / 0.0f; // 保存 float 类型的非数字 (NaN) 值的常量
	public static final float POSITIVE_INFINITY = 1.0f / 0.0f; // 保存 float 类型的正无穷大值的常量
	public static final float NEGATIVE_INFINITY = -1.0f / 0.0f; // 保存 float 类型的负无穷大值的常量

	public static final int MAX_EXPONENT = 127; // 有限 float 变量可能具有的最大指数
	public static final int MIN_EXPONENT = -126; // 标准化 float 变量可能具有的最小指数

	public static final float MAX_VALUE = 0x1.fffffeP+127f; // 最大正有限值，即 (2-2^23) · 2^127
	public static final float MIN_NORMAL = 0x1.0p-126f; // float 类型最小正标准值，即 2^-126
	public static final float MIN_VALUE = 0x0.000002P-126f; // float 类型最小正非零值，即 2^-149

	static boolean isNaN(float v) {} // 如果指定的数是一个非数字 (NaN) 值，则返回 true
	static boolean isInfinite(float v) {} // 如果指定数的数值是无穷大，则返回 true

	/** Float 只支持 10 进制 / 16 的转换，浮点数的 16 进制为 toHexString(String) 的结果 */
	static float Float.parseFloat(String s) {}

	/** 返回 float 参数的十六进制字符串表示形式，可以通过 parseFloat 转换为浮点数
	 *  1.如果参数为NaN，那么结果是字符串 "NaN";
	 *  2.如果符号为负，那么结果的第一个字符是 "-",为正则不显示；
	 *  3.如果 f 为无穷大，则用字符串 "Infinity" 表示，负无穷大生成结果 "-Infinity";
	 *  4.如果 f 为 0，则用字符串 "0x0.0p0" 表示，因此，负 0 生成结果 "-0x0.0p0";
	 *  5.如果是有效浮点数，形式为：0x1.MpE(M 用于表示有效底数，E 用于表示偏移指数) 则需要计算：
	 *     5.1 前缀不变，为: 0x1.
	 * 	   5.2 先将浮点书转为二进制表示形式，如： 10.5 二进制为: 0100 0001 0010 1000 0000 0000 0000 0000
	 * 	   5.3 先计算指数 E:
	 *         5.3.1 取出二进制指数位(第 2 位开始取 8 位):  100 0001 0 = 130
     * 		   5.3.2 减去 127, 130 - 127 = 3，即 E = 3(如果浮点数 < 1.0，此值就为负)
     *     5.4 计算底数 M
     *         5.4.1 取出二进制底数位(第 10 位开始): 010 1000 0000 0000 0000 0000
     * 	       5.4.2 去除左右的 '0', 10 1 = 5
     *     5.5 最终结果为： 0x1.5p3
	 */
	static String toHexString(float f) {}

	/** 要明白下面的方法，首先明白一点，float 和 int 的二进制都是 32 位，在二进制范围无区别
	 * 因此，一个 32 位的二进制，可以用 int 表示，也可以用 float 表示，下面的方法就是相互转化
	 */
	static float intBitsToFloat(int bits) {} // 将 int 表示的二进制转化为 float 类型
	static int floatToIntBits(float value) {} // 将浮点数的二进制转化为 int 值
	static int floatToRawIntBits(float value) {} // 将浮点数的二进制转化为 int 值，不压缩 NaN 值
}
</pre>
							</li>
                            <li><p><a href="docs/docs-java/api/java/lang/Double.html" target="_blank">Double</a> 类在对象中包装一个基本类型 double 的值，在不超出范围情况下，<b>其精度只有小数点后面 15 位，第 16 位可能为舍入的</b>。每个 Double 类型的对象都包含一个 double 类型的字段。 </p>
								<p><b>一个 Double 有 2 部分组成：底数 和 指数</b></p>
								<ul>
									<li><p>底数 -- 使用二进制数来表示此 Double 的实际值，但是最高位始终为 1，所以，最高位省去不存储，在存储中占 52 bit</p></li>
									<li><p>指数 -- 占用 11 bit 的二进制数，可表示数值范围为 0-1023。</p></li>
								</ul>
								<p><b>float 类型在内存中的表示：</b></p>
								<pre class="brush: java;">
SEEEEEEE EEEEMMMM MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
S: 符号位
E: 指数位，实际指数加上 1023(2^10-1) 后的值后得二进制数据
M: 底数位，IEEE 794 规定最高位始终为 1，所以，最高位省去不存储
</pre>
								<pre class="brush: java;">
/** Double 的方法和 Float 都是类似的
 * Double 类型使用 64 位存储，因此对应 Long 类型
 */
public final class Double extends Number implements Comparable&lt;Double> {
	public static final int SIZE = 64; // int 值的二进制位数
	public static final int BYTES = SIZE / Byte.SIZE; // 字节数

	public static final double NaN = 0.0d / 0.0; // 保存 double 类型的非数字 (NaN) 值的常量
	public static final double POSITIVE_INFINITY = 1.0 / 0.0; // 保存 double 类型的正无穷大值的常量
	public static final double NEGATIVE_INFINITY = -1.0 / 0.; // 保存 double 类型的负无穷大值的常量

	public static final int MAX_EXPONENT = 1023; // 有限 double 变量可能具有的最大指数
	public static final int MIN_EXPONENT = -1022; // 标准化 double 变量可能具有的最小指数

	public static final double MAX_VALUE = 0x1.fffffffffffffP+1023;; // 最大正有限值
	public static final double MIN_NORMAL = 0x1.0p-1022; // double 类型最小正标准值
	public static final double MIN_VALUE = 0x0.0000000000001P-1022;; // double 类型最小正非零值

	static double longBitsToDouble(long bits) {} // 将 long 表示的二进制转化为 double 类型
	static long doubleToLongBits(double value) {} // 将 double 的二进制转化为 long 值
	static long doubleToRawLongBits(double value) {} // 将 double 的二进制转化为 long 值，不压缩 NaN 值
}
</pre>
							</li>
							<li><p><a href="docs/docs-java/api/java/math/BigInteger.html" target="_blank">java.math.BigInteger</a> 不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 BigInteger（如 Java 的基本整数类型）。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 </p>
								<pre class="brush: java;">
public class BigInteger extends Number implements Comparable&lt;BigInteger> {
	public static final BigInteger ONE = valueOf(1); // BigInteger 的常量 1
	public static final BigInteger TEN = valueOf(10); // BigInteger 的常量 10
	public static final BigInteger ZERO = new BigInteger(new int[0], 0); // BigInteger 的常量 0

	/** 将 BigInteger 的十进制字符串表示形式转换为 BigInteger */
	public BigInteger(String val) {}
	/** 将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger */
	public BigInteger(String val, int radix) {}
	/** 将包含 BigInteger 的二进制补码表示形式的 byte 数组转换为 BigInteger */
	public BigInteger(byte[] val) {}
	/** 将 BigInteger 的符号-数量表示形式转换为 BigInteger */
	public BigInteger(int signum, byte[] magnitude) {}
	/** 构造一个随机生成的正 BigInteger，它可能是一个具有指定 bitLength 的素数 */
	public BigInteger(int bitLength, int certainty, Random rnd) {}
	/** 构造一个随机生成的 BigInteger，它是在 0 到 (2numBits - 1)（包括）范围内均匀分布的值 */
	public BigInteger(int numBits, Random rnd) {}
}
</pre>
								<ol>
									<li><p><code>static BigInteger 	valueOf(long val)</code> -- 返回其值等于指定 long 的值的 BigInteger</p></li>
									<li><p><code>static BigInteger 	probablePrime(int bitLength, Random rnd)</code> -- 返回有可能是素数的、具有指定长度的正 BigInteger</p></li>

                                    <li class="group"><p><code>BigInteger 	add(BigInteger val)</code> -- 返回其值为 (this + val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	subtract(BigInteger val)</code> -- 返回其值为 (this - val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	multiply(BigInteger val)</code> -- 返回其值为 (this * val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	divide(BigInteger val)</code> -- 返回其值为 (this / val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	remainder(BigInteger val)</code> -- 返回其值为 (this % val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	negate()</code> -- 返回其值是 (-this) 的 BigInteger。</p></li>

                                    <li class="group"><p><code>BigInteger 	and(BigInteger val)</code> -- 返回其值为 (this & val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	or(BigInteger val)</code> -- 返回其值为 (this | val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	not()</code> -- 返回其值为 (~this) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	xor(BigInteger val)</code> -- 返回其值为 (this ^ val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	andNot(BigInteger val)</code> -- 返回其值为 (this & ~val) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	shiftLeft(int n)</code> -- 返回其值为 (this << n) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	shiftRight(int n)</code> -- 返回其值为 (this >> n) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger[] 	divideAndRemainder(BigInteger val)</code> -- 返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。</p></li>

                                    <li class="group"><p><code>int 	bitLength()</code> -- 返回此 BigInteger 的最小的二进制补码表示形式的位数，不包括符号位。</p></li>
                                    <li><p><code>int 	bitCount()</code> -- 返回此 BigInteger 的二进制补码表示形式中与符号不同的位的数量。</p></li>
                                    <li><p><code>BigInteger 	clearBit(int n)</code> -- 返回其值与清除了指定位的此 BigInteger 等效的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	setBit(int n)</code> -- 返回其值与设置了指定位的此 BigInteger 等效的 BigInteger。</p></li>
                                    <li><p><code>boolean 	testBit(int n)</code> -- 当且仅当设置了指定的位时，返回 true。</p></li>
                                    <li><p><code>int 	getLowestSetBit()</code> -- 返回此 BigInteger 最右端（最低位）1 比特的索引（即从此字节的右端开始到本字节中最右端 1 比特之间的 0 比特的位数）。</p></li>
                                    <li><p><code>BigInteger 	flipBit(int n)</code> -- 返回其值与对此 BigInteger 进行指定位翻转后的值等效的 BigInteger。</p></li>

                                    <li class="group"><p><code>BigInteger 	abs()</code> -- 返回其值是此 BigInteger 的绝对值的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	max(BigInteger val)</code> -- 返回此 BigInteger 和 val 的最大值。</p></li>
                                    <li><p><code>BigInteger 	min(BigInteger val)</code> -- 返回此 BigInteger 和 val 的最小值。</p></li>
                                    <li><p><code>BigInteger 	mod(BigInteger m)</code> -- 返回其值为 (this mod m) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	modInverse(BigInteger m)</code> -- 返回其值为 (this^-1 mod m) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	modPow(BigInteger exponent, BigInteger m)</code> -- 返回其值为 (thisexponent mod m) 的 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	pow(int exponent)</code> -- 返回其值为 (thisexponent) 的 BigInteger。</p></li>

                                    <li class="group"><p><code>int 	intValue()</code> -- 将此 BigInteger 转换为 int。</p></li>
                                    <li><p><code>long 	longValue()</code> -- 将此 BigInteger 转换为 long。</p></li>
                                    <li><p><code>float 	floatValue()</code> -- 将此 BigInteger 转换为 float。</p></li>
                                    <li><p><code>double 	doubleValue()</code> -- 将此 BigInteger 转换为 double。</p></li>
                                    <li><p><code>int 	signum()</code> -- 返回此 BigInteger 的正负号函数。</p></li>

                                    <li class="group"><p><code>BigInteger 	gcd(BigInteger val)</code> -- 返回一个 BigInteger，其值是 abs(this) 和 abs(val) 的最大公约数。</p></li>
                                    <li><p><code>boolean 	isProbablePrime(int certainty)</code> -- 如果此 BigInteger 可能为素数，则返回 true，如果它一定为合数，则返回 false。</p></li>
                                    <li><p><code>BigInteger 	nextProbablePrime()</code> -- 返回大于此 BigInteger 的可能为素数的第一个整数。</p></li>

                                    <li class="group"><p><code>int 	hashCode()</code> -- 返回此 BigInteger 的哈希码。</p></li>
                                    <li><p><code>boolean 	equals(Object x)</code> -- 比较此 BigInteger 与指定的 Object 的相等性。</p></li>
                                    <li><p><code>int 	compareTo(BigInteger val)</code> -- 将此 BigInteger 与指定的 BigInteger 进行比较。</p></li>
                                    <li><p><code>String 	toString()</code> -- 返回此 BigInteger 的十进制字符串表示形式。</p></li>
                                    <li><p><code>byte[] 	toByteArray()</code> -- 返回一个 byte 数组，该数组包含此 BigInteger 的二进制补码表示形式。</p></li>
                                    <li><p><code>String 	toString(int radix)</code> -- 返回此 BigInteger 的给定基数的字符串表示形式。</p></li>
								</ol>
							</li>
                            <li><p><a href="docs/docs-java/api/java/math/BigDecimal.html" target="_blank">java.math.BigDecimal</a> 不可变的、任意精度的有符号十进制数。由任意精度的整数非标度值 和 32 位的整数标度 (scale) 组成。如果为零或正数，则标度是小数点后的位数。如果为负数，则将该数的非标度值乘以 10 的负 scale 次幂。</p>
								<p>BigDecimal 类提供以下操作：算术、标度操作、舍入、比较、哈希算法和格式转换。toString() 方法提供 BigDecimal 的规范表示形式。 </p>
                                <p>BigDecimal 类使用户能完全控制舍入行为。如果未指定舍入模式，并且无法表示准确结果，则抛出一个异常；否则，通过向该操作提供适当的 MathContext 对象，可以对已选择的精度和舍入模式执行计算。在任何情况下，可以为舍入控制提供八种舍入模式。</p>
								<pre class="brush: java;">
public class BigDecimal extends Number implements Comparable&lt;BigDecimal> {
    /** 舍入远离零的舍入模式 */
    public final static int ROUND_UP =           0;
    /** 接近零的舍入模式 */
    public final static int ROUND_DOWN =         1;
    /** 接近正无穷大的舍入模式 */
    public final static int ROUND_CEILING =      2;
    /** 接近负无穷大的舍入模式 */
    public final static int ROUND_FLOOR =        3;
    /** 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式 */
    public final static int ROUND_HALF_UP =      4;
    /** 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式 */
    public final static int ROUND_HALF_DOWN =    5;
    /** 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入 */
    public final static int ROUND_HALF_EVEN =    6;
    /** 断言请求的操作具有精确的结果，因此不需要舍入 */
    public final static int ROUND_UNNECESSARY =  7;

    /** 将 BigInteger 转换为 BigDecimal */
    public BigDecimal(BigInteger val) {}
    /** 将 BigInteger 非标度值和 int 标度转换为 BigDecimal */
    public BigDecimal(BigInteger unscaledVal, int scale) {}
    /** 将 BigInteger 非标度值和 int 标度转换为 BigDecimal（根据上下文设置进行舍入） */
    public BigDecimal(BigInteger unscaledVal, int scale, MathContext mc) {}
    /** 将 BigInteger 转换为 BigDecimal（根据上下文设置进行舍入） */
    public BigDecimal(BigInteger val, MathContext mc) {}
    /** 将 BigDecimal 的字符数组表示形式转换为 BigDecimal，接受与 BigDecimal(String) 构造方法相同的字符序列 */
    public BigDecimal(char[] in) {}
    /** 将 BigDecimal 的字符数组表示形式转换为 BigDecimal，接受与 BigDecimal(String) 构造方法相同的字符序列，
     * 同时允许指定子数组 */
    public BigDecimal(char[] in, int offset, int len) {}
    /** 将 BigDecimal 的字符数组表示形式转换为 BigDecimal，接受与 BigDecimal(String) 构造方法相同的字符序列，
     * 同时允许指定子数组，并根据上下文设置进行舍入 */
    public BigDecimal(char[] in, int offset, int len, MathContext mc) {}
    /** 将 BigDecimal 的字符数组表示形式转换为 BigDecimal，接受与 BigDecimal(String) 构造方法相同的字符序列
     *（根据上下文设置进行舍入） */
    public BigDecimal(char[] in, MathContext mc) {}
    /** 将 double 转换为 BigDecimal，后者是 double 的二进制浮点值准确的十进制表示形式 */
    public BigDecimal(double val) {}
    /** 将 double 转换为 BigDecimal（根据上下文设置进行舍入） */
    public BigDecimal(double val, MathContext mc) {}
    /** 将 int 转换为 BigDecimal */
    public BigDecimal(int val) {}
    /**  将 int 转换为 BigDecimal（根据上下文设置进行舍入） */
    public BigDecimal(int val, MathContext mc) {}
    /** 将 long 转换为 BigDecimal */
    public BigDecimal(long val) {}
    /** 将 long 转换为 BigDecimal（根据上下文设置进行舍入） */
    public BigDecimal(long val, MathContext mc) {}
    /** 将 BigDecimal 的字符串表示形式转换为 BigDecimal */
    public BigDecimal(String val) {}
    /** 将 BigDecimal 的字符串表示形式转换为 BigDecimal，接受与 BigDecimal(String) 构造方法相同的字符串
     * （按照上下文设置进行舍入） */
    public BigDecimal(String val, MathContext mc) {}
}
</pre>
								<ol>
                                    <li><p><code>static BigDecimal 	valueOf(double val)</code> -- 使用 Double.toString(double) 方法提供的 double 规范的字符串表示形式将 double 转换为 BigDecimal。</p></li>
                                    <li><p><code>static BigDecimal 	valueOf(long val)</code> -- 将 long 值转换为具有零标度的 BigDecimal。</p></li>
                                    <li><p><code>static BigDecimal 	valueOf(long unscaledVal, int scale)</code> -- 将 long 非标度值和 int 标度转换为 BigDecimal。</p></li>


                                    <li class="group"><p><code>BigDecimal 	add(BigDecimal augend)</code> -- 返回一个 BigDecimal，其值为 (this + augend)，其标度为 max(this.scale(), augend.scale())。</p></li>
                                    <li><p><code>BigDecimal 	add(BigDecimal augend, MathContext mc)</code> -- 返回其值为 (this + augend) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	subtract(BigDecimal subtrahend)</code> -- 返回一个 BigDecimal，其值为 (this - subtrahend)，其标度为 max(this.scale(), subtrahend.scale())。</p></li>
                                    <li><p><code>BigDecimal 	subtract(BigDecimal subtrahend, MathContext mc)</code> -- 返回其值为 (this - subtrahend) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	multiply(BigDecimal multiplicand)</code> -- 返回一个 BigDecimal，其值为 (this × multiplicand)，其标度为 (this.scale() + multiplicand.scale())。</p></li>
                                    <li><p><code>BigDecimal 	multiply(BigDecimal multiplicand, MathContext mc)</code> -- 返回其值为 (this × multiplicand) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	plus()</code> -- 返回 BigDecimal，其值为 (+this)，其标度为 this.scale()。</p></li>
                                    <li><p><code>BigDecimal 	plus(MathContext mc)</code> -- 返回其值为 (+this) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	negate()</code> -- 返回 BigDecimal，其值为 (-this)，其标度为 this.scale()。</p></li>
                                    <li><p><code>BigDecimal 	negate(MathContext mc)</code> -- 返回其值为 (-this) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	remainder(BigDecimal divisor)</code> -- 返回其值为 (this % divisor) 的 BigDecimal。</p></li>
                                    <li><p><code>BigDecimal 	remainder(BigDecimal divisor, MathContext mc)</code> -- 返回其值为 (this % divisor) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>

                                    <li class="group"><p><code>BigDecimal 	divide(BigDecimal divisor)</code> -- 返回一个 BigDecimal，其值为 (this / divisor)，其首选标度为 (this.scale() - divisor.scale())；如果无法表示准确的商值（因为它有无穷的十进制扩展），则抛出 ArithmeticException。</p></li>
                                    <li><p><code>BigDecimal 	divide(BigDecimal divisor, int roundingMode)</code> -- 返回一个 BigDecimal，其值为 (this / divisor)，其标度为 this.scale()。</p></li>
                                    <li><p><code>BigDecimal 	divide(BigDecimal divisor, int scale, int roundingMode)</code> -- 返回一个 BigDecimal，其值为 (this / divisor)，其标度为指定标度。</p></li>
                                    <li><p><code>BigDecimal 	divide(BigDecimal divisor, int scale, RoundingMode roundingMode)</code> -- 返回一个 BigDecimal，其值为 (this / divisor)，其标度为指定标度。</p></li>
                                    <li><p><code>BigDecimal 	divide(BigDecimal divisor, MathContext mc)</code> -- 返回其值为 (this / divisor) 的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	divide(BigDecimal divisor, RoundingMode roundingMode)</code> -- 返回一个 BigDecimal，其值为 (this / divisor)，其标度为 this.scale()。</p></li>
                                    <li><p><code>BigDecimal[] 	divideAndRemainder(BigDecimal divisor)</code> -- 返回由两个元素组成的 BigDecimal 数组，该数组包含 divideToIntegralValue 的结果，后跟对两个操作数计算所得到的 remainder。</p></li>
                                    <li><p><code>BigDecimal[] 	divideAndRemainder(BigDecimal divisor, MathContext mc)</code> -- 返回由两个元素组成的 BigDecimal 数组，该数组包含 divideToIntegralValue 的结果，后跟根据上下文设置对两个操作数进行舍入计算所得到的 remainder 的结果。</p></li>
                                    <li><p><code>BigDecimal 	divideToIntegralValue(BigDecimal divisor)</code> -- 返回 BigDecimal，其值为向下舍入所得商值 (this / divisor) 的整数部分。</p></li>
                                    <li><p><code>BigDecimal 	divideToIntegralValue(BigDecimal divisor, MathContext mc)</code> -- 返回 BigDecimal，其值为 (this / divisor) 的整数部分。</p>
										<pre class="brush:java;">
BigDecimal b1 = BigDecimal.valueOf(Math.PI); // 3.141592653589793
BigDecimal b2 = BigDecimal.valueOf(1.0);
b1.divide(b2) == 3.141592653589793;
b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP) == 3.14; // 指定精度和舍入模式
</pre>
									</li>

                                    <li class="group"><p><code>int 	intValue()</code> -- 将此 BigDecimal 转换为 int。</p></li>
                                    <li><p><code>int 	intValueExact()</code> -- 将此 BigDecimal 转换为 int，以检查丢失的信息。</p></li>
                                    <li><p><code>byte 	byteValueExact()</code> -- 将此 BigDecimal 转换为 byte，以检查丢失的信息。</p></li>
                                    <li><p><code>long 	longValue()</code> -- 将此 BigDecimal 转换为 long。</p></li>
                                    <li><p><code>long 	longValueExact()</code> -- 将此 BigDecimal 转换为 long，以检查丢失的信息。</p></li>
                                    <li><p><code>float 	floatValue()</code> -- 将此 BigDecimal 转换为 float。</p></li>
                                    <li><p><code>double 	doubleValue()</code> -- 将此 BigDecimal 转换为 double。</p></li>

                                    <li class="group"><p><code>BigDecimal 	abs()</code> -- 返回 BigDecimal，其值为此 BigDecimal 的绝对值，其标度为 this.scale()。</p></li>
                                    <li><p><code>BigDecimal 	abs(MathContext mc)</code> -- 返回其值为此 BigDecimal 绝对值的 BigDecimal（根据上下文设置进行舍入）。</p></li>
                                    <li><p><code>BigDecimal 	max(BigDecimal val)</code> -- 返回此 BigDecimal 和 val 的最大值。</p></li>
                                    <li><p><code>BigDecimal 	min(BigDecimal val)</code> -- 返回此 BigDecimal 和 val 的最小值。</p></li>
                                    <li><p><code>BigDecimal 	pow(int n)</code> -- 返回其值为 (thisn) 的 BigDecimal，准确计算该幂，使其具有无限精度。</p></li>
                                    <li><p><code>BigDecimal 	pow(int n, MathContext mc)</code> -- 返回其值为 (thisn) 的 BigDecimal。</p></li>
                                    <li><p><code>BigDecimal 	round(MathContext mc)</code> -- 返回根据 MathContext 设置进行舍入后的 BigDecimal。</p></li>

                                    <li class="group"><p><code>BigDecimal 	movePointLeft(int n)</code> -- 返回一个 BigDecimal，它等效于将该值的小数点向左移动 n 位。</p></li>
                                    <li><p><code>BigDecimal 	movePointRight(int n)</code> -- 返回一个 BigDecimal，它等效于将该值的小数点向右移动 n 位。</p></li>
                                    <li><p><code>BigDecimal 	scaleByPowerOfTen(int n)</code> -- 返回其数值等于 (this * 10n) 的 BigDecimal。</p></li>
                                    <li><p><code>BigDecimal 	setScale(int newScale)</code> -- 返回一个 BigDecimal，其标度为指定值，其值在数值上等于此 BigDecimal 的值。</p></li>
                                    <li><p><code>BigDecimal 	setScale(int newScale, int roundingMode)</code> -- 返回一个 BigDecimal，其标度为指定值，其非标度值通过此 BigDecimal 的非标度值乘以或除以十的适当次幂来确定，以维护其总值。</p></li>
                                    <li><p><code>BigDecimal 	setScale(int newScale, RoundingMode roundingMode)</code> -- 返回 BigDecimal，其标度为指定值，其非标度值通过此 BigDecimal 的非标度值乘以或除以十的适当次幂来确定，以维护其总值。</p></li>
                                    <li><p><code>short 	shortValueExact()</code> -- 将此 BigDecimal 转换为 short，以检查丢失的信息。</p></li>
                                    <li><p><code>BigDecimal 	stripTrailingZeros()</code> -- 返回数值上等于此小数，但从该表示形式移除所有尾部零的 BigDecimal。</p></li>

                                    <li class="group"><p><code>BigInteger 	toBigInteger()</code> -- 将此 BigDecimal 转换为 BigInteger。</p></li>
                                    <li><p><code>BigInteger 	toBigIntegerExact()</code> -- 将此 BigDecimal 转换为 BigInteger，以检查丢失的信息。</p></li>

                                    <li class="group"><p><code>int 	signum()</code> -- 返回此 BigDecimal 的正负号函数。</p></li>
                                    <li><p><code>int 	precision()</code> -- 返回此 BigDecimal 的精度。</p></li>
                                    <li><p><code>int 	scale()</code> -- 返回此 BigDecimal 的标度。</p></li>
                                    <li><p><code>BigDecimal 	ulp()</code> -- 返回此 BigDecimal 的 ulp（最后一位的单位）的大小。</p></li>
                                    <li><p><code>BigInteger 	unscaledValue()</code> -- 返回其值为此 BigDecimal 的非标度值 的 BigInteger。</p></li>

                                    <li class="group"><p><code>String 	toString()</code> -- 返回此 BigDecimal 的字符串表示形式，如果需要指数，则使用科学记数法。</p></li>
                                    <li><p><code>String 	toPlainString()</code> -- 返回不带指数字段的此 BigDecimal 的字符串表示形式。</p></li>
                                    <li><p><code>String 	toEngineeringString()</code> -- 返回此 BigDecimal 的字符串表示形式，需要指数时，则使用工程计数法。</p></li>
                                    <li><p><code>int 	compareTo(BigDecimal val)</code> -- 将此 BigDecimal 与指定的 BigDecimal 比较。</p></li>
                                    <li><p><code>boolean 	equals(Object x)</code> -- 比较此 BigDecimal 与指定的 Object 的相等性。</p></li>
                                    <li><p><code>int 	hashCode()</code> -- 返回此 BigDecimal 的哈希码。</p></li>
								</ol>
							</li>
                            <li><p><a href="docs/docs-java/api/java/util/concurrent/atomic/AtomicInteger.html" target="_blank">java.util.concurrent.atomic.AtomicInteger</a> 可以用原子方式更新的 int 值，可用在应用程序中（如以原子方式增加的计数器），并且不能用于替换 Integer。但是，此类确实扩展了 Number，允许那些处理基于数字类的工具和实用工具进行统一访问。</p>
								<p><a href="docs/docs-java/api/java/util/concurrent/atomic/AtomicLong.html" target="_blank">java.util.concurrent.atomic.AtomicLong</a> 可以用原子方式更新的 long 值，可用在应用程序中（如以原子方式增加的序列号），并且不能用于替换 Long。但是，此类确实扩展了 Number，允许那些处理基于数字类的工具和实用工具进行统一访问。 </p>
								<pre class="brush: java;">
public class AtomicInteger extends Number implements Serializable {
    public AtomicInteger() {}
    public AtomicInteger(int initialValue) {}
}

public class AtomicLong extends Number implements Serializable {
    public AtomicLong() {}
    public AtomicLong(long initialValue) {}
}
</pre>
                                <ol>
                                    <li><p><code>int/long 	incrementAndGet()</code> -- 以原子方式将当前值加 1。</p></li>
                                    <li><p><code>int/long 	decrementAndGet()</code> -- 以原子方式将当前值减 1。</p></li>
                                    <li><p><code>int/long 	getAndDecrement()</code> -- 以原子方式将当前值减 1。</p></li>
                                    <li><p><code>int/long 	getAndIncrement()</code> -- 以原子方式将当前值加 1。</p></li>

                                    <li class="group"><p><code>int/long 	addAndGet(int/long delta)</code> -- 以原子方式将给定值与当前值相加。</p></li>
                                    <li><p><code>int/long 	getAndAdd(int/long delta)</code> -- 以原子方式将给定值与当前值相加。</p></li>
                                    <li><p><code>int/long 	getAndSet(int/long newValue)</code> -- 以原子方式设置为给定值，并返回旧值。</p></li>
                                    <li><p><code>int/long 	get()</code> -- 获取当前值。</p></li>
                                    <li><p><code>void 	set(int/long newValue)</code> -- 设置为给定值。</p></li>
                                    <li><p><code>void 	lazySet(int/long newValue)</code> -- 最后设置为给定值。</p></li>
                                    <li><p><code>String 	toString()</code> -- 返回当前值的字符串表示形式。</p></li>
                                    <li><p><code>boolean 	compareAndSet(int/long expect, int/long update)</code> -- 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。</p></li>
                                    <li><p><code>boolean 	weakCompareAndSet(int/long expect, int/long update)</code> -- 如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。</p></li>

                                    <li class="group"><p><code>int 	intValue()</code> -- 以 int 形式返回指定的数值。</p></li>
                                    <li><p><code>long 	longValue()</code> -- 以 long 形式返回指定的数值。</p></li>
                                    <li><p><code>float 	floatValue()</code> -- 以 float 形式返回指定的数值。</p></li>
                                    <li><p><code>double 	doubleValue()</code> -- 以 double 形式返回指定的数值。</p></li>

                                </ol>
							</li>
                        </ul>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Exception"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Exception 和 Error</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">
public class Throwable implements Serializable {
    public Throwable() {}
    public Throwable(String message) {}
    public Throwable(String message, Throwable cause) {}
    public Throwable(Throwable cause) {}
    protected Throwable(String message, Throwable cause, boolean enableSuppression,
                            boolean writableStackTrace) {}
}
</pre>
                        <p><a href="docs/docs-java/api/java/lang/Throwable.html" target="_blank">Throwable</a> 是 Java 语言中所有错误或异常的超类。只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。类似地，只有此类或其子类之一才可以是 catch 子句中的参数类型。 </p>
                        <p>两个子类的实例，<a href="docs/docs-java/api/java/lang/Error.html" target="_blank">Error</a> 和 <a href="docs/docs-java/api/java/lang/Exception.html" target="_blank">Exception</a>，通常用于指示发生了异常情况。通常，这些实例是在异常情况的上下文中新近创建的，因此包含了相关的信息（比如堆栈跟踪数据）。 </p>
                        <ul>
                            <li><p><a href="docs/docs-java/api/java/lang/Exception.html" target="_blank">Exception</a> -- 类及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。</p></li>
                            <li><p><a href="docs/docs-java/api/java/lang/Error.html" target="_blank">Error</a> -- 是 Throwable 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。虽然 ThreadDeath 错误是一个“正规”的条件，但它也是 Error 的子类，因为大多数应用程序都不应该试图捕获它。 </p></li>
                        </ul>
                        <p><b>Throwable</b> API:</p>
                        <ol>
                            <li><p><code>Throwable 	getCause()</code> -- 返回此 throwable 的 cause；如果 cause 不存在或未知，则返回 null。</p></li>
                            <li><p><code>String 	getLocalizedMessage()</code> -- 创建此 throwable 的本地化描述。</p></li>
                            <li><p><code>String 	getMessage()</code> -- 返回此 throwable 的详细消息字符串。</p></li>
                            <li><p><code>StackTraceElement[] 	getStackTrace()</code> -- 提供编程访问由 printStackTrace() 输出的堆栈跟踪信息。</p></li>
                            <li><p><code>void 	setStackTrace(StackTraceElement[] stackTrace)</code> -- 设置将由 getStackTrace() 返回，并由 printStackTrace() 和相关方法输出的堆栈跟踪元素。</p></li>
                            <li><p><code>String 	toString()</code> -- 返回此 throwable 的简短描述。</p></li>

                            <li class="group"><p><code>void 	printStackTrace()</code> -- 将此 throwable 及其追踪输出至标准错误流。</p></li>
                            <li><p><code>void 	printStackTrace(PrintStream s)</code> -- 将此 throwable 及其追踪输出到指定的输出流。</p></li>
                            <li><p><code>void 	printStackTrace(PrintWriter s)</code> -- 将此 throwable 及其追踪输出到指定的 PrintWriter。</p></li>

                            <li class="group"><p><code>void 	addSuppressed(Throwable exception)</code> -- 将指定的异常追加到为传递此异常而被抑制的异常中。</p></li>
                            <li><p><code>Throwable 	fillInStackTrace()</code> -- 在异常堆栈跟踪中填充。</p></li>
                            <li><p><code>Throwable 	initCause(Throwable cause)</code> -- 将此 throwable 的 cause 初始化为指定值。</p></li>
                        </ol>

                        <p><p><a href="docs/docs-java/api/java/lang/Exception.html" target="_blank">Exception</a> 类的常见直接子类和间接子类:</p>
                            <pre class="brush: java;">
java.lang.Object
    java.lang.Throwable
        java.lang.Exception
         ├─ CloneNotSupportedException -- 对象未实现 Cloneable 接口
         ├─ ClassNotFoundException -- 未找到加载的类(使用反射时候发生)
         ├─ NoSuchMethodException -- 无法找到某一特定方法时，抛出该异常(使用反射时候发生)
         ├─ NoSuchFieldException -- 不包含指定名称的字段时产生的信号(使用反射时候发生)
         ├─ InterruptedException -- 当线程在活动之前或活动期间处于正在等待、休眠或占用状态且该线程被中断时，抛出该异常
         ├─ java.net.URISyntaxException -- 经过检查的指示字符串不能解析为 URI
         ├─ java.util.concurrent.TimeoutException -- 阻塞操作超时时
         ├─ java.sql.SQLException -- 数据库访问错误或其他错误信息
         ├─ java.util.zip.DataFormatException -- 当数据格式发生错误时
         └─ RuntimeException -- 可能在 Java 虚拟机正常运行期间抛出的异常的超类
             ├─ IllegalArgumentException -- 异常表明向方法传递了一个不合法或不正确的参数
             │   ├─ NumberFormatException -- 试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时
             │   ├─ PatternSyntaxException -- 表明正则表达式模式中的语法错误
             │   ├─ IllegalCharsetNameException -- 不是合法 charset 名称的字符串用作 charset 名称时
             │   ├─ IllegalFormatException -- 格式字符串包含非法语法，或者包含与给定参数不兼容的格式说明符时
             │   ├─ IllegalThreadStateException -- 指示线程没有处于请求操作所要求的适当状态时抛出的异常
             │   ├─ UnresolvedAddressException -- 试图对未解析的套接字地址调用网络操作时
             │   ├─ UnsupportedAddressTypeException -- 试图绑定或连接到一个其类型不受支持的套接字地址时
             │   └─ UnsupportedCharsetException -- 当不支持请求的 charset 时
             ├─ ArithmeticException -- 当出现异常的运算条件时(比如除以 0)
             ├─ ClassCastException -- 当试图将对象强制转换为不是实例的子类时
             ├─ org.w3c.dom.DOMException -- DOM 操作只在 "exceptional" 情况下引发异常，即不能执行操作时
             ├─ ArrayStoreException -- 将错误类型的对象存储到一个对象数组时
             ├─ IllegalStateException -- 在非法或不适当的时间调用方法时产生的信号
             ├─ IndexOutOfBoundsException -- 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出
             │   ├─ StringIndexOutOfBoundsException -- 常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小
             │   └─ ArrayIndexOutOfBoundsException -- 用非法索引访问数组时
             ├─ NoSuchElementException -- 由 Enumeration 的 nextElement 方法抛出，表明枚举中没有更多的元素
             ├─ NullPointerException -- 在需要对象的地方使用 null 时
             └─ ......
</pre>
                        <p><p><a href="docs/docs-java/api/java/lang/Error.html" target="_blank">Error</a> 类的常见直接子类和间接子类:</p>
                        <pre class="brush: java;">
java.lang.Error
 ├─ AnnotationFormatError -- 当注释解析器试图从类文件读取注释并确定注释出现异常时
 ├─ AssertionError -- 抛出该异常指示某个断言失败
 ├─ ThreadDeath -- 调用 Thread 类中带有零参数的 stop 方法时，受害线程将抛出一个 ThreadDeath 实例
 ├─ java.io.IOError -- 当发生严重的 I/O 错误时，抛出此错误
 ├─ VirtualMachineError -- 当 Java 虚拟机崩溃或用尽了它继续操作所需的资源时
 │   ├─ OutOfMemoryError -- 因为内存溢出或没有可用的内存提供给垃圾回收器时，Java 虚拟机无法分配一个对象
 │   ├─ StackOverflowError -- 当应用程序递归太深而发生堆栈溢出时
 │   ├─ UnknownError -- 当 Java 虚拟机中出现一个未知但严重的异常时
 │   └─ InternalError -- 该异常指示 Java 虚拟机中出现一些意外的内部错误
 └─ LinkageError -- 指示一个类在一定程度上依赖于另一个类；但是，在编译前一个类之后，后一个类发生了不相容的改变
     ├─ ClassFormatError -- 当 Java 虚拟机试图读取类文件并确定该文件存在格式错误或无法解释为类文件时
     │   ├─ GenericSignatureFormatError -- 解释类型、方法或构造方法的一般签名信息的反射方法遇到语法错误的签名属性时
     │   └─ UnsupportedClassVersionError -- 当 Java 虚拟机试图读取一个类文件，并确定文件的主辅版本号不受支持时
     ├─ ClassCircularityError -- 当初始化类时检测到类的循环调用的时候
     ├─ NoClassDefFoundError -- 当 Java 虚拟机或 ClassLoader 实例试图在类的定义中加载，但无法找到该类的定义时
     ├─ VerifyError -- 当“校验器”检测到一个类文件虽然格式正确，但包含着一些内部不一致性或安全性问题时
     ├─ UnsatisfiedLinkError -- 当 Java 虚拟机无法找到声明为 native 的方法的适当本地语言定义时
     ├─ ExceptionInInitializerError -- 静态初始化程序中发生意外异常的信号
     └─ IncompatibleClassChangeError -- 通常由编译器捕获此类错误
         ├─ NoSuchMethodError -- 当应用程序试图调用类（静态或实例）的指定方法，而该类已不再具有该方法的定义时
         ├─ NoSuchFieldError -- 如果应用程序试图访问或修改一个指定的对象字段，而该对象不再包含该字段时
         ├─ AbstractMethodError -- 当应用程序试图使用 Java 的 new 结构来实例化一个抽象类或一个接口时
         ├─ IllegalAccessError -- 当应用程序试图访问或修改它不能访问的字段，或调用它不能访问的方法时
         └─ InstantiationError -- 当应用程序试图调用一个抽象方法时


</pre>
					</div>
				</div>
				<!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-Date"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Date, Calendar, TimeZone</h3>
                    </div>
                    <div class="panel-body">
                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.util.Date

public class Date implements Serializable, Cloneable, Comparable&lt;Date> {
    public Date() { this(System.currentTimeMillis(); }
    public Date(long millis) {}
}
</pre>
                            <p><a href="docs/docs-java/api/java/util/Date.html" target="_blank">Date</a> 表示特定的瞬间，精确到毫秒。</p>
                            <p><a href="docs/docs-java/api/java/util/Date.html" target="_blank">Date</a> 类的很多方法已过时，应该使用 Calendar 类实现日期和时间字段之间转换，使用 java.text.DateFormat 类来格式化和解析日期字符串。</p>
                            <p><a href="docs/docs-java/api/java/util/Date.html" target="_blank">Date</a> 有三个直接子类： <a href="docs/docs-java/api/java/sql/Date.html" target="_blank">java.sql.Date</a>, <a href="docs/docs-java/api/java/sql/Time.html" target="_blank">java.sql.Time</a>, <a href="docs/docs-java/api/java/sql/Timestamp.html" target="_blank">java.sql.Timestamp</a>。</p>
                            <ol>
                                <li><p><code>static Date 	from(<a href="docs/docs-java/api/java/time/Instant.html">Instant</a> instant)</code> -- 从 Instant 转化</p></li>
                                <li><p><code><a href="docs/docs-java/api/java/time/Instant.html">Instant</a> 	toInstant()</code> -- 转化为 Instant</p></li>

                                <li class="group"><p><code>boolean 	after(Date when)</code> -- 测试此日期是否在指定日期之后。</p></li>
                                <li><p><code>boolean 	before(Date when)</code> -- 测试此日期是否在指定日期之前。</p></li>
                                <li><p><code>long 	getTime()</code> -- 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数</p></li>
                                <li><p><code>void 	setTime(long time)</code> -- 设置此 Date 对象，以表示 1970 年 1 月 1 日 00:00:00 GMT 以后 time 毫秒的时间点。</p></li>

                                <li class="group"><p><code>int 	compareTo(Date anotherDate)</code> -- 比较两个日期的顺序。</p></li>
                                <li><p><code>boolean 	equals(Object obj)</code> -- 比较两个日期的相等性。</p></li>
                                <li><p><code>Object 	clone()</code> -- 返回此对象的副本。</p></li>
                                <li><p><code>int 	hashCode()</code> -- 返回此对象的哈希码值</p></li>
                                <li><p><code>String 	toString()</code> -- 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.util.Calendar

public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar> {
    /** Calendar 构造器 */
    public static class Builder {}

    public final static int FIELD_COUNT = 17;
    /** get(int) / set(int, int) 方法使用的常量: */
    public final static int ERA = 0; // 返回 GregorianCalendar.AD(公元后) 或 GregorianCalendar.BC(公元前)
    public final static int YEAR = 1; // 年
    public final static int MONTH = 2; // 月, 0 - 11
    public final static int WEEK_OF_YEAR = 3; // 年的星期数, 1 ~
    public final static int WEEK_OF_MONTH = 4; // 月中的星期数, 1 ~
    public final static int DATE = 5; // 月中的某天, 1 ~
    public final static int DAY_OF_MONTH = 5; // 同 DATE
    public final static int DAY_OF_YEAR = 6; // 年中的天数, 1 ~
    public final static int DAY_OF_WEEK = 7; // 星期中的某天, 1 ~
    // 月中的第几个星期, DAY_OF_MONTH 1 到 7 总是对应于 DAY_OF_WEEK_IN_MONTH 1；依此类推。
    public final static int DAY_OF_WEEK_IN_MONTH = 8;
    public final static int AM_PM = 9; // 上午 / 下午
    public final static int HOUR = 10; // 小时, 12 小时制, 0 ~ 11
    public final static int HOUR_OF_DAY = 11; // 小时, 24 小时制, 0 ~ 23
    public final static int MINUTE = 12; // 分钟, 0 ~ 59
    public final static int SECOND = 13; // 秒数, 0 ~ 59
    public final static int MILLISECOND = 14; // 毫秒, 0 ~ 999
    public final static int ZONE_OFFSET = 15; // 以毫秒为单位指示距 GMT 的大致偏移量
    public final static int DST_OFFSET = 16; // 以毫秒为单位指示夏令时的偏移量

    /** 星期 */
    public final static int SUNDAY = 1;
    public final static int MONDAY = 2;
    public final static int TUESDAY = 3;
    public final static int WEDNESDAY = 4;
    public final static int THURSDAY = 5;
    public final static int FRIDAY = 6;
    public final static int SATURDAY = 7;

    /** 月份 */
    public final static int JANUARY = 0;
    public final static int FEBRUARY = 1;
    public final static int MARCH = 2;
    public final static int APRIL = 3;
    public final static int MAY = 4;
    public final static int JUNE = 5;
    public final static int JULY = 6;
    public final static int AUGUST = 7;
    public final static int SEPTEMBER = 8;
    public final static int OCTOBER = 9;
    public final static int NOVEMBER = 10;
    public final static int DECEMBER = 11;
    public final static int UNDECIMBER = 12; // 一年中第十三个月, 阳历没有使用该值，但阴历会使用

    /** 上午 / 下午 */
    public final static int AM = 0;
    public final static int PM = 1;


    public static final int ALL_STYLES = 0;
    public static final int SHORT = 1;
    public static final int LONG = 2;

    public static final int NARROW_FORMAT = 4;
    public static final int NARROW_STANDALONE = NARROW_FORMAT | STANDALONE_MASK;
    public static final int SHORT_FORMAT = 1;
    public static final int LONG_FORMAT = 2;
    public static final int SHORT_STANDALONE = SHORT | STANDALONE_MASK;
    public static final int LONG_STANDALONE = LONG | STANDALONE_MASK;
}
</pre>
                            <p><a href="docs/docs-java/api/java/util/Calendar.html" target="_blank">Calendar</a> 是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p>
                            <p>Calendar 对象能够生成为特定语言和日历风格实现日期-时间格式化所需的所有日历字段值，例如，日语-格里高里历，日语-传统日历。Calendar 定义了某些日历字段返回值的范围，以及这些值的含义。</p>
                            <p><code>Calendar.getInstance()</code> 方法获取的实例其实是其子类 <a href="docs/docs-java/api/java/util/GregorianCalendar.html" target="_blank">GregorianCalendar</a> 的实例，它提供了世界上大多数国家/地区使用的标准日历系统，是一种混合日历，在单一间断性的支持下同时支持儒略历和格里高利历系统，在默认情况下，它对应格里高利日历创立时的格里高利历日期。</p>
                            <p>在 <code>Calendar.getInstance()</code> 方法中调用了 <a href="docs/docs-java/api/java/util/Calendar.Builder.html" target="_blank">Calendar.Builder</a> 来构建 Calendar, 并传入了 <code>System.currentTimeMillis()</code> 为日历的当前时间，也就是说在构建时，已经确定了时间。</p>
                            <ol>
                                <li><p><code>static Calendar 	getInstance()</code> -- 使用默认时区和语言环境获得一个日历。</p></li>
                                <li><p><code>static Calendar 	getInstance(Locale aLocale)</code> -- 使用默认时区和指定语言环境获得一个日历。</p></li>
                                <li><p><code>static Calendar 	getInstance(TimeZone zone)</code> -- 使用指定时区和默认语言环境获得一个日历。</p></li>
                                <li><p><code>static Calendar 	getInstance(TimeZone zone, Locale aLocale)</code> -- 使用指定时区和语言环境获得一个日历</p></li>

                                <li class="group"><p><code>static Locale[] 	getAvailableLocales()</code> --  返回所有语言环境的数组</p></li>
                                <li><p><code>static Set&lt;String> getAvailableCalendarTypes()</code> -- 返回一个不可修改的集合，包含运行时环境中日历支持的所有类型</p></li>

                                <li class="group"><p><code>int 	get(int field)</code> -- 返回给定日历字段的值，此方法返回 fields[field], fileds 数组长度为: Calendar.FIELD_COUNT ,filed 支持的值看前面常量</p></li>
                                <li><p><code>void 	set(int field, int value)</code> -- 将给定的日历字段设置为给定值</p></li>
								<li><p><code>void 	set(int year, int month, int date)</code> -- 设置日历字段</p></li>
								<li><p><code>void 	set(int year, int month, int date, int hourOfDay, int minute)</code> -- 设置日历字段</p></li>
								<li><p><code>void 	set(int year, int month, int date, int hourOfDay, int minute, int second)</code> -- 设置日历字段</p>
                                    <pre class="brush: java;">
Calendar calendar = Calendar.getInstance();
calendar.set(2018, Calendar.JUNE, 15, 16, 20, 40); // 2018/6/15 16:20:40
calendar.set(Calendar.HOUR_OF_DAY, 17); // 2018/6/15 17:20:40
</pre>
                                </li>


								<li class="group"><p><code>abstract  void 	add(int field, int amount)</code> -- 据日历的规则，为给定的日历字段添加或减去指定的时间量</p></li>
								<li><p><code>abstract  void 	roll(int field, boolean up)</code> -- 在给定的时间字段上添加或减去单个时间单元，不更改更大的字段</p></li>
								<li><p><code>void 	roll(int field, int amount)</code> -- 向指定日历字段添加指定（有符号的）时间量，不更改更大的字段</p>
                                    <pre class="brush: java;">
Calendar calendar = Calendar.getInstance();
calendar.set(2018, Calendar.JUNE, 15, 16, 20, 40); // 2018/6/15 16:20:40

calendar.add(Calendar.SECOND, 5); // 2018/6/15 16:20:45
calendar.add(Calendar.SECOND, -55); // 2018/6/15 16:19:50

/** roll 方法不会更改更大字段，如下：当秒数超出时候，分钟数没变 */
calendar.roll(Calendar.SECOND, 20); // 2018/6/15 16:20:10
calendar.roll(Calendar.SECOND, true); // 2018/6/15 16:19:51
calendar.roll(Calendar.SECOND, false); // 2018/6/15 16:19:50


</pre>
                                </li>

								<li class="group"><p><code>void 	setTimeInMillis(long millis)</code> -- 用给定的 long 值设置此 Calendar 的当前时间值。</p></li>
								<li><p><code>long 	getTimeInMillis()</code> -- 返回此 Calendar 的时间值，以毫秒为单位</p></li>
								<li><p><code>Date 	getTime()</code> -- 返回一个表示此 Calendar 时间值</p></li>
								<li><p><code>void 	setTime(Date date)</code> -- 使用给定的 Date 设置此 Calendar 的时间。</p></li>
								<li><p><code>void 	setTimeZone(TimeZone value)</code> -- 使用给定的时区值来设置时区。</p></li>
								<li><p><code>TimeZone 	getTimeZone()</code> -- 获得时区</p></li>
								<li><p><code>void 	setFirstDayOfWeek(int value)</code> -- 设置一星期的第一天是哪一天；美国(SUNDAY)，法国(MONDAY)</p></li>
								<li><p><code>int 	getFirstDayOfWeek()</code> -- 获取一星期的第一天，美国(SUNDAY)，法国(MONDAY)</p></li>
								<li><p><code>int 	getMinimalDaysInFirstWeek()</code> -- 获取一年中第一个星期所需的最少天数</p></li>
								<li><p><code>void 	setMinimalDaysInFirstWeek(int value)</code> -- 设置一年中第一个星期所需的最少天数，例如，如果定义第一个星期包含一年第一个月的第一天，则使用值 1 调用此方法。</p></li>

								<li class="group"><p><code>String 	getDisplayName(int field, int style, Locale locale)</code> -- 返回给定 style 下的日历 field 值的字符串表示形式</p></li>
								<li><p><code>Map&lt;String, Integer> 	getDisplayNames(int field, int style, Locale locale)</code> -- 返回给定 style 和 locale 下包含日历 field 所有名称的 Map 及其相应字段值</p>
                                    <pre class="brush: java;">
// Month 和 Week 有字符表示形式，指定使用完整写法(Calendar.LONG)或者缩写(Calendar.SHORT)，如: Monday - Mon
calendar.getDisplayName(filed, Calendar.LONG, Locale.getDefault());

/** 返回 field 字段的指定 style 的 Map，比如字段为: DAY_OF_WEEK，不同的 style 返回如下：
 * SHORT -- {"Sun":1, "Mon": 2, ...}
 * LONG -- {"Sunday":1, "Monday": 2, ...}
 * ALL_STYLES -- 以上两个
 */
calendar.getDisplayNames(Calendar.DAY_OF_WEEK, Calendar.ALL_STYLES, Locale.getDefault());
</pre>
                                </li>

								<li class="group"><p><code>abstract  int 	getMaximum(int field)</code> -- 返回此 Calendar 实例给定日历字段的最大值</p></li>
								<li><p><code>abstract  int 	getMinimum(int field)</code> -- 返回此 Calendar 实例给定日历字段的最小值</p></li>
								<li><p><code>abstract  int 	getGreatestMinimum(int field)</code> -- 返回此 Calendar 实例给定日历字段的最高的最小值</p></li>
								<li><p><code>abstract  int 	getLeastMaximum(int field)</code> -- 返回此 Calendar 实例给定日历字段的最低的最大值</p></li>
								<li><p><code>int 	getActualMaximum(int field)</code> -- 给定此 Calendar 的时间值，返回指定日历字段可能拥有的最大值</p></li>
								<li><p><code>int 	getActualMinimum(int field)</code> -- 给定此 Calendar 的时间值，返回指定日历字段可能拥有的最小值</p></li>

								<li class="group"><p><code>boolean 	isLenient()</code> -- 判断日期/时间的解释是否为宽松的</p></li>
								<li><p><code>void 	setLenient(boolean lenient)</code> -- 指定日期/时间解释是否是宽松的。</p></li>
                                <li><p><code>boolean 	isSet(int field)</code> -- 确定给定日历字段是否已经设置了一个值</p></li>

								<li class="group"><p><code>boolean 	after(Object when)</code> -- 判断此 Calendar 表示的时间是否在指定 Object 表示的时间之后，返回判断结果。</p></li>
								<li><p><code>boolean 	before(Object when)</code> -- 判断此 Calendar 表示的时间是否在指定 Object 表示的时间之前，返回判断结果。</p></li>
								<li><p><code>void 	clear()</code> -- 将此 Calendar 的所日历字段值和时间值（从历元至现在的毫秒偏移量）设置成未定义。</p></li>
								<li><p><code>void 	clear(int field)</code> -- 将此 Calendar 的给定日历字段值和时间值（从历元至现在的毫秒偏移量）设置成未定义。</p></li>

								<li class="group"><p><code>int 	compareTo(Calendar anotherCalendar)</code> -- 比较两个 Calendar 对象表示的时间值（从历元至现在的毫秒偏移量）。</p></li>
								<li><p><code>Object 	clone()</code> -- 创建并返回此对象的一个副本。</p></li>
								<li><p><code>boolean 	equals(Object obj)</code> -- 将此 Calendar 与指定 Object 比较。</p></li>
								<li><p><code>String 	toString()</code> -- 返回此日历的字符串表示形式。</p></li>
								<li><p><code>int 	hashCode()</code> -- 哈希值</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
						    <pre class="brush: java;">
java.lang.Object
    java.util.TimeZone

public abstract class TimeZone implements Serializable, Cloneable {
    public static final int SHORT = 0; // 指出短名称的 getDisplayName() 的风格说明符
    public static final int LONG = 1; // 指出长名称的 getDisplayName() 的风格说明符
}
</pre>
                            <p><a href="docs/docs-java/api/java/util/TimeZone.html" target="_blank">TimeZone</a> 表示时区偏移量，也可以计算夏令时。 </p>
                            <p>通常，使用 getDefault 获取 TimeZone，getDefault 基于程序运行所在的时区创建 TimeZone。</p>
                            <ol>
                                <li><p><code>static String[] 	getAvailableIDs()</code> -- 获取受支持的所有可用 ID。</p></li>
                                <li><p><code>static String[] 	getAvailableIDs(int rawOffset)</code> -- 根据给定的时区偏移量（以毫秒为单位）获取可用的 ID。</p></li>
                                <li><p><code>static TimeZone 	getDefault()</code> -- 获取此主机的默认 TimeZone</p></li>
                                <li><p><code>static TimeZone 	getTimeZone(String ID)</code> -- 获取给定 ID 的 TimeZone</p></li>
                                <li><p><code>static TimeZone 	getTimeZone(ZoneId zoneId)</code> -- 获取给定 ZoneId 的 TimeZone</p></li>
                                <li><p><code>static void 	setDefault(TimeZone zone)</code> -- 设置默认的 TimeZone</p></li>

								<li class="group"><p><code>String 	getID()</code> -- 获取此时区的 ID，如："Asia/Shanghai"</p></li>
								<li><p><code>void 	setID(String ID)</code> -- 设置时区 ID</p></li>

                                <li class="group"><p><code>String 	getDisplayName()</code> -- 返回适合于展示给默认区域的用户的时区名称</p></li>
								<li><p><code>String 	getDisplayName(boolean daylight, int style)</code> -- 返回适合于展示给默认区域的用户的时区名称</p></li>
								<li><p><code>String 	getDisplayName(Locale locale)</code> -- 返回适合于展示给指定区域的用户的时区名称</p></li>
								<li><p><code>String 	getDisplayName(boolean daylight, int style, Locale locale)</code> -- 返回适合于展示给指定区域的用户的时区名称</p></li>

								<li class="group"><p><code>int 	getOffset(long date)</code> -- 从给定日期的 UTC 返回此时区的偏移量</p></li>
								<li><p><code>abstract  int 	getOffset(int era, int year, int month, int day, int dayOfWeek, int milliseconds)</code> -- 获取当前日期的时区偏移量</p></li>
								<li><p><code>abstract  void 	setRawOffset(int offsetMillis)</code> -- 把基准时区偏移量设置到 GMT</p></li>
								<li><p><code> abstract  int 	getRawOffset()</code> -- 返回添加到 UTC 以获取此时区中的标准时间的时间量</p></li>

								<li class="group"><p><code>abstract  boolean 	useDaylightTime()</code> -- 查询此时区是否使用夏令时</p></li>
								<li><p><code>abstract  boolean 	inDaylightTime(Date date)</code> -- 查询给定的日期是否在此时区的夏令时中</p>
									<p><b>夏令时</b> -- 是一种为节约能源而人为规定地方时间的制度，在这一制度实行期间所采用的统一时间称为“夏令时间”。</p>
									<p>夏令时具体作法是：每年从四月中旬第一个星期日的凌晨2时整（北京时间），将时钟拨快一小时，即将表针由2时拨至3时，夏令时开始；到九月中旬第一个星期日的凌晨2时整（北京夏令时），再将时钟拨回一小时，即将表针由2时拨至1时，夏令时结束。</p>
								</li>


								<li class="group"><p><code>int 	getDSTSavings()</code> -- 返回要添加到本地标准时间以获取本地挂钟时间的时间量</p></li>
								<li><p><code>boolean 	hasSameRules(TimeZone other)</code> -- 如果此区域和另一个区域具有相同的规则和偏移量</p></li>
								<li><p><code>Object 	clone()</code> -- 创建此 TimeZone 的一个副本</p></li>
                            </ol>
                        </div>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-Timer"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Timer 和 TimerTask</h3>
                    </div>
                    <div class="panel-body">
						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object
	java.util.Timer

public class Timer {
	public Timer() {}
	public Timer(boolean isDaemon) {}
	public Timer(String name) {}
	public Timer(String name, boolean isDaemon) {}
}
</pre>
							<p><a href="docs/docs-java/api/java/util/Timer.html" target="_blank">Timer</a> 是一种工具，线程用其安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行。</p>
							<p>与每个 Timer 对象相对应的是单个后台线程，用于顺序地执行所有计时器任务。计时器任务应该迅速完成。如果完成某个计时器任务的时间太长，那么它会“独占”计时器的任务执行线程。因此，这就可能延迟后续任务的执行，而这些任务就可能“堆在一起”，并且在上述不友好的任务最终完成时才能够被快速连续地执行。 </p>
							<p>对 Timer 对象最后的引用完成后，并且 所有未处理的任务都已执行完成后，计时器的任务执行线程会正常终止（并且成为垃圾回收的对象）。但是这可能要很长时间后才发生。默认情况下，任务执行线程并不作为守护线程 来运行，所以它能够阻止应用程序终止。如果调用者想要快速终止计时器的任务执行线程，那么调用者应该调用计时器的 cancel 方法。 </p>
							<p>如果意外终止了计时器的任务执行线程，例如调用了它的 stop 方法，那么所有以后对该计时器安排任务的尝试都将导致 IllegalStateException，就好像调用了计时器的 cancel 方法一样。 </p>
							<p>此类是线程安全的：多个线程可以共享单个 Timer 对象而无需进行外部同步。 </p>
							<ol>
								<li><p><code>void 	cancel()</code> -- 终止此计时器，丢弃所有当前已安排的任务</p></li>
								<li><p><code>int 	purge()</code> -- 从此计时器的任务队列中移除所有已取消的任务</p></li>
								<li class="group"><p><code>void 	schedule(TimerTask task, long delay)</code> -- 安排在指定延迟后执行指定的任务</p></li>
								<li><p><code>void 	schedule(TimerTask task, long delay, long period)</code> -- 指定的任务从指定的延迟后开始进行重复的固定延迟执行，第一次以 delay 为延迟，后面以 period 为间隔无限重复执行任务</p></li>
								<li><p><code>void 	schedule(TimerTask task, Date time)</code> -- 安排在指定的时间执行指定的任务</p></li>
								<li><p><code>void 	schedule(TimerTask task, Date firstTime, long period)</code> -- 安排指定的任务在指定的时间开始进行重复的固定延迟执行</p></li>
								<li><p><code>void 	scheduleAtFixedRate(TimerTask task, long delay, long period)</code> -- 安排指定的任务在指定的延迟后开始进行重复的固定速率执行，区别在于如果由于任何原因（如垃圾回收或其他后台活动）而延迟了某次执行，则将快速连续地出现两次或更多的执行，从而使后续执行能够“追赶上来”。</p></li>
								<li><p><code>void 	scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</code> -- 安排指定的任务在指定的时间开始进行重复的固定速率执行</p></li>
							</ol>
						</div>

						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object
	java.util.TimerTask

public abstract class TimerTask implements Runnable {
 	protected TimerTask() {}
}
</pre>
							<p><a href="docs/docs-java/api/java/util/TimerTask.html" target="_blank">TimerTask</a> 由 Timer 安排为一次执行或重复执行的任务。</p>
							<ol>
								<li><p><code>boolean 	cancel()</code> -- 取消此计时器任务</p></li>
								<li><p><code>abstract  void 	run()</code> -- 此计时器任务要执行的操作</p></li>
								<li><p><code>long 	scheduledExecutionTime()</code> -- 返回此任务最近实际 执行的已安排 执行时间</p></li>
							</ol>
						</div>
                    </div>
                </div>
                <!-- item over -->

                <a class="offset" id="java-util-List"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">List, Map, Set, Queue, Arrays, Collections...</h3>
                    </div>
                    <div class="panel-body">
						<div class="sub-item">
                            <p><b>Java Collections Framework 结构</b></p>
                            <p>主要包括三大顶级接口：<code>Iterator</code>, <code>Collection</code> 和 <code>Map</code>。基本所有的实现类都继承抽象类 <code>AbstractCollection</code>，数据结构主要分为以下四种: </p>
                            <ul>
                                <li><p><b>List</b> -- 有序的 Collection（也称为序列）；</p></li>
                                <li><p><b>Map</b> -- 将键映射到值的对象；</p></li>
                                <li><p><b>Queue</b> -- 在处理元素前用于保存元素的 Collection(队列)；</p></li>
                                <li><p><b>Set</b> -- 不包含重复元素的 Collection。</p></li>
                            </ul>
                            <p>还有一些用于操作的工具类：<code>Collection</code>, <code>Arrays</code> ...</p>
							<pre class="brush: java; gutter: false;">
Iterator /** 对 Collection 进行迭代的迭代器，Collection 的实现类一般都有内部类实现此接口，并提供了返回 Iterator 的方法 */
 └─ ListIterator /** 系列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置 */

/** 容器接口继承结构和父接口(不包括非容器接口，):
 * java.util.concurrent 包类，在并发编程中很常用的实用工具类，以 * 开头
 * 有两个父接口的只写在深的父接口下，并加 extends 标明，开头加 = 区分 */
Iterable /** 实现这个接口允许对象成为 "foreach" 语句的目标，主要是: Iterator&lt;T> iterator() 方法。 */
 └─ Collection /** Collection 层次结构中的根接口 */
	 ├─ List /** 有序的 Collection（也称为序列） */
     ├─ Queue /** 在处理元素前用于保存元素的 Collection */
	 │	 ├─	Deque /** 一个线性 Collection，支持在两端插入和移除元素 */
	 │	 └─ * BlockingQueue /** 支持两个附加操作的 Queue */
	 │		  └─ *= BlockingDeque extends BlockingQueue, Deque /** 支持两个附加操作的 Queue */
	 └─ Set /** 一个不包含重复元素的 Collection */
		 └─	SortedSet /** 进一步提供关于元素的总体排序 的 Set */
		 	 └─ NavigableSet /** 扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法 */

Map /** 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值 */
 ├─ SortedMap /** 进一步提供关于键的总体排序的 Map */
 │   └─ NavigableMap /** 扩展的 SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法 */
 └─ * ConcurrentMap /** 提供其他原子 putIfAbsent、remove、replace 方法的 Map */
	  └─ *= ConcurrentNavigableMap extends ConcurrentMap, NavigableMap/**递归方式支持子映射的 ConcurrentMap */


/** 容器类继承结构和实现接口(不包括非容器接口): java.util.concurrent 包类，在并发编程中很常用的实用工具类，以 * 开头 */
AbstractCollection implements Collection /** 提供 Collection 接口的骨干实现*/
 ├─	AbstractList implements List /** 提供 List 接口的骨干实现 */
 │	 ├─	AbstractSequentialList /** 链接列表骨干实现(非数组) */
 │	 │	 └─	LinkedList implements List, Deque /** List 接口的链接列表实现 */
 │	 ├─	ArrayList implements List /** 大小可变数组的实现 */
 │	 └─	Vector implements List /** 实现可增长的对象数组，和 ArrayList 相同，但此类是线程安全的 */
 │		 └─	Stack /** 后进先出（LIFO）的对象堆栈 */
 ├─ AbstractSet implements Set /** 提供 Set 接口的骨干实现 */
 │	 ├─	HashSet implements Set /** 实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持 */
 │	 │	 └─	LinkedHashSet implements Set /** 具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现 */
 │	 ├─	TreeSet implements NavigableSet /** 基于 TreeMap 的 NavigableSet 实现 */
 │	 ├─	EnumSet /** 与枚举类型一起使用的专用 Set 实现 */
 │	 ├─	* ConcurrentSkipListSet implements NavigableSet /** 可缩放并发 NavigableSet 实现 */
 │	 └─	* CopyOnWriteArraySet /** 对其所有操作使用内部 CopyOnWriteArrayList 的 Set */
 ├─	AbstractMap implements Map /** 提供 Map 接口的骨干实现 */
 │	 ├─	HashMap implements Map /** 基于哈希表的 Map 接口的实现 */
 │	 │	 └─	LinkedHashMap implements Map /** Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序 */
 │	 ├─	WeakHashMap implements Map /** 以弱键 实现的基于哈希表的 Map */
 │	 ├─	TreeMap implements NavigableMap /** 基于红黑树（Red-Black tree）的 NavigableMap 实现 */
 │	 ├─	EnumMap /** 与枚举类型键一起使用的专用 Map 实现 */
 │	 ├─	IdentityHashMap implements Map /** 利用哈希表实现 Map 接口，比较键（和值）时使用引用相等性代替对象相等性 */
 │	 ├─	* ConcurrentHashMap implements ConcurrentMap /** 支持获取的完全并发和更新的所期望可调整并发的哈希表 */
 │	 └─	* ConcurrentSkipListMap implements ConcurrentNavigableMap /** 可缩放的并发 ConcurrentNavigableMap 实现 */
 ├─	AbstractQueue implements Queue /** 提供某些 Queue 操作的骨干实现 */
 │	 ├─	PriorityQueue /** 一个基于优先级堆的无界优先级队列 */
 │	 ├─	* ArrayBlockingQueue implements BlockingQueue /** 一个由数组支持的有界阻塞队列 */
 │	 ├─	* LinkedBlockingQueue implements BlockingQueue /** 一个基于已链接节点的、范围任意的 BlockingBueue */
 │	 ├─	* LinkedBlockingDeque implements BlockingDeque /** 一个基于已链接节点的、任选范围的阻塞双端队列 */
 │	 ├─	* PriorityBlockingQueue implements BlockingQueue /** 无界阻塞队列，使用与类 PriorityQueue 相同的顺序规则 */
 │	 ├─	* SynchronousQueue implements BlockingQueue /** 阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 */
 │	 ├─	* DelayQueue implements BlockingQueue /** Delayed 元素的一个无界阻塞队列，只有在延迟期满时才能从中提取元素 */
 │	 └─	* ConcurrentLinkedQueue implements Queue /** 一个基于链接节点的无界线程安全队列 */
 ├─	ArrayDeque implements Deque /** Deque 接口的大小可变数组的实现 */
 ├─	* CopyOnWriteArrayList implements List /** ArrayList 的一个线程安全的变体 */
 └─	Dictionary /** 任何可将键映射到相应值的类（如 Hashtable）的抽象父类 */
 	 └─	Hashtable implements Map /** 实现一个哈希表，该哈希表将键映射到相应的值 */
</pre>
						</div>

						<div class="sub-item">
							<p><b><code>Arrays</code>  和 <code>Collections</code> 这两个类提供了许多静态方法操作集合和数组。</b></p>
                            <p><a href="docs/docs-java/api/java/util/Arrays.html" target="_blank">Arrays</a> 包含用来操作数组（比如排序和搜索）的各种方法。此类还包含一个允许将数组作为列表来查看的静态工厂。</p>
                            <ol>


                                <li><p><code>static int 	binarySearch(byte[] a, byte key)</code> -- 使用二分搜索法来搜索指定的数组，以获得指定的值</p></li>
                                <li><p><code>static int 	binarySearch(char[] a, char key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(short[] a, short key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(int[] a, int key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(long[] a, long key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(float[] a, float key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(double[] a, double key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(Object[] a, Object key)</code> -- 同上</p></li>
                                <li><p><code>static &lt;T> int binarySearch(T[] a, T key, Comparator&lt;? super T> c)</code> -- 指定比较器</p></li>

                                <li class="group"><p><code>static int 	binarySearch(byte[] a, int fromIndex, int toIndex, byte key)</code> -- 二分搜索法搜索指定的范围的值</p></li>
                                <li><p><code>static int 	binarySearch(char[] a, int fromIndex, int toIndex, char key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(short[] a, int fromIndex, int toIndex, short key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(int[] a, int fromIndex, int toIndex, int key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(long[] a, int fromIndex, int toIndex, long key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(float[] a, int fromIndex, int toIndex, float key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(double[] a, int fromIndex, int toIndex, double key)</code> -- 同上</p></li>
                                <li><p><code>static int 	binarySearch(Object[] a, int fromIndex, int toIndex, Object key)</code> -- 同上</p></li>
                                <li><p><code>static &lt;T> int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator&lt;? super T> c)</code> -- 指定比较器</p></li>

                                <li class="group"><p><code>static boolean[] 	copyOf(boolean[] original, int newLength)</code> -- 复制使副本具有指定的长度，截取或用 false 填充</p></li>
                                <li><p><code>static byte[] 	copyOf(byte[] original, int newLength)</code> -- 复制，截取或用 0 填充</p></li>
                                <li><p><code>static char[] 	copyOf(char[] original, int newLength)</code> -- 复制，截取或用 空字符 填充</p></li>
                                <li><p><code>static short[] 	copyOf(short[] original, int newLength)</code> --复制，截取或用 0 填充</p></li>
                                <li><p><code>static int[] 	copyOf(int[] original, int newLength)</code> -- 复制，截取或用 0 填充</p></li>
                                <li><p><code>static long[] 	copyOf(long[] original, int newLength)</code> -- 复制，截取或用 0 填充</p></li>
                                <li><p><code>static float[] 	copyOf(float[] original, int newLength)</code> -- 复制，截取或用 0 填充</p></li>
                                <li><p><code>static double[] 	copyOf(double[] original, int newLength)</code> -- 复制，截取或用 0 填充</p></li>
                                <li><p><code>static &lt;T> T[] copyOf(T[] original, int newLength)</code> -- 复制，截取或用 null 填充</p></li>
                                <li><p><code>static &lt;T,U> T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]> newType)</code> -- 复制，截取或用 null 填充</p></li>

                                <li class="group"><p><code>static boolean[] 	copyOfRange(boolean[] original, int from, int to)</code> -- 将指定数组的指定范围复制到一个新数组</p></li>
                                <li><p><code>static byte[] 	copyOfRange(byte[] original, int from, int to)</code> -- 同上</p></li>
                                <li><p><code>static char[] 	copyOfRange(char[] original, int from, int to)</code> -- 同上</p></li>
                                <li><p><code>static short[] 	copyOfRange(short[] original, int from, int to)</code> -- 同上</p></li>
                                <li><p><code>static int[] 	copyOfRange(int[] original, int from, int to)</code> -- 同上</p></li>
                                <li><p><code>static long[] 	copyOfRange(long[] original, int from, int to)</code> -- 同上</p></li>
                                <li><p><code>static float[] 	copyOfRange(float[] original, int from, int to)</code> -- 同上</p></li>
                                <li><p><code>static double[] 	copyOfRange(double[] original, int from, int to)</code> -- 同上</p></li>
                                <li><p><code>static &lt;T> T[] copyOfRange(T[] original, int from, int to)</code> -- 同上</p></li>
                                <li><p><code>static &lt;T,U> T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]> newType)</code> -- 同上</p></li>


                                <li class="group"><p><code>static void 	sort(byte[] a)</code> -- 对 a 数组按数字升序进行排序</p></li>
                                <li><p><code>static void 	sort(char[] a)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(short[] a)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(int[] a)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(long[] a)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(float[] a)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(double[] a)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(Object[] a)</code> -- 根据元素的自然顺序对指定对象数组按升序进行排序</p></li>
                                <li><p><code>static &lt;T> void sort(T[] a, Comparator&lt;? super T> c)</code> -- 根据指定比较器产生的顺序对指定对象数组进行排序</p></li>

                                <li class="group"><p><code>static void 	sort(byte[] a, int fromIndex, int toIndex)</code> -- 对 a 数组的指定范围按数字升序进行排序</p></li>
                                <li><p><code>static void 	sort(char[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(double[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(float[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(int[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(long[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(Object[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
                                <li><p><code>static void 	sort(short[] a, int fromIndex, int toIndex)</code> -- 同上</p></li>
                                <li><p><code>static &lt;T> void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T> c)</code> -- 指定比较器</p></li>

                                <li class="group"><p><code>static void 	fill(boolean[] a, boolean val)</code> -- 将 val 分配给 a 数组的每个元素</p></li>
                                <li><p><code>static void 	fill(byte[] a, byte val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(char[] a, char val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(short[] a, short val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(int[] a, int val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(long[] a, long val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(float[] a, float val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(double[] a, double val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(Object[] a, Object val)</code> -- 同上</p></li>

                                <li class="group"><p><code>static void 	fill(boolean[] a, int fromIndex, int toIndex, boolean val)</code> -- 用 val 填充 a 数组指定范围中的每个元素</p></li>
                                <li><p><code>static void 	fill(byte[] a, int fromIndex, int toIndex, byte val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(char[] a, int fromIndex, int toIndex, char val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(short[] a, int fromIndex, int toIndex, short val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(int[] a, int fromIndex, int toIndex, int val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(long[] a, int fromIndex, int toIndex, long val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(float[] a, int fromIndex, int toIndex, float val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(double[] a, int fromIndex, int toIndex, double val)</code> -- 同上</p></li>
                                <li><p><code>static void 	fill(Object[] a, int fromIndex, int toIndex, Object val)</code> -- 同上</p></li>

                                <li class="group"><p><code>static &lt;T> List&lt;T> asList(T... a)</code> -- 返回一个受指定数组支持的固定大小的列表</p></li>
                                <li><p><code>static boolean 	deepEquals(Object[] a1, Object[] a2)</code> -- 如果两个指定数组彼此是深层相等 的，则返回 true</p></li>
                                <li><p><code>static int 	deepHashCode(Object[] a)</code> -- 基于指定数组的“深层内容”返回哈希码</p></li>
                                <li><p><code>static String 	deepToString(Object[] a)</code> -- 返回指定数组“深层内容”的字符串表示形式</p></li>

                                <li class="group"><p><code>static int 	hashCode(boolean[] a)</code> -- 基于指定数组的内容返回哈希码</p></li>
                                <li><p><code>static int 	hashCode(byte[] a)</code> -- 同上</p></li>
                                <li><p><code>static int 	hashCode(char[] a)</code> -- 同上</p></li>
                                <li><p><code>static int 	hashCode(short[] a)</code> -- 同上</p></li>
                                <li><p><code>static int 	hashCode(int[] a)</code> -- 同上</p></li>
                                <li><p><code>static int 	hashCode(long[] a)</code> -- 同上</p></li>
                                <li><p><code>static int 	hashCode(float[] a)</code> -- 同上</p></li>
                                <li><p><code>static int 	hashCode(double[] a)</code> -- 同上</p></li>
                                <li><p><code>static int 	hashCode(Object[] a)</code> -- 同上</p>
                                    <pre class="brush: java;">
/** 对于长度相等的数组 a[n] 和 b[n], 有 a[i] == b[i], 那么 Arrays.hashCode(a) == Arrays.hashCode(b); */
                                    </pre>
                                </li>

                                <li class="group"><p><code>static boolean 	equals(boolean[] a, boolean[] a2)</code> -- 如果两个指定类型数组彼此相等，则返回 true</p></li>
                                <li><p><code>static boolean 	equals(byte[] a, byte[] a2)</code> -- 同上</p></li>
                                <li><p><code>static boolean 	equals(char[] a, char[] a2)</code> -- 同上</p></li>
                                <li><p><code>static boolean 	equals(short[] a, short[] a2)</code> -- 同上</p></li>
                                <li><p><code>static boolean 	equals(int[] a, int[] a2)</code> -- 同上</p></li>
                                <li><p><code>static boolean 	equals(long[] a, long[] a2)</code> -- 同上</p></li>
                                <li><p><code>static boolean 	equals(float[] a, float[] a2)</code> -- 同上</p></li>
                                <li><p><code>static boolean 	equals(double[] a, double[] a2)</code> -- 同上</p></li>
                                <li><p><code>static boolean 	equals(Object[] a, Object[] a2)</code> -- 同上</p></li>

                                <li class="group"><p><code>static String 	toString(boolean[] a)</code> -- 返回指定数组内容的字符串表示形式，<code>[false, true...]</code></p></li>
                                <li><p><code>static String 	toString(byte[] a)</code> -- 同上，<code>[1, 2...]</code></p></li>
                                <li><p><code>static String 	toString(char[] a)</code> -- 同上，<code>[a, b...]</code></p></li>
                                <li><p><code>static String 	toString(int[] a)</code> -- 同上，<code>[1, 2...]</code></p></li>
                                <li><p><code>static String 	toString(long[] a)</code> -- 同上，<code>[1, 2...]</code></p></li>
                                <li><p><code>static String 	toString(short[] a)</code> -- 同上，<code>[1, 2...]</code></p></li>
                                <li><p><code>static String 	toString(float[] a)</code> -- 同上，<code>[1.0, 2.0...]</code></p></li>
                                <li><p><code>static String 	toString(double[] a)</code> -- 同上，<code>[1.0, 2.0...]</code></p></li>
                                <li><p><code>static String 	toString(Object[] a)</code> -- 同上，<code>[a[0].toString(), a[1].toString()...]</code></p></li>

                                <li class="group"><p><code>static void 	parallelSort(byte[] a)</code> -- 并行排序，在多核设备上，当数组容量在 10000 以上的时候，并行排序比较快</p></li>
                                <li><p><code>static void 	parallelSort(char[] a)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSort(short[] a)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSort(int[] a)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSort(long[] a)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSort(float[] a)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSort(double[] a)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T extends Comparable&lt;? super T>> void 	parallelSort(T[] a)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T> void 	parallelSort(T[] a, Comparator&lt;? super T> cmp)</code> -- 同上，Java 8</p></li>

                                <li class="group"><p><code>static void 	parallelSort(byte[] a, int fromIndex, int toIndex)</code> -- 指定范围并行排序</p></li>
                                <li><p><code>static void 	parallelSort(char[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSort(double[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSort(float[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSort(int[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSort(long[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSort(short[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T extends Comparable&lt;? super T>> void 	parallelSort(T[] a, int fromIndex, int toIndex)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T> void 	parallelSort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T> cmp)</code> -- 同上，Java 8</p></li>

                                <li class="group"><p><code>static void 	parallelPrefix(int[] array, IntBinaryOperator op)</code> -- 使用函数并行地对给定数组中的每个元素进行累积</p>
                                    <pre class="brush: java;">
int[] a = {1, 2, 3, 4};
Arrays.parallelPrefix(a, new IntBinaryOperator() {
   @Override
   public int applyAsInt(int left, int right) {
       log(left, right);
       return left * right;
   }
});
log(Arrays.toString(a)); // 计算后：a = [1, 2, 6, 24]
</pre>
                                </li>
                                <li><p><code>static void 	parallelPrefix(long[] array, LongBinaryOperator op)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelPrefix(double[] array, DoubleBinaryOperator op)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T> void 	parallelPrefix(T[] array, BinaryOperator&lt;T> op)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelPrefix(int[] array, int fromIndex, int toIndex, IntBinaryOperator op)</code> -- 指定范围，Java 8</p></li>
                                <li><p><code>static void 	parallelPrefix(long[] array, int fromIndex, int toIndex, LongBinaryOperator op)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelPrefix(double[] array, int fromIndex, int toIndex, DoubleBinaryOperator op)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T> void 	parallelPrefix(T[] array, int fromIndex, int toIndex, BinaryOperator&lt;T> op)</code> -- 同上，Java 8</p></li>


                                <li class="group"><p><code>static void 	setAll(int[] array, IntUnaryOperator generator)</code> -- 使用提供的生成器函数计算每个元素</p>
                                    <pre class="brush: java;">
int[] a = {1, 2, 3, 4};
Arrays.setAll(a, new IntUnaryOperator() {
   @Override
   public int applyAsInt(int operand) { // operand 为索引
       return a[operand] * operand;
   }
});
log(Arrays.toString(a)); // 计算后：a = [0, 2, 6, 12]
</pre>
                                </li>
                                <li><p><code>static void 	setAll(long[] array, IntToLongFunction generator)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	setAll(double[] array, IntToDoubleFunction generator)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T> void 	setAll(T[] array, IntFunction&lt;? extends T> generator)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSetAll(int[] array, IntUnaryOperator generator)</code> -- 并行计算</p></li>
                                <li><p><code>static void 	parallelSetAll(long[] array, IntToLongFunction generator)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static void 	parallelSetAll(double[] array, IntToDoubleFunction generator)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T> void 	parallelSetAll(T[] array, IntFunction&lt;? extends T> generator)</code> -- 同上，Java 8</p></li>

                                <li class="group"><p><code>static Spliterator.OfInt 	spliterator(int[] array)</code> -- 创建数组的可分割迭代器，<a href="docs/docs-java/api/java/util/Spliterator.html" target="_blank">Spliterator</a> 是为了并行遍历元素而设计的一个迭代器，相对于顺序遍历迭代器 Iterator，Spliterator 一个是并行遍历的迭代器。</p></li>
                                <li><p><code>static Spliterator.OfLong 	spliterator(long[] array)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static Spliterator.OfDouble 	spliterator(double[] array)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T> Spliterator&lt;T> 	spliterator(T[] array)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static Spliterator.OfInt 	spliterator(int[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static Spliterator.OfLong 	spliterator(long[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static Spliterator.OfDouble 	spliterator(double[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T> Spliterator&lt;T> 	spliterator(T[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>

                                <li class="group"><p><code>static IntStream 	stream(int[] array)</code> -- <a href="">IntStream</a> 为支持顺序和并行聚合操作的原始值元素序列，参阅 <a href="docs/docs-java/api/java/util/stream/package-summary.html" target="_blank">java.util.stream</a></p></li>
                                <li><p><code>static LongStream 	stream(long[] array)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T> Stream&lt;T> 	stream(T[] array)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static DoubleStream 	stream(double[] array)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static IntStream 	stream(int[] array, int startInclusive, int endExclusive)</code> -- 指定范围</p></li>
                                <li><p><code>static LongStream 	stream(long[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static DoubleStream 	stream(double[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
                                <li><p><code>static &lt;T> Stream&lt;T> 	stream(T[] array, int startInclusive, int endExclusive)</code> -- 同上，Java 8</p></li>
                            </ol>


                            <p><a href="docs/docs-java/api/java/util/Collections.html" target="_blank">Collections</a> 此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。它包含在 collection 上操作的多态算法，即“包装器”，包装器返回由指定 collection 支持的新 collection，以及少数其他内容。</p>
                            <pre class="brush: java;">
public class Collections {
    public static final List EMPTY_LIST = new EmptyList<>();
    public static final Map EMPTY_MAP = new EmptyMap<>();
    public static final Set EMPTY_SET = new EmptySet<>();
}
</pre>
                            <ol>



                                <li class="group"><p><code>static &lt;T> int binarySearch(List&lt;? extends Comparable&lt;? super T>> list, T key)</code> -- 二分搜索法搜索列表返回索引</p></li>
                                <li><p><code>static &lt;T> int binarySearch(List&lt;? extends T> list, T key, Comparator&lt;? super T> c)</code> -- 二分搜索法搜索返回索引</p></li>

                                <li class="group"><p><code>static &lt;E> List&lt;E> checkedList(List&lt;E> list, Class&lt;E> type)</code> -- 返回一个动态类型安全视图，只能添加固定类型数据</p>
                                    <pre class="brush: java;">
List list = new ArrayList<>();
list.add("nate");
list.add(2);

List sList = Collections.checkedList(list, String.class); // sList 只能 add(String)
sList.add("1024");
list.add(4);
log(list, sList, list == sList); // list 和 sList 都包括以上 4 项，却不是同一个对象
// sList.add(2); // 插入非 String, 报 ClassCastException
</pre>
                                </li>
                                <li><p><code>static &lt;E> Collection&lt;E> checkedCollection(Collection&lt;E> c, Class&lt;E> type)</code> -- 同上</p></li>
                                <li><p><code>static &lt;E> Queue&lt;E> 	checkedQueue(Queue&lt;E> queue, Class&lt;E> type)</code> -- 同上, Java8</p></li>
                                <li><p><code>static &lt;E> Set&lt;E> checkedSet(Set&lt;E> s, Class&lt;E> type)</code> -- 同上</p></li>
                                <li><p><code>static &lt;E> SortedSet&lt;E> checkedSortedSet(SortedSet&lt;E> s, Class&lt;E> type)</code> -- 同上</p></li>
                                <li><p><code>static &lt;E> NavigableSet&lt;E> 	checkedNavigableSet(NavigableSet&lt;E> s, Class&lt;E> type)</code> -- 同上, Java8</p></li>
                                <li><p><code>static &lt;K,V> Map&lt;K,V> checkedMap(Map&lt;K,V> m, Class&lt;K> keyType, Class&lt;V> valueType)</code> -- 同上</p></li>
                                <li><p><code>static &lt;K,V> SortedMap&lt;K,V> checkedSortedMap(SortedMap&lt;K,V> m, Class&lt;K> keyType, Class&lt;V> valueType)</code> -- 同上</p></li>
                                <li><p><code>static &lt;K,V> NavigableMap&lt;K,V> 	checkedNavigableMap(NavigableMap&lt;K,V> m, Class&lt;K> keyType, Class&lt;V> valueType)</code></p></li>

                                <li class="group"><p><code>static  &lt;T> Collection&lt;T> synchronizedCollection(Collection&lt;T> c)</code> -- 返回线程安全支持的 Collection</p></li>
                                <li><p><code>static &lt;T> List&lt;T> synchronizedList(List&lt;T> list)</code> -- 返回指定线程安全支持的列表，操作加了 <code>synchronized</code></p></li>
                                <li><p><code>static &lt;K,V> Map&lt;K,V> synchronizedMap(Map&lt;K,V> m)</code> -- 返回指定线程安全支持的映射</p></li>
                                <li><p><code>static &lt;K,V> SortedMap&lt;K,V> synchronizedSortedMap(SortedMap&lt;K,V> m)</code> -- 返回指定线程安全支持的有序映射</p></li>
                                <li><p><code>static &lt;K,V> NavigableMap&lt;K,V> 	synchronizedNavigableMap(NavigableMap&lt;K,V> m)</code> -- 线程安全支持的 NavigableMap</p></li>
                                <li><p><code>static &lt;T> Set&lt;T> synchronizedSet(Set&lt;T> s)</code> -- 返回指定线程安全支持的set</p></li>
                                <li><p><code>static &lt;T> SortedSet&lt;T> synchronizedSortedSet(SortedSet&lt;T> s)</code> -- 返回指定线程安全支持的有序 set</p></li>
                                <li><p><code>static &lt;T> NavigableSet&lt;T> 	synchronizedNavigableSet(NavigableSet&lt;T> s)</code> -- 返回指定线程安全支持的 NavigableSet</p></li>


                                <li class="group"><p><code>static &lt;T> Collection&lt;T> unmodifiableCollection(Collection&lt;? extends T> c)</code> -- 返回指定 collection 的不可修改视图</p></li>
                                <li><p><code>static &lt;T> List&lt;T> unmodifiableList(List&lt;? extends T> list)</code> -- 返回指定列表的不可修改视图</p></li>
                                <li><p><code>static &lt;K,V> Map&lt;K,V> unmodifiableMap(Map&lt;? extends K,? extends V> m)</code> -- 返回指定映射的不可修改视图</p></li>
                                <li><p><code>static &lt;K,V> SortedMap&lt;K,V> unmodifiableSortedMap(SortedMap&lt;K,? extends V> m)</code> -- 返回指定有序映射的不可修改视图</p></li>
                                <li><p><code>static &lt;K,V> NavigableMap&lt;K,V> 	unmodifiableNavigableMap(NavigableMap&lt;K,? extends V> m)</code> -- 不可修改视图</p></li>
                                <li><p><code>static &lt;T> Set&lt;T> unmodifiableSet(Set&lt;? extends T> s)</code> -- 返回指定 set 的不可修改视图</p></li>
                                <li><p><code>static &lt;T> SortedSet&lt;T> unmodifiableSortedSet(SortedSet&lt;T> s)</code> -- 返回指定有序 set 的不可修改视图</p></li>
                                <li><p><code>static &lt;T> NavigableSet&lt;T> 	unmodifiableNavigableSet(NavigableSet&lt;T> s)</code> -- NavigableSet 不可修改视图</p></li>

                                <li class="group"><p><code>static &lt;T> List&lt;T> emptyList()</code> -- 返回空的列表</p></li>
                                <li><p><code>static &lt;K,V> Map&lt;K,V> emptyMap()</code> -- 返回空的映射</p></li>
                                <li><p><code>static &lt;T> Set&lt;T> emptySet()</code> -- 返回空的 set</p></li>
                                <li><p><code>static &lt;T> Enumeration&lt;T> 	emptyEnumeration()</code> -- 返回空的 Enumeration, Java8</p></li>
                                <li><p><code>static &lt;T> Iterator&lt;T> 	emptyIterator()</code> -- 返回空的 Iterator, Java8</p></li>
                                <li><p><code>static &lt;T> ListIterator&lt;T> 	emptyListIterator()</code> -- 返回空的 ListIterator, Java8</p></li>
                                <li><p><code>static &lt;E> SortedSet&lt;E> 	emptySortedSet()</code> -- 返回空的 SortedSet, Java8</p></li>
                                <li><p><code>static &lt;E> NavigableSet&lt;E> 	emptyNavigableSet()</code> -- 返回空的 NavigableSet, Java8</p></li>
                                <li><p><code>static &lt;K,V> SortedMap&lt;K,V> 	emptySortedMap()</code> -- 返回空的 SortedMap, Java8</p></li>
                                <li><p><code>static &lt;K,V> NavigableMap&lt;K,V> 	emptyNavigableMap()</code> -- 返回空的 NavigableMap, Java8</p></li>
                                <li><p><code>static &lt;T> Set&lt;T> singleton(T o)</code> -- 返回只包含一个指定对象的不可变 set</p></li>
                                <li><p><code>static &lt;T> List&lt;T> singletonList(T o)</code> -- 返回只包含一个指定对象的不可变列表</p></li>
                                <li><p><code>static &lt;K,V> Map&lt;K,V> singletonMap(K key, V value)</code> -- 返回一个不可变的映射，它只将指定键映射到指定值</p></li>

                                <li class="group"><p><code>static &lt;T> void fill(List&lt;? super T> list, T obj)</code> -- 使用指定元素替换指定列表中的所有元素</p></li>
                                <li><p><code>static void 	rotate(List&lt;?> list, int distance)</code> -- 根据指定的距离轮换指定列表中的元素</p>
                                    <pre class="brush: java;">
list = [1, 2, 3, 4];
rotate(list, 1) ==> [4, 1, 2, 3]
rotate(list, 2) ==> [3, 4, 1, 2]
rotate(list, 3) ==> [2, 3, 4, 1]
</pre>
                                </li>
                                <li><p><code>static void 	shuffle(List&lt;?> list)</code> -- 使用默认随机源对指定列表进行置换(随机打乱顺序)</p></li>
                                <li><p><code>static void 	shuffle(List&lt;?> list, Random rnd)</code> -- 使用指定的随机源对指定列表进行置换</p></li>
                                <li><p><code>static void 	swap(List&lt;?> list, int i, int j)</code> -- 在指定列表的指定位置处交换元素</p></li>
                                <li><p><code>static void 	reverse(List&lt;?> list)</code> -- 反转指定列表中元素的顺序</p></li>
                                <li><p><code>static &lt;T> List&lt;T> nCopies(int n, T o)</code> -- 返回由指定对象的 n 个副本组成的不可变列表</p></li>
                                <li><p><code>static &lt;T> boolean replaceAll(List&lt;T> list, T oldVal, T newVal)</code> -- 使用另一个值替换列表中出现的所有某一指定值</p></li>
                                <li><p><code>static &lt;T> void copy(List&lt;? super T> dest, List&lt;? extends T> src)</code> -- 将所有元素从一个列表复制到另一个列表</p></li>
                                <li><p><code>static int 	indexOfSubList(List&lt;?> src, List&lt;?> target)</code> -- 返回指定源列表中第一次出现指定目标列表的起始位置</p></li>
                                <li><p><code>static int 	lastIndexOfSubList(List&lt;?> src, List&lt;?> tar)</code> -- 返回指定源列表中最后一次出现指定目标列表的起始位置</p></li>

                                <li class="group"><p><code>static &lt;T extends Object & Comparable&lt;? super T>> T max(Collection&lt;? extends T> coll)</code> -- 自然顺序最大元素</p></li>
                                <li><p><code>static &lt;T extends Object & Comparable&lt;? super T>> T min(Collection&lt;? extends T> coll)</code> -- 自然顺序最小元素</p></li>
                                <li><p><code>static &lt;T> T max(Collection&lt;? extends T> coll, Comparator&lt;? super T> comp)</code> -- 指定比较器的最大元素</p></li>
                                <li><p><code>static &lt;T> T min(Collection&lt;? extends T> coll, Comparator&lt;? super T> comp)</code> -- 指定比较器的最小元素</p></li>

                                <li class="group"><p><code>static &lt;T extends Comparable&lt;? super T>> void sort(List&lt;T> list)</code> -- 根据元素的自然顺序对指定列表按升序进行排序</p></li>
                                <li><p><code>static  &lt;T> void sort(List&lt;T> list, Comparator&lt;? super T> c)</code> -- 根据指定比较器产生的顺序对指定列表进行排序</p></li>
                                <li><p><code>static &lt;T> Comparator&lt;T> reverseOrder()</code> -- 返回一个逆转的比较器</p></li>
                                <li><p><code>static &lt;T> Comparator&lt;T>  reverseOrder(Comparator&lt;T> cmp)</code> -- 返回一个比较器，它强行逆转指定比较器的顺序</p></li>


                                <li class="group"><p><code>static &lt;T> boolean addAll(Collection&lt;? super T> c, T... elements)</code> -- 将所有指定元素添加到指定 collection 中</p></li>
                                <li><p><code>static boolean 	disjoint(Collection&lt;?> c1, Collection&lt;?> c2)</code> -- 是否有相同元素</p></li>
                                <li><p><code>static int 	frequency(Collection&lt;?> c, Object o)</code> -- 返回指定 collection 中等于指定对象的元素数</p></li>
                                <li><p><code>static &lt;T> Queue&lt;T> asLifoQueue(Deque&lt;T> deque)</code> -- 以后进先出 (Lifo) Queue 的形式返回某个 Deque 的视图</p></li>
                                <li><p><code>static &lt;E> Set&lt;E> newSetFromMap(Map&lt;E,Boolean> map)</code> -- 返回指定映射支持的 set</p></li>

                                <li class="group"><p><code>static &lt;T> Enumeration&lt;T> enumeration(Collection&lt;T> c)</code> -- 返回一个指定 collection 上的枚举</p></li>
                                <li><p><code>static &lt;T> ArrayList&lt;T> list(Enumeration&lt;T> e)</code> -- 返回一个数组列表，它按返回顺序包含指定枚举返回的元素</p>
                                    <pre class="brush: java;">
List list = Arrays.asList(1, 2, 3, 4);
Enumeration e = Collections.enumeration(list);
// ArrayList l2 = Collections.list(e); // 可以将 e 转换回 ArrayList
while(e.hasMoreElements()) { // 遍历元素
    log(e.nextElement());
}
</pre>
                                </li>
                            </ol>
                        </div>

						<div  class="sub-item">
							<p><b>从顶向下分析 Java Collections Framework：</b></p>
							<p><a href="docs/docs-java/api/java/util/Iterator.html" target="_blank">Iterator</a> 对 Collection 进行迭代的迭代器。</p>
							<pre class="brush: java;">
public interface Iterator&lt;E> {
	boolean hasNext(); // 如果仍有元素可以迭代，则返回 true
 	E next(); // 返回迭代的下一个元素

 	default void remove() {} // 从迭代器指向的 Collection 中移除迭代器返回的最后一个元素
	default void forEachRemaining(Consumer&lt;? super E> action) {}
}
</pre>

                            <p><a href="docs/docs-java/api/java/util/ListIterator.html" target="_blank">ListIterator</a> 列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。</p>
                            <p>ListIterator 没有当前元素；它的光标位置 始终位于调用 previous() 所返回的元素和调用 next() 所返回的元素之间。</p>
                            <p>List 接口的 <code>listIterator()</code> 方法会返回此接口实现类的实例。</p>
                            <ol>
                                <li><p><code>int 	nextIndex()</code> -- 返回对 next 的后续调用所返回元素的索引</p></li>

                                <li class="group"><p><code>E 	previous()</code> -- 返回列表中的前一个元素</p></li>
                                <li><p><code>int 	previousIndex()</code> -- 返回对 previous 的后续调用所返回元素的索引</p></li>
                                <li><p><code>boolean 	hasPrevious()</code> -- 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true</p></li>

                                <li class="group"><p><code>void 	add(E e)</code> -- 将指定的元素插入列表</p></li>
                                <li><p><code>void 	set(E e)</code> -- 用指定元素替换 next 或 previous 返回的最后一个元素</p></li>
                            </ol>

                        </div>

                        <div class="sub-item">
							<p><a href="docs/docs-java/api/java/lang/Iterable.html" target="_blank">java.lang.Iterable</a> 实现这个接口允许对象成为 "foreach" 语句的目标。</p>
							<pre class="brush: java;">
public interface Iterable&lt;T> {
	Iterator&lt;T> iterator(); // 返回一个在一组 T 类型的元素上进行迭代的迭代器

	default void forEach(Consumer&lt;? super T> action) {}
	default Spliterator&lt;T> spliterator() {}
}
</pre>

							<p><a href="docs/docs-java/api/java/util/Collection.html" target="_blank">Collection</a> 表示一组对象，这些对象也称为 Collection 的元素。一些 Collection 允许有重复的元素，而另一些则不允许。一些 Collection 是有序的，而另一些则是无序的。</p>
                            <ol>
                                <li><p><code>boolean 	add(E e)</code> -- 确保此 collection 包含指定的元素</p></li>
                                <li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 将指定 collection 中的所有元素都添加到此 collection 中</p></li>
                                <li><p><code>int 	size()</code> -- 返回此 collection 中的元素数</p></li>
                                <li><p><code>boolean 	isEmpty()</code> -- 如果此 collection 不包含元素，则返回 true</p></li>
                                <li><p><code>void 	clear()</code> -- 移除此 collection 中的所有元素</p></li>
                                <li><p><code>Iterator&lt;E> 	iterator()</code> -- 返回在此 collection 的元素上进行迭代的迭代器</p></li>

                                <li class="group"><p><code>boolean 	contains(Object o)</code> -- 如果此 collection 包含指定的元素，则返回 true</p></li>
                                <li><p><code>boolean 	containsAll(Collection&lt;?> c)</code> -- 如果此 collection 包含指定 collection 中的所有元素，则返回 true</p></li>
                                <li><p><code>boolean 	remove(Object o)</code> -- 从此 collection 中移除指定元素的单个实例，如果存在的话</p></li>
                                <li><p><code>boolean 	removeAll(Collection&lt;?> c)</code> -- 移除此 collection 中那些也包含在指定 collection 中的所有元素</p></li>

                                <li class="group"><p><code>boolean 	retainAll(Collection&lt;?> c)</code> -- 仅保留此 collection 中那些也包含在指定 collection 的元素</p></li>
                                <li><p><code>int 	hashCode()</code> -- 返回此 collection 的哈希码值</p></li>
                                <li><p><code>boolean 	equals(Object o)</code> -- 比较此 collection 与指定对象是否相等。</p></li>
                                <li><p><code>Object[] 	toArray()</code> -- 返回包含此 collection 中所有元素的数组</p></li>
                                <li><p><code>&lt;T>T[] toArray(T[] a)</code> -- 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同</p></li>

                            </ol>

                            <p><a href="docs/docs-java/api/java/util/List.html" target="_blank">List</a> 是有序的序列,可以对列表中每个元素的插入位置进行精确地控制,根据元素的整数索引访问元素，并搜索列表中的元素。</p>
                            <p>与 set 不同，列表通常允许重复的元素。更确切地讲，列表通常允许满足 <code>e1.equals(e2)</code> 的元素对 e1 和 e2，并且如果列表本身允许 null 元素的话，通常它们允许多个 null 元素。</p>
                            <ol>
                                <li><p><code>void 	add(int index, E element</code> -- 在列表的指定位置插入指定元素</p></li>
                                <li><p><code>boolean 	addAll(int index, Collection&lt;? extends E> c)</code> -- 添加指定 collection 中的所有元素到此列表的结尾</p></li>
                                <li><p><code>E 	get(int index)</code> -- 返回列表中指定位置的元素</p></li>
                                <li><p><code>int 	indexOf(Object o)</code> -- 返回此列表中第一次出现的指定元素的索引</p></li>
                                <li><p><code>int 	lastIndexOf(Object o)</code> -- 返回此列表中最后出现的指定元素的索引</p></li>
                                <li><p><code>ListIterator&lt;E> 	listIterator()</code> -- 返回此列表元素的列表迭代器（按适当顺序）</p></li>
                                <li><p><code>ListIterator&lt;E> 	listIterator(int index)</code> -- 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始</p></li>
                                <li><p><code>E 	remove(int index)</code> -- 移除列表中指定位置的元素</p></li>
                                <li><p><code>E 	set(int index, E element)</code> -- 用指定元素替换列表中指定位置的元素</p></li>
                                <li><p><code>List&lt;E> 	subList(int from, int to)</code> -- 返回列表中指定的 from（包括 ）和 to（不包括）之间的部分视图</p></li>
                            </ol>

							<p><a href="docs/docs-java/api/java/util/Queue.html" target="_blank">Queue</a> 在处理元素前用于保存元素的 collection。除了基本的 Collection 操作外，队列还提供其他的插入、提取和检查操作。</p>
							<p>队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。不过优先级队列和 LIFO 队列（或堆栈）例外，前者根据提供的比较器或元素的自然顺序对元素进行排序，后者按 LIFO（后进先出）的方式对元素进行排序。无论使用哪种排序方式，队列的头 都是调用 remove() 或 poll() 所移除的元素。在 FIFO 队列中，所有的新元素都插入队列的末尾。其他种类的队列可能使用不同的元素放置规则。每个 Queue 实现必须指定其顺序属性。 </p>
							<p>Queue 接口并未定义阻塞队列的方法，而这在并发编程中是很常见的。BlockingQueue 接口定义了那些等待元素出现或等待队列中有可用空间的方法，这些方法扩展了此接口。 </p>
                            <ol>
                                <li><p><code>boolean 	add(E e)</code> -- 将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException</p></li>
                                <li><p><code>boolean 	offer(E e)</code> -- 将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常</p></li>
                                <li class="group"><p><code>E 	peek()</code> -- 获取但不移除此队列的头；如果此队列为空，则返回 null</p></li>
                                <li><p><code>E 	element()</code> -- 获取但不移除此队列的头，与 peek 唯一的不同在于：此队列为空时将抛出一个异常</p></li>
                                <li><p><code>E 	poll()</code> --  获取并移除此队列的头，如果此队列为空，则返回 null</p></li>
                                <li><p><code>E 	remove()</code> -- 获取并移除此队列的头，与 poll 唯一的不同在于：此队列为空时将抛出一个异常</p></li>
                            </ol>

							<p><a href="docs/docs-java/api/java/util/Deque.html" target="_blank">Deque</a> 一个线性 collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。 </p>
                            <p>此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 Deque 实现设计的；在大多数实现中，插入操作不能失败。 </p>
                            <p>注意，在将双端队列用作队列或堆栈时，peek 方法同样正常工作；无论哪种情况下，都从双端队列的开头抽取元素。 </p>
                            <ol>
                                <li><p><code>void 	addFirst(E e)</code> -- 将指定元素插入此双端队列的开头</p></li>
                                <li><p><code>void 	addLast(E e)</code> -- 将指定元素插入此双端队列的末尾</p></li>
                                <li><p><code>E 	getFirst()</code> -- 获取但不移除此双端队列的第一个元素</p></li>
                                <li><p><code>E 	getLast()</code> -- 获取但不移除此双端队列的最后一个元素</p></li>
                                <li><p><code>boolean 	offerFirst(E e)</code> -- 将指定的元素插入此双端队列的开头</p></li>
                                <li><p><code>boolean 	offerLast(E e)</code> -- 在不违反容量限制的情况下，将指定的元素插入此双端队列的末尾</p></li>

                                <li class="group"><p><code>Iterator&lt;E> 	iterator()</code> -- 返回以恰当顺序在此双端队列的元素上进行迭代的迭代器</p></li>
                                <li><p><code>Iterator&lt;E> 	descendingIterator()</code> -- 返回以逆向顺序在此双端队列的元素上进行迭代的迭代器</p></li>

                                <li class="group"><p><code>E 	peekFirst()</code> -- 获取但不移除此双端队列的第一个元素</p></li>
                                <li><p><code>E 	peekLast()</code> -- 获取但不移除此双端队列的最后一个元素</p></li>
                                <li><p><code>E 	pollFirst()</code> -- 获取并移除此双端队列的第一个元素</p></li>
                                <li><p><code>E 	pollLast()</code> -- 获取并移除此双端队列的最后一个元素</p></li>

                                <li class="group"><p><code>E 	pop()</code> -- 从此双端队列所表示的堆栈中弹出一个元素</p></li>
                                <li><p><code>void 	push(E e)</code> -- 将一个元素推入此双端队列所表示的堆栈</p></li>

                                <li class="group"><p><code>boolean 	remove(Object o)</code> -- 从此双端队列中移除第一次出现的指定元素</p></li>
                                <li><p><code>E 	removeFirst()</code> -- 获取并移除此双端队列第一个元素</p></li>
                                <li><p><code>E 	removeLast()</code> -- 获取并移除此双端队列的最后一个元素</p></li>
                                <li><p><code>boolean 	removeFirstOccurrence(Object o)</code> -- 从此双端队列移除第一次出现的指定元素</p></li>
                                <li><p><code>boolean 	removeLastOccurrence(Object o)</code> -- 从此双端队列移除最后一次出现的指定元素</p></li>
                            </ol>

							<p><a href="docs/docs-java/api/java/util/concurrent/BlockingQueue.html" target="_blank">BlockingQueue</a> 支持两个附加操作的 Queue，这两个操作是：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用。 </p>
                            <p>其方法以四种形式出现，对于不能立即满足但可能在将来某一时刻可以满足的操作，这四种形式的处理方式不同：</p>
                            <ol>
                                <li><p>第一种是抛出一个异常；</p></li>
                                <li><p>第二种是返回一个特殊值（null 或 false，具体取决于操作）;</p></li>
                                <li><p>第三种是在操作可以成功前，无限期地阻塞当前线程；</p></li>
                                <li><p>第四种是在放弃前只在给定的最大时间限制内阻塞。</p></li>
                            </ol>
                            <p>BlockingQueue 实现主要用于生产者-使用者队列，但它另外还支持 Collection 接口。</p>
                            <p>BlockingQueue 实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。</p>
                            <ol>
                                <li><p><code>E 	take()</code> -- 获取并移除此队列的头部，在元素变得可用之前一直等待</p></li>
                                <li><p><code>void 	put(E e)</code> -- 将指定元素插入此队列中，将等待可用的空间</p></li>
                                <li><p><code>boolean 	offer(E e, long timeout, TimeUnit unit)</code> -- 将指定元素插入此队列中，在到达指定的等待时间前等待可用的空间</p></li>
                                <li><p><code>E 	poll(long timeout, TimeUnit unit)</code> -- 获取并移除此队列的头部，在指定的等待时间前等待可用的元素</p></li>
                                <li class="group"><p><code>int 	drainTo(Collectio&lt;? super E> c)</code> -- 移除此队列中所有可用的元素，并将它们添加到给定 collection 中</p></li>
                                <li><p><code>int 	drainTo(Collection&lt;? super E> c, int maxElements)</code> -- 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</p></li>
                                <li><p><code>int 	remainingCapacity()</code> -- 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的附加元素数量</p></li>
                            </ol>

							<p><a href="docs/docs-java/api/java/util/concurrent/BlockingDeque.html" target="_blank">BlockingDeque</a> 支持两个附加操作的 Queue，这两个操作是：获取元素时等待双端队列变为非空；存储元素时等待双端队列中的空间变得可用。 </p>
                            <p>像所有 BlockingQueue 一样，BlockingDeque 是线程安全的，只是它支持双端操作。</p>
                            <ol>
                                <li><p><code>boolean 	offerFirst(E e, long timeout, TimeUnit unit)</code> -- 将指定的元素插入此双端队列的开头，必要时将在指定的等待时间内等待可用空间</p></li>
                                <li><p><code>boolean 	offerLast(E e, long timeout, TimeUnit unit)</code> -- 将指定的元素插入此双端队列的末尾，必要时将在指定的等待时间内等待可用空间</p></li>
                                <li><p><code>E pollFirst(long timeout, TimeUnit unit)</code> -- 获取并移除此双端队列的第一个元素，必要时将在指定的等待时间等待可用元素</p></li>
                                <li><p><code>E 	pollLast(long timeout, TimeUnit unit)</code> -- 获取并移除此双端队列的最后一个元素，必要时将在指定的等待时间内等待可用元素</p></li>
                                <li><p><code>void 	putFirst(E e)</code> -- 将指定的元素插入此双端队列的开头，必要时将一直等待可用空间</p></li>
                                <li><p><code>void 	putLast(E e)</code> -- 将指定的元素插入此双端队列的末尾，必要时将一直等待可用空间</p></li>
                                <li><p><code>E 	takeFirst()</code> -- 获取并移除此双端队列的第一个元素，必要时将一直等待可用元素</p></li>
                                <li><p><code>E 	takeLast()</code> -- 获取并移除此双端队列的最后一个元素，必要时将一直等待可用元素</p></li>
                            </ol>

                            <p><a href="docs/docs-java/api/java/util/Set.html" target="_blank">Set</a> 一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。</p>
                            <p>注：如果将可变对象用作 set 元素，那么必须极其小心。如果对象是 set 中某个元素，以一种影响 equals 比较的方式改变对象的值，那么 set 的行为就是不确定的。此项禁止的一个特殊情况是不允许某个 set 包含其自身作为元素。 </p>

							<p><a href="docs/docs-java/api/java/util/SortedSet.html" target="_blank">SortedSet</a> 进一步提供关于元素的总体排序 的 Set。这些元素使用其自然顺序进行排序，或者根据通常在创建有序 set 时提供的 Comparator 进行排序。该 set 的迭代器将按元素升序遍历 set。提供了一些附加的操作来利用这种排序。</p>
                            <p>插入有序 set 的所有元素都必须实现 Comparable 接口（或者被指定的比较器所接受）。另外，所有这些元素都必须是可互相比较的：对于有序 set 中的任意两个元素 e1 和 e2，执行 e1.compareTo(e2)（或 comparator.compare(e1, e2)）都不得抛出 ClassCastException。试图违反此限制将导致违反规则的方法或者构造方法调用抛出 ClassCastException。 </p>
                            <p>所有通用有序 set 实现类都应该提供 4 个“标准”构造方法：</p>
                                <ul><li><p>1) void（无参数）构造方法，它创建一个空的有序 set，按照元素的自然顺序进行排序；</p></li>
                                    <li><p>2) 带有一个 Comparator 类型参数的构造方法，它创建一个空的有序 set，根据指定的比较器进行排序；</p></li>
                                    <li><p>3) 带有一个 Collection 类型参数的构造方法，它创建一个新的有序 set，其元素与参数相同，按照元素的自然顺序进行排序；</p></li>
                                    <li><p>4) 带有一个 SortedSet 类型参数的构造方法，它创建一个新的有序 set，其元素和排序方法与输入的有序 set 相同。无法保证强制实施此建议，因为接口不能包含构造方法。 </p>
                                </ul>
                            <ol>
                                <li><p><code>E 	first()</code> -- 返回此 set 中当前第一个（最低）元素</p></li>
                                <li><p><code>E 	last()</code> -- 返回此 set 中当前最后一个（最高）元素</p></li>
                                <li><p><code>SortedSet&lt;E> 	headSet(E toElement)</code> -- 返回此 set 的部分视图，其元素严格小于 toElement</p></li>
                                <li><p><code>SortedSet&lt;E> 	tailSet(E fromElement)</code> -- 返回此 set 的部分视图，其元素大于等于 fromElement</p></li>
                                <li><p><code>SortedSet&lt;E> 	subSet(E fromElement, E toElement)</code> -- 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）</p></li>
                                <li><p><code>Comparator&lt;? super E></code> -- 返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null</p></li>
                            </ol>

							<p><a href="docs/docs-java/api/java/util/NavigableSet.html" target="_blank">NavigableSet</a> 扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法。</p>
                            <p>方法 lower、floor、ceiling 和 higher 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null。可以按升序或降序访问和遍历 NavigableSet。descendingSet 方法返回 set 的一个视图，该视图表示的所有关系方法和方向方法都是逆向的。升序操作和视图的性能很可能比降序操作和视图的性能要好。此外，此接口还定义了 pollFirst 和 pollLast 方法，它们返回并移除最小和最大的元素（如果存在），否则返回 null。subSet、headSet 和 tailSet 方法与名称相似的 SortedSet 方法的不同之处在于：可以接受用于描述是否包括（或不包括）下边界和上边界的附加参数。任何 NavigableSet 的 Submap 必须实现 NavigableSet 接口。</p>
                            <ol>
                                <li><p><code>E 	ceiling(E e)</code> -- 返回此 set 中大于等于给定元素的最小元素</p></li>
                                <li><p><code>E 	floor(E e)</code> -- 返回此 set 中小于等于给定元素的最大元素</p></li>
                                <li><p><code>E 	higher(E e)</code> -- 返回此 set 中严格大于给定元素的最小元素</p></li>
                                <li><p><code>E 	lower(E e)</code> -- 返回此 set 中严格小于给定元素的最大元素</p></li>
                                <li><p><code>E 	pollFirst()</code> -- 获取并移除第一个（最低）元素</p></li>
                                <li><p><code>E 	pollLast()</code> -- 获取并移除最后一个（最高）元素</p></li>

                                <li class="group"><p><code>Iterator&lt;E> 	descendingIterator()</code> -- 以降序返回在此 set 的元素上进行迭代的迭代器</p></li>
                                <li><p><code>NavigableSet&lt;E> 	descendingSet()</code> -- 返回此 set 中所包含元素的逆序视图</p></li>

                                <li class="group"><p><code>NavigableSet&lt;E> 	headSet(E toElement, boolean inclusive)</code> -- </p></li>
                                <li><p><code>NavigableSet&lt;E> 	subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)</code> -- 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement</p></li>
                                <li><p><code>NavigableSet&lt;E> 	tailSet(E fromElement, boolean inclusive)</code> -- 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <p><a href="docs/docs-java/api/java/util/Map.html" target="_blank">Map</a> 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 </p>
                            <p>Map 接口提供三种 Collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。</p>
                            <p>注：将可变对象用作映射键时必须格外小心。当对象是映射中某个键时，如果以影响 equals 比较的方式更改了对象的值，则映射的行为将是不确定的。此项禁止的一种特殊情况是不允许某个映射将自身作为一个键包含。虽然允许某个映射将自身作为值包含，但请格外小心：在这样的映射上 equals 和 hashCode 方法的定义将不再是明确的。 </p>
                            <pre class="brush: java;">
public interface Map&lt;K, V> {
	interface Entry&lt;K,V> {
		boolean equals(Object o); // 比较指定对象与此项的相等性
 		K getKey(); // 返回与此项对应的键
 		V getValue(); // 返回与此项对应的值
 		int hashCode(); // 返回此映射项的哈希码值
 		V setValue(V value); // 用指定的值替换与此项对应的值

		static &lt;K extends Comparable&lt;? super K>,V> Comparator&lt;Map.Entry&lt;K,V>> comparingByKey() {}
		static &lt;K,V> Comparator&lt;Map.Entry&lt;K,V>> comparingByKey(Comparator&lt;? super K> cmp) {}
		static &lt;K,V extends Comparable&lt;? super V>> Comparator&lt;Map.Entry&lt;K,V>> comparingByValue() {}
		static &lt;K,V> Comparator&lt;Map.Entry&lt;K,V>> comparingByValue(Comparator&lt;? super V> cmp) {}
	}
}
</pre>
                            <ol>
                                <li><p><code>V put(K key, V value)</code> -- 将指定的值与此映射中的指定键关联</p></li>
                                <li><p><code>V get(Object key)</code> -- 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null</p></li>
                                <li><p><code>boolean isEmpty()</code> -- 如果此映射未包含键-值映射关系，则返回 true</p></li>
                                <li><p><code>int size()</code> -- 返回此映射中的键-值映射关系数</p></li>
                                <li><p><code>V remove(Object key)</code> -- 如果存在一个键的映射关系，则将其从此映射中移除</p></li>
                                <li><p><code>void clear()</code> -- 从此映射中移除所有映射关系</p></li>

                                <li class="group"><p><code>boolean containsKey(Object key)</code> -- 如果此映射包含指定键的映射关系，则返回 true</p></li>
                                <li><p><code>Set&lt;K> keySet()</code> -- 返回此映射中包含的键的 Set 视图</p></li>
                                <li><p><code>boolean containsValue(Object value)</code> -- 如果此映射将一个或多个键映射到指定值，则返回 true</p></li>
                                <li><p><code>Set&lt;Map.Entry&lt;K,V>> entrySet()</code> --  返回此映射中包含的映射关系的 Set 视图</p></li>
                                <li><p><code>void putAll(Map&lt;? extends K,? extends V> m)</code> -- 从指定映射中将所有映射关系复制到此映射中</p></li>
                                <li><p><code>Collection&lt;V> values()</code> -- 返回此映射中包含的值的 Collection 视图</p></li>
                            </ol>

							<p><a href="docs/docs-java/api/java/util/SortedMap.html" target="_blank">SortedMap</a> 进一步提供关于键的总体排序 的 Map。该映射是根据其键的自然顺序进行排序的，或者根据通常在创建有序映射时提供的 Comparator 进行排序。对有序映射的 collection 视图（由 entrySet、keySet 和 values 方法返回）进行迭代时，此顺序就会反映出来。要采用此排序方式，还需要提供一些其他操作（此接口是 SortedSet 的对应映射）。</p>
                            <p>插入有序映射的所有键都必须实现 Comparable 接口（或者被指定的比较器接受）。另外，所有这些键都必须是可互相比较的：对有序映射中的任意两个键 k1 和 k2 执行 k1.compareTo(k2)（或 comparator.compare(k1, k2)）都不得抛出 ClassCastException。试图违反此限制将导致违反规则的方法或者构造方法调用抛出 ClassCastException。 </p>
                            <ol>
                                <li><p><code>K 	firstKey()</code> -- 返回此映射中当前第一个（最低）键</p></li>
                                <li><p><code>K 	lastKey()</code> -- 返回映射中当前最后一个（最高）键</p></li>

                                <li class="group"><p><code>SortedMap&lt;K, V> 	headMap(K toKey)</code> -- 返回此映射的部分视图，其键值严格小于 toKey</p></li>
                                <li><p><code>SortedMap&lt;K, V> 	subMap(K fromKey, K toKey)</code> -- 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）</p></li>
                                <li><p><code>SortedMap&lt;K, V> 	tailMap(K fromKey)</code> -- 返回此映射的部分视图，其键大于等于 fromKey</p></li>

                                <li class="group"><p><code>Comparator&lt;? super K> 	comparator()</code> -- 返回对此映射中的键进行排序的比较器；</p></li>
                            </ol>

                            <p><a href="docs/docs-java/api/java/util/NavigableMap.html" target="_blank">NavigableMap</a> 扩展的 SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法。</p>
                            <p>方法 lowerEntry、floorEntry、ceilingEntry 和 higherEntry 分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象，如果不存在这样的键，则返回 null。类似地，方法 lowerKey、floorKey、ceilingKey 和 higherKey 只返回关联的键。所有这些方法是为查找条目而不是遍历条目而设计的。 </p>
                            <ol>
                                <li><p><code>K 	ceilingKey(K key)</code> -- 返回大于等于给定键的最小键</p></li>
                                <li><p><code>Map.Entry&lt;K,V> 	ceilingEntry(K key)</code> -- 返回一个键-值映射关系，它与大于等于给定键的最小键关联</p></li>
                                <li><p><code>K 	floorKey(K key</code> -- 返回小于等于给定键的最大键</p></li>
                                <li><p><code>Map.Entry&lt;K,V> 	floorEntry(K key)</code> -- 返回一个键-值映射关系，它与小于等于给定键的最大键关联</p></li>
                                <li><p><code>K 	higherKey(K key)</code> -- 返回严格大于给定键的最小键</p></li>
                                <li><p><code>Map.Entry&lt;K,V> 	higherEntry(K key)</code> -- 返回一个键-值映射关系，它与严格大于给定键的最小键关联</p></li>
                                <li><p><code>K 	lowerKey(K key)</code> -- 返回严格小于给定键的最大键</p></li>
                                <li><p><code>Map.Entry&lt;K,V> 	lowerEntry(K key)</code> -- 返回一个键-值映射关系</p></li>
                                <li><p><code>Map.Entry&lt;K,V> 	firstEntry()</code> -- 返回一个与此映射中的最小键关联的键-值映射关系</p></li>
                                <li><p><code>Map.Entry&lt;K,V> 	lastEntry()</code> -- 返回与此映射中的最大键关联的键-值映射关系</p></li>

                                <li class="group"><p><code>Map.Entry&lt;K,V> 	pollFirstEntry()</code> -- 移除并返回与此映射中的最小键关联的键-值映射关系</p></li>
                                <li><p><code>Map.Entry&lt;K,V> 	pollLastEntry()</code> -- 移除并返回与此映射中的最大键关联的键-值映射关系</p></li>

                                <li class="group"><p><code>NavigableSet&lt;K> 	descendingKeySet()</code> -- 返回此映射中所包含键的逆序 NavigableSet 视图</p></li>
                                <li><p><code>NavigableSet&lt;K> 	navigableKeySet()</code> -- 返回此映射中所包含键的 NavigableSet 视图</p></li>
                                <li><p><code>NavigableMap&lt;K,V> 	descendingMap()</code> -- 返回此映射中所包含映射关系的逆序视图</p></li>

                                <li class="group"><p><code>NavigableMap&lt;K,V> 	headMap(K toKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey</p></li>
                                <li><p><code>NavigableMap&lt;K,V> 	subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</code> -- 返回此映射的部分视图，其键的范围从 fromKey 到 toKey</p></li>
                                <li><p><code>NavigableMap&lt;K,V> 	tailMap(K fromKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey</p></li>
                            </ol>

                            <p><a href="docs/docs-java/api/java/util/concurrent/ConcurrentMap.html" target="_blank">ConcurrentMap</a> 提供其他原子 putIfAbsent、remove、replace 方法的 Map。</p>
                            <ol>
                                <li><p><code>V 	putIfAbsent(K key, V value)</code> -- 如果指定键已经不再与某个值相关联，则将它与给定值关联。</p></li>
                                <li><p><code>boolean 	remove(Object key, Object value)</code> -- 只有目前将键的条目映射到给定值时，才移除该键的条目。</p></li>
                                <li><p><code>V 	replace(K key, V value)</code> -- 只有目前将键的条目映射到某一值时，才替换该键的条目。</p></li>
                                <li><p><code>boolean 	replace(K key, V oldValue, V newValue)</code> -- 只有目前将键的条目映射到给定值时，才替换该键的条目。</p></li>
                            </ol>

                            <p><a href="docs/docs-java/api/java/util/concurrent/ConcurrentNavigableMap.html" target="_blank">ConcurrentNavigableMap</a> 支持 NavigableMap 操作，且以递归方式支持其可导航子映射的 ConcurrentMap。</p>
                            <ol>
                                <li><p><code>ConcurrentNavigableMap&lt;K,V> 	headMap(K toKey)</code> -- 返回此映射的部分视图，其键值严格小于 toKey。</p></li>
                                <li><p><code>ConcurrentNavigableMap&lt;K,V> 	headMap(K toKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。</p></li>
                                <li><p><code>ConcurrentNavigableMap&lt;K,V> 	subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</code> -- 返回此映射的部分视图，其键的范围从 fromKey 到 toKey。</p></li>
                                <li><p><code>ConcurrentNavigableMap&lt;K,V> 	subMap(K fromKey, K toKey)</code> -- 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。</p></li>
                                <li><p><code>ConcurrentNavigableMap&lt;K,V> 	tailMap(K fromKey)</code> -- 返回此映射的部分视图，其键大于等于 fromKey。</p></li>
                                <li><p><code>ConcurrentNavigableMap&lt;K,V> 	tailMap(K fromKey, boolean inclusive)</code> -- 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。</p></li>

                                <li class="group"><p><code>NavigableSet&lt;K> 	keySet()</code> -- 返回此映射中所包含键的 NavigableSet 视图。</p></li>
                                <li><p><code>NavigableSet&lt;K> 	navigableKeySet()</code> -- 返回此映射中所包含键的 NavigableSet 视图。</p></li>

                                <li class="group"><p><code>NavigableSet&lt;K> 	descendingKeySet()</code> -- 返回此映射中所包含键的逆序 NavigableSet 视图。</p></li>
                                <li><p><code>ConcurrentNavigableMap&lt;K,V> 	descendingMap()</code> -- 返回此映射中所包含映射关系的逆序视图。</p></li>
                            </ol>
						</div>

                        <div class="sub-item">

                            <p><a href="docs/docs-java/api/java/util/AbstractCollection.html" target="_blank">AbstractCollection</a> 此类提供 Collection 接口的骨干实现，以最大限度地减少了实现此接口所需的工作。 </p>
							<pre class="brush: java;">
public abstract class AbstractCollection&lt;E> implements Collection&lt;E> {
    public abstract Iterator&lt;E> iterator();
    public abstract int size();
}
</pre>
                            <ul>
                                <li><p>要实现一个不可修改的 collection，只需扩展此类，并提供 <code>iterator()</code> 和 <code>size()</code> 方法的实现。</p></li>
                                <li><p>要实现可修改的 collection，必须另外重写此类的 <code>add(E)</code> 方法（否则，会抛出 UnsupportedOperationException），iterator 方法返回的迭代器还必须另外实现其 <code>remove()</code> 方法。</p></li>
                                <li><p>按照 Collection 接口规范中的建议，通常应提供一个 void （无参数）和 Collection 构造方法。</p></li>
                            </ul>

							<p><a href="docs/docs-java/api/java/util/AbstractList.html" target="_blank">AbstractList</a> 此类提供 List 接口的骨干实现，以最大限度地减少实现“随机访问”数据存储（如数组）支持的该接口所需的工作。对于连续的访问数据（如链表），应优先使用 AbstractSequentialList，而不是此类。  </p>
                            <pre class="brush: java;">
/** 实现了 AbstractCollection 的 iterator() 方法，但未实现 size() 方法 */
public abstract class AbstractList&lt;E> extends AbstractCollection&lt;E> implements List&lt;E> {
    abstract public E get(int index);
}
</pre>
							<ul>
								<li><p>要实现不可修改的列表，只需扩展此类，并提供 <code>get(int)</code> 和 <code>size()</code> 方法的实现；</p></li>
								<li><p>要实现可修改的列表，必须另外重写 <code>set(int, E)</code> 方法（否则将抛出 UnsupportedOperationException）。如果列表为可变大小，则必须另外重写 <code>add(int, E)</code> 和 <code>remove(int)</code> 方法； </p></li>
								<li><p>按照 Collection 接口规范中的建议，通常应该提供一个 void（无参数）和 collection 构造方法。</p></li>
							</ul>

                            <p><a href="docs/docs-java/api/java/util/ArrayList.html" target="_blank">ArrayList</a> 是 List 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。</p>
                            <p>每个 ArrayList 实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。并未指定增长策略的细节，因为这不只是添加元素会带来分摊固定时间开销那样简单。</p>
                            <p>在添加大量元素前，应用程序可以使用 <code>ensureCapacity(int)</code> 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</p>
                            <p>ArrayList 内部有一个 <code>transient Object[] elementData;</code> 数组，针对 ArrayList 的操作都是操作此数组。当数组长度不够时，调用 <code>elementData = Arrays.copyOf(elementData, newCapacity);</code> 方法，创建一个新的数组，并复制原有数组的数据到新的数组。</p>
                            <pre class="brush: java;">
public class ArrayList&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess,
                                Cloneable, java.io.Serializable {
    public ArrayList() {}
    public ArrayList(Collection&lt;? extends E> c) {}
    public ArrayList(int initialCapacity) {} // 构造一个具有指定初始容量的空列表
}
</pre>
                            <ol>

                                <li><p><code>boolean 	add(E e)</code> -- 将指定的元素添加到此列表的尾部</p></li>
                                <li><p><code>void 	add(int index, E element)</code> -- 将指定的元素插入此列表中的指定位置</p></li>
                                <li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 按 collection 的迭代器顺序，将所有元素添加到此列表的尾部</p></li>
                                <li><p><code>boolean 	addAll(int index, Collection&lt;? extends E> c)</code> -- 从指定的位置将 collection 中所有元素插入到此列表中</p></li>

                                <li class="group"><p><code>E 	remove(int index)</code> -- 移除此列表中指定位置上的元素</p></li>
                                <li><p><code>boolean 	remove(Object o)</code> -- 移除此列表中首次出现的指定元素</p></li>
                                <li><p><code>protected  void 	removeRange(int from, int to)</code> -- 移除索引在 from（包括）和 to（不包括）之间的所有元素</p></li>
                                <li><p><code>void 	clear()</code> -- 移除此列表中的所有元素</p></li>

                                <li class="group"><p><code>E 	set(int index, E element)</code> -- 用指定的元素替代此列表中指定位置上的元素</p></li>

                                <li class="group"><p><code>E 	get(int index)</code> -- 返回此列表中指定位置上的元素。</p></li>
                                <li><p><code>int 	indexOf(Object o)</code> -- 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。</p></li>
                                <li><p><code>int 	lastIndexOf(Object o)</code> -- 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。</p></li>
                                <li><p><code>boolean 	contains(Object o)</code> --  如果此列表中包含指定的元素，则返回 true。</p></li>

                                <li class="group"><p><code>void 	ensureCapacity(int minCapacity)</code> -- 如有必要，增加此 ArrayList 实例的容量</p></li>
                                <li><p><code>boolean 	isEmpty()</code> -- 如果此列表中没有元素，则返回 true</p></li>
                                <li><p><code>int 	size()</code> -- 返回此列表中的元素数</p></li>
                                <li><p><code>void 	trimToSize()</code> -- 将此 ArrayList 实例的容量调整为列表的当前大小</p></li>
                                <li><p><code>Object 	clone()</code> -- 返回此 ArrayList 实例的浅表副本</p></li>

                                <li class="group"><p><code>void 	forEach(Consumer&lt;? super E> action)</code> -- 和 <code>for</code> 循环一样</p></li>
                                <li><p><code>Iterator&lt;E> 	iterator()</code> -- 返回迭代器</p></li>
                                <li><p><code>ListIterator&lt;E> 	listIterator()</code> -- 返回 ListIterator 迭代器</p></li>
                                <li><p><code>ListIterator&lt;E> 	listIterator(int index)</code> -- 返回指定索引开始的 ListIterator 迭代器</p></li>
                                <li><p><code>boolean 	removeAll(Collection&lt;?> c)</code> -- 移除在 c 中的元素</p></li>
                                <li><p><code>boolean 	removeIf(Predicate&lt;? super E> filter)</code> -- 移除所有符合条件项</p>
                                <pre class="brush: java;">
ArrayList&lt;Integer> a1 = new ArrayList<>();
Collections.addAll(a1, 1, 2, 3, 4);
a1.removeIf(filter -> filter % 2 == 0); // 移除了偶数，a1 = [1, 3]
</pre>
                                </li>
                                <li><p><code>void 	replaceAll(UnaryOperator&lt;E> operator)</code> -- 替换所有符合条件项</p>
                                    <pre class="brush: java;">
ArrayList&lt;nteger> a1 = new ArrayList<>();
Collections.addAll(a1, 1, 2, 3, 4);
a1.replaceAll(operator -> operator % 2 == 0 ? operator * operator : operator); // a1 = [1, 4, 3, 16]
</pre>
                                </li>
                                <li><p><code>boolean 	retainAll(Collection&lt;?> c)</code> -- 仅保留那些也包含在 c 的元素</p></li>
                                <li><p><code>void 	sort(Comparator&lt;? super E> c)</code> -- 指定比较器排序</p></li>
                                <li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 返回可分割迭代器，用于并行迭代</p></li>
                                <li><p><code>List&lt;E> 	subList(int fromIndex, int toIndex)</code> -- 返回在 from（包括）和 to（不包括）子列表</p></li>

                                <li class="group"><p><code>Object[] 	toArray()</code> -- 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组</p></li>
                                <li><p><code>&lt;T> T[] toArray(T[] a)</code> -- 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组</p></li>

                            </ol>

                            <p><a href="docs/docs-java/api/java/util/AbstractSequentialList.html" target="_blank">AbstractSequentialList</a> 此类提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作。对于随机访问数据（如数组），应该优先使用 AbstractList，而不是先使用此类。</p>
                            <pre class="brush: java;">
public abstract class AbstractSequentialList&lt;E> extends AbstractList&lt;E> {
    public abstract ListIterator listIterator(int index);
}
</pre>
                            <ul>
                                <li><p>对于不可修改的列表，程序员只需要实现列表迭代器的 <code>hasNext</code>、<code>next</code>、<code>hasPrevious</code>、<code>previous</code> 和 <code>index</code> 方法即可；</p></li>
                                <li><p>对于可修改的列表，程序员应该再另外实现列表迭代器的 <code>set</code> 方法。对于可变大小的列表，程序员应该再另外实现列表迭代器的 <code>remove</code> 和 <code>add</code> 方法。</p></li>
                            </ul>


                            <p><a href="docs/docs-java/api/java/util/LinkedList.html" target="_blank">LinkedList</a> 是 List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p>
                            <p>此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。</p>
                            <p>所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表。</p>
                            <pre class="brush: java;">
public class LinkedList&lt;E> extends AbstractSequentialList&lt;E> implements List&lt;E>, Deque&lt;E>,
                                Cloneable, Serializable {
    public LinkedList() {}
    public LinkedList(Collection&lt;? extends E> c) {}

    transient int size = 0;
    transient Node&lt;E> first; // 始终指向第一个元素
    transient Node&lt;E> last; // 始终指向最后一个元素

    /** 包装数据，一个指针指向前一个节点，一个指针指向下一个节点 */
    private static class Node&lt;E> {
        E item; // 真实数据值
        Node&lt;E> next; // 指向下一个元素
        Node&lt;E> prev; // 指向前一个元素

        Node(Node&lt;E> prev, E element, Node&lt;E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
}
</pre>
                            <div class="panel panel-default">
                                <div class="panel-heading">
                                    <a data-toggle="collapse" data-parent="#accordion"
                                       href="#java-util-LinkedList-example" aria-expanded="true"
                                       class="code-header">
                                        <span class="glyphicon glyphicon-plus"></span> View Code - Sample
                                    </a>
                                </div>
                                <div id="java-util-LinkedList-example" class="panel-collapse collapse"
                                     style="" aria-expanded="true">
							<pre class="brush: java;">
/** 一个简单的链表，只有 add(E), size(), get(Int) 方法 */
public class MyLink&lt;E> {
    private Node&lt;E> first;
    private Node&lt;E> last;
    private int size;

    public void add(E v) {
        final Node&lt;E> l = last;
        final Node&lt;E> newNode = new Node<>(l, v, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
    }

    public int size() {
        return size;
    }

    private Node&lt;E> node(int index) {
        if (index < (size >> 1)) { // 从 first 到 last 搜索
            Node&lt;E> x = first;
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else { // 从 last 到 first 搜索
            Node&lt;E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.pre;
            return x;
        }
    }

    public E get(int index) {
        if(index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        return node(index).value;
    }

    class Node&lt;E> {
        Node pre;
        Node next;
        E value;

        public Node(Node&lt;E> prev, E element,  Node&lt;E> next) {
            this.value = element;
            this.next = next;
            this.pre = prev;
        }
    }
}
</pre>
                                </div>
                            </div>
                            <ol>
                                <li><p><code>boolean 	add(E e)</code> -- 将指定元素添加到此列表的结尾</p></li>
                                <li><p><code>void 	addFirst(E e)</code> -- 将指定元素插入此列表的开头</p></li>
                                <li><p><code>void 	addLast(E e)</code> -- 将指定元素添加到此列表的结尾</p></li>
                                <li><p><code>void 	add(int index, E element)</code> -- 在此列表中指定的位置插入指定的元素</p></li>
                                <li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 添加指定 collection 中的所有元素到此列表的结尾</p></li>
                                <li><p><code>boolean 	addAll(int index, Collection&lt;? extends E> c)</code> -- 将指定 collection 中的所有元素从指定位置开始插入此列表</p></li>

                                <li class="group"><p><code>boolean 	offer(E e)</code> -- 调用 <code>add(E)</code></p></li>
                                <li><p><code>boolean 	offerFirst(E e)</code> -- 调用 <code>addFirst(E)</code></p></li>
                                <li><p><code>boolean 	offerLast(E e)</code> -- 调用 <code>addLast(E)</code></p></li>

                                <li class="group"><p><code>E 	get(int index)</code> -- 返回此列表中指定位置处的元素</p></li>
                                <li><p><code>int 	size()</code> -- 返回此列表的元素数</p></li>
                                <li><p><code>E 	set(int index, E element)</code> -- 将此列表中指定位置的元素替换为指定的元。</p></li>
                                <li><p><code>E 	getFirst()</code> -- 返回此列表的第一个元素，无则抛出异常</p></li>
                                <li><p><code>E 	getLast()</code> -- 返回此列表的最后一个元素，无则抛出异常</p></li>
                                <li><p><code>E 	element()</code> -- 调用 <code>getFirst()</code></p></li>
                                <li><p><code>int 	indexOf(Object o)</code> -- 返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1</p></li>
                                <li><p><code>int 	lastIndexOf(Object o)</code> -- 返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1</p></li>

                                <li class="group"><p><code>E 	peek()</code> -- 获取但不移除此列表的头（第一个元素）；如果此列表为空，则返回 null</p></li>
                                <li><p><code>E 	peekFirst()</code> -- 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null</p></li>
                                <li><p><code>E 	peekLast()</code> -- 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null</p></li>

                                <li class="group"><p><code>E 	remove(int index)</code> -- 移除此列表中指定位置处的元素</p></li>
                                <li><p><code>void 	clear()</code> -- 从此列表中移除所有元素</p></li>
                                <li><p><code>boolean 	remove(Object o)</code> -- 从此列表中移除首次出现的指定元素（如果存在）</p></li>
                                <li><p><code>E 	removeFirst()</code> -- 移除并返回此列表的第一个元素，无则抛出异常</p></li>
                                <li><p><code>E 	removeLast()</code> -- 移除并返回此列表的最后一个元素，无则抛出异常</p></li>
                                <li><p><code>E 	remove()</code> -- 调用 <code>removeFirst()</code></p></li>
                                <li><p><code>boolean 	removeFirstOccurrence(Object o)</code> -- 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）</p></li>
                                <li><p><code>boolean 	removeLastOccurrence(Object o)</code> -- 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）</p></li>

                                <li class="group"><p><code>E 	poll()</code> -- 获取并移除此列表的头；如果此列表为空，则返回 null。</p></li>
                                <li><p><code>E 	pollFirst()</code> -- 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。</p></li>
                                <li><p><code>E 	pollLast()</code> -- 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。</p></li>

                                <li class="group"><p><code>E 	pop()</code> -- 调用 <code>removeFirst()</code></p></li>
                                <li><p><code>void 	push(E e)</code> -- 调用 <code>addFirst(E)</code></p></li>


                                <li class="group"><p><code>Object 	clone()</code> -- 返回此 LinkedList 的浅表副本</p></li>
                                <li><p><code>boolean 	contains(Object o)</code> -- 如果此列表包含指定元素，则返回 true</p></li>
                                <li><p><code>Iterator&lt;E> 	descendingIterator()</code> -- 返回以逆向顺序在此双端队列的元素上进行迭代的迭代器</p></li>
                                <li><p><code>ListIterator&lt;E> 	listIterator(int index)</code> -- 返回此列表中的元素的列表迭代器（按适当顺序），从列表中指定位置开始</p></li>
                                <li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 返回可分割迭代器，用于并行迭代</p></li>

                                <li class="group"><p><code>Object[] 	toArray()</code> -- 返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组</p></li>
                                <li><p><code>&lt;T> T[] toArray(T[] a)</code> -- 返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组；返回数组的运行时类型为指定数组的类型</p></li>
                            </ol>


                            <p><a href="docs/docs-java/api/java/util/Vector.html" target="_blank">Vector</a> 类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。但是，Vector 的大小可以根据需要增大或缩小，以适应创建 Vector 后进行添加或移除项的操作。 </p>
                            <p>每个向量会试图通过维护 capacity 和 capacityIncrement 来优化存储管理。capacity 始终至少应与向量的大小相等；这个值通常比后者大些，因为随着将组件添加到向量中，其存储将按 capacityIncrement 的大小增加存储块。应用程序可以在插入大量组件前增加向量的容量；这样就减少了增加的重分配的量。</p>
                            <p>Vector 和 ArrayList 最大区别是: <b>Vector 是线程安全的</b>，Vector 类对集合的元素操作时都加了 <code>synchronized</code>，保证线程安全。</p>
                            <pre class="brush: java;">
public class Vector&lt;E> extends AbstractList&lt;E> implements List&lt;E>,
                                RandomAccess, Cloneable, Serializable {
    protected  int capacityIncrement; // 向量的大小大于其容量时，容量自动增加的量
    protected  int 	elementCount; // Vector 对象中的有效组件数
    protected  Object[] elementData; // 存储向量组件的数组缓冲区。

    public Vector() {}
    public Vector(Collection&lt;? extends E> c) {}
    public Vector(int initialCapacity) {} // 使用指定的初始容量和等于零的容量增量构造一个空向量
    public Vector(int initialCapacity, int capacityIncrement) {} // 使用指定的初始容量和容量增量构造一个空的向量
}
</pre>
							<ol>
								<li><p><code>boolean 	add(E e)</code> -- 将指定元素添加到此向量的末尾</p></li>
								<li><p><code>void 	addElement(E obj)</code> -- 同 <code>add(E)</code>, 无返回值</p></li>
								<li><p><code>void 	add(int index, E element)</code> -- 在此向量的指定位置插入指定的元素</p></li>
								<li><p><code>void 	insertElementAt(E obj, int index)</code> -- 同 <code>add(E, int)，无返回值</code></p></li>
								<li><p><code>boolean 	addAll(Collection&lt;? extends E> c)</code> -- 将指定 Collection 中的所有元素添加到此向量的末尾</p></li>
								<li><p><code>boolean 	addAll(int index, Collection&lt;? extends E> c)</code> -- 在指定位置将指定 Collection 中的所有元素插入到此向量中</p></li>

								<li class="group"><p><code>E 	get(int index)</code> -- 返回向量中指定位置的元素</p></li>
								<li><p><code>E 	elementAt(int index)</code> -- 同 <code>get(int)</code></p></li>
								<li><p><code>E 	firstElement()</code> -- 返回此向量的第一个组件（位于索引 0) 处的项）</p></li>
								<li><p><code>E 	lastElement()</code> -- 返回此向量的最后一个组件</p></li>
								<li><p><code>List&lt;E> 	subList(int from, int to)</code> -- 返回此 List 的部分视图，元素范围为从 from（包括）到 to（不包括）</p></li>

								<li class="group"><p><code>E 	set(int index, E element)</code> -- 用指定的元素替换此向量中指定位置处的元素，并返回被替换的元素</p></li>
								<li><p><code>void 	setElementAt(E obj, int index)</code> -- 将此向量指定 index 处的组件设置为指定的对象</p></li>

								<li class="group"><p><code>E 	remove(int index)</code> -- 移除此向量中指定位置的元素，返回被移除的元素</p></li>
								<li><p><code>void 	removeElementAt(int index)</code> -- 删除指定索引处的组件</p></li>
								<li><p><code>boolean 	removeElement(Object obj)</code> -- 从此向量中移除变量的第一个（索引最小的）匹配项</p></li>
								<li><p><code>boolean 	remove(Object o)</code> -- 调用 <code>removeElement(Object)</code></p></li>
								<li><p><code>protected  void 	removeRange(int from, int to)</code> -- 移除其索引位于 from（包括）与 to（不包括）之间的所有元素</p></li>
								<li><p><code>boolean 	removeAll(Collection&lt;?> c)</code> -- 从此向量中移除包含在指定 Collection 中的所有元素</p></li>
								<li><p><code>void 	removeAllElements()</code> -- 从此向量中移除全部组件(将数组元素全部置为 null)，并将其大小设置为零</p></li>
								<li><p><code>void 	clear()</code> -- 调用 <code>removeAllElements()</code></p></li>

								<li class="group"><p><code>int 	capacity()</code> -- 返回此向量的当前容量</p></li>
								<li><p><code>int 	size()</code> -- 返回此向量中的组件数</p></li>
								<li><p><code>void 	setSize(int newSize)</code> -- 设置此向量的大小</p></li>
								<li><p><code>void 	ensureCapacity(int minCapacity)</code> -- 增加此向量的容量，以确保其至少能够保存最小容量参数指定的组件数</p></li>
								<li><p><code>void 	trimToSize()</code> -- 对此向量的容量进行微调，使其等于向量的当前大小</p></li>
								<li><p><code>boolean 	isEmpty()</code> -- 测试此向量是否不包含组件</p></li>

								<li class="group"><p><code>boolean 	contains(Object o)</code> -- 如果此向量包含指定的元素，则返回 true</p></li>
								<li><p><code>boolean 	containsAll(Collection&lt;?> c)</code> -- 如果此向量包含指定 Collection 中的所有元素，则返回 true</p></li>
								<li><p><code>int 	indexOf(Object o)</code> -- 返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1</p></li>
								<li><p><code>int 	indexOf(Object o, int index)</code> -- 返回此向量中第一次出现的指定元素的索引，从 index 处正向搜索</p></li>
								<li><p><code>int 	lastIndexOf(Object o)</code> -- 返回此向量中最后一次出现的指定元素的索引；如果此向量不包含该元素，则返回 -1</p></li>
								<li><p><code>int 	lastIndexOf(Object o, int index)</code> -- 返回此向量中最后一次出现的指定元素的索引，从 index 处逆向搜索</p></li>


								<li class="group"><p><code>boolean 	retainAll(Collection&lt;?> c)</code> -- 在此向量中仅保留包含在指定 Collection 中的元素</p></li
								<li><p><code>Enumeration&lt;E> 	elements()</code> -- 返回此向量的组件的枚举</p></li>

								<li class="group"><p><code>void 	copyInto(Object[] anArray)</code> -- 将此向量的组件复制到指定的数组中</p></li>
								<li><p><code>Object[] 	toArray()</code> -- 返回一个数组，包含此向量中以恰当顺序存放的所有元素</p></li>
								<li><p><code>&lt;T> T[] toArray(T[] a)</code> -- 返回一个数组，包含此向量中以恰当顺序存放的所有元素；返回数组的运行时类型为指定数组的类型</p></li>

								<li class="group"><p><code>Object 	clone()</code> -- 返回向量的一个副本</p></li>
								<li><p><code>boolean 	equals(Object o)</code> -- 比较指定对象与此向量的相等性</p></li>
								<li><p><code>String 	toString()</code> -- 返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式</p></li>
								<li><p><code>int 	hashCode()</code> -- 返回此向量的哈希码值</p></li>

                                <li class="group"><p><code>void 	forEach(Consumer&lt;? super E> action)</code> -- 参照 <code>ArrayList</code></p></li>
                                <li><p><code>Iterator&lt;E> 	iterator()</code> -- 参照 <code>ArrayList</code></p></li>
                                <li><p><code>ListIterator&lt;E> 	listIterator()</code> -- 参照 <code>ArrayList</code></p></li>
                                <li><p><code>ListIterator&lt;E> 	listIterator(int index)</code> -- 参照 <code>ArrayList</code></p></li>
                                <li><p><code>boolean 	removeIf(Predicate&lt;? super E> filter)</code> -- 参照 <code>ArrayList</code></p></li>
                                <li><p><code>void 	replaceAll(UnaryOperator&lt;E> operator)</code> -- 参照 <code>ArrayList</code></p></li>
                                <li><p><code>void 	sort(Comparator&lt;? super E> c)</code> -- 参照 <code>ArrayList</code></p></li>
                                <li><p><code>Spliterator&lt;E> 	spliterator()</code> -- 参照 <code>ArrayList</code></p></li>
							</ol>



                            <p><a href="docs/docs-java/api/java/util/Stack.html" target="_blank">Stack</a> 类表示后进先出（LIFO）的对象堆栈，是线程安全的。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。它提供了通常的 push 和 pop 操作，以及取堆栈顶点的 peek 方法、测试堆栈是否为空的 empty 方法、在堆栈中查找项并确定到堆栈顶距离的 search 方法。 </p>
                            <p>Deque 接口及其实现提供了 LIFO 堆栈操作的更完整和更一致的 set，应该优先使用此 set，而非此类。</p>
                            <pre class="brush: java;">
public class Stack&lt;E> extends Vector&lt;E> {
    public Stack() {}
}
</pre>
                            <ol>
                                <li><p><code>boolean 	empty()</code> -- 同 <code>isEmpty()</code></p></li>
                                <li><p><code>E 	peek()</code> -- 同 <code>lastElement()</code>，抛出的异常不同</p></li>
                                <li><p><code>E 	pop()</code> -- 先调用 <code>peek()</code>, 再移除最后一个元素</p></li>
                                <li><p><code>E 	push(E item)</code> -- 调用 <code>addElement(E)</code>, 返回 item</p></li>
                                <li><p><code>int 	search(Object o)</code> -- 从 1 开始，从后面往前数, 如: <code>["aa", "bb"], search("aa") == 2</code></p></li>
                            </ol>

                        </div>

                        <div class="sub-item">
                            <p><a href="docs/docs-java/api/java/util/AbstractSet.html" target="_blank">AbstractSet</a></p>
                        </div>

                        <div class="sub-item">
                            <p><a href="docs/docs-java/api/java/util/AbstractMap.html" target="_blank">AbstractMap</a> 此类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作。</p>
                            <ul>
                                <li><p>要实现不可修改的映射，编程人员只需扩展此类并提供 entrySet 方法的实现即可，该方法将返回映射的映射关系 set 视图。通常，返回的 set 将依次在 AbstractSet 上实现。此 set 不支持 add 或 remove 方法，其迭代器也不支持 remove 方法； </p></li>
                                <li><p>要实现可修改的映射，编程人员必须另外重写此类的 put 方法（否则将抛出 UnsupportedOperationException），entrySet().iterator() 返回的迭代器也必须另外实现其 remove 方法。 </p></li>
                            </ul>


                            <p><a href="docs/docs-java/api/java/util/HashMap.html" target="_blank">HashMap</a> 基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。</p>
                            <p>除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。</p>
                            <p>此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>

                            <pre class="brush: java;">
public class HashMap&lt;K,V> extends AbstractMap&lt;K,V> implements Map&lt;K,V>, Cloneable, Serializable {
    transient Node&lt;K,V>[] table; // 内部存储的还是包装了的数组

    static class Node&lt;K,V> implements Map.Entry&lt;K,V> {
        final int hash;
        final K key;
        V value;
        Node&lt;K,V> next;

        Node(int hash, K key, V value, Node&lt;K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public HashMap() {}
    public HashMap(int initialCapacity) {}
    public HashMap(int initialCapacity, float loadFactor) {}
    public HashMap(Map&lt;? extends K,? extends V> m) {}
}
</pre>
                            <ol>
                                <li><p><code>V 	put(K key, V value)</code> -- 添加一个键值对，如果 <code>key</code> 已存在，则替换对应的 <code>value</code>, 并返回被替换的 <code>value</code></p></li>
                                <li><p><code>V 	get(Object key)</code> -- 返回指定键所映射的值</p></li>
                                <li><p><code>V 	remove(Object key)</code> -- 如果存在指定的键，则移除此键值对</p></li>
                                <li><p><code>V 	replace(K key, V value)</code> -- 如果存在指定的键，则将值天替换为指定值</p></li>
                                <li><p><code>boolean 	remove(Object key, Object value)</code> -- 如果存在指定键和值，则移除此键值对</p></li>
                                <li><p><code>boolean 	replace(K key, V oldValue, V newValue)</code> -- 如果存在指定的键和值，则将值天替换为指定值</p></li>
                                <li><p><code>V 	getOrDefault(Object key, V defaultValue)</code> -- 如果不存在指定的键，则返回默认值</p></li>

                                <li class="group"><p><code>int 	size()</code> -- 返回此映射中的键-值映射关系数</p></li>
                                <li><p><code>boolean 	isEmpty()</code> -- 是否为空</p></li>
                                <li><p><code>void 	clear()</code> -- 青海粗</p></li>

                                <li class="group"><p><code>boolean 	containsKey(Object key)</code> -- 是否包含指定的键</p></li>
                                <li><p><code>boolean 	containsValue(Object value)</code> -- 是否包含指定的值</p></li>
                                <li><p><code>Set&lt;Map.Entry&lt;K,V>> 	entrySet()</code> -- 返回 <code>key-value</code> 的 <code>Set</code> 视图</p></li>
                                <li><p><code>Collection&lt;V> 	values()</code> -- 返回值的 <code>Collection</code> 视图</p></li>
                                <li><p><code>Set&lt;K> 	keySet()</code> -- 返回 <code>key</code> 的 <code>Set</code> 视图</p></li>

                                <li class="group"><p><code>V 	compute(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- </p></li>
                                <li><p><code>V 	computeIfAbsent(K key, Function&lt;? super K,? extends V> mappingFunction)</code> -- </p></li>
                                <li><p><code>V 	computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V> remappingFunction)</code> -- </p></li>

                                <li class="group"><p><code>void 	putAll(Map&lt;? extends K,? extends V> m)</code> --   将指定映射的所有映射关系复制到此映射中</p></li>
                                <li><p><code>void 	replaceAll(BiFunction&lt;? super K,? super V,? extends V> function)</code> -- </p></li>
                                <li><p><code>V 	merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V> remappingFunction)</code> -- </p></li>
                                <li><p><code>Object 	clone()</code> -- 复制</p></li>

                                <li class="group"><p><code>void 	forEach(BiConsumer&lt;? super K,? super V> action)</code> -- 键值迭代器</p>
                                    <pre class="brush: java;">
hashMap.forEach(new BiConsumer() {
    @Override
    public void accept(Object key, Object value) {
        log(key, value);
    }
});
</pre>
                                </li>
                                <li><p><code>V 	putIfAbsent(K key, V value)</code> -- 如果指定的 <code>key</code> 已经在 map 中，并且其值不为 null，返回原有的 <code>value</code>；否则同 <code>put(K, V)</code>，并返回 null</p></li>
                            </ol>
                        </div>

                        <div class="sub-item">
                            <p><a href="docs/docs-java/api/java/util/AbstractQueue.html" target="_blank">AbstractQueue</a></p>
                        </div>

                    </div>
                </div>
                <!-- item over -->

                <a class="offset" id="java-util-Formatter"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Formatter</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">
java.lang.Object
    java.util.Formatter

public final class Formatter implements Closeable, Flushable {

}
</pre>
                        <p><a href="docs/docs-java/api/java/util/Formatter.html" target="_blank">Formatter</a> 是 <code>printf</code> 风格的格式字符串的解释程序。此类提供了对布局对齐和排列的支持，以及对数值、字符串和日期/时间数据的常规格式和特定于语言环境的输出的支持。</p>
                        <p>Java 语言的格式化输出在很大程度上受到 C 语言 printf 的启发。虽然一些格式字符串与 C 类似，但已进行了某些定制，以适应 Java 语言，并且利用了其中一些特性。此外，Java 的格式比 C 的格式更严格；例如，如果转换与标志不兼容，则会抛出异常。在 C 中，不适用的标志会被忽略。这样，便于 C 程序员识别这些格式字符串，而又不必与 C 中的那些标志完全兼容。</p>

                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-Observable"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Observable</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">

						</pre>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-UUID"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">UUID</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">

						</pre>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-concurrent-Executor"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">java.util.concurrent.Executor 及实现类</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">

						</pre>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-util-concurrent-Future"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">java.util.concurrent.Future 及实现类</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">

						</pre>
                    </div>
                </div>
                <!-- item over -->


                <!-- item start -->
                <a class="offset" id="java-io-File"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">File</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">

						</pre>
                    </div>
                </div>
                <!-- item over -->

                <!-- item start -->
                <a class="offset" id="java-"></a>
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">...</h3>
                    </div>
                    <div class="panel-body">
						<pre class="brush: java;">

						</pre>
                    </div>
                </div>
                <!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
		<a target="_blank" href="./docs/docs-java/api-zh/index.html"
			type="button" class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> DOCS-6 </a>
		<a target="_blank" href="./docs/docs-java/api/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-8 </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushXml.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>