<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="keywords" content="key1, key2" />
<meta name="description" content=””>
<meta name="author" content="nate">
<meta name="author" content="nate &lt;jiwanger@126.com&gt;">
<link href="images/favicon.ico" rel="bookmark" type="image/x-icon" />
<link href="images/favicon.ico" rel="icon" type="image/x-icon" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<title>NATE--笔记--JDK</title>
<!-- Bootstrap -->
<link href="../support/bootstrap/theme/yeti-bootstrap.min.css"
	rel="stylesheet">
<!-- 
<link href="../support/bootstrap/css/bootstrap.css" rel="stylesheet">
-->
<link type="text/css" rel="stylesheet"
	href="../support/syntaxhighlighter/styles/shCoreDefault.css" />
<link href="../commons/css/common.css" rel="stylesheet">
<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
	<!-- nav start -->
	<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
		<div class="container-fluid">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target="#bs-example-navbar-collapse-1">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="../index.html">
					<img src="../commons/images/icon.png">
				</a>
			</div>

			<div class="collapse navbar-collapse"
				id="bs-example-navbar-collapse-1" >
				<ul id="my-nav" class="nav navbar-nav">

				</ul>
			</div>
		</div>
	</nav>
	<!-- nav end -->

	<div class="container">
		<div class="row">
			<!-- left-menu start -->
			<div class="col-md-3">
				<div class="panel panel-default"
					  id="left_menu_modify">
					<div class="panel-heading">
						<h3 class="panel-title">JDK</h3>
					</div>
					<div class="list-group">
						<a href="#jdk-intro" class="list-group-item">简介</a>
						<a class="list-group-item active dropdown" data-toggle="collapse"
							data-parent="#accordion" href="#java-lang" aria-expanded="true">
							<code>java.lang</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-lang" class="panel-collapse collapse"
							role="tabpanel">
							<a href="#java-lang-Object" class="list-group-item">Object</a>
							<a href="#java-lang-Class" class="list-group-item">Class</a>
							<a href="#java-lang-Package" class="list-group-item">Package</a>
							<a href="#java-lang-System" class="list-group-item">System</a>
							<a href="#java-lang-Process" class="list-group-item">Process</a>
							<a href="#java-lang-Runtime" class="list-group-item">Runtime</a>
							<a href="#java-lang-" class="list-group-item"></a>
						</div>


						<a class="list-group-item active drop" data-toggle="collapse"
						   data-parent="#accordion" href="#java-xxx" aria-expanded="true" style="border-top: 1px solid #DDDDDD;">
							<code>java...</code><span class="caret pull-right" style="margin-top: 5px;"></span>
						</a>
						<div id="java-xxx" class="panel-collapse collapse"
							 role="tabpanel">
							<a href="#java-" class="list-group-item"></a>
						</div>

						<a href="#java-" class="list-group-item">...</a>
					</div>
				</div>
			</div>
			<!-- left-menu over -->
		</div>
	</div>


	<div class="container" style="margin-top: 70px;">
		<div class="row">
			<div class="col-md-9 col-md-push-3" style="float: left;">
				<!-- item start -->
				<a class="offset" id="jdk-intro"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">简介</h3>
					</div>
					<div class="panel-body">
						<p>JDK 是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的 java 应用程序。JDK 是整个
							java 开发的核心，它包含了 JAVA 的运行环境（JVM + Java 系统类库）和 JAVA 工具。</p>
						<p>
							<b>以下是各版本的名称及发布日期：</b>
						</p>
						<table class="table table-bordered table-responsive">
							<tbody>
								<tr>
									<td><div>版本</div></td>
									<td><div>名称</div></td>
									<td><div>发行日期</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.4</div></td>
									<td><div>Sparkler（宝石）</div></td>
									<td><div>1997-09-12</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.5</div></td>
									<td><div>Pumpkin（南瓜）</div></td>
									<td><div>1997-12-13</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.6</div></td>
									<td><div>Abigail（阿比盖尔–女子名）</div></td>
									<td><div>1998-04-24</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.7</div></td>
									<td><div>Brutus（布鲁图–古罗马政治家和将军）</div></td>
									<td><div>1998-09-28</div></td>
								</tr>
								<tr>
									<td><div>JDK 1.1.8</div></td>
									<td><div>Chelsea（切尔西–城市名）</div></td>
									<td><div>1999-04-08</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.2</div></td>
									<td><div>Playground（运动场）</div></td>
									<td><div>1998-12-04</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.2.1</div></td>
									<td><div>none（无）</div></td>
									<td><div>1999-03-30</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.2.2</div></td>
									<td><div>Cricket（蟋蟀）</div></td>
									<td><div>1999-07-08</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.3</div></td>
									<td><div>Kestrel（美洲红隼）</div></td>
									<td><div>2000-05-08</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.3.1</div></td>
									<td><div>Ladybird（瓢虫）</div></td>
									<td><div>2001-05-17</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.4.0</div></td>
									<td><div>Merlin（灰背隼）</div></td>
									<td><div>2002-02-13</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.4.1</div></td>
									<td><div>grasshopper（蚱蜢）</div></td>
									<td><div>2002-09-16</div></td>
								</tr>
								<tr>
									<td><div>J2SE 1.4.2</div></td>
									<td><div>Mantis（螳螂）</div></td>
									<td><div>2003-06-26</div></td>
								</tr>
								<tr>
									<td><div>Java SE 5.0 (1.5.0)</div></td>
									<td><div>Tiger（老虎）</div></td>
									<td><div>2004-09-30</div></td>
								</tr>
								<tr>
									<td><div>Java SE 6.0 (1.6.0)</div></td>
									<td><div>Mustang（野马）</div></td>
									<td><div>2006-04</div></td>
								</tr>
								<tr>
									<td><div>Java SE 7.0 (1.7.0)</div></td>
									<td><div>Dolphin（海豚）</div></td>
									<td><div>2011-07-28</div></td>
								</tr>
								<tr>
									<td><div>Java SE 8.0 (1.8.0)</div></td>
									<td>Spider（蜘蛛）</td>
									<td><div>2014-03-18</div></td>
								</tr>
								<tr>
									<td colspan="1" rowspan="1">Java SE 9</td>
									<td colspan="1" rowspan="1"></td>
									<td colspan="1" rowspan="1">2017-09-21</td>
								</tr>
							</tbody>
						</table>
						<p>
							<b>JDK 各版本新增的主要特性</b>
						</p>
						<p>
							<b>JDK 5 新特性：</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. 自动装箱与拆箱：</p>
							<p>2. 枚举</p>
							<p>
								3. 静态导入，如：
								<code>import staticjava.lang.System.out</code>
							</p>
							<p>4. 可变参数（Varargs）</p>
							<p>5. 内省（Introspector），主要用于操作 JavaBean 中的属性，通过
								getXxx/setXxx。一般的做法是通过类 Introspector 来获取某个对象的 BeanInfo 信息，然后通过
								BeanInfo 来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的
								getter/setter 方法，然后我们就可以通过反射机制来调用这些方法。</p>
							<p>6. 泛型(Generic)（包括通配类型/边界类型等）</p>
							<p>7. For-Each 循环</p>
							<p>8. 注解</p>
							<p>9. 协变返回类型：实际返回类型可以是要求的返回类型的一个子类型</p>
						</div>
						<p>
							<b>JDK 6 新特性：</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. AWT 新增加了两个类: Desktop 和
								SystemTray，其中前者用来通过系统默认程序来执行一个操作，如使用默认浏览器浏览指定的URL,用默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以
								txt 为后缀名的文件),用系统默认的打印机打印文档等。后者可以用来在系统托盘区创建一个托盘程序</p>
							<p>2. 使用 JAXB2 来实现对象与 XML 之间的映射，可以将一个 Java 对象转变成为 XML 格式，反之亦然</p>
							<p>3. StAX，一种利用拉模式解析(pull-parsing)XML 文档的API。类似于
								SAX，也基于事件驱动模型。之所以将 StAX 加入到 JAXP 家族，是因为 JDK6 中的 JAXB2 和 JAX-WS
								2.0 中都会用 StAX。</p>
							<p>4.使用 Compiler API，动态编译 Java 源文件，如 JSP
								编译引擎就是动态的，所以修改后无需重启服务器。</p>
							<p>5. 轻量级 Http Server API，据此可以构建自己的嵌入式 HttpServer,它支持 Http 和
								Https 协议。</p>
							<p>6. 插入式注解处理 API(PluggableAnnotation Processing API)</p>
							<p>7. 提供了 Console 类用以开发控制台程序，位于 java.io 包中。据此可方便与 Windows 下的
								cmd 或 Linux 下的 Terminal 等交互。</p>
							<p>8. 对脚本语言的支持如: ruby, groovy, javascript</p>
							<p>9. Common Annotations，原是 J2EE 5.0 规范的一部分，现在把它的一部分放到了 J2SE
								6.0 中</p>
							<p>10. 嵌入式数据库 Derby</p>
						</div>
						<p>
							<b>JDK 7 新特性</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. 对 Java 集合（Collections）的增强支持，可直接采用 []、{} 的形式存入对象，采用 []
								的形式按照索引、键值来获取集合中的对象。如：
							<pre class="brush: java;">
List&lt;String&gt; list = [“item1”, ”item2”]; // 存
String item = list[0]; // 直接取
Set&lt;String&gt; set = {“item1”, ”item2”, ”item3”}; // 存
Map&lt;String, Integer&gt; map = {“key1”:1, ”key2”:2}; // 存
Int value = map[“key1”]; // 取
</pre>
							<p>2. 在 Switch 中可用 String</p>
							<p>3. 数值可加下划线用作分隔符（编译时自动被忽略）</p>
							<p>
								4. 支持二进制数字，如：
								<code>int binary = 0b1001_1001;</code>
							</p>
							<p>5. 简化了可变参数方法的调用</p>
							<p>6. 调用泛型类的构造方法时，可以省去泛型参数，编译器会自动判断。</p>
							<p>7. Boolean 类型反转，空指针安全,参与位运算</p>
							<p>
								8. char 类型的 equals 方法:
								<code>booleanCharacter.equalsIgnoreCase(char ch1, char
									ch2)</code>
							</p>
							<p>9. 安全的加减乘除:
							<pre class="brush: java;">
Math.safeToInt(longv); 
Math.safeNegate(int v);
Math.safeSubtract(long v1, int v2);
Math.safeMultiply(int v1, int v2);
......
</pre>
							<p>
								10. Map 集合支持并发请求，注 HashTable 是线程安全的，Map
								是非线程安全的。但此处更新使得其也支持并发。另外，Map 对象可这样定义：
								<code>Map map = {name:"xxx",age:18};</code>
							</p>
						</div>
						<p>
							<b>JDK 8 新特性</b>
						</p>
						<div style="margin-left: 20px;">
							<p>1.
								接口的默认方法：即接口中可以声明一个非抽象的方法做为默认的实现，但只能声明一个，且在方法的返回类型前要加上“default”关键字。
							</p>
							<p>2. Lambda 表达式：是对匿名比较器的简化，如：</p>
							<pre class="brush: java;">
Collections.sort(names,(String a, String b) -&gt; {
	returnb.compareTo(a);
});
</pre>
							<p>对于函数体只有一行代码的，你可以去掉大括号 {} 以及 return 关键字。如：</p>
							<pre class="brush: java;">
Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));
// 或
Collections.sort(names, (a, b) -&gt; b.compareTo(a));
</pre>
							<p>3. 函数式接口：是指仅仅只包含一个抽象方法的接口，要加 @FunctionalInterface 注解</p>
							<p>4. 使用 :: 关键字来传递方法或者构造函数引用</p>
							<p>5. 多重注解</p>
							<p>6. 还增加了很多与函数式接口类似的接口以及与Map相关的API等……</p>
						</div>
						<p>
							<b>JDK 9 新特性 </b>
						</p>
						<div style="margin-left: 20px;">
							<p>1. Jigsaw 项目：模块化 JDK 源码。</p>
							<p>2. 简化了的进程 API。</p>
							<p>3. 轻量级的 JSON API。</p>
							<p>4. 钱和货币的相关 API。</p>
							<p>5. 改善锁争用机制。</p>
							<p>6. 代码分段缓存。</p>
							<p>7. 智能 Java 编译工具。</p>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Object"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">java.lang.Object</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<p>
								<code>java.lang</code>
								包在使用的时候无需显示导入，编译时由编译器自动导入。
							</p>
						</div>

						<div class="sub-item">
							<pre class="brush: java;">
java.lang.Object

public class Object {}
</pre>

							<p><a href="docs/docs-java/api/java/lang/Object.html" target="_blank">Object</a> 类是类层次结构的根，Java中所有的类从根本上都继承自这个类。</p>
							<p>Object 类是 Java 中唯一没有父类的类。Java 中的每个类都具有定义在 Object 类中的这些方法。</p>
							<ol>
								<li>
									<p>
										<code>protected native Object clone()</code>
										-- 对象复制(浅层复制)。1.要实现 Cloneable; 2.覆写此方法要修改为 public
										修饰,才能让类外部的代码调用。
									</p>
									<p>
										<strong>浅层复制：&nbsp;</strong>被复制的对象的所有成员属性都有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅层复制仅仅复制所考虑的对象，而不复制它所引用的对象。
									</p>
									<p>
										<strong>深层复制：</strong>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不是原有的那些被引用的对象。换言之，深层复制要复制的对象引用的对象都复制一遍。
									</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-clone" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-clone" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
/**
 * 要实现 Cloneable
 */
public class Person implements Cloneable {
	private String name;
	private Student student;
	
	public Person() {
	}

	public Person(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	/**
	 * 覆写此方法修改为 public, 才能让类外部的代码调用
	 */
	@Override
	public Object clone() throws CloneNotSupportedException {
		// TODO Auto-generated method stub
		return super.clone();
	}
	
	private void testClone() throws CloneNotSupportedException {
		Person p1 = new Person();
		p1.setName("aaa");
		Person p2 = (Person) p1.clone();	// p2 也有 name=aaa属性
		p1.setName("bbb");
		System.out.println(p1.getName() + "==" + p2.getName());
		
		Student s1 = new Student();
		p1.setStudent(s1);
		
		Person p3 = (Person) p1.clone();
		Student s2 = p3.getStudent();
		System.out.println(s1 == s2);		// s1==s2, 说明p1和p3引用了同一个Student对象
	}
}
</pre>
										</div>
									</div>

									<p>
										<b>使用序列化实现深层复制:</b>
									</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-deepClone" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-deepClone" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
public class DeepClone {
	public static void main(String[] args) throws Exception {
		Teacher t = new Teacher();
		t.setName("Teacher Wang");
		t.setAge(50);

		Student s1 = new Student();
		s1.setAge(20);
		s1.setName("ZhangSan");
		s1.setTeacher(t);

		Student s2 = (Student) s1.deepClone();

		System.out.println("拷贝得到的信息:");
		System.out.println(s2.getName());
		System.out.println(s2.getAge());
		System.out.println(s2.getTeacher().getName());
		System.out.println(s2.getTeacher().getAge());
		System.out.println("---------------------------");

		// 将复制后的对象的老师信息修改一下：
		s2.getTeacher().setName("New Teacher Wang");
		s2.getTeacher().setAge(28);

		System.out.println("修改了拷贝对象的教师后：");
		System.out.println("拷贝对象的教师：");
		System.out.println(s2.getTeacher().getName());
		System.out.println(s2.getTeacher().getAge());
		System.out.println("原来对象的教师：");
		System.out.println(s1.getTeacher().getName());
		System.out.println(s1.getTeacher().getAge());

		// 由此证明序列化的方式实现了对象的深拷贝
	}

}

class Teacher implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;
	private int age;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}

class Student implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;
	private int age;
	private Teacher teacher;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public Teacher getTeacher() {
		return teacher;
	}

	public void setTeacher(Teacher teacher) {
		this.teacher = teacher;
	}

	/**
	 * 使用序列化实现深层复制
	 */ 
	public Object deepClone() throws Exception {
		// 序列化
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		ObjectOutputStream oos = new ObjectOutputStream(bos);

		oos.writeObject(this);

		// 反序列化
		ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
		ObjectInputStream ois = new ObjectInputStream(bis);

		return ois.readObject();
	}

}
</pre>
										</div>
									</div>
								</li>
								<li>
									<p>
										<code>public boolean equals(Object obj)</code>
										-- 两个对象是否相等。如果不覆写此方法，使用
										<code>return (this == obj);</code>
										,就是说同一个对象才返回 true。并且覆写equals()方法时，应该同时覆写hashCode()方法，反之亦然。
									</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-equals" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-equals" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
/**
 * 两个对象的 name 属性相等，返回　true
 */
@Override
public boolean equals(Object obj) {
	return this.name.equals(((Person) obj).getName());
}

public void testEquals() {
	Person p1 = new Person("aa");
	Person p2 = new Person("aa");
	System.out.println(p1.equals(p2));
}
</pre>
										</div>
									</div>
								</li>
								<li>
									<p>
										<code>public native int hashCode()</code>
										--
										Object 类的 hashCode() 方法为不同的对象返回不同的值，Object 类的 hashCode 值表示的是对象的地址。两个不相等的对象产生两个不同的 hashCode 可以改善哈希表的性能。
									</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-hashCode" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-hashCode" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
/**
 * 直接使用 name 的 hashCode 返回
 */
@Override
public int hashCode() {
	return this.name.hashCode();
}

public void testHashCode(){
	Person p1 = new Person("aa");
	Person p2 = new Person("aa");
	System.out.println(p1.hashCode() + "==" + p2.hashCode());
}
</pre>
										</div>
									</div>
								</li>
								<li>
									<p>
										<code>public String toString()</code>
										-- Object 的 toString 方法返回 className 和 hashCode 的十六进制值
									</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-toString" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-toString" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
// Object 的 toString 方法
return getClass().getName() + "@" + Integer.toHexString(hashCode());

@Override
public String toString() {
	return "Person [name=" + name + "]";
}
</pre>
										</div>
									</div>
								</li>
								<li>
									<p>
										<code>public final native Class&lt;?> getClass()</code>
										-- 返回该对象的运行时类的 Java.lang.Class 对象
									</p>
									<div class="panel panel-default">
										<div class="panel-heading">
											<a data-toggle="collapse" data-parent="#accordion"
												href="#jdk-Object-getClass" aria-expanded="true"
												class="code-header">
												<span class="glyphicon glyphicon-plus"></span> View Code
											</a>
										</div>
										<div id="jdk-Object-getClass" class="panel-collapse collapse"
											style="" aria-expanded="true">
											<pre class="brush: java;">
public class ObjectDemo {
	class Person {
		Person() {
			// 注意如果是实例化了子类的调用，这里打印的是运行时类的类名, 是 Student
			System.out.println("Person:" + getClass().getName());
		}
	}
	
	class Student extends Person {
		Student(){
			System.out.println("Student:" + getClass().getName());
		}
	}
	
	public static void main(String[] args) {
		/** 输出:
		 * Person:cm.nate.lang.ObjectDemo$Student
		 * Student:cm.nate.lang.ObjectDemo$Student
		 */
		new ObjectDemo().new Student();
	}
}
</pre>
										</div>
									</div>
								</li>
								<li>
									<p><code>protected void finalize()</code> -- 用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p>
								</li>
								<li>
									<p><code>notity</code>,<code>wait</code>,<code>notityAll</code>方法参见:<a href="index.html#java-thread">Java 多线程</a></p>
								</li>
							</ol>
						</div>

					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Class"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">java.lang.Class</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">Class 类</h5>
							<pre class="brush: java;">
java.lang.Object
	java.lang.Class&lt;T>

public final class Class&lt;T> implements java.io.Serializable, java.lang.reflect.GenericDeclaration,
	java.lang.reflect.Type, java.lang.reflect.AnnotatedElement {

}
</pre>
							<p><a href="docs/docs-java/api/java/lang/Class.html" target="_blank">Class</a> 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。</p>
							<p><a href="docs/docs-java/api/java/lang/Class.html" target="_blank">Class</a> 类没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。</p>
							<pre class="brush: java;">
Class&lt;MyClass> clazz = MyClass.class; // 类名直接访问
Class cls = obj.getClass(); // Object 的 getClass() 方法
</pre>
							<p><b>类的加载:</b></p>
							<ol>
								<li>
									<code>Class.forName</code>
									方式加载 -- 静态代码块 -> 如果调用 newInstance 方法 -> 非静态代码块 -> 构造方法
								</li>
								<li>
									<code>直接 new</code>
									-- 静态代码块 -> [如果加载过了 class -> 非静态代码块 -> 构造方法 | 没加载过 class ->
									静态代码块 -> 非静态代码块 -> 构造方法]
								</li>
							</ol>
							<div class="panel panel-default">
								<div class="panel-heading">
									<a data-toggle="collapse" data-parent="#accordion"
										href="#jdk-Class-load" aria-expanded="true"
										class="code-header">
										<span class="glyphicon glyphicon-plus"></span> View Code
									</a>
								</div>
								<div id="jdk-Class-load" class="panel-collapse collapse"
									style="" aria-expanded="true">
									<pre class="brush: java;">
public class ClassDemo {
	static {
		System.out.println("===静态代码块===");
	}
	
	{
		System.out.println("===非静态代码块===");
	}
	
	public ClassDemo() {
		System.out.println("===构造方法===");
	}
	
	// Class.forName 方式加载
	public static void testForName(){
		try {
			Class testTypeForName = Class.forName("cm.nate.lang.ClassDemo");
			testTypeForName.newInstance();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) {
		testForName();
		
		// 前面加载过class了,这里不会调用静态代码块 
		new ClassDemo();
	}
}
</pre>
								</div>
							</div>
                            <p><b>Class 类的常用方法:</b></p>
							<ol>
								<li>
									<p><code>static Class&lt;?> forName(String className)</code> -- 动态加载类。调用了 native 方法加载类</p>
								</li>
                                <li>
                                    <p><code>static Class&lt;?> 	forName(String name, boolean initialize, ClassLoader loader)</code> -- 使用给定的类加载器</p></li>
                                <li class="group">
                                    <p><code>native boolean isInterface()</code> -- 是否是接口</p>
                                </li>
                                <li>
                                    <p><code>native boolean isPrimitive()</code> -- 是否是基础类</p>
                                </li>
                                <li>
                                    <p><code>boolean isEnum()</code> -- 是否是枚举</p>
                                </li>
                                <li>
                                    <p><code>boolean isAnnotation()</code> -- 是否为注解类</p>
                                </li>
                                <li>
                                    <p><code>native boolean isArray()</code> -- 是否是数组</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isAnonymousClass()</code> -- 是否为匿名类</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isMemberClass()</code> -- 是否为成员类</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isSynthetic()</code> -- 是否为复合类(编译器生成的特殊类)</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isAssignableFrom(Class&lt;?> cls)</code> -- 此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isInstance(Object obj)</code> -- 对象是否为 class 的实例</p>
                                </li>
                                <li>
                                    <p><code>boolean 	isLocalClass()</code> -- 是否为局部类(在方法体中的类)</p>
                                </li>

                                <li class="group">
                                    <p><code>ClassLoader getClassLoader()</code> -- 获得类的类加载器</p>
                                </li>
                                <li>
                                    <p><code>Package getPackage()</code> -- 获得 package，参见相关类</p>
                                </li>
                                <li class="group">
                                    <p><code>Class&lt;?>[] getInterfaces()</code> -- 获得直接实现的接口列表</p>
                                </li>
                                <li>
                                    <p><code>Type[] getGenericInterfaces()</code> -- 直接实现接口的类型，参见相关类</p>
                                </li>
                                <li>
                                    <p><code>native Class&lt;? super T> getSuperclass()</code> -- 获取类的直接父类，继承了父类则返回父类，否则返回 Object</p>
                                </li>
                                <li>
                                    <p><code>Type 	getGenericSuperclass()</code> -- 直接继承类的类型，只有 Object 返回空，参见相关类</p>
                                </li>
                                <li class="group">
                                    <p><code>native int getModifiers()</code> -- 获得整数表示的修饰符，由 <a href="docs/docs-java/api/java/lang/reflect/Modifier.html" target="_blank">Modifier</a> 定义</p>
                                    <pre class="brush: java;">
/** Modifier 类定义以下常量，并且定义了相关 is 方法。
 * 因为修饰符有多个叠加，返回值需要计算：比如 public static 为 9
 */
public static final int PUBLIC           = 0x00000001;
public static final int PRIVATE          = 0x00000002;
public static final int PROTECTED        = 0x00000004;
public static final int STATIC           = 0x00000008;
public static final int FINAL            = 0x00000010;
public static final int SYNCHRONIZED     = 0x00000020;
public static final int VOLATILE         = 0x00000040;
public static final int TRANSIENT        = 0x00000080;
public static final int NATIVE           = 0x00000100;
public static final int INTERFACE        = 0x00000200;
public static final int ABSTRACT         = 0x00000400;
public static final int STRICT           = 0x00000800;
                                    </pre>
                                </li>
                                <li>
                                    <p><code>String getName()</code> -- 获取类或接口的名字，包括包名</p>
                                </li>
                                <li>
                                    <p><code>String getSimpleName()</code> -- 获得类名</p>
                                </li>
                                <li>
                                    <p><code>String 	getCanonicalName()</code> -- 同 getName(), 内部类的 <code>$</code> 变成 <code>.</code></p>
                                </li>
                                <li>
                                    <p><code>String getTypeName()</code> -- 如果是数组，获得数组数据类型名，否则返回类名</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?> 	getComponentType()</code> -- 返回表示数组组件类型的 Class</p>
                                </li>
                                <li>
                                    <p><code>TypeVariable&lt;Class&lt;T>>[] 	getTypeParameters()</code> -- 声明顺序返回类型变量对象的数组，就是下面的 <code>T, M</code></p>
                                    <pre class="brush: java;">
public class Test&lt;T, M> {}
                                    </pre>
                                </li>

                                <li class="group">
                                    <p><code>Constructor&lt;?>[] getConstructors()</code> -- 获得所有的构造函数</p>
                                </li>
                                <li>
                                    <p><code>Constructor&lt;T> getConstructor(Class&lt;?>... parameterTypes)</code> -- 获得指定参数类型的构造函数</p>
                                </li>
                                <li>
                                    <p><code>Constructor&lt;?>[] 	getDeclaredConstructors()</code> -- 自己的构造方法</p>
                                </li>
                                <li>
                                    <p><code>Constructor&lt;T> 	getDeclaredConstructor(Class&lt;?>... parameterTypes)</code> -- 指定参数类型的自己的构造方法</p>
                                </li>

                                <li class="group">
                                    <p><code>Field[] getFields()</code> -- 获得字段数组(public 修饰的，包括继承的)</p>
                                </li>
                                <li>
                                    <p><code>Field 	getField(String name)</code> -- 获取指定名字字段(public 修饰的，包括继承的)</p>
                                </li>
                                <li>
                                    <p><code>Field[] 	getDeclaredFields()</code> -- 自己的所有字段列表，不包括父类</p>
                                </li>
                                <li>
                                    <p><code>Field 	getDeclaredField(String name)</code> -- 指定名字的自己的字段</p>
                                </li>
                                <li>
                                    <p><code>T[] getEnumConstants()</code> -- 获取枚举常量数组</p>
                                </li>

                                <li class="group">
                                    <p><code>Method[] 	getDeclaredMethods()</code> -- 自己的所有方法列表，不包括父类</p>
                                </li>
                                <li>
                                    <p><code>Method 	getDeclaredMethod(String name, Class&lt;?>... parameterTypes)</code> -- 指定名字和参数类型的自己的方法</p>
                                </li>
                                <li>
                                    <p><code>Method[] getMethods()</code> -- 获得 public 方法(包括继承的)</p>
                                </li>
                                <li>
                                    <p><code>Method 	getMethod(String name, Class&lt;?>... parameterTypes)</code> -- 指定名字和参数类型的 public 方法(包括继承的)</p>
                                </li>

                                <li class="group">
                                    <p><code>Class&lt;?>[] 	getClasses()</code> -- public 的成员类</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?>[] 	getDeclaredClasses()</code> -- 所有成员类/接口/枚举</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?> 	getDeclaringClass()</code> -- 如果是成员类，则返回其包裹类</p>
                                </li>
                                <li>
                                    <p><code>Class&lt;?> 	getEnclosingClass()</code> -- 返回其包裹类(上一级的类)</p>
                                </li>
                                <li>
                                    <p><code>Constructor&lt;?> 	getEnclosingConstructor()</code> -- 如果局部类定义在构造方法中，返回局部类所在的构造方法</p>
                                </li>
                                <li>
                                    <p><code>Method 	getEnclosingMethod()</code> -- 如果局部类定义在普通方法中，返回局部类所在的方法</p>
                                </li>

                                <li class="group">
									<p><code>T newInstance()</code> -- 根据对象的 class 新建一个对象，用于反射。</p>
								</li>

								<li>
									<p><code>java.net.URL getResource(String name)</code> -- 返回文件的却对路径(file:/home/nate/....)</p>
								</li>
                                <li>
                                    <p><code>InputStream 	getResourceAsStream(String name)</code> -- 指定文件读取为流</p>
                                </li>
                                <li class="group">
                                    <p><code>&lt;A extends Annotation> A getAnnotation(Class&lt;A> annotationClass)</code> -- 如果存在指定类型的注释，则返回这些注释</p>
                                </li>
                                <li>
                                    <p><code>Annotation[] getAnnotations</code> -- 返回此元素上存在的所有注释</p>
                                </li>
                                <li>
                                    <p><code>&lt;A extends Annotation> A[] 	getAnnotationsByType(Class&lt;A> annotationClass)</code> -- 获取指定类型注解列表</p>
                                </li>
                                <li>
                                    <p><code>&lt;A extends Annotation> A[] getDeclaredAnnotationsByType(Class&lt;A> annotationClass)</code> -- 获取指定类型注解列表</p>
                                </li>
                                <li>
                                    <p><code>&lt;A extends Annotation> A getDeclaredAnnotation(Class&lt;A> annotationClass)</code> -- 获取指定类型注解</p>
                                </li>
                                <li>
                                    <p><code>Annotation[] getDeclaredAnnotations()</code> -- 直接存在于此元素上的所有注释</p>
                                </li>
                                <li>
                                    <p><code>boolean isAnnotationPresent(Class&lt;? extends Annotation> annotationClass)</code> -- 是否有指定注解存在此元素上</p>
                                </li>


                                <li class="group">
                                    <p><code>&lt;U> Class&lt;? extends U> 	asSubclass(Class&lt;U> clazz)</code> -- 强制转换为 <code>clazz</code> 的子类</p>
                                </li>
                                <li>
                                    <p><code>T 	cast(Object obj)</code> -- 强制类型转换</p>
                                </li>
                                <li>
                                    <p><code>boolean 	desiredAssertionStatus()</code> -- 如果要在调用此方法时将要初始化该类，则返回将分配给该类的断言状态</p>
                                </li>

                                <li class="group">
                                    <p><code>AnnotatedType[] 	getAnnotatedInterfaces()</code> -- 获取直接继承/实现带注解的接口列表</p>
                                </li>
                                <li>
                                    <p><code>AnnotatedType 	getAnnotatedSuperclass()</code> -- 获取直接继承带注解的类</p>
                                </li>



                                <li class="group">
                                    <p><code>ProtectionDomain 	getProtectionDomain()</code> -- 返回该类的 ProtectionDomain，参见相关类</p>
                                </li>
                                <li>
                                    <p><code>Object[] 	getSigners()</code> -- 获取类的签名，一般为 NULL</p>
                                </li>

                                <li>
                                    <p><code>String 	toGenericString()</code> -- 返回形式：<code>修饰符 + class/interface/enum + getName()</code></p>
                                </li>
                                <li>
                                    <p><code>String 	toString()</code> -- 返回形式：<code>interface / class + getName()</code></p>
                                </li>

							</ol>
							<div class="panel panel-default">
								<div class="panel-heading">
									<a data-toggle="collapse" data-parent="#accordion"
										href="#jdk-Class-clazz" aria-expanded="true"
										class="code-header">
										<span class="glyphicon glyphicon-plus"></span> View Code
									</a>
								</div>
								<div id="jdk-Class-clazz" class="panel-collapse collapse"
									style="" aria-expanded="true">
									<pre class="brush: java;">
public class MyReflect {
	public static void main(String[] args) {
		/** 类型 */
		System.out.println(Serializable.class.isInterface());
		System.out.println(ElementType.class.isEnum());
		System.out.println(Target.class.isAnnotation());
		String[] array = {};
		System.out.println(array.getClass().isArray());
	
		MyReflect testReflect = new MyReflect();
		Class&lt;?> clazz = testReflect.getClass();
		
		System.out.println("完整类名: " + clazz.getName());
		System.out.println("类名: " + clazz.getSimpleName());
		System.out.println("类型名: " + clazz.getTypeName());
		System.out.println("ClassLoader名: "
				+ clazz.getClassLoader().getClass().getName());
		System.out.println("父类: " + clazz.getSuperclass().getName());
		
		/** 实例化一个对象，并操作这个对象 */
		try {
			// 第一种方法，实例化默认构造方法，调用set赋值
			Class&lt;?> myClass = Class.forName("cm.nate.reflect.MyReflect");
			MyReflect mr = (MyReflect) myClass.newInstance();
			mr.setName("hello");
			System.out.println(mr.getName());
			
			// 取得指定的构造函数 使用构造函数赋值
			@SuppressWarnings("unchecked")
			Constructor&lt;MyReflect> constructor = 
				(Constructor&lt;MyReflect>) myClass.getConstructor(String.class);
			MyReflect mr2 = constructor.newInstance("jiwanger");
			System.out.println(mr2.getName());
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		/** 取得本类的全部属性 */
		Field[] field = clazz.getDeclaredFields();
        for (int i = 0; i &lt; field.length; i++) {
            // 权限修饰符
            int mo = field[i].getModifiers();
            String priv = Modifier.toString(mo);
            // 属性类型
            Class&lt;?> type = field[i].getType();
            System.out.println(priv + " " + type.getName() + " " + field[i].getName() + ";");
        }
        
        /** 获取某个类的全部方法 */
        Method method[] = clazz.getMethods();
        for (int i = 0; i &lt; method.length; ++i) {
            Class&lt;?> returnType = method[i].getReturnType();
            Class&lt;?> para[] = method[i].getParameterTypes();
            int temp = method[i].getModifiers();
            System.out.print(Modifier.toString(temp) + " ");
            System.out.print(returnType.getName() + "  ");
            System.out.print(method[i].getName() + " ");
            System.out.print("(");
            for (int j = 0; j &lt; para.length; ++j) {
                System.out.print(para[j].getName() + " " + "arg" + j);
                if (j &lt; para.length - 1) {
                    System.out.print(",");
                }
            }
            Class&lt;?> exce[] = method[i].getExceptionTypes();
            if (exce.length > 0) {
                System.out.print(") throws ");
                for (int k = 0; k &lt; exce.length; ++k) {
                    System.out.print(exce[k].getName() + " ");
                    if (k &lt; exce.length - 1) {
                        System.out.print(",");
                    }
                }
            } else {
                System.out.print(")");
            }
            System.out.println();
        }
        
        /** 反射机制调用某个类的方法 */
        try {
			Class&lt;?> myClass = Class.forName("cm.nate.reflect.MyReflect");
			// 调用TestReflect类中的reflect1方法
			
			// Java 反射机制 - 调用某个类的方法1.
			// 调用TestReflect的reflect2方法
			MyReflect mr3 = (MyReflect) myClass.newInstance();
			Method method2 = myClass.getMethod("setName", String.class);
			method2.invoke(mr3, "张三");
			
			Method method3 = myClass.getMethod("getName");
			String name = (String) method3.invoke(mr3);
			System.out.println(name);
			
		}  catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public MyReflect(){}
	
	public MyReflect(String name){
		this.name = name;
	}

	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

}
</pre>
								</div>
							</div>
						</div>

						<div class="sub-item">
                            <p><b><code>Class</code> 相关类：</b></p>
							<p><a href="docs/docs-java/api/java/lang/ClassLoader.html" target="_blank">ClassLoader</a> -- 是一个抽象类，负责加载类的对象。如果给定类的二进制名称，那么类加载器会试图查找或生成构成类定义的数据。一般策略是将名称转换为某个文件名，然后从文件系统读取该名称的“类文件”。 </p>
                            <p>每个 Class 对象都包含一个对定义它的 ClassLoader 的引用。 </p>
                            <p>数组类的 Class 对象不是由类加载器创建的，而是由 Java 运行时根据需要自动创建。数组类的类加载器由 <code>Class.getClassLoader()</code> 返回，该加载器与其元素类型的类加载器是相同的；如果该元素类型是基本类型，则该数组类没有类加载器。 </p>
                            <p>类加载器通常由安全管理器使用，用于指示安全域。</p>

                            <p>ClassLoader 类使用委托模型来搜索类和资源。每个 ClassLoader 实例都有一个相关的父类加载器。需要查找类或资源时，ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。虚拟机的内置类加载器（称为 "bootstrap class loader"）本身没有父类加载器，但是可以将它用作 ClassLoader 实例的父类加载器。</p>

                            <p>通常情况下，Java 虚拟机以与平台有关的方式，从本地文件系统中加载类。例如，在 UNIX 系统中，虚拟机从 CLASSPATH 环境变量定义的目录中加载类。</p>
                            <pre class="brush: java;">


public abstract class ClassLoader {
    protected 	ClassLoader() {}
    protected 	ClassLoader(ClassLoader parent) {}
}
                            </pre>
                            <ol>
                                <li><p><code>static ClassLoader 	getSystemClassLoader()</code> -- 返回委托的系统类加载器</p></li>
                                <li><p><code>static URL 	getSystemResource(String name)</code> -- 从用来加载类的搜索路径中查找具有指定名称的资源</p></li>
                                <li><p><code>static InputStream 	getSystemResourceAsStream(String name)</code> -- 以流的形式读取该资源</p></li>
                                <li><p><code>static Enumeration&lt;URL> 	getSystemResources(String name)</code> -- 从用来加载类的搜索路径中查找所有具有指定名称的资源</p></li>

                                <li class="group"><p><code>Class&lt;?> 	loadClass(String name)</code> -- 使用指定的二进制名称来加载类</p></li>
                                <li><p><code>protected Class&lt;?> 	loadClass(String name, boolean resolve)</code> -- 使用指定的二进制名称来加载类</p></li>

                                <li class="group"><p><code>protected Class&lt;?> 	findClass(String name)</code> -- 使用指定的二进制名称查找类</p></li>
                                <li><p><code>protected String 	findLibrary(String libname)</code> -- 返回本机库的绝对路径名</p></li>
                                <li><p><code>protected Class&lt;?> 	findLoadedClass(String name)</code> -- 如果 JVM 已将此加载器记录为具有给定二进制名称的某个类的启动加载器，则返回该二进制名称的类</p></li>
                                <li><p><code>protected URL 	findResource(String name)</code> -- 查找具有给定名称的资源</p></li>
                                <li><p><code>protected Enumeration&lt;URL> 	findResources(String name)</code> -- 返回表示所有具有给定名称的资源的 URL 对象的枚举</p></li>
                                <li><p><code>protected Class&lt;?> 	findSystemClass(String name)</code> --  查找具有指定的二进制名称的类，必要时加载它</p></li>


                                <li class="group"><p><code>protected Class&lt;?> 	defineClass(String name, byte[] b, int off, int len)</code> -- 将一个 byte 数组转换为 Class 类的实例</p></li>
                                <li><p><code>protected Class&lt;?> 	defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)</code> -- 使用可选的 ProtectionDomain 将一个 byte 数组转换为 Class 类的实例</p></li>
                                <li><p><code>protected Class<?> 	defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)</code> -- 使用可选的 ProtectionDomain 将 ByteBuffer 转换为 Class 类的实例</p></li>
                                <li><p><code>protected Package 	definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)</code> -- 根据 name 在此 ClassLoader 中定义包</p></li>

                                <li class="group"><p><code>protected Object 	getClassLoadingLock(String className)</code> -- 返回类加载操作的锁定对象</p></li>
                                <li><p><code>protected Package 	getPackage(String name)</code> --  返回由此类加载器或其任何祖先所定义的 Package</p></li>
                                <li><p><code>protected Package[] 	getPackages()</code> -- 返回此类加载器及其祖先所定义的所有 Package</p></li>
                                <li><p><code>ClassLoader 	getParent()</code> -- 返回委托的父类加载器</p></li>
                                <li><p><code>URL 	getResource(String name)</code> -- 查找具有给定名称的资源</p></li>
                                <li><p><code>InputStream 	getResourceAsStream(String name)</code> -- 返回读取指定资源的输入流</p></li>
                                <li><p><code>Enumeration&lt;URL> 	getResources(String name)</code> -- 查找所有给定名称的资源</p></li>

                                <li class="group"><p><code>protected static boolean 	registerAsParallelCapable()</code> -- 注册为并行</p></li>
                                <li><p><code>protected void 	resolveClass(Class&lt;?> c)</code> -- 链接指定的类</p></li>
								<li><p><code>protected void 	setSigners(Class&lt;?> c, Object[] signers)</code> -- 设置类的签署者</p></li>
								<li><p><code>void 	setPackageAssertionStatus(String packageName, boolean enabled)</code> -- 为指定包设置默认断言状态</p></li>
								<li><p><code>void 	setDefaultAssertionStatus(boolean enabled)</code> -- 设置此类加载器的默认断言状态</p></li>
								<li><p><code>void 	setClassAssertionStatus(String className, boolean enabled)</code> -- 设置在此类加载器及其包含的嵌套类中指定的最高层类所需的断言状态</p></li>
								<li><p><code>void 	clearAssertionStatus()</code> -- 将此类加载器的默认断言状态设置为 false，并放弃与此类加载器关联的所有默认包或类断言状态设置</p></li>
                            </ol>
                            <p><a href="docs/docs-java/api/java/lang/annotation/Annotation.html" target="_blank">Annotation</a></p>
                            <pre class="brush: java;">

                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Constructor.html" target="_blank">Constructor</a></p>
                            <pre class="brush: java;">

                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Field.html" target="_blank">Field</a></p>
                            <pre class="brush: java;">

                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Method.html" target="_blank">Method</a></p>
                            <pre class="brush: java;">

                            </pre>
                            <p><a href="docs/docs-java/api/java/lang/reflect/Type.html" target="_blank">Type</a></p>
                            <pre class="brush: java;">

                            </pre>
                            <p><a href="docs/docs-java/api/java/security/ProtectionDomain.html" target="_blank">ProtectionDomain</a></p>
                            <pre class="brush: java;">

                            </pre>

						</div>
				</div>
			</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Package"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Class</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">Package 类</h5>
							<pre class="brush: java;">
public class Package implements java.lang.reflect.AnnotatedElement
</pre>
							<p>Package 对象包含有关 Java 包的实现和规范的版本信息。通过用于加载类的 ClassLoader
								实例，可以获取并获得此版本信息。通常，此信息存储在与类一起分发的清单中。</p>
							<p>组成包的类集可以实现一个特定规范，如此一来，就可以通过规范标题、版本号和供应商字符串来标识该规范。应用程序可以询问包是否与特定版本兼容，有关详细信息，请参阅
								isCompatibleWith 方法。</p>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-System"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Class</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">System</h5>
							<p>System 类代表系统，系统级的很多属性和控制方法都放置在该类的内部。</p>
							<p>
								System类内部包含
								<code>in</code>
								、
								<code>out</code>
								和
								<code>err</code>
								三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。
							</p>
							<ul>
								<li>
									<p>
										<code>setIn(InputStream in) / setOut(PrintStream out) /
											setError(PrintStream out)</code>
										-- 改变标准输入流, 输出流, 错误流。
									</p>
								</li>
								<li>
									<p>
										<code>public static native long currentTimeMillis()</code>
										-- 该方法的作用是返回当前的计算机时间。
									</p>
								</li>
								<li>
									<p>
										<code>public static native void arraycopy(Object src,
											int srcPos, Object dest, int destPos, int length)</code>
										-- 该方法的作用是数组拷贝。比使用循环更高效。
									</p>
									<pre class="brush: java;">
int[] a = { 1, 2, 3, 4 };
int[] b = new int[5];

// 将数组a中，从下标为1开始，复制到数组b从下标3开始的位置，总共复制2个。b -> 0 0 0 2 3
System.arraycopy(a, 1, b, 3, 2);
</pre>
								</li>
								<li>
									<p>
										<code>setProperty(String key, String value) /
											getProperty(String key) / getProperty(String key, String def)
											/ getProperties()</code>
										-- 获得/设置系统属性
									</p>
									<pre class="brush: java;">
//  所有的 property
Properties properties = System.getProperties();
Iterator it = properties.keySet().iterator();
while(it.hasNext()) {
	String key = (String) it.next();
	System.out.println(key + ":" + properties.get(key));
}

// 指定的 property
System.out.println(System.getProperty("os.name"));
// 如果没有指定的 property, 返回指定的 default
System.out.println(System.getProperty("os.name2", "default"));

// 自己定义属性
System.setProperty("property.define", "myProperty");
</pre>
								</li>
								<li>
									<p>
										<code>public static String getenv(String name) /
											getenv()</code>
										-- 获得环境变量
									</p>
									<pre class="brush: java;">
//  所有的 env
Map&lt;String, String> env = System.getenv();
Iterator&lt;String> it = env.keySet().iterator();
while(it.hasNext()) {
	String key = it.next();
	System.out.println(key + ":" + env.get(key));
}

// 指定 env
System.out.println(System.getenv("PATH"));
</pre>
								</li>


								<li>
									<p>
										<code>public static void load(String filename) /
											loadLibrary(String libname)</code>
										-- 主要用来加载动态链接库, JNI 中使用, 实例参见:
										<a href="index.html#java-jni">Java 本地编程 - JNI</a>
									</p>
								</li>
								<li>
									<p>
										<code>public static void exit(int status) / gc()</code>
										-- 退出程序(调用 Runtime 的 exit) / 请求系统进行垃圾回收
									</p>
								</li>
								<li>
									<p>
										<code>public static void setSecurityManager(final
											SecurityManager s) / getSecurityManager()</code>
										-- 设置 / 获得安全管理器
									</p>
								</li>

							</ul>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Process"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Class</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary">Process</h5>
							<p>ProcessBuilder.start() 和 Runtime.exec 方法创建一个本机进程，并返回
								Process 子类的一个实例，该实例可用来控制进程并获得相关信息。Process
								类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程的方法。</p>
							<p>创建进程的方法可能无法针对某些本机平台上的特定进程很好地工作，比如，本机窗口进程，守护进程，Microsoft
								Windows 上的 Win16/DOS 进程，或者 shell 脚本。创建的子进程没有自己的终端或控制台。它的所有标准
								io（即 stdin、stdout 和 stderr）操作都将通过三个流
								(getOutputStream()、getInputStream() 和 getErrorStream())
								重定向到父进程。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。因为有些本机平台仅针对标准输入和输出流提供有限的缓冲区大小，如果读写子进程的输出流或输入流迅速出现失败，则可能导致子进程阻塞，甚至产生死锁。
							</p>
							<p>当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。</p>
							<p>对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</p>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-Runtime"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Class</h3>
					</div>
					<div class="panel-body">

						<div class="sub-item">
							<h5 class="text-primary">Runtime</h5>
							<p>每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。可以通过
								getRuntime 方法获取当前运行时。 应用程序不能创建自己的 Runtime 类实例。</p>

						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-lang-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">Class</h3>
					</div>
					<div class="panel-body">
						<div class="sub-item">
							<h5 class="text-primary"></h5>
						</div>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">...</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">

						</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">...</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">

						</pre>
					</div>
				</div>
				<!-- item over -->

				<!-- item start -->
				<a class="offset" id="java-"></a>
				<div class="panel panel-default">
					<div class="panel-heading">
						<h3 class="panel-title">...</h3>
					</div>
					<div class="panel-body">
						<pre class="brush: java;">

						</pre>
					</div>
				</div>
				<!-- item over -->
			</div>
		</div>
	</div>

	<div class="btn-group-vertical bottom-button">
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle dropup" data-toggle="dropup">
			<span class="caret"></span>
		</a>
		<a href="#" type="button"
			class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> TOP </a>
		<a target="_blank" href="./docs/docs-java/api-zh/index.html"
			type="button" class="btn btn-default dropdown-toggle btn-primary"
			data-toggle="dropup"> DOCS-6 </a>
		<a target="_blank" href="./docs/docs-java/api/index.html"
		   type="button" class="btn btn-default dropdown-toggle btn-primary"
		   data-toggle="dropup"> DOCS-8 </a>
	</div>

	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script src="../support/jquery/jquery-3.1.1.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<script src="../support/bootstrap/js/bootstrap.min.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shCore.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushJava.js"></script>
	<script src="../support/syntaxhighlighter/scripts/shBrushXml.js"></script>
	<script src="res/menu.js"></script>
	<script src="../commons/js/common.js"></script>
</body>
</html>
